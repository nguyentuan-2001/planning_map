// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/ol/events/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.preventDefault = preventDefault;
exports.stopPropagation = stopPropagation;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/events/Event
 */
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var BaseEvent = /*#__PURE__*/function () {
  /**
   * @param {string} type Type.
   */
  function BaseEvent(type) {
    _classCallCheck(this, BaseEvent);
    /**
     * @type {boolean}
     */
    this.propagationStopped;

    /**
     * @type {boolean}
     */
    this.defaultPrevented;

    /**
     * The event type.
     * @type {string}
     * @api
     */
    this.type = type;

    /**
     * The event target.
     * @type {Object}
     * @api
     */
    this.target = null;
  }

  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  _createClass(BaseEvent, [{
    key: "preventDefault",
    value: function preventDefault() {
      this.defaultPrevented = true;
    }

    /**
     * Stop event propagation.
     * @api
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
  }]);
  return BaseEvent;
}();
/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}
var _default = exports.default = BaseEvent;
},{}],"node_modules/ol/ObjectEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/ObjectEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};
/**
 * @typedef {'propertychange'} Types
 */
},{}],"node_modules/ol/Disposable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/Disposable
 */
/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = /*#__PURE__*/function () {
  function Disposable() {
    _classCallCheck(this, Disposable);
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }

  /**
   * Clean up.
   */
  _createClass(Disposable, [{
    key: "dispose",
    value: function dispose() {
      if (!this.disposed) {
        this.disposed = true;
        this.disposeInternal();
      }
    }

    /**
     * Extension point for disposable objects.
     * @protected
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {}
  }]);
  return Disposable;
}();
var _default = exports.default = Disposable;
},{}],"node_modules/ol/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ascending = ascending;
exports.binarySearch = binarySearch;
exports.descending = descending;
exports.equals = equals;
exports.extend = extend;
exports.isSorted = isSorted;
exports.linearFindNearest = linearFindNearest;
exports.remove = remove;
exports.reverseSubArray = reverseSubArray;
exports.stableSort = stableSort;
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, comparator) {
  var mid, cmp;
  comparator = comparator || ascending;
  var low = 0;
  var high = haystack.length;
  var found = false;
  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  var n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === 'function') {
    for (var i = 1; i < n; ++i) {
      var candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (var _i = 1; _i < n; ++_i) {
      if (arr[_i] < target) {
        return _i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (var _i2 = 1; _i2 < n; ++_i2) {
      if (arr[_i2] <= target) {
        return _i2;
      }
    }
    return n - 1;
  }
  for (var _i3 = 1; _i3 < n; ++_i3) {
    if (arr[_i3] == target) {
      return _i3;
    }
    if (arr[_i3] < target) {
      if (arr[_i3 - 1] - target < target - arr[_i3]) {
        return _i3 - 1;
      }
      return _i3;
    }
  }
  return n - 1;
}

/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, func, strict) {
  var compare = func || ascending;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
},{}],"node_modules/ol/functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FALSE = FALSE;
exports.TRUE = TRUE;
exports.VOID = VOID;
exports.memoizeOne = memoizeOne;
exports.toPromise = toPromise;
var _array = require("./array.js");
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @return {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @return {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
function memoizeOne(fn) {
  var called = false;

  /** @type {ReturnType} */
  var lastResult;

  /** @type {Array<any>} */
  var lastArgs;
  var lastThis;
  return function () {
    var nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !(0, _array.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
function toPromise(getter) {
  function promiseGetter() {
    var value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
},{"./array.js":"node_modules/ol/array.js"}],"node_modules/ol/obj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.isEmpty = isEmpty;
/**
 * @module ol/obj
 */

/**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}
},{}],"node_modules/ol/events/Target.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Disposable2 = _interopRequireDefault(require("../Disposable.js"));
var _Event = _interopRequireDefault(require("./Event.js"));
var _functions = require("../functions.js");
var _obj = require("../obj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/events/Target
 */
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */
/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target = /*#__PURE__*/function (_Disposable) {
  _inherits(Target, _Disposable);
  var _super = _createSuper(Target);
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  function Target(target) {
    var _this;
    _classCallCheck(this, Target);
    _this = _super.call(this);

    /**
     * @private
     * @type {*}
     */
    _this.eventTarget_ = target;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    _this.pendingRemovals_ = null;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    _this.dispatching_ = null;

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */
    _this.listeners_ = null;
    return _this;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  _createClass(Target, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (!type || !listener) {
        return;
      }
      var listeners = this.listeners_ || (this.listeners_ = {});
      var listenersForType = listeners[type] || (listeners[type] = []);
      if (!listenersForType.includes(listener)) {
        listenersForType.push(listener);
      }
    }

    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var isString = typeof event === 'string';
      var type = isString ? event : event.type;
      var listeners = this.listeners_ && this.listeners_[type];
      if (!listeners) {
        return;
      }
      var evt = isString ? new _Event.default(event) : ( /** @type {Event} */event);
      if (!evt.target) {
        evt.target = this.eventTarget_ || this;
      }
      var dispatching = this.dispatching_ || (this.dispatching_ = {});
      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      if (!(type in dispatching)) {
        dispatching[type] = 0;
        pendingRemovals[type] = 0;
      }
      ++dispatching[type];
      var propagate;
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if ('handleEvent' in listeners[i]) {
          propagate = /** @type {import("../events.js").ListenerObject} */listeners[i].handleEvent(evt);
        } else {
          propagate = /** @type {import("../events.js").ListenerFunction} */listeners[i].call(this, evt);
        }
        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      if (--dispatching[type] === 0) {
        var pr = pendingRemovals[type];
        delete pendingRemovals[type];
        while (pr--) {
          this.removeEventListener(type, _functions.VOID);
        }
        delete dispatching[type];
      }
      return propagate;
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.listeners_ && (0, _obj.clear)(this.listeners_);
    }

    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
  }, {
    key: "getListeners",
    value: function getListeners(type) {
      return this.listeners_ && this.listeners_[type] || undefined;
    }

    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
  }, {
    key: "hasListener",
    value: function hasListener(type) {
      if (!this.listeners_) {
        return false;
      }
      return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }

    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      if (!this.listeners_) {
        return;
      }
      var listeners = this.listeners_[type];
      if (!listeners) {
        return;
      }
      var index = listeners.indexOf(listener);
      if (index !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          // make listener a no-op, and remove later in #dispatchEvent()
          listeners[index] = _functions.VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);
          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  }]);
  return Target;
}(_Disposable2.default);
var _default = exports.default = Target;
},{"../Disposable.js":"node_modules/ol/Disposable.js","./Event.js":"node_modules/ol/events/Event.js","../functions.js":"node_modules/ol/functions.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/events/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/events/EventType
 */
/**
 * @enum {string}
 * @const
 */
var _default = exports.default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',
  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel'
};
},{}],"node_modules/ol/events.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listen = listen;
exports.listenOnce = listenOnce;
exports.unlistenByKey = unlistenByKey;
var _obj = require("./obj.js");
/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, _listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    _listener = _listener.bind(thisArg);
  }
  if (once) {
    var originalListener = _listener;
    _listener = function listener() {
      target.removeEventListener(type, _listener);
      originalListener.apply(this, arguments);
    };
  }
  var eventsKey = {
    target: target,
    type: type,
    listener: _listener
  };
  target.addEventListener(type, _listener);
  return eventsKey;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0, _obj.clear)(key);
  }
}
},{"./obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/Observable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.unByKey = unByKey;
var _Target = _interopRequireDefault(require("./events/Target.js"));
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _events = require("./events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Observable
 */
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */
/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */
/**
 * @typedef {'change'|'error'} EventTypes
 */
/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
var Observable = /*#__PURE__*/function (_EventTarget) {
  _inherits(Observable, _EventTarget);
  var _super = _createSuper(Observable);
  function Observable() {
    var _this;
    _classCallCheck(this, Observable);
    _this = _super.call(this);
    _this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onInternal;
    _this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onceInternal;
    _this.un = /** @type {ObservableOnSignature<void>} */_this.unInternal;

    /**
     * @private
     * @type {number}
     */
    _this.revision_ = 0;
    return _this;
  }

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  _createClass(Observable, [{
    key: "changed",
    value: function changed() {
      ++this.revision_;
      this.dispatchEvent(_EventType.default.CHANGE);
    }

    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
  }, {
    key: "getRevision",
    value: function getRevision() {
      return this.revision_;
    }

    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
  }, {
    key: "onInternal",
    value: function onInternal(type, listener) {
      if (Array.isArray(type)) {
        var len = type.length;
        var keys = new Array(len);
        for (var i = 0; i < len; ++i) {
          keys[i] = (0, _events.listen)(this, type[i], listener);
        }
        return keys;
      }
      return (0, _events.listen)(this, /** @type {string} */type, listener);
    }

    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
  }, {
    key: "onceInternal",
    value: function onceInternal(type, listener) {
      var key;
      if (Array.isArray(type)) {
        var len = type.length;
        key = new Array(len);
        for (var i = 0; i < len; ++i) {
          key[i] = (0, _events.listenOnce)(this, type[i], listener);
        }
      } else {
        key = (0, _events.listenOnce)(this, /** @type {string} */type, listener);
      }
      /** @type {Object} */
      listener.ol_key = key;
      return key;
    }

    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
  }, {
    key: "unInternal",
    value: function unInternal(type, listener) {
      var key = /** @type {Object} */listener.ol_key;
      if (key) {
        unByKey(key);
      } else if (Array.isArray(type)) {
        for (var i = 0, ii = type.length; i < ii; ++i) {
          this.removeEventListener(type[i], listener);
        }
      } else {
        this.removeEventListener(type, listener);
      }
    }
  }]);
  return Observable;
}(_Target.default);
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on;

/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once;

/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */
Observable.prototype.un;

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(key[i]);
    }
  } else {
    (0, _events.unlistenByKey)( /** @type {import("./events.js").EventsKey} */key);
  }
}
var _default = exports.default = Observable;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
exports.abstract = abstract;
exports.getUid = getUid;
/**
 * @module ol/util
 */

/**
 * @return {never} Any return.
 */
function abstract() {
  throw new Error('Unimplemented abstract method.');
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = exports.VERSION = '8.2.0';
},{}],"node_modules/ol/Object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ObjectEvent = void 0;
var _Event2 = _interopRequireDefault(require("./events/Event.js"));
var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));
var _Observable2 = _interopRequireDefault(require("./Observable.js"));
var _util = require("./util.js");
var _obj = require("./obj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Object
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent = exports.ObjectEvent = /*#__PURE__*/function (_Event) {
  _inherits(ObjectEvent, _Event);
  var _super = _createSuper(ObjectEvent);
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  function ObjectEvent(type, key, oldValue) {
    var _this;
    _classCallCheck(this, ObjectEvent);
    _this = _super.call(this, type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    _this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    _this.oldValue = oldValue;
    return _this;
  }
  return _createClass(ObjectEvent);
}(_Event2.default);
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject = /*#__PURE__*/function (_Observable) {
  _inherits(BaseObject, _Observable);
  var _super2 = _createSuper(BaseObject);
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  function BaseObject(values) {
    var _this2;
    _classCallCheck(this, BaseObject);
    _this2 = _super2.call(this);

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {ObjectOnSignature<void>}
     */
    _this2.un;

    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    (0, _util.getUid)(_assertThisInitialized(_this2));

    /**
     * @private
     * @type {Object<string, *>|null}
     */
    _this2.values_ = null;
    if (values !== undefined) {
      _this2.setProperties(values);
    }
    return _this2;
  }

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  _createClass(BaseObject, [{
    key: "get",
    value: function get(key) {
      var value;
      if (this.values_ && this.values_.hasOwnProperty(key)) {
        value = this.values_[key];
      }
      return value;
    }

    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
  }, {
    key: "getKeys",
    value: function getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }

    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
  }, {
    key: "getProperties",
    value: function getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }

    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
  }, {
    key: "getPropertiesInternal",
    value: function getPropertiesInternal() {
      return this.values_;
    }

    /**
     * @return {boolean} The object has properties.
     */
  }, {
    key: "hasProperties",
    value: function hasProperties() {
      return !!this.values_;
    }

    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
  }, {
    key: "notify",
    value: function notify(key, oldValue) {
      var eventType;
      eventType = "change:".concat(key);
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
      eventType = _ObjectEventType.default.PROPERTYCHANGE;
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
    }

    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
  }, {
    key: "addChangeListener",
    value: function addChangeListener(key, listener) {
      this.addEventListener("change:".concat(key), listener);
    }

    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
  }, {
    key: "removeChangeListener",
    value: function removeChangeListener(key, listener) {
      this.removeEventListener("change:".concat(key), listener);
    }

    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
  }, {
    key: "set",
    value: function set(key, value, silent) {
      var values = this.values_ || (this.values_ = {});
      if (silent) {
        values[key] = value;
      } else {
        var oldValue = values[key];
        values[key] = value;
        if (oldValue !== value) {
          this.notify(key, oldValue);
        }
      }
    }

    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
  }, {
    key: "setProperties",
    value: function setProperties(values, silent) {
      for (var key in values) {
        this.set(key, values[key], silent);
      }
    }

    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
  }, {
    key: "applyProperties",
    value: function applyProperties(source) {
      if (!source.values_) {
        return;
      }
      Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }

    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
  }, {
    key: "unset",
    value: function unset(key, silent) {
      if (this.values_ && key in this.values_) {
        var oldValue = this.values_[key];
        delete this.values_[key];
        if ((0, _obj.isEmpty)(this.values_)) {
          this.values_ = null;
        }
        if (!silent) {
          this.notify(key, oldValue);
        }
      }
    }
  }]);
  return BaseObject;
}(_Observable2.default);
var _default = exports.default = BaseObject;
},{"./events/Event.js":"node_modules/ol/events/Event.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./Observable.js":"node_modules/ol/Observable.js","./util.js":"node_modules/ol/util.js","./obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/has.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WORKER_OFFSCREEN_CANVAS = exports.WEBKIT = exports.SAFARI_BUG_237906 = exports.SAFARI = exports.PASSIVE_EVENT_LISTENERS = exports.MAC = exports.IMAGE_DECODE = exports.FIREFOX = exports.DEVICE_PIXEL_RATIO = exports.CREATE_IMAGE_BITMAP = void 0;
/**
 * @module ol/has
 */

var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = exports.FIREFOX = ua.includes('firefox');

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = exports.SAFARI = ua.includes('safari') && !ua.includes('chrom');

/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */
var SAFARI_BUG_237906 = exports.SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = exports.WEBKIT = ua.includes('webkit') && !ua.includes('edge');

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = exports.MAC = ua.includes('macintosh');

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = exports.DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;

/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
var WORKER_OFFSCREEN_CANVAS = exports.WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
var IMAGE_DECODE = exports.IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;

/**
 * createImageBitmap() is supported.
 * @type {boolean}
 */
var CREATE_IMAGE_BITMAP = exports.CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';

/**
 * @type {boolean}
 */
var PASSIVE_EVENT_LISTENERS = exports.PASSIVE_EVENT_LISTENERS = function () {
  var passive = false;
  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passive = true;
      }
    });

    // @ts-ignore Ignore invalid event type '_'
    window.addEventListener('_', null, options);
    // @ts-ignore Ignore invalid event type '_'
    window.removeEventListener('_', null, options);
  } catch (error) {
    // passive not supported
  }
  return passive;
}();
},{}],"node_modules/ol/asserts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
},{}],"node_modules/ol/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apply = apply;
exports.compose = compose;
exports.composeCssTransform = composeCssTransform;
exports.create = create;
exports.determinant = determinant;
exports.invert = invert;
exports.makeInverse = makeInverse;
exports.makeScale = makeScale;
exports.multiply = multiply;
exports.reset = reset;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.setFromArray = setFromArray;
exports.toString = toString;
exports.translate = translate;
var _has = require("./has.js");
var _asserts = require("./asserts.js");
/**
 * @module ol/transform
 */

/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 33 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}

/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}

/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}

/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}

/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}

/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}

/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}

/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
  return makeInverse(source, source);
}

/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
  var det = determinant(source);
  (0, _asserts.assert)(det !== 0, 'Transformation matrix cannot be inverted');
  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}

/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

/**
 * @type {HTMLElement}
 * @private
 */
var transformStringDiv;

/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
  var transformString = 'matrix(' + mat.join(', ') + ')';
  if (_has.WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
  node.style.transform = transformString;
  return node.style.transform;
}
},{"./has.js":"node_modules/ol/has.js","./asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/extent/Relationship.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/extent/Relationship
 */
/**
 * Relationship to an extent.
 * @enum {number}
 */
var _default = exports.default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
},{}],"node_modules/ol/extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyTransform = applyTransform;
exports.approximatelyEquals = approximatelyEquals;
exports.boundingExtent = boundingExtent;
exports.buffer = buffer;
exports.clone = clone;
exports.closestSquaredDistanceXY = closestSquaredDistanceXY;
exports.containsCoordinate = containsCoordinate;
exports.containsExtent = containsExtent;
exports.containsXY = containsXY;
exports.coordinateRelationship = coordinateRelationship;
exports.createEmpty = createEmpty;
exports.createOrUpdate = createOrUpdate;
exports.createOrUpdateEmpty = createOrUpdateEmpty;
exports.createOrUpdateFromCoordinate = createOrUpdateFromCoordinate;
exports.createOrUpdateFromCoordinates = createOrUpdateFromCoordinates;
exports.createOrUpdateFromFlatCoordinates = createOrUpdateFromFlatCoordinates;
exports.createOrUpdateFromRings = createOrUpdateFromRings;
exports.equals = equals;
exports.extend = extend;
exports.extendCoordinate = extendCoordinate;
exports.extendCoordinates = extendCoordinates;
exports.extendFlatCoordinates = extendFlatCoordinates;
exports.extendRings = extendRings;
exports.extendXY = extendXY;
exports.forEachCorner = forEachCorner;
exports.getArea = getArea;
exports.getBottomLeft = getBottomLeft;
exports.getBottomRight = getBottomRight;
exports.getCenter = getCenter;
exports.getCorner = getCorner;
exports.getEnlargedArea = getEnlargedArea;
exports.getForViewAndSize = getForViewAndSize;
exports.getHeight = getHeight;
exports.getIntersection = getIntersection;
exports.getIntersectionArea = getIntersectionArea;
exports.getMargin = getMargin;
exports.getRotatedViewport = getRotatedViewport;
exports.getSize = getSize;
exports.getTopLeft = getTopLeft;
exports.getTopRight = getTopRight;
exports.getWidth = getWidth;
exports.intersects = intersects;
exports.intersectsSegment = intersectsSegment;
exports.isEmpty = isEmpty;
exports.returnOrUpdate = returnOrUpdate;
exports.scaleFromCenter = scaleFromCenter;
exports.wrapAndSliceX = wrapAndSliceX;
exports.wrapX = wrapX;
var _Relationship = _interopRequireDefault(require("./extent/Relationship.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } /**
 * @module ol/extent
 */
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, dest) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}

/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
}

/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _Relationship.default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | _Relationship.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _Relationship.default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _Relationship.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _Relationship.default.ABOVE;
  }
  if (relationship === _Relationship.default.UNKNOWN) {
    relationship = _Relationship.default.INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, dest) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}

/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}

/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}

/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
  var val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate;
  if (corner === 'bottom-left') {
    coordinate = getBottomLeft(extent);
  } else if (corner === 'bottom-right') {
    coordinate = getBottomRight(extent);
  } else if (corner === 'top-left') {
    coordinate = getTopLeft(extent);
  } else if (corner === 'top-right') {
    coordinate = getTopRight(extent);
  } else {
    throw new Error('Invalid corner');
  }
  return coordinate;
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, dest) {
  var _getRotatedViewport = getRotatedViewport(center, resolution, rotation, size),
    _getRotatedViewport2 = _slicedToArray(_getRotatedViewport, 8),
    x0 = _getRotatedViewport2[0],
    y0 = _getRotatedViewport2[1],
    x1 = _getRotatedViewport2[2],
    y1 = _getRotatedViewport2[3],
    x2 = _getRotatedViewport2[4],
    y2 = _getRotatedViewport2[5],
    x3 = _getRotatedViewport2[6],
    y3 = _getRotatedViewport2[7];
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */
function getRotatedViewport(center, resolution, rotation, size) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  return [x - xCos + ySin, y - xSin - yCos, x - xCos - ySin, y - xSin + yCos, x + xCos - ySin, y + xSin + yCos, x + xCos + ySin, y + xSin - yCos, x - xCos + ySin, y - xSin - yCos];
}

/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, dest) {
  var intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}

/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _Relationship.default.INTERSECTING || endRel === _Relationship.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _Relationship.default.ABOVE) && !(startRel & _Relationship.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship.default.RIGHT) && !(startRel & _Relationship.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _Relationship.default.BELOW) && !(startRel & _Relationship.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship.default.LEFT) && !(startRel & _Relationship.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  var coordinates = [];
  if (stops > 1) {
    var width = extent[2] - extent[0];
    var height = extent[3] - extent[1];
    for (var i = 0; i < stops; ++i) {
      coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
    }
  } else {
    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
  }
  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];
  for (var _i = 0, l = coordinates.length; _i < l; _i += 2) {
    xs.push(coordinates[_i]);
    ys.push(coordinates[_i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}

/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}

/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    var worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth) {
      // the extent wraps around on itself
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [[extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2], extent[3]]];
    }
    if (extent[2] > projectionExtent[2]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [[extent[0], extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]];
    }
  }
  return [extent];
}
},{"./extent/Relationship.js":"node_modules/ol/extent/Relationship.js"}],"node_modules/ol/proj/Units.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.METERS_PER_UNIT = void 0;
exports.fromCode = fromCode;
/**
 * @module ol/proj/Units
 */

/**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */

/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
var unitByCode = {
  '9001': 'm',
  '9002': 'ft',
  '9003': 'us-ft',
  '9101': 'radians',
  '9102': 'degrees'
};

/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
  return unitByCode[code];
}

/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */

/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  'radians': 6370997 / (2 * Math.PI),
  'degrees': 2 * Math.PI * 6370997 / 360,
  'ft': 0.3048,
  'm': 1,
  'us-ft': 1200 / 3937
};
},{}],"node_modules/ol/proj/Projection.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Units = require("./Units.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/proj/Projection
 */
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */
/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */
var Projection = /*#__PURE__*/function () {
  /**
   * @param {Options} options Projection options.
   */
  function Projection(options) {
    _classCallCheck(this, Projection);
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;

    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */
    this.units_ = /** @type {import("./Units.js").Units} */options.units;

    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = options.extent !== undefined ? options.extent : null;

    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;

    /**
     * @private
     * @type {string}
     */
    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

    /**
     * @private
     * @type {boolean}
     */
    this.global_ = options.global !== undefined ? options.global : false;

    /**
     * @private
     * @type {boolean}
     */
    this.canWrapX_ = !!(this.global_ && this.extent_);

    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */
    this.getPointResolutionFunc_ = options.getPointResolution;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.defaultTileGrid_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.metersPerUnit_ = options.metersPerUnit;
  }

  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  _createClass(Projection, [{
    key: "canWrapX",
    value: function canWrapX() {
      return this.canWrapX_;
    }

    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
  }, {
    key: "getCode",
    value: function getCode() {
      return this.code_;
    }

    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent_;
    }

    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
  }, {
    key: "getUnits",
    value: function getUnits() {
      return this.units_;
    }

    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
  }, {
    key: "getMetersPerUnit",
    value: function getMetersPerUnit() {
      return this.metersPerUnit_ || _Units.METERS_PER_UNIT[this.units_];
    }

    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getWorldExtent",
    value: function getWorldExtent() {
      return this.worldExtent_;
    }

    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
  }, {
    key: "getAxisOrientation",
    value: function getAxisOrientation() {
      return this.axisOrientation_;
    }

    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
  }, {
    key: "isGlobal",
    value: function isGlobal() {
      return this.global_;
    }

    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
  }, {
    key: "setGlobal",
    value: function setGlobal(global) {
      this.global_ = global;
      this.canWrapX_ = !!(global && this.extent_);
    }

    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
  }, {
    key: "getDefaultTileGrid",
    value: function getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }

    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
  }, {
    key: "setDefaultTileGrid",
    value: function setDefaultTileGrid(tileGrid) {
      this.defaultTileGrid_ = tileGrid;
    }

    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
  }, {
    key: "setExtent",
    value: function setExtent(extent) {
      this.extent_ = extent;
      this.canWrapX_ = !!(this.global_ && extent);
    }

    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
  }, {
    key: "setWorldExtent",
    value: function setWorldExtent(worldExtent) {
      this.worldExtent_ = worldExtent;
    }

    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
  }, {
    key: "setGetPointResolution",
    value: function setGetPointResolution(func) {
      this.getPointResolutionFunc_ = func;
    }

    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
  }, {
    key: "getPointResolutionFunc",
    value: function getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  }]);
  return Projection;
}();
var _default = exports.default = Projection;
},{"./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/epsg3857.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WORLD_EXTENT = exports.RADIUS = exports.PROJECTIONS = exports.MAX_SAFE_Y = exports.HALF_SIZE = exports.EXTENT = void 0;
exports.fromEPSG4326 = fromEPSG4326;
exports.toEPSG4326 = toEPSG4326;
var _Projection2 = _interopRequireDefault(require("./Projection.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/proj/epsg3857
 */
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
var HALF_SIZE = exports.HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = exports.EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = exports.WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
var MAX_SAFE_Y = exports.MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = /*#__PURE__*/function (_Projection) {
  _inherits(EPSG3857Projection, _Projection);
  var _super = _createSuper(EPSG3857Projection);
  /**
   * @param {string} code Code.
   */
  function EPSG3857Projection(code) {
    _classCallCheck(this, EPSG3857Projection);
    return _super.call(this, {
      code: code,
      units: 'm',
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function getPointResolution(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      }
    });
  }
  return _createClass(EPSG3857Projection);
}(_Projection2.default);
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, output, dimension) {
  var length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, output, dimension) {
  var length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
},{"./Projection.js":"node_modules/ol/proj/Projection.js"}],"node_modules/ol/proj/epsg4326.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RADIUS = exports.PROJECTIONS = exports.METERS_PER_UNIT = exports.EXTENT = void 0;
var _Projection2 = _interopRequireDefault(require("./Projection.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/proj/epsg4326
 */
/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = exports.EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = Math.PI * RADIUS / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = /*#__PURE__*/function (_Projection) {
  _inherits(EPSG4326Projection, _Projection);
  var _super = _createSuper(EPSG4326Projection);
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  function EPSG4326Projection(code, axisOrientation) {
    _classCallCheck(this, EPSG4326Projection);
    return _super.call(this, {
      code: code,
      units: 'degrees',
      extent: EXTENT,
      axisOrientation: axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });
  }
  return _createClass(EPSG4326Projection);
}(_Projection2.default);
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')];
},{"./Projection.js":"node_modules/ol/proj/Projection.js"}],"node_modules/ol/proj/projections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clear = clear;
exports.get = get;
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}
},{}],"node_modules/ol/proj/transforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clear = clear;
exports.get = get;
exports.remove = remove;
var _obj = require("../obj.js");
/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};

/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0, _obj.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}
},{"../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ceil = ceil;
exports.clamp = clamp;
exports.floor = floor;
exports.lerp = lerp;
exports.modulo = modulo;
exports.round = round;
exports.solveLinearSystem = solveLinearSystem;
exports.squaredDistance = squaredDistance;
exports.squaredSegmentDistance = squaredSegmentDistance;
exports.toDegrees = toDegrees;
exports.toFixed = toFixed;
exports.toRadians = toRadians;
/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;
  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
function toFixed(n, decimals) {
  var factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}

/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}

/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}

/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
},{}],"node_modules/ol/string.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareVersions = compareVersions;
exports.padNumber = padNumber;
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, precision) {
  var numberString = precision !== undefined ? number.toFixed(precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');
  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
},{}],"node_modules/ol/coordinate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.closestOnCircle = closestOnCircle;
exports.closestOnSegment = closestOnSegment;
exports.createStringXY = createStringXY;
exports.degreesToStringHDMS = degreesToStringHDMS;
exports.distance = distance;
exports.equals = equals;
exports.format = format;
exports.getWorldsAway = getWorldsAway;
exports.rotate = rotate;
exports.scale = scale;
exports.squaredDistance = squaredDistance;
exports.squaredDistanceToSegment = squaredDistanceToSegment;
exports.toStringHDMS = toStringHDMS;
exports.toStringXY = toStringXY;
exports.wrapX = wrapX;
var _extent = require("./extent.js");
var _math = require("./math.js");
var _string = require("./string.js");
/**
 * @module ol/coordinate
 */

/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}

/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);
  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;
  return [x, y];
}

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}

/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}

/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  var normalizedDegrees = (0, _math.modulo)(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var decimals = fractionDigits || 0;
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = (0, _math.toFixed)(x - deg * 3600 - min * 60, decimals);
  if (sec >= 60) {
    sec = 0;
    min += 1;
  }
  if (min >= 60) {
    min = 0;
    deg += 1;
  }
  var hdms = deg + "\xB0";
  if (min !== 0 || sec !== 0) {
    hdms += ' ' + (0, _string.padNumber)(min, 2) + "\u2032";
  }
  if (sec !== 0) {
    hdms += ' ' + (0, _string.padNumber)(sec, 2, decimals) + "\u2033";
  }
  if (normalizedDegrees !== 0) {
    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }
  return hdms;
}

/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(fractionDigits)).replace('{y}', coordinate[1].toFixed(fractionDigits));
  }
  return '';
}

/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47 58 60 N 7 50 60 E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47 58 60.0 N 7 50 60.0 E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], fractionDigits);
  }
  return '';
}

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, '{x}, {y}', fractionDigits);
}

/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    var worldWidth = (0, _extent.getWidth)(projection.getExtent());
    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || (0, _extent.getWidth)(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }
  return worldsAway;
}
},{"./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./string.js":"node_modules/ol/string.js"}],"node_modules/ol/sphere.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_RADIUS = void 0;
exports.getArea = getArea;
exports.getDistance = getDistance;
exports.getLength = getLength;
exports.offset = offset;
var _math = require("./math.js");
/**
 * @module ol/sphere
 */

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = exports.DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lat2 = (0, _math.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0, _math.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, options) {
  options = options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint':
      {
        break;
      }
    case 'LineString':
    case 'LinearRing':
      {
        coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }
    case 'MultiLineString':
    case 'Polygon':
      {
        coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }
        break;
      }
    case 'MultiPolygon':
      {
        coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }
        break;
      }
    case 'GeometryCollection':
      {
        var geometries = /** @type {import("./geom/GeometryCollection.js").default} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0, _math.toRadians)(x2 - x1) * (2 + Math.sin((0, _math.toRadians)(y1)) + Math.sin((0, _math.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, options) {
  options = options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'LinearRing':
      {
        break;
      }
    case 'Polygon':
      {
        coordinates = /** @type {import("./geom/Polygon.js").default} */geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));
        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }
        break;
      }
    case 'MultiPolygon':
      {
        coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));
          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }
        break;
      }
    case 'GeometryCollection':
      {
        var geometries = /** @type {import("./geom/GeometryCollection.js").default} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lon1 = (0, _math.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/console.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.error = error;
exports.log = log;
exports.setLevel = setLevel;
exports.warn = warn;
/**
 * @module ol/console
 */

/**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */

/**
 * @type {Object<Level, number>}
 */
var levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};

/**
 * @type {number}
 */
var level = levels.info;

/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */
function setLevel(l) {
  level = levels[l];
}

/**
 * @param  {...any} args Arguments to log
 */
function log() {
  var _console;
  if (level > levels.info) {
    return;
  }
  (_console = console).log.apply(_console, arguments); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function warn() {
  var _console2;
  if (level > levels.warn) {
    return;
  }
  (_console2 = console).warn.apply(_console2, arguments); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function error() {
  var _console3;
  if (level > levels.error) {
    return;
  }
  (_console3 = console).error.apply(_console3, arguments); // eslint-disable-line no-console
}
},{}],"node_modules/ol/proj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "METERS_PER_UNIT", {
  enumerable: true,
  get: function () {
    return _Units.METERS_PER_UNIT;
  }
});
Object.defineProperty(exports, "Projection", {
  enumerable: true,
  get: function () {
    return _Projection.default;
  }
});
exports.addCommon = addCommon;
exports.addCoordinateTransforms = addCoordinateTransforms;
exports.addEquivalentProjections = addEquivalentProjections;
exports.addEquivalentTransforms = addEquivalentTransforms;
exports.addProjection = addProjection;
exports.addProjections = addProjections;
exports.clearAllProjections = clearAllProjections;
exports.clearUserProjection = clearUserProjection;
exports.cloneTransform = cloneTransform;
exports.createProjection = createProjection;
exports.createSafeCoordinateTransform = createSafeCoordinateTransform;
exports.createTransformFromCoordinateTransform = createTransformFromCoordinateTransform;
exports.disableCoordinateWarning = disableCoordinateWarning;
exports.equivalent = equivalent;
exports.fromLonLat = fromLonLat;
exports.fromUserCoordinate = fromUserCoordinate;
exports.fromUserExtent = fromUserExtent;
exports.fromUserResolution = fromUserResolution;
exports.get = get;
exports.getPointResolution = getPointResolution;
exports.getTransform = getTransform;
exports.getTransformFromProjections = getTransformFromProjections;
exports.getUserProjection = getUserProjection;
exports.identityTransform = identityTransform;
exports.setUserProjection = setUserProjection;
exports.toLonLat = toLonLat;
exports.toUserCoordinate = toUserCoordinate;
exports.toUserExtent = toUserExtent;
exports.toUserResolution = toUserResolution;
exports.transform = transform;
exports.transformExtent = transformExtent;
exports.transformWithProjections = transformWithProjections;
exports.useGeographic = useGeographic;
var _Projection = _interopRequireDefault(require("./proj/Projection.js"));
var _epsg = require("./proj/epsg3857.js");
var _epsg2 = require("./proj/epsg4326.js");
var _Units = require("./proj/Units.js");
var _projections = require("./proj/projections.js");
var _transforms = require("./proj/transforms.js");
var _extent = require("./extent.js");
var _math = require("./math.js");
var _coordinate = require("./coordinate.js");
var _sphere = require("./sphere.js");
var _console = require("./console.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */

/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */

var showCoordinateWarning = true;

/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */
function disableCoordinateWarning(disable) {
  var hide = disable === undefined ? true : disable;
  showCoordinateWarning = !hide;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, output) {
  if (output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, output) {
  if (output !== undefined && input !== output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  (0, _projections.add)(projection.getCode(), projection);
  (0, _transforms.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string' ? (0, _projections.get)( /** @type {string} */projectionLike) : /** @type {Projection} */projectionLike || null;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / _Units.METERS_PER_UNIT[units];
      }
    }
  } else {
    var projUnits = projection.getUnits();
    if (projUnits == 'degrees' && !units || units == 'degrees') {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var _toEPSG = getTransformFromProjections(projection, get('EPSG:4326'));
      if (_toEPSG === identityTransform && projUnits !== 'degrees') {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
        vertices = _toEPSG(vertices, vertices, 2);
        var width = (0, _sphere.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = (0, _sphere.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      var _metersPerUnit = units ? _Units.METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (_metersPerUnit !== undefined) {
        pointResolution /= _metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0, _transforms.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0, _transforms.add)(projection1, projection2, forwardTransform);
      (0, _transforms.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  (0, _projections.clear)();
  (0, _transforms.clear)();
}

/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  }
  if (typeof projection === 'string') {
    return get(projection);
  }
  return /** @type {Projection} */projection;
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, output, dimension) {
      var length = input.length;
      dimension = dimension !== undefined ? dimension : 2;
      output = output !== undefined ? output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform(input.slice(i, i + dimension));
        var pointLength = point.length;
        for (var j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0, _transforms.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0, _transforms.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, projection) {
  var lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0, _math.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  var transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0, _transforms.get)(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, stops) {
  var transformFunc = getTransform(source, destination);
  return (0, _extent.applyTransform)(extent, transformFunc, undefined, stops);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * @type {Projection|null}
 */
var userProjection = null;

/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
function setUserProjection(projection) {
  userProjection = get(projection);
}

/**
 * Clear the user projection if set.
 * @api
 */
function clearUserProjection() {
  userProjection = null;
}

/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
function getUserProjection() {
  return userProjection;
}

/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */
function useGeographic() {
  setUserProjection('EPSG:4326');
}

/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}

/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !(0, _coordinate.equals)(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      (0, _console.warn)('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}

/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}

/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  var sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
  var userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  var destMetersPerUnit = get(destProjection).getMetersPerUnit();
  var userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}

/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    var transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = (0, _extent.getWidth)(sourceExtent);
      coord = coord.slice(0);
      worldsAway = (0, _coordinate.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        // Move x to the real world
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = (0, _math.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = (0, _math.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform(coord);
    } else {
      transformed = transform(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0, _extent.getWidth)(destProj.getExtent());
    }
    return transformed;
  };
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_epsg.PROJECTIONS);
  addEquivalentProjections(_epsg2.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_epsg2.PROJECTIONS, _epsg.PROJECTIONS, _epsg.fromEPSG4326, _epsg.toEPSG4326);
}
addCommon();
},{"./proj/Projection.js":"node_modules/ol/proj/Projection.js","./proj/epsg3857.js":"node_modules/ol/proj/epsg3857.js","./proj/epsg4326.js":"node_modules/ol/proj/epsg4326.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./proj/projections.js":"node_modules/ol/proj/projections.js","./proj/transforms.js":"node_modules/ol/proj/transforms.js","./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./coordinate.js":"node_modules/ol/coordinate.js","./sphere.js":"node_modules/ol/sphere.js","./console.js":"node_modules/ol/console.js"}],"node_modules/ol/geom/flat/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rotate = rotate;
exports.scale = scale;
exports.transform2D = transform2D;
exports.translate = translate;
/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
  dest = dest ? dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
},{}],"node_modules/ol/geom/Geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("../Object.js"));
var _util = require("../util.js");
var _transform = require("../transform.js");
var _extent2 = require("../extent.js");
var _proj = require("../proj.js");
var _functions = require("../functions.js");
var _transform2 = require("./flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/Geometry
 */
/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */

/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = (0, _transform.create)();

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = /*#__PURE__*/function (_BaseObject) {
  _inherits(Geometry, _BaseObject);
  var _super = _createSuper(Geometry);
  function Geometry() {
    var _this;
    _classCallCheck(this, Geometry);
    _this = _super.call(this);

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.extent_ = (0, _extent2.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    _this.extentRevision_ = -1;

    /**
     * @protected
     * @type {number}
     */
    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    _this.simplifiedGeometryRevision = 0;

    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    _this.simplifyTransformedInternal = (0, _functions.memoizeOne)(function (revision, squaredTolerance, transform) {
      if (!transform) {
        return _this.getSimplifiedGeometry(squaredTolerance);
      }
      var clone = _this.clone();
      clone.applyTransform(transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }

  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  _createClass(Geometry, [{
    key: "simplifyTransformed",
    value: function simplifyTransformed(squaredTolerance, transform) {
      return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }

    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
  }, {
    key: "clone",
    value: function clone() {
      return (0, _util.abstract)();
    }

    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      return (0, _util.abstract)();
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      var coord = this.getClosestPoint([x, y]);
      return coord[0] === x && coord[1] === y;
    }

    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
  }, {
    key: "getClosestPoint",
    value: function getClosestPoint(point, closestPoint) {
      closestPoint = closestPoint ? closestPoint : [NaN, NaN];
      this.closestPointXY(point[0], point[1], closestPoint, Infinity);
      return closestPoint;
    }

    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
  }, {
    key: "intersectsCoordinate",
    value: function intersectsCoordinate(coordinate) {
      return this.containsXY(coordinate[0], coordinate[1]);
    }

    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      return (0, _util.abstract)();
    }

    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      if (this.extentRevision_ != this.getRevision()) {
        var _extent = this.computeExtent(this.extent_);
        if (isNaN(_extent[0]) || isNaN(_extent[1])) {
          (0, _extent2.createOrUpdateEmpty)(_extent);
        }
        this.extentRevision_ = this.getRevision();
      }
      return (0, _extent2.returnOrUpdate)(this.extent_, extent);
    }

    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      (0, _util.abstract)();
    }

    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
  }, {
    key: "scale",
    value: function scale(sx, sy, anchor) {
      (0, _util.abstract)();
    }

    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
  }, {
    key: "simplify",
    value: function simplify(tolerance) {
      return this.getSimplifiedGeometry(tolerance * tolerance);
    }

    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      return (0, _util.abstract)();
    }

    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
  }, {
    key: "getType",
    value: function getType() {
      return (0, _util.abstract)();
    }

    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      (0, _util.abstract)();
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _util.abstract)();
    }

    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
  }, {
    key: "translate",
    value: function translate(deltaX, deltaY) {
      (0, _util.abstract)();
    }

    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {Geometry} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
  }, {
    key: "transform",
    value: function transform(source, destination) {
      /** @type {import("../proj/Projection.js").default} */
      var sourceProj = (0, _proj.get)(source);
      var transformFn = sourceProj.getUnits() == 'tile-pixels' ? function (inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        var projectedExtent = sourceProj.getWorldExtent();
        var scale = (0, _extent2.getHeight)(projectedExtent) / (0, _extent2.getHeight)(pixelExtent);
        (0, _transform.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
        (0, _transform2.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
        return (0, _proj.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
      } : (0, _proj.getTransform)(sourceProj, destination);
      this.applyTransform(transformFn);
      return this;
    }
  }]);
  return Geometry;
}(_Object.default);
var _default = exports.default = Geometry;
},{"../Object.js":"node_modules/ol/Object.js","../util.js":"node_modules/ol/util.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../functions.js":"node_modules/ol/functions.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/geom/SimpleGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getLayoutForStride = getLayoutForStride;
exports.getStrideForLayout = getStrideForLayout;
exports.transformGeom2D = transformGeom2D;
var _Geometry2 = _interopRequireDefault(require("./Geometry.js"));
var _util = require("../util.js");
var _extent = require("../extent.js");
var _transform = require("./flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/SimpleGeometry
 */
/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = /*#__PURE__*/function (_Geometry) {
  _inherits(SimpleGeometry, _Geometry);
  var _super = _createSuper(SimpleGeometry);
  function SimpleGeometry() {
    var _this;
    _classCallCheck(this, SimpleGeometry);
    _this = _super.call(this);

    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */
    _this.layout = 'XY';

    /**
     * @protected
     * @type {number}
     */
    _this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    _this.flatCoordinates;
    return _this;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  _createClass(SimpleGeometry, [{
    key: "computeExtent",
    value: function computeExtent(extent) {
      return (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }

    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return (0, _util.abstract)();
    }

    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
  }, {
    key: "getFirstCoordinate",
    value: function getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }

    /**
     * @return {Array<number>} Flat coordinates.
     */
  }, {
    key: "getFlatCoordinates",
    value: function getFlatCoordinates() {
      return this.flatCoordinates;
    }

    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
  }, {
    key: "getLastCoordinate",
    value: function getLastCoordinate() {
      return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    }

    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
  }, {
    key: "getLayout",
    value: function getLayout() {
      return this.layout;
    }

    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     */
  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      if (this.simplifiedGeometryRevision !== this.getRevision()) {
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = this.getRevision();
      }
      // If squaredTolerance is negative or if we know that simplification will not
      // have any effect then just return this.
      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }
      var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        return simplifiedGeometry;
      }
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      return this;
    }

    /**
     * @return {number} Stride.
     */
  }, {
    key: "getStride",
    value: function getStride() {
      return this.stride;
    }

    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
  }, {
    key: "setFlatCoordinates",
    value: function setFlatCoordinates(layout, flatCoordinates) {
      this.stride = getStrideForLayout(layout);
      this.layout = layout;
      this.flatCoordinates = flatCoordinates;
    }

    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      (0, _util.abstract)();
    }

    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
  }, {
    key: "setLayout",
    value: function setLayout(layout, coordinates, nesting) {
      var stride;
      if (layout) {
        stride = getStrideForLayout(layout);
      } else {
        for (var i = 0; i < nesting; ++i) {
          if (coordinates.length === 0) {
            this.layout = 'XY';
            this.stride = 2;
            return;
          }
          coordinates = /** @type {Array<unknown>} */coordinates[0];
        }
        stride = coordinates.length;
        layout = getLayoutForStride(stride);
      }
      this.layout = layout;
      this.stride = stride;
    }

    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      if (this.flatCoordinates) {
        transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
        this.changed();
      }
    }

    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      var flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        var stride = this.getStride();
        (0, _transform.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
        this.changed();
      }
    }

    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
  }, {
    key: "scale",
    value: function scale(sx, sy, anchor) {
      if (sy === undefined) {
        sy = sx;
      }
      if (!anchor) {
        anchor = (0, _extent.getCenter)(this.getExtent());
      }
      var flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        var stride = this.getStride();
        (0, _transform.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
        this.changed();
      }
    }

    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
  }, {
    key: "translate",
    value: function translate(deltaX, deltaY) {
      var flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        var stride = this.getStride();
        (0, _transform.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
        this.changed();
      }
    }
  }]);
  return SimpleGeometry;
}(_Geometry2.default);
/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = 'XY';
  } else if (stride == 3) {
    layout = 'XYZ';
  } else if (stride == 4) {
    layout = 'XYZM';
  }
  return /** @type {import("./Geometry.js").GeometryLayout} */layout;
}

/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  var stride;
  if (layout == 'XY') {
    stride = 2;
  } else if (layout == 'XYZ' || layout == 'XYM') {
    stride = 3;
  } else if (layout == 'XYZM') {
    stride = 4;
  }
  return /** @type {number} */stride;
}

/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  var stride = simpleGeometry.getStride();
  return (0, _transform.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);
}
var _default = exports.default = SimpleGeometry;
},{"./Geometry.js":"node_modules/ol/geom/Geometry.js","../util.js":"node_modules/ol/util.js","../extent.js":"node_modules/ol/extent.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/geom/flat/deflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deflateCoordinate = deflateCoordinate;
exports.deflateCoordinates = deflateCoordinates;
exports.deflateCoordinatesArray = deflateCoordinatesArray;
exports.deflateMultiCoordinatesArray = deflateMultiCoordinatesArray;
/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  var i = 0;
  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  var i = 0;
  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}
},{}],"node_modules/ol/geom/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _transform = require("./flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/Circle
 */
/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(Circle, _SimpleGeometry);
  var _super = _createSuper(Circle);
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function Circle(center, radius, layout) {
    var _this;
    _classCallCheck(this, Circle);
    _this = _super.call(this);
    if (layout !== undefined && radius === undefined) {
      _this.setFlatCoordinates(layout, center);
    } else {
      radius = radius ? radius : 0;
      _this.setCenterAndRadius(center, radius, layout);
    }
    return _this;
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  _createClass(Circle, [{
    key: "clone",
    value: function clone() {
      var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
      circle.applyProperties(this);
      return circle;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      var flatCoordinates = this.flatCoordinates;
      var dx = x - flatCoordinates[0];
      var dy = y - flatCoordinates[1];
      var squaredDistance = dx * dx + dy * dy;
      if (squaredDistance < minSquaredDistance) {
        if (squaredDistance === 0) {
          for (var i = 0; i < this.stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
        } else {
          var delta = this.getRadius() / Math.sqrt(squaredDistance);
          closestPoint[0] = flatCoordinates[0] + delta * dx;
          closestPoint[1] = flatCoordinates[1] + delta * dy;
          for (var _i = 2; _i < this.stride; ++_i) {
            closestPoint[_i] = flatCoordinates[_i];
          }
        }
        closestPoint.length = this.stride;
        return squaredDistance;
      }
      return minSquaredDistance;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      var flatCoordinates = this.flatCoordinates;
      var dx = x - flatCoordinates[0];
      var dy = y - flatCoordinates[1];
      return dx * dx + dy * dy <= this.getRadiusSquared_();
    }

    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      var flatCoordinates = this.flatCoordinates;
      var radius = flatCoordinates[this.stride] - flatCoordinates[0];
      return (0, _extent.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    }

    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
  }, {
    key: "getRadius",
    value: function getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }

    /**
     * @private
     * @return {number} Radius squared.
     */
  }, {
    key: "getRadiusSquared_",
    value: function getRadiusSquared_() {
      var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
      var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return dx * dx + dy * dy;
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'Circle';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      var circleExtent = this.getExtent();
      if ((0, _extent.intersects)(extent, circleExtent)) {
        var center = this.getCenter();
        if (extent[0] <= center[0] && extent[2] >= center[0]) {
          return true;
        }
        if (extent[1] <= center[1] && extent[3] >= center[1]) {
          return true;
        }
        return (0, _extent.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
      }
      return false;
    }

    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
  }, {
    key: "setCenter",
    value: function setCenter(center) {
      var stride = this.stride;
      var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
      var flatCoordinates = center.slice();
      flatCoordinates[stride] = flatCoordinates[0] + radius;
      for (var i = 1; i < stride; ++i) {
        flatCoordinates[stride + i] = center[i];
      }
      this.setFlatCoordinates(this.layout, flatCoordinates);
      this.changed();
    }

    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCenterAndRadius",
    value: function setCenterAndRadius(center, radius, layout) {
      this.setLayout(layout, center, 0);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      /** @type {Array<number>} */
      var flatCoordinates = this.flatCoordinates;
      var offset = (0, _deflate.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
      flatCoordinates[offset++] = flatCoordinates[0] + radius;
      for (var i = 1, ii = this.stride; i < ii; ++i) {
        flatCoordinates[offset++] = flatCoordinates[i];
      }
      flatCoordinates.length = offset;
      this.changed();
    }
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return null;
    }
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {}

    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
      this.changed();
    }

    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      var center = this.getCenter();
      var stride = this.getStride();
      this.setCenter((0, _transform.rotate)(center, 0, center.length, stride, angle, anchor, center));
      this.changed();
    }
  }]);
  return Circle;
}(_SimpleGeometry2.default);
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
var _default = exports.default = Circle;
},{"./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStyleFunction = createStyleFunction;
exports.default = void 0;
var _Object = _interopRequireDefault(require("./Object.js"));
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _asserts = require("./asserts.js");
var _events = require("./events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Feature
 */
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */
/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */
/***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */
/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */
var Feature = /*#__PURE__*/function (_BaseObject) {
  _inherits(Feature, _BaseObject);
  var _super = _createSuper(Feature);
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  function Feature(geometryOrProperties) {
    var _this;
    _classCallCheck(this, Feature);
    _this = _super.call(this);

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    _this.on;

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    _this.once;

    /***
     * @type {FeatureOnSignature<void>}
     */
    _this.un;

    /**
     * @private
     * @type {number|string|undefined}
     */
    _this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    _this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    _this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    _this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    _this.geometryChangeKey_ = null;
    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
    if (geometryOrProperties) {
      if (typeof ( /** @type {?} */geometryOrProperties.getSimplifiedGeometry) === 'function') {
        var geometry = /** @type {Geometry} */geometryOrProperties;
        _this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = geometryOrProperties;
        _this.setProperties(properties);
      }
    }
    return _this;
  }

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  _createClass(Feature, [{
    key: "clone",
    value: function clone() {
      var clone = /** @type {Feature<Geometry>} */
      new Feature(this.hasProperties() ? this.getProperties() : null);
      clone.setGeometryName(this.getGeometryName());
      var geometry = this.getGeometry();
      if (geometry) {
        clone.setGeometry( /** @type {Geometry} */geometry.clone());
      }
      var style = this.getStyle();
      if (style) {
        clone.setStyle(style);
      }
      return clone;
    }

    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return /** @type {Geometry|undefined} */this.get(this.geometryName_);
    }

    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
  }, {
    key: "getId",
    value: function getId() {
      return this.id_;
    }

    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
  }, {
    key: "getGeometryName",
    value: function getGeometryName() {
      return this.geometryName_;
    }

    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style_;
    }

    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
  }, {
    key: "getStyleFunction",
    value: function getStyleFunction() {
      return this.styleFunction_;
    }

    /**
     * @private
     */
  }, {
    key: "handleGeometryChange_",
    value: function handleGeometryChange_() {
      this.changed();
    }

    /**
     * @private
     */
  }, {
    key: "handleGeometryChanged_",
    value: function handleGeometryChanged_() {
      if (this.geometryChangeKey_) {
        (0, _events.unlistenByKey)(this.geometryChangeKey_);
        this.geometryChangeKey_ = null;
      }
      var geometry = this.getGeometry();
      if (geometry) {
        this.geometryChangeKey_ = (0, _events.listen)(geometry, _EventType.default.CHANGE, this.handleGeometryChange_, this);
      }
      this.changed();
    }

    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      this.set(this.geometryName_, geometry);
    }

    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.style_ = style;
      this.styleFunction_ = !style ? undefined : createStyleFunction(style);
      this.changed();
    }

    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
  }, {
    key: "setId",
    value: function setId(id) {
      this.id_ = id;
      this.changed();
    }

    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
  }, {
    key: "setGeometryName",
    value: function setGeometryName(name) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.geometryName_ = name;
      this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.handleGeometryChanged_();
    }
  }]);
  return Feature;
}(_Object.default);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  }
  /**
   * @type {Array<import("./style/Style.js").default>}
   */
  var styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    (0, _asserts.assert)(typeof ( /** @type {?} */obj.getZIndex) === 'function', 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`');
    var style = /** @type {import("./style/Style.js").default} */obj;
    styles = [style];
  }
  return function () {
    return styles;
  };
}
var _default = exports.default = Feature;
},{"./Object.js":"node_modules/ol/Object.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./asserts.js":"node_modules/ol/asserts.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/geom/GeometryCollection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Geometry2 = _interopRequireDefault(require("./Geometry.js"));
var _extent = require("../extent.js");
var _events = require("../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/GeometryCollection
 */
/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */
var GeometryCollection = /*#__PURE__*/function (_Geometry) {
  _inherits(GeometryCollection, _Geometry);
  var _super = _createSuper(GeometryCollection);
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  function GeometryCollection(geometries) {
    var _this;
    _classCallCheck(this, GeometryCollection);
    _this = _super.call(this);

    /**
     * @private
     * @type {Array<Geometry>}
     */
    _this.geometries_ = geometries ? geometries : null;

    /**
     * @type {Array<import("../events.js").EventsKey>}
     */
    _this.changeEventsKeys_ = [];
    _this.listenGeometriesChange_();
    return _this;
  }

  /**
   * @private
   */
  _createClass(GeometryCollection, [{
    key: "unlistenGeometriesChange_",
    value: function unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(_events.unlistenByKey);
      this.changeEventsKeys_.length = 0;
    }

    /**
     * @private
     */
  }, {
    key: "listenGeometriesChange_",
    value: function listenGeometriesChange_() {
      if (!this.geometries_) {
        return;
      }
      for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
        this.changeEventsKeys_.push((0, _events.listen)(this.geometries_[i], _EventType.default.CHANGE, this.changed, this));
      }
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var geometryCollection = new GeometryCollection(null);
      geometryCollection.setGeometries(this.geometries_);
      geometryCollection.applyProperties(this);
      return geometryCollection;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
      }
      return minSquaredDistance;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        if (geometries[i].containsXY(x, y)) {
          return true;
        }
      }
      return false;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      (0, _extent.createOrUpdateEmpty)(extent);
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        (0, _extent.extend)(extent, geometries[i].getExtent());
      }
      return extent;
    }

    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
  }, {
    key: "getGeometries",
    value: function getGeometries() {
      return cloneGeometries(this.geometries_);
    }

    /**
     * @return {Array<Geometry>} Geometries.
     */
  }, {
    key: "getGeometriesArray",
    value: function getGeometriesArray() {
      return this.geometries_;
    }

    /**
     * @return {Array<Geometry>} Geometries.
     */
  }, {
    key: "getGeometriesArrayRecursive",
    value: function getGeometriesArrayRecursive() {
      /** @type {Array<Geometry>} */
      var geometriesArray = [];
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        if (geometries[i].getType() === this.getType()) {
          geometriesArray = geometriesArray.concat( /** @type {GeometryCollection} */geometries[i].getGeometriesArrayRecursive());
        } else {
          geometriesArray.push(geometries[i]);
        }
      }
      return geometriesArray;
    }

    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     */
  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      if (this.simplifiedGeometryRevision !== this.getRevision()) {
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = this.getRevision();
      }
      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }
      var simplifiedGeometries = [];
      var geometries = this.geometries_;
      var simplified = false;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        var geometry = geometries[i];
        var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
        simplifiedGeometries.push(simplifiedGeometry);
        if (simplifiedGeometry !== geometry) {
          simplified = true;
        }
      }
      if (simplified) {
        var simplifiedGeometryCollection = new GeometryCollection(null);
        simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
        return simplifiedGeometryCollection;
      }
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'GeometryCollection';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        if (geometries[i].intersectsExtent(extent)) {
          return true;
        }
      }
      return false;
    }

    /**
     * @return {boolean} Is empty.
     */
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.geometries_.length === 0;
    }

    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].rotate(angle, anchor);
      }
      this.changed();
    }

    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
  }, {
    key: "scale",
    value: function scale(sx, sy, anchor) {
      if (!anchor) {
        anchor = (0, _extent.getCenter)(this.getExtent());
      }
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].scale(sx, sy, anchor);
      }
      this.changed();
    }

    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
  }, {
    key: "setGeometries",
    value: function setGeometries(geometries) {
      this.setGeometriesArray(cloneGeometries(geometries));
    }

    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
  }, {
    key: "setGeometriesArray",
    value: function setGeometriesArray(geometries) {
      this.unlistenGeometriesChange_();
      this.geometries_ = geometries;
      this.listenGeometriesChange_();
      this.changed();
    }

    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].applyTransform(transformFn);
      }
      this.changed();
    }

    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
  }, {
    key: "translate",
    value: function translate(deltaX, deltaY) {
      var geometries = this.geometries_;
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].translate(deltaX, deltaY);
      }
      this.changed();
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.unlistenGeometriesChange_();
      _get(_getPrototypeOf(GeometryCollection.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return GeometryCollection;
}(_Geometry2.default);
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */
function cloneGeometries(geometries) {
  var clonedGeometries = [];
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
}
var _default = exports.default = GeometryCollection;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Geometry.js":"node_modules/ol/geom/Geometry.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/interaction/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/interaction/Property
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  ACTIVE: 'active'
};
},{}],"node_modules/ol/geom/flat/closest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMaxSquaredDelta = arrayMaxSquaredDelta;
exports.assignClosestArrayPoint = assignClosestArrayPoint;
exports.assignClosestMultiArrayPoint = assignClosestMultiArrayPoint;
exports.assignClosestPoint = assignClosestPoint;
exports.maxSquaredDelta = maxSquaredDelta;
exports.multiArrayMaxSquaredDelta = multiArrayMaxSquaredDelta;
var _math = require("../../math.js");
/**
 * @module ol/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = (0, _math.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (var _i = 0; _i < stride; ++_i) {
    closestPoint[_i] = flatCoordinates[offset + _i];
  }
  closestPoint.length = stride;
}

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = (0, _math.squaredDistance)(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/simplify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.douglasPeucker = douglasPeucker;
exports.douglasPeuckerArray = douglasPeuckerArray;
exports.douglasPeuckerMultiArray = douglasPeuckerMultiArray;
exports.quantize = quantize;
exports.quantizeArray = quantizeArray;
exports.quantizeMultiArray = quantizeMultiArray;
exports.radialDistance = radialDistance;
exports.simplifyLineString = simplifyLineString;
exports.snap = snap;
var _math = require("../../math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
  simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var _squaredDistance = (0, _math.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
      if (_squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = _squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (var _i = 0; _i < n; ++_i) {
    if (markers[_i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride + 1];
    }
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    /** @type {Array<number>} */
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if ((0, _math.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    /** @type {Array<number>} */
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/segments.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;
/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  var ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
    if (ret) {
      return ret;
    }
  }
  return false;
}
},{}],"node_modules/ol/geom/flat/inflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inflateCoordinates = inflateCoordinates;
exports.inflateCoordinatesArray = inflateCoordinatesArray;
exports.inflateMultiCoordinatesArray = inflateMultiCoordinatesArray;
/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
  coordinates = coordinates !== undefined ? coordinates : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== undefined ? coordinatess : [];
  var i = 0;
  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
  var i = 0;
  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
},{}],"node_modules/ol/geom/flat/interpolate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolatePoint = interpolatePoint;
exports.lineStringCoordinateAtM = lineStringCoordinateAtM;
exports.lineStringsCoordinateAtM = lineStringsCoordinateAtM;
var _array = require("../../array.js");
var _math = require("../../math.js");
/**
 * @module ol/geom/flat/interpolate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  var o, t;
  var n = (end - offset) / stride;
  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = (0, _array.binarySearch)(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (var _i = 0; _i < dimension; ++_i) {
    dest[_i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + _i] : (0, _math.lerp)(flatCoordinates[o + _i], flatCoordinates[o + stride + _i], t);
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push((0, _math.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
}
},{"../../array.js":"node_modules/ol/array.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/contains.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingContainsExtent = linearRingContainsExtent;
exports.linearRingContainsXY = linearRingContainsXY;
exports.linearRingsContainsXY = linearRingsContainsXY;
exports.linearRingssContainsXY = linearRingssContainsXY;
var _extent = require("../../extent.js");
/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = (0, _extent.forEachCorner)(extent,
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/flat/intersectsextent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intersectsLineString = intersectsLineString;
exports.intersectsLineStringArray = intersectsLineStringArray;
exports.intersectsLinearRing = intersectsLinearRing;
exports.intersectsLinearRingArray = intersectsLinearRingArray;
exports.intersectsLinearRingMultiArray = intersectsLinearRingMultiArray;
var _extent = require("../../extent.js");
var _segments = require("./segments.js");
var _contains = require("./contains.js");
/**
 * @module ol/geom/flat/intersectsextent
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = (0, _extent.extendFlatCoordinates)((0, _extent.createEmpty)(), flatCoordinates, offset, end, stride);
  if (!(0, _extent.intersects)(extent, coordinatesExtent)) {
    return false;
  }
  if ((0, _extent.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return (0, _segments.forEach)(flatCoordinates, offset, end, stride,
  /**
   * @param {import("../../coordinate.js").Coordinate} point1 Start point.
   * @param {import("../../coordinate.js").Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return (0, _extent.intersectsSegment)(extent, point1, point2);
  });
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if ((0, _contains.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js","./segments.js":"node_modules/ol/geom/flat/segments.js","./contains.js":"node_modules/ol/geom/flat/contains.js"}],"node_modules/ol/geom/flat/length.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineStringLength = lineStringLength;
exports.linearRingLength = linearRingLength;
/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
},{}],"node_modules/ol/geom/LineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _closest = require("./flat/closest.js");
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _simplify = require("./flat/simplify.js");
var _array = require("../array.js");
var _segments = require("./flat/segments.js");
var _inflate = require("./flat/inflate.js");
var _interpolate = require("./flat/interpolate.js");
var _intersectsextent = require("./flat/intersectsextent.js");
var _length = require("./flat/length.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/LineString
 */
/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(LineString, _SimpleGeometry);
  var _super = _createSuper(LineString);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function LineString(coordinates, layout) {
    var _this;
    _classCallCheck(this, LineString);
    _this = _super.call(this);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    _this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDeltaRevision_ = -1;
    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
    } else {
      _this.setCoordinates( /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, layout);
    }
    return _this;
  }

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  _createClass(LineString, [{
    key: "appendCoordinate",
    value: function appendCoordinate(coordinate) {
      (0, _array.extend)(this.flatCoordinates, coordinate);
      this.changed();
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
      lineString.applyProperties(this);
      return lineString;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }

    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
  }, {
    key: "forEachSegment",
    value: function forEachSegment(callback) {
      return (0, _segments.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    }

    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
  }, {
    key: "getCoordinateAtM",
    value: function getCoordinateAtM(m, extrapolate) {
      if (this.layout != 'XYM' && this.layout != 'XYZM') {
        return null;
      }
      extrapolate = extrapolate !== undefined ? extrapolate : false;
      return (0, _interpolate.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    }

    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }

    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
  }, {
    key: "getCoordinateAt",
    value: function getCoordinateAt(fraction, dest) {
      return (0, _interpolate.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
    }

    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
  }, {
    key: "getLength",
    value: function getLength() {
      return (0, _length.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }

    /**
     * @return {Array<number>} Flat midpoint.
     */
  }, {
    key: "getFlatMidpoint",
    value: function getFlatMidpoint() {
      if (this.flatMidpointRevision_ != this.getRevision()) {
        var _this$flatMidpoint_;
        this.flatMidpoint_ = this.getCoordinateAt(0.5, (_this$flatMidpoint_ = this.flatMidpoint_) !== null && _this$flatMidpoint_ !== void 0 ? _this$flatMidpoint_ : undefined);
        this.flatMidpointRevision_ = this.getRevision();
      }
      return /** @type {Array<number>} */this.flatMidpoint_;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      /** @type {Array<number>} */
      var simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
      return new LineString(simplifiedFlatCoordinates, 'XY');
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'LineString';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _intersectsextent.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }

    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);
  return LineString;
}(_SimpleGeometry2.default);
var _default = exports.default = LineString;
},{"./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../array.js":"node_modules/ol/array.js","./flat/segments.js":"node_modules/ol/geom/flat/segments.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/length.js":"node_modules/ol/geom/flat/length.js"}],"node_modules/ol/MapEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Event2 = _interopRequireDefault(require("./events/Event.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/MapEvent
 */
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */
var MapEvent = /*#__PURE__*/function (_Event) {
  _inherits(MapEvent, _Event);
  var _super = _createSuper(MapEvent);
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  function MapEvent(type, map, frameState) {
    var _this;
    _classCallCheck(this, MapEvent);
    _this = _super.call(this, type);

    /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */
    _this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */
    _this.frameState = frameState !== undefined ? frameState : null;
    return _this;
  }
  return _createClass(MapEvent);
}(_Event2.default);
var _default = exports.default = MapEvent;
},{"./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/MapBrowserEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _MapEvent2 = _interopRequireDefault(require("./MapEvent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/MapBrowserEvent
 */
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
var MapBrowserEvent = /*#__PURE__*/function (_MapEvent) {
  _inherits(MapBrowserEvent, _MapEvent);
  var _super = _createSuper(MapBrowserEvent);
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  function MapBrowserEvent(type, map, originalEvent, dragging, frameState, activePointers) {
    var _this;
    _classCallCheck(this, MapBrowserEvent);
    _this = _super.call(this, type, map, frameState);

    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */
    _this.originalEvent = originalEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */
    _this.pixel_ = null;

    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */
    _this.coordinate_ = null;

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    _this.dragging = dragging !== undefined ? dragging : false;

    /**
     * @type {Array<PointerEvent>|undefined}
     */
    _this.activePointers = activePointers;
    return _this;
  }

  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  _createClass(MapBrowserEvent, [{
    key: "pixel",
    get: function get() {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }
      return this.pixel_;
    },
    set: function set(pixel) {
      this.pixel_ = pixel;
    }

    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
  }, {
    key: "coordinate",
    get: function get() {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }
      return this.coordinate_;
    },
    set: function set(coordinate) {
      this.coordinate_ = coordinate;
    }

    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     */
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      _get(_getPrototypeOf(MapBrowserEvent.prototype), "preventDefault", this).call(this);
      if ('preventDefault' in this.originalEvent) {
        /** @type {UIEvent} */this.originalEvent.preventDefault();
      }
    }

    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      _get(_getPrototypeOf(MapBrowserEvent.prototype), "stopPropagation", this).call(this);
      if ('stopPropagation' in this.originalEvent) {
        /** @type {UIEvent} */this.originalEvent.stopPropagation();
      }
    }
  }]);
  return MapBrowserEvent;
}(_MapEvent2.default);
var _default = exports.default = MapBrowserEvent;
},{"./MapEvent.js":"node_modules/ol/MapEvent.js"}],"node_modules/ol/MapBrowserEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/MapBrowserEventType
 */
/**
 * Constants for event names.
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _EventType.default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _EventType.default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */
},{"./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/geom/MultiLineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _LineString = _interopRequireDefault(require("./LineString.js"));
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _closest = require("./flat/closest.js");
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _simplify = require("./flat/simplify.js");
var _array = require("../array.js");
var _inflate = require("./flat/inflate.js");
var _interpolate = require("./flat/interpolate.js");
var _intersectsextent = require("./flat/intersectsextent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/MultiLineString
 */
/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(MultiLineString, _SimpleGeometry);
  var _super = _createSuper(MultiLineString);
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  function MultiLineString(coordinates, layout, ends) {
    var _this;
    _classCallCheck(this, MultiLineString);
    _this = _super.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    _this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDeltaRevision_ = -1;
    if (Array.isArray(coordinates[0])) {
      _this.setCoordinates( /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, layout);
    } else if (layout !== undefined && ends) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
      _this.ends_ = ends;
    } else {
      var lineStrings = /** @type {Array<LineString>} */coordinates;
      /** @type {Array<number>} */
      var flatCoordinates = [];
      var _ends = [];
      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];
        (0, _array.extend)(flatCoordinates, lineString.getFlatCoordinates());
        _ends.push(flatCoordinates.length);
      }
      var _layout = lineStrings.length === 0 ? _this.getLayout() : lineStrings[0].getLayout();
      _this.setFlatCoordinates(_layout, flatCoordinates);
      _this.ends_ = _ends;
    }
    return _this;
  }

  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  _createClass(MultiLineString, [{
    key: "appendLineString",
    value: function appendLineString(lineString) {
      (0, _array.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      multiLineString.applyProperties(this);
      return multiLineString;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }

    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
  }, {
    key: "getCoordinateAtM",
    value: function getCoordinateAtM(m, extrapolate, interpolate) {
      if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) {
        return null;
      }
      extrapolate = extrapolate !== undefined ? extrapolate : false;
      interpolate = interpolate !== undefined ? interpolate : false;
      return (0, _interpolate.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    }

    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return (0, _inflate.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
    }

    /**
     * @return {Array<number>} Ends.
     */
  }, {
    key: "getEnds",
    value: function getEnds() {
      return this.ends_;
    }

    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
  }, {
    key: "getLineString",
    value: function getLineString(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }
      return new _LineString.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }

    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
  }, {
    key: "getLineStrings",
    value: function getLineStrings() {
      var flatCoordinates = this.flatCoordinates;
      var ends = this.ends_;
      var layout = this.layout;
      /** @type {Array<LineString>} */
      var lineStrings = [];
      var offset = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var lineString = new _LineString.default(flatCoordinates.slice(offset, end), layout);
        lineStrings.push(lineString);
        offset = end;
      }
      return lineStrings;
    }

    /**
     * @return {Array<number>} Flat midpoints.
     */
  }, {
    key: "getFlatMidpoints",
    value: function getFlatMidpoints() {
      /** @type {Array<number>} */
      var midpoints = [];
      var flatCoordinates = this.flatCoordinates;
      var offset = 0;
      var ends = this.ends_;
      var stride = this.stride;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
        (0, _array.extend)(midpoints, midpoint);
        offset = end;
      }
      return midpoints;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      /** @type {Array<number>} */
      var simplifiedFlatCoordinates = [];
      /** @type {Array<number>} */
      var simplifiedEnds = [];
      simplifiedFlatCoordinates.length = (0, _simplify.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
      return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'MultiLineString';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _intersectsextent.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    }

    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 2);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    }
  }]);
  return MultiLineString;
}(_SimpleGeometry2.default);
var _default = exports.default = MultiLineString;
},{"./LineString.js":"node_modules/ol/geom/LineString.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../array.js":"node_modules/ol/array.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js"}],"node_modules/ol/geom/Point.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _math = require("../math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/Point
 */
/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(Point, _SimpleGeometry);
  var _super = _createSuper(Point);
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function Point(coordinates, layout) {
    var _this;
    _classCallCheck(this, Point);
    _this = _super.call(this);
    _this.setCoordinates(coordinates, layout);
    return _this;
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  _createClass(Point, [{
    key: "clone",
    value: function clone() {
      var point = new Point(this.flatCoordinates.slice(), this.layout);
      point.applyProperties(this);
      return point;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      var flatCoordinates = this.flatCoordinates;
      var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);
      if (squaredDistance < minSquaredDistance) {
        var stride = this.stride;
        for (var i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
        closestPoint.length = stride;
        return squaredDistance;
      }
      return minSquaredDistance;
    }

    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return this.flatCoordinates.slice();
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      return (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'Point';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _extent.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }

    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 0);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = (0, _deflate.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);
  return Point;
}(_SimpleGeometry2.default);
var _default = exports.default = Point;
},{"./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/MultiPoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Point = _interopRequireDefault(require("./Point.js"));
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _array = require("../array.js");
var _inflate = require("./flat/inflate.js");
var _math = require("../math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/MultiPoint
 */
/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(MultiPoint, _SimpleGeometry);
  var _super = _createSuper(MultiPoint);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function MultiPoint(coordinates, layout) {
    var _this;
    _classCallCheck(this, MultiPoint);
    _this = _super.call(this);
    if (layout && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
    } else {
      _this.setCoordinates( /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, layout);
    }
    return _this;
  }

  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  _createClass(MultiPoint, [{
    key: "appendPoint",
    value: function appendPoint(point) {
      (0, _array.extend)(this.flatCoordinates, point.getFlatCoordinates());
      this.changed();
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
      multiPoint.applyProperties(this);
      return multiPoint;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      var flatCoordinates = this.flatCoordinates;
      var stride = this.stride;
      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
        if (squaredDistance < minSquaredDistance) {
          minSquaredDistance = squaredDistance;
          for (var j = 0; j < stride; ++j) {
            closestPoint[j] = flatCoordinates[i + j];
          }
          closestPoint.length = stride;
        }
      }
      return minSquaredDistance;
    }

    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }

    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
  }, {
    key: "getPoint",
    value: function getPoint(index) {
      var n = this.flatCoordinates.length / this.stride;
      if (index < 0 || n <= index) {
        return null;
      }
      return new _Point.default(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    }

    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
  }, {
    key: "getPoints",
    value: function getPoints() {
      var flatCoordinates = this.flatCoordinates;
      var layout = this.layout;
      var stride = this.stride;
      /** @type {Array<Point>} */
      var points = [];
      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        var point = new _Point.default(flatCoordinates.slice(i, i + stride), layout);
        points.push(point);
      }
      return points;
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'MultiPoint';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      var flatCoordinates = this.flatCoordinates;
      var stride = this.stride;
      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        var x = flatCoordinates[i];
        var y = flatCoordinates[i + 1];
        if ((0, _extent.containsXY)(extent, x, y)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);
  return MultiPoint;
}(_SimpleGeometry2.default);
var _default = exports.default = MultiPoint;
},{"./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/area.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRing = linearRing;
exports.linearRings = linearRings;
exports.linearRingss = linearRingss;
/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}
},{}],"node_modules/ol/geom/LinearRing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _closest = require("./flat/closest.js");
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _simplify = require("./flat/simplify.js");
var _inflate = require("./flat/inflate.js");
var _area = require("./flat/area.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/LinearRing
 */
/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(LinearRing, _SimpleGeometry);
  var _super = _createSuper(LinearRing);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function LinearRing(coordinates, layout) {
    var _this;
    _classCallCheck(this, LinearRing);
    _this = _super.call(this);

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDeltaRevision_ = -1;
    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
    } else {
      _this.setCoordinates( /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, layout);
    }
    return _this;
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  _createClass(LinearRing, [{
    key: "clone",
    value: function clone() {
      return new LinearRing(this.flatCoordinates.slice(), this.layout);
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }

    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
  }, {
    key: "getArea",
    value: function getArea() {
      return (0, _area.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }

    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      /** @type {Array<number>} */
      var simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
      return new LinearRing(simplifiedFlatCoordinates, 'XY');
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'LinearRing';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return false;
    }

    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);
  return LinearRing;
}(_SimpleGeometry2.default);
var _default = exports.default = LinearRing;
},{"./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/area.js":"node_modules/ol/geom/flat/area.js"}],"node_modules/ol/geom/flat/interiorpoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteriorPointOfArray = getInteriorPointOfArray;
exports.getInteriorPointsOfMultiArray = getInteriorPointsOfMultiArray;
var _array = require("../../array.js");
var _contains = require("./contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array.ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if ((0, _contains.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  /** @type {Array<number>} */
  var interiorPoints = [];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}
},{"../../array.js":"node_modules/ol/array.js","./contains.js":"node_modules/ol/geom/flat/contains.js"}],"node_modules/ol/geom/flat/reverse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordinates = coordinates;
/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
},{}],"node_modules/ol/geom/flat/orient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inflateEnds = inflateEnds;
exports.linearRingIsClockwise = linearRingIsClockwise;
exports.linearRingsAreOriented = linearRingsAreOriented;
exports.linearRingssAreOriented = linearRingssAreOriented;
exports.orientLinearRings = orientLinearRings;
exports.orientLinearRingsArray = orientLinearRingsArray;
var _reverse = require("./reverse.js");
/**
 * @module ol/geom/flat/orient
 */

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? undefined : edge > 0;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== undefined ? right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== undefined ? right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      (0, _reverse.coordinates)(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
  }
  return offset;
}

/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */
function inflateEnds(flatCoordinates, ends) {
  var endss = [];
  var offset = 0;
  var prevEndIndex = 0;
  var startOrientation;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    // classifies an array of rings into polygons with outer rings and holes
    var orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === undefined) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}
},{"./reverse.js":"node_modules/ol/geom/flat/reverse.js"}],"node_modules/ol/geom/Polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circular = circular;
exports.default = void 0;
exports.fromCircle = fromCircle;
exports.fromExtent = fromExtent;
exports.makeRegular = makeRegular;
var _LinearRing = _interopRequireDefault(require("./LinearRing.js"));
var _Point = _interopRequireDefault(require("./Point.js"));
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _closest = require("./flat/closest.js");
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _array = require("../array.js");
var _interiorpoint = require("./flat/interiorpoint.js");
var _inflate = require("./flat/inflate.js");
var _intersectsextent = require("./flat/intersectsextent.js");
var _orient = require("./flat/orient.js");
var _area = require("./flat/area.js");
var _contains = require("./flat/contains.js");
var _math = require("../math.js");
var _simplify = require("./flat/simplify.js");
var _sphere = require("../sphere.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/Polygon
 */
/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(Polygon, _SimpleGeometry);
  var _super = _createSuper(Polygon);
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  function Polygon(coordinates, layout, ends) {
    var _this;
    _classCallCheck(this, Polygon);
    _this = _super.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    _this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    _this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    _this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    _this.orientedFlatCoordinates_ = null;
    if (layout !== undefined && ends) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
      _this.ends_ = ends;
    } else {
      _this.setCoordinates( /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, layout);
    }
    return _this;
  }

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  _createClass(Polygon, [{
    key: "appendLinearRing",
    value: function appendLinearRing(linearRing) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = linearRing.getFlatCoordinates().slice();
      } else {
        (0, _array.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
      }
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      polygon.applyProperties(this);
      return polygon;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      return (0, _contains.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }

    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
  }, {
    key: "getArea",
    value: function getArea() {
      return (0, _area.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }

    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates(right) {
      var flatCoordinates;
      if (right !== undefined) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        (0, _orient.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
      } else {
        flatCoordinates = this.flatCoordinates;
      }
      return (0, _inflate.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
    }

    /**
     * @return {Array<number>} Ends.
     */
  }, {
    key: "getEnds",
    value: function getEnds() {
      return this.ends_;
    }

    /**
     * @return {Array<number>} Interior point.
     */
  }, {
    key: "getFlatInteriorPoint",
    value: function getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        var flatCenter = (0, _extent.getCenter)(this.getExtent());
        this.flatInteriorPoint_ = (0, _interiorpoint.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
        this.flatInteriorPointRevision_ = this.getRevision();
      }
      return /** @type {import("../coordinate.js").Coordinate} */(
        this.flatInteriorPoint_
      );
    }

    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
  }, {
    key: "getInteriorPoint",
    value: function getInteriorPoint() {
      return new _Point.default(this.getFlatInteriorPoint(), 'XYM');
    }

    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
  }, {
    key: "getLinearRingCount",
    value: function getLinearRingCount() {
      return this.ends_.length;
    }

    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
  }, {
    key: "getLinearRing",
    value: function getLinearRing(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }
      return new _LinearRing.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }

    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
  }, {
    key: "getLinearRings",
    value: function getLinearRings() {
      var layout = this.layout;
      var flatCoordinates = this.flatCoordinates;
      var ends = this.ends_;
      var linearRings = [];
      var offset = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var linearRing = new _LinearRing.default(flatCoordinates.slice(offset, end), layout);
        linearRings.push(linearRing);
        offset = end;
      }
      return linearRings;
    }

    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
  }, {
    key: "getOrientedFlatCoordinates",
    value: function getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        var flatCoordinates = this.flatCoordinates;
        if ((0, _orient.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
        }
        this.orientedRevision_ = this.getRevision();
      }
      return /** @type {Array<number>} */this.orientedFlatCoordinates_;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      /** @type {Array<number>} */
      var simplifiedFlatCoordinates = [];
      /** @type {Array<number>} */
      var simplifiedEnds = [];
      simplifiedFlatCoordinates.length = (0, _simplify.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
      return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'Polygon';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _intersectsextent.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }

    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 2);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    }
  }]);
  return Polygon;
}(_SimpleGeometry2.default);
var _default = exports.default = Polygon;
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  /** @type {Array<number>} */
  var flatCoordinates = [];
  for (var i = 0; i < n; ++i) {
    (0, _array.extend)(flatCoordinates, (0, _sphere.offset)(center, radius, 2 * Math.PI * i / n, sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  if ((0, _extent.isEmpty)(extent)) {
    throw new Error('Cannot create polygon from empty extent');
  }
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */
function makeRegular(polygon, center, radius, angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = angle ? angle : 0;
  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var _angle = startAngle + (0, _math.modulo)(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(_angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(_angle);
  }
  polygon.changed();
}
},{"./LinearRing.js":"node_modules/ol/geom/LinearRing.js","./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","../math.js":"node_modules/ol/math.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../sphere.js":"node_modules/ol/sphere.js"}],"node_modules/ol/geom/flat/center.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingss = linearRingss;
var _extent = require("../../extent.js");
/**
 * @module ol/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = (0, _extent.createEmpty)();
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = (0, _extent.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/MultiPolygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _MultiPoint = _interopRequireDefault(require("./MultiPoint.js"));
var _Polygon = _interopRequireDefault(require("./Polygon.js"));
var _SimpleGeometry2 = _interopRequireDefault(require("./SimpleGeometry.js"));
var _closest = require("./flat/closest.js");
var _extent = require("../extent.js");
var _deflate = require("./flat/deflate.js");
var _array = require("../array.js");
var _interiorpoint = require("./flat/interiorpoint.js");
var _inflate = require("./flat/inflate.js");
var _intersectsextent = require("./flat/intersectsextent.js");
var _orient = require("./flat/orient.js");
var _area = require("./flat/area.js");
var _center = require("./flat/center.js");
var _contains = require("./flat/contains.js");
var _simplify = require("./flat/simplify.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/geom/MultiPolygon
 */
/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(MultiPolygon, _SimpleGeometry);
  var _super = _createSuper(MultiPolygon);
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  function MultiPolygon(coordinates, layout, endss) {
    var _this;
    _classCallCheck(this, MultiPolygon);
    _this = _super.call(this);

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    _this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    _this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    _this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    _this.orientedFlatCoordinates_ = null;
    if (!endss && !Array.isArray(coordinates[0])) {
      var polygons = /** @type {Array<Polygon>} */coordinates;
      /** @type {Array<number>} */
      var flatCoordinates = [];
      var thisEndss = [];
      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];
        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        (0, _array.extend)(flatCoordinates, polygon.getFlatCoordinates());
        thisEndss.push(ends);
      }
      layout = polygons.length === 0 ? _this.getLayout() : polygons[0].getLayout();
      coordinates = flatCoordinates;
      endss = thisEndss;
    }
    if (layout !== undefined && endss) {
      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);
      _this.endss_ = endss;
    } else {
      _this.setCoordinates( /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      coordinates, layout);
    }
    return _this;
  }

  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  _createClass(MultiPolygon, [{
    key: "appendPolygon",
    value: function appendPolygon(polygon) {
      /** @type {Array<number>} */
      var ends;
      if (!this.flatCoordinates) {
        this.flatCoordinates = polygon.getFlatCoordinates().slice();
        ends = polygon.getEnds().slice();
        this.endss_.push();
      } else {
        var offset = this.flatCoordinates.length;
        (0, _array.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
        ends = polygon.getEnds().slice();
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          ends[i] += offset;
        }
      }
      this.endss_.push(ends);
      this.changed();
    }

    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     */
  }, {
    key: "clone",
    value: function clone() {
      var len = this.endss_.length;
      var newEndss = new Array(len);
      for (var i = 0; i < len; ++i) {
        newEndss[i] = this.endss_[i].slice();
      }
      var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
      multiPolygon.applyProperties(this);
      return multiPolygon;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt((0, _closest.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return (0, _closest.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      return (0, _contains.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    }

    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
  }, {
    key: "getArea",
    value: function getArea() {
      return (0, _area.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }

    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     */
  }, {
    key: "getCoordinates",
    value: function getCoordinates(right) {
      var flatCoordinates;
      if (right !== undefined) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        (0, _orient.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, right);
      } else {
        flatCoordinates = this.flatCoordinates;
      }
      return (0, _inflate.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
    }

    /**
     * @return {Array<Array<number>>} Endss.
     */
  }, {
    key: "getEndss",
    value: function getEndss() {
      return this.endss_;
    }

    /**
     * @return {Array<number>} Flat interior points.
     */
  }, {
    key: "getFlatInteriorPoints",
    value: function getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        var flatCenters = (0, _center.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
        this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
        this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return /** @type {Array<number>} */this.flatInteriorPoints_;
    }

    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
  }, {
    key: "getInteriorPoints",
    value: function getInteriorPoints() {
      return new _MultiPoint.default(this.getFlatInteriorPoints().slice(), 'XYM');
    }

    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
  }, {
    key: "getOrientedFlatCoordinates",
    value: function getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        var flatCoordinates = this.flatCoordinates;
        if ((0, _orient.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
        }
        this.orientedRevision_ = this.getRevision();
      }
      return /** @type {Array<number>} */this.orientedFlatCoordinates_;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     */
  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      /** @type {Array<number>} */
      var simplifiedFlatCoordinates = [];
      /** @type {Array<Array<number>>} */
      var simplifiedEndss = [];
      simplifiedFlatCoordinates.length = (0, _simplify.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
      return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
    }

    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
  }, {
    key: "getPolygon",
    value: function getPolygon(index) {
      if (index < 0 || this.endss_.length <= index) {
        return null;
      }
      var offset;
      if (index === 0) {
        offset = 0;
      } else {
        var prevEnds = this.endss_[index - 1];
        offset = prevEnds[prevEnds.length - 1];
      }
      var ends = this.endss_[index].slice();
      var end = ends[ends.length - 1];
      if (offset !== 0) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          ends[i] -= offset;
        }
      }
      return new _Polygon.default(this.flatCoordinates.slice(offset, end), this.layout, ends);
    }

    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
  }, {
    key: "getPolygons",
    value: function getPolygons() {
      var layout = this.layout;
      var flatCoordinates = this.flatCoordinates;
      var endss = this.endss_;
      var polygons = [];
      var offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i].slice();
        var end = ends[ends.length - 1];
        if (offset !== 0) {
          for (var j = 0, jj = ends.length; j < jj; ++j) {
            ends[j] -= offset;
          }
        }
        var polygon = new _Polygon.default(flatCoordinates.slice(offset, end), layout, ends);
        polygons.push(polygon);
        offset = end;
      }
      return polygons;
    }

    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return 'MultiPolygon';
    }

    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return (0, _intersectsextent.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    }

    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 3);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      var endss = (0, _deflate.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
      if (endss.length === 0) {
        this.flatCoordinates.length = 0;
      } else {
        var lastEnds = endss[endss.length - 1];
        this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
      }
      this.changed();
    }
  }]);
  return MultiPolygon;
}(_SimpleGeometry2.default);
var _default = exports.default = MultiPolygon;
},{"./MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","./Polygon.js":"node_modules/ol/geom/Polygon.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/center.js":"node_modules/ol/geom/flat/center.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/easing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.inAndOut = inAndOut;
exports.linear = linear;
exports.upAndDown = upAndDown;
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  }
  return 1 - inAndOut(2 * (t - 0.5));
}
},{}],"node_modules/ol/interaction/Interaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.pan = pan;
exports.zoomByDelta = zoomByDelta;
var _Object = _interopRequireDefault(require("../Object.js"));
var _Property = _interopRequireDefault(require("./Property.js"));
var _easing = require("../easing.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/Interaction
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */
/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction = /*#__PURE__*/function (_BaseObject) {
  _inherits(Interaction, _BaseObject);
  var _super = _createSuper(Interaction);
  /**
   * @param {InteractionOptions} [options] Options.
   */
  function Interaction(options) {
    var _this;
    _classCallCheck(this, Interaction);
    _this = _super.call(this);

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {InteractionOnSignature<void>}
     */
    _this.un;
    if (options && options.handleEvent) {
      _this.handleEvent = options.handleEvent;
    }

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    _this.map_ = null;
    _this.setActive(true);
    return _this;
  }

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  _createClass(Interaction, [{
    key: "getActive",
    value: function getActive() {
      return /** @type {boolean} */this.get(_Property.default.ACTIVE);
    }

    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }

    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      return true;
    }

    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
  }, {
    key: "setActive",
    value: function setActive(active) {
      this.set(_Property.default.ACTIVE, active);
    }

    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      this.map_ = map;
    }
  }]);
  return Interaction;
}(_Object.default);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */
function pan(view, delta, duration) {
  var currentCenter = view.getCenterInternal();
  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== undefined ? duration : 250,
      easing: _easing.linear,
      center: view.getConstrainedCenter(center)
    });
  }
}

/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */
function zoomByDelta(view, delta, anchor, duration) {
  var currentZoom = view.getZoom();
  if (currentZoom === undefined) {
    return;
  }
  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor: anchor,
    duration: duration !== undefined ? duration : 250,
    easing: _easing.easeOut
  });
}
var _default = exports.default = Interaction;
},{"../Object.js":"node_modules/ol/Object.js","./Property.js":"node_modules/ol/interaction/Property.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/interaction/Pointer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.centroid = centroid;
exports.default = void 0;
var _Interaction2 = _interopRequireDefault(require("./Interaction.js"));
var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/Pointer
 */
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */
/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction = /*#__PURE__*/function (_Interaction) {
  _inherits(PointerInteraction, _Interaction);
  var _super = _createSuper(PointerInteraction);
  /**
   * @param {Options} [options] Options.
   */
  function PointerInteraction(options) {
    var _this;
    _classCallCheck(this, PointerInteraction);
    options = options ? options : {};
    _this = _super.call(this, /** @type {import("./Interaction.js").InteractionOptions} */options);
    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }

    /**
     * @type {boolean}
     * @protected
     */
    _this.handlingDownUpSequence = false;

    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    _this.targetPointers = [];
    return _this;
  }

  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  _createClass(PointerInteraction, [{
    key: "getPointerCount",
    value: function getPointerCount() {
      return this.targetPointers.length;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      return false;
    }

    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
  }, {
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {}

    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      if (!mapBrowserEvent.originalEvent) {
        return true;
      }
      var stopEvent = false;
      this.updateTrackedPointers_(mapBrowserEvent);
      if (this.handlingDownUpSequence) {
        if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDRAG) {
          this.handleDragEvent(mapBrowserEvent);
          // prevent page scrolling during dragging
          mapBrowserEvent.originalEvent.preventDefault();
        } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERUP) {
          var handledUp = this.handleUpEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
        }
      } else {
        if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDOWN) {
          var handled = this.handleDownEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handled;
          stopEvent = this.stopDown(handled);
        } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE) {
          this.handleMoveEvent(mapBrowserEvent);
        }
      }
      return !stopEvent;
    }

    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
  }, {
    key: "handleMoveEvent",
    value: function handleMoveEvent(mapBrowserEvent) {}

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      return false;
    }

    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
  }, {
    key: "stopDown",
    value: function stopDown(handled) {
      return handled;
    }

    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
  }, {
    key: "updateTrackedPointers_",
    value: function updateTrackedPointers_(mapBrowserEvent) {
      if (mapBrowserEvent.activePointers) {
        this.targetPointers = mapBrowserEvent.activePointers;
      }
    }
  }]);
  return PointerInteraction;
}(_Interaction2.default);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {{clientX: number, clientY: number}} Centroid pixel.
 */
function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return {
    clientX: clientX / length,
    clientY: clientY / length
  };
}
var _default = exports.default = PointerInteraction;
},{"./Interaction.js":"node_modules/ol/interaction/Interaction.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js"}],"node_modules/ol/layer/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/layer/Property
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source',
  MAP: 'map'
};
},{}],"node_modules/ol/layer/Base.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("../Object.js"));
var _Property = _interopRequireDefault(require("./Property.js"));
var _util = require("../util.js");
var _asserts = require("../asserts.js");
var _math = require("../math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Base
 */
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */
/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = /*#__PURE__*/function (_BaseObject) {
  _inherits(BaseLayer, _BaseObject);
  var _super = _createSuper(BaseLayer);
  /**
   * @param {Options} options Layer options.
   */
  function BaseLayer(options) {
    var _this;
    _classCallCheck(this, BaseLayer);
    _this = _super.call(this);

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {BaseLayerOnSignature<void>}
     */
    _this.un;

    /**
     * @type {BackgroundColor|false}
     * @private
     */
    _this.background_ = options.background;

    /**
     * @type {Object<string, *>}
     */
    var properties = Object.assign({}, options);
    if (_typeof(options.properties) === 'object') {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[_Property.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
    (0, _asserts.assert)(typeof properties[_Property.default.OPACITY] === 'number', 'Layer opacity must be a number');
    properties[_Property.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
    properties[_Property.default.Z_INDEX] = options.zIndex;
    properties[_Property.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property.default.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property.default.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;

    /**
     * @type {string}
     * @private
     */
    _this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
    delete properties.className;
    _this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    _this.state_ = null;
    return _this;
  }

  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  _createClass(BaseLayer, [{
    key: "getBackground",
    value: function getBackground() {
      return this.background_;
    }

    /**
     * @return {string} CSS class name.
     */
  }, {
    key: "getClassName",
    value: function getClassName() {
      return this.className_;
    }

    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
  }, {
    key: "getLayerState",
    value: function getLayerState(managed) {
      /** @type {import("./Layer.js").State} */
      var state = this.state_ || ( /** @type {?} */{
        layer: this,
        managed: managed === undefined ? true : managed
      });
      var zIndex = this.getZIndex();
      state.opacity = (0, _math.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
      state.visible = this.getVisible();
      state.extent = this.getExtent();
      state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
      state.maxResolution = this.getMaxResolution();
      state.minResolution = Math.max(this.getMinResolution(), 0);
      state.minZoom = this.getMinZoom();
      state.maxZoom = this.getMaxZoom();
      this.state_ = state;
      return state;
    }

    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
  }, {
    key: "getLayersArray",
    value: function getLayersArray(array) {
      return (0, _util.abstract)();
    }

    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(states) {
      return (0, _util.abstract)();
    }

    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent() {
      return /** @type {import("../extent.js").Extent|undefined} */(
        this.get(_Property.default.EXTENT)
      );
    }

    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getMaxResolution",
    value: function getMaxResolution() {
      return /** @type {number} */this.get(_Property.default.MAX_RESOLUTION);
    }

    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getMinResolution",
    value: function getMinResolution() {
      return /** @type {number} */this.get(_Property.default.MIN_RESOLUTION);
    }

    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return /** @type {number} */this.get(_Property.default.MIN_ZOOM);
    }

    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return /** @type {number} */this.get(_Property.default.MAX_ZOOM);
    }

    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return /** @type {number} */this.get(_Property.default.OPACITY);
    }

    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
  }, {
    key: "getSourceState",
    value: function getSourceState() {
      return (0, _util.abstract)();
    }

    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getVisible",
    value: function getVisible() {
      return /** @type {boolean} */this.get(_Property.default.VISIBLE);
    }

    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
  }, {
    key: "getZIndex",
    value: function getZIndex() {
      return /** @type {number|undefined} */this.get(_Property.default.Z_INDEX);
    }

    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
  }, {
    key: "setBackground",
    value: function setBackground(background) {
      this.background_ = background;
      this.changed();
    }

    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setExtent",
    value: function setExtent(extent) {
      this.set(_Property.default.EXTENT, extent);
    }

    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setMaxResolution",
    value: function setMaxResolution(maxResolution) {
      this.set(_Property.default.MAX_RESOLUTION, maxResolution);
    }

    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setMinResolution",
    value: function setMinResolution(minResolution) {
      this.set(_Property.default.MIN_RESOLUTION, minResolution);
    }

    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(maxZoom) {
      this.set(_Property.default.MAX_ZOOM, maxZoom);
    }

    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setMinZoom",
    value: function setMinZoom(minZoom) {
      this.set(_Property.default.MIN_ZOOM, minZoom);
    }

    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      (0, _asserts.assert)(typeof opacity === 'number', 'Layer opacity must be a number');
      this.set(_Property.default.OPACITY, opacity);
    }

    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      this.set(_Property.default.VISIBLE, visible);
    }

    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zindex) {
      this.set(_Property.default.Z_INDEX, zindex);
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.state_) {
        this.state_.layer = null;
        this.state_ = null;
      }
      _get(_getPrototypeOf(BaseLayer.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return BaseLayer;
}(_Object.default);
var _default = exports.default = BaseLayer;
},{"../Object.js":"node_modules/ol/Object.js","./Property.js":"node_modules/ol/layer/Property.js","../util.js":"node_modules/ol/util.js","../asserts.js":"node_modules/ol/asserts.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/render/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/render/EventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
};
/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */
/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */
},{}],"node_modules/ol/ViewHint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/ViewHint
 */
/**
 * @enum {number}
 */
var _default = exports.default = {
  ANIMATING: 0,
  INTERACTING: 1
};
},{}],"node_modules/ol/ViewProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/ViewProperty
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};
},{}],"node_modules/ol/tilegrid/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TILE_SIZE = exports.DEFAULT_MAX_ZOOM = void 0;
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = exports.DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = exports.DEFAULT_TILE_SIZE = 256;
},{}],"node_modules/ol/centerconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createExtent = createExtent;
exports.none = none;
var _math = require("./math.js");
/**
 * @module ol/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return undefined;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      var viewWidth = onlyCenter ? 0 : size[0] * resolution;
      var viewHeight = onlyCenter ? 0 : size[1] * resolution;
      var shiftX = centerShift ? centerShift[0] : 0;
      var shiftY = centerShift ? centerShift[1] : 0;
      var minX = extent[0] + viewWidth / 2 + shiftX;
      var maxX = extent[2] - viewWidth / 2 + shiftX;
      var minY = extent[1] + viewHeight / 2 + shiftY;
      var maxY = extent[3] - viewHeight / 2 + shiftY;

      // note: when zooming out of bounds, min and max values for x and y may
      // end up inverted (min > max); this has to be accounted for
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      var x = (0, _math.clamp)(center[0], minX, maxX);
      var y = (0, _math.clamp)(center[1], minY, maxY);

      // during an interaction, allow some overscroll
      if (isMoving && smooth && resolution) {
        var ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/resolutionconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMinMaxResolution = createMinMaxResolution;
exports.createSnapToPower = createSnapToPower;
exports.createSnapToResolutions = createSnapToResolutions;
var _math = require("./math.js");
var _extent = require("./extent.js");
var _array = require("./array.js");
/**
 * @module ol/resolutionconstraint
 */

/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = (0, _extent.getWidth)(maxExtent) / viewportSize[0];
  var yResolution = (0, _extent.getHeight)(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}

/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return (0, _math.clamp)(result, minResolution / 2, maxResolution * 2);
}

/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor((0, _array.linearFindNearest)(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return undefined;
    }
  );
}

/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  minResolution = minResolution !== undefined ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0, _math.clamp)(newResolution, minResolution, cappedMaxRes);
      }
      return undefined;
    }
  );
}

/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
        if (!smooth || !isMoving) {
          return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      return undefined;
    }
  );
}
},{"./math.js":"node_modules/ol/math.js","./extent.js":"node_modules/ol/extent.js","./array.js":"node_modules/ol/array.js"}],"node_modules/ol/rotationconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSnapToN = createSnapToN;
exports.createSnapToZero = createSnapToZero;
exports.disable = disable;
exports.none = none;
var _math = require("./math.js");
/**
 * @module ol/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  }
  return undefined;
}

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  }
  return undefined;
}

/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return undefined;
    }
  );
}

/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(tolerance) {
  var t = tolerance === undefined ? (0, _math.toRadians)(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving || rotation === undefined) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/View.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCenterConstraint = createCenterConstraint;
exports.createResolutionConstraint = createResolutionConstraint;
exports.createRotationConstraint = createRotationConstraint;
exports.default = void 0;
exports.isNoopAnimation = isNoopAnimation;
var _Object = _interopRequireDefault(require("./Object.js"));
var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));
var _ViewProperty = _interopRequireDefault(require("./ViewProperty.js"));
var _common = require("./tilegrid/common.js");
var _proj = require("./proj.js");
var _functions = require("./functions.js");
var _coordinate = require("./coordinate.js");
var _asserts = require("./asserts.js");
var _centerconstraint = require("./centerconstraint.js");
var _math = require("./math.js");
var _resolutionconstraint = require("./resolutionconstraint.js");
var _rotationconstraint = require("./rotationconstraint.js");
var _easing = require("./easing.js");
var _extent2 = require("./extent.js");
var _array = require("./array.js");
var _Polygon = require("./geom/Polygon.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/View
 */
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to
 * fit the extent into. Defaults to the size of the map the view is associated with.
 * If no map or multiple maps are connected to the view, provide the desired box size
 * (e.g. `map.getSize()`).
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */

/**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;

/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */

/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */
var View = /*#__PURE__*/function (_BaseObject) {
  _inherits(View, _BaseObject);
  var _super = _createSuper(View);
  /**
   * @param {ViewOptions} [options] View options.
   */
  function View(options) {
    var _this;
    _classCallCheck(this, View);
    _this = _super.call(this);

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    _this.on;

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    _this.once;

    /***
     * @type {ViewOnSignature<void>}
     */
    _this.un;
    options = Object.assign({}, options);

    /**
     * @private
     * @type {Array<number>}
     */
    _this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    _this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    _this.updateAnimationKey_;

    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    _this.projection_ = (0, _proj.createProjection)(options.projection, 'EPSG:3857');

    /**
     * @private
     * @type {import("./size.js").Size}
     */
    _this.viewportSize_ = [100, 100];

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    _this.targetCenter_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.targetResolution_;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.targetRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    _this.nextCenter_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.nextResolution_;

    /**
     * @private
     * @type {number}
     */
    _this.nextRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    _this.cancelAnchor_ = undefined;
    if (options.projection) {
      (0, _proj.disableCoordinateWarning)();
    }
    if (options.center) {
      options.center = (0, _proj.fromUserCoordinate)(options.center, _this.projection_);
    }
    if (options.extent) {
      options.extent = (0, _proj.fromUserExtent)(options.extent, _this.projection_);
    }
    _this.applyOptions_(options);
    return _this;
  }

  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  _createClass(View, [{
    key: "applyOptions_",
    value: function applyOptions_(options) {
      var properties = Object.assign({}, options);
      for (var key in _ViewProperty.default) {
        delete properties[key];
      }
      this.setProperties(properties, true);
      var resolutionConstraintInfo = createResolutionConstraint(options);

      /**
       * @private
       * @type {number}
       */
      this.maxResolution_ = resolutionConstraintInfo.maxResolution;

      /**
       * @private
       * @type {number}
       */
      this.minResolution_ = resolutionConstraintInfo.minResolution;

      /**
       * @private
       * @type {number}
       */
      this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

      /**
       * @private
       * @type {Array<number>|undefined}
       */
      this.resolutions_ = options.resolutions;

      /**
       * @type {Array<number>|undefined}
       * @private
       */
      this.padding_ = options.padding;

      /**
       * @private
       * @type {number}
       */
      this.minZoom_ = resolutionConstraintInfo.minZoom;
      var centerConstraint = createCenterConstraint(options);
      var resolutionConstraint = resolutionConstraintInfo.constraint;
      var rotationConstraint = createRotationConstraint(options);

      /**
       * @private
       * @type {Constraints}
       */
      this.constraints_ = {
        center: centerConstraint,
        resolution: resolutionConstraint,
        rotation: rotationConstraint
      };
      this.setRotation(options.rotation !== undefined ? options.rotation : 0);
      this.setCenterInternal(options.center !== undefined ? options.center : null);
      if (options.resolution !== undefined) {
        this.setResolution(options.resolution);
      } else if (options.zoom !== undefined) {
        this.setZoom(options.zoom);
      }
    }

    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
  }, {
    key: "padding",
    get: function get() {
      return this.padding_;
    },
    set: function set(padding) {
      var oldPadding = this.padding_;
      this.padding_ = padding;
      var center = this.getCenterInternal();
      if (center) {
        var newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        var resolution = this.getResolution();
        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    }

    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
  }, {
    key: "getUpdatedOptions_",
    value: function getUpdatedOptions_(newOptions) {
      var options = this.getProperties();

      // preserve resolution (or zoom)
      if (options.resolution !== undefined) {
        options.resolution = this.getResolution();
      } else {
        options.zoom = this.getZoom();
      }

      // preserve center
      options.center = this.getCenterInternal();

      // preserve rotation
      options.rotation = this.getRotation();
      return Object.assign({}, options, newOptions);
    }

    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
  }, {
    key: "animate",
    value: function animate(var_args) {
      if (this.isDef() && !this.getAnimating()) {
        this.resolveConstraints(0);
      }
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; ++i) {
        var options = arguments[i];
        if (options.center) {
          options = Object.assign({}, options);
          options.center = (0, _proj.fromUserCoordinate)(options.center, this.getProjection());
        }
        if (options.anchor) {
          options = Object.assign({}, options);
          options.anchor = (0, _proj.fromUserCoordinate)(options.anchor, this.getProjection());
        }
        args[i] = options;
      }
      this.animateInternal.apply(this, args);
    }

    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
  }, {
    key: "animateInternal",
    value: function animateInternal(var_args) {
      var animationCount = arguments.length;
      var callback;
      if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
        callback = arguments[animationCount - 1];
        --animationCount;
      }
      var i = 0;
      for (; i < animationCount && !this.isDef(); ++i) {
        // if view properties are not yet set, shortcut to the final state
        var state = arguments[i];
        if (state.center) {
          this.setCenterInternal(state.center);
        }
        if (state.zoom !== undefined) {
          this.setZoom(state.zoom);
        } else if (state.resolution) {
          this.setResolution(state.resolution);
        }
        if (state.rotation !== undefined) {
          this.setRotation(state.rotation);
        }
      }
      if (i === animationCount) {
        if (callback) {
          animationCallback(callback, true);
        }
        return;
      }
      var start = Date.now();
      var center = this.targetCenter_.slice();
      var resolution = this.targetResolution_;
      var rotation = this.targetRotation_;
      var series = [];
      for (; i < animationCount; ++i) {
        var options = /** @type {AnimationOptions} */arguments[i];
        var animation = {
          start: start,
          complete: false,
          anchor: options.anchor,
          duration: options.duration !== undefined ? options.duration : 1000,
          easing: options.easing || _easing.inAndOut,
          callback: callback
        };
        if (options.center) {
          animation.sourceCenter = center;
          animation.targetCenter = options.center.slice();
          center = animation.targetCenter;
        }
        if (options.zoom !== undefined) {
          animation.sourceResolution = resolution;
          animation.targetResolution = this.getResolutionForZoom(options.zoom);
          resolution = animation.targetResolution;
        } else if (options.resolution) {
          animation.sourceResolution = resolution;
          animation.targetResolution = options.resolution;
          resolution = animation.targetResolution;
        }
        if (options.rotation !== undefined) {
          animation.sourceRotation = rotation;
          var delta = (0, _math.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
          animation.targetRotation = rotation + delta;
          rotation = animation.targetRotation;
        }

        // check if animation is a no-op
        if (isNoopAnimation(animation)) {
          animation.complete = true;
          // we still push it onto the series for callback handling
        } else {
          start += animation.duration;
        }
        series.push(animation);
      }
      this.animations_.push(series);
      this.setHint(_ViewHint.default.ANIMATING, 1);
      this.updateAnimations_();
    }

    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
  }, {
    key: "getAnimating",
    value: function getAnimating() {
      return this.hints_[_ViewHint.default.ANIMATING] > 0;
    }

    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
  }, {
    key: "getInteracting",
    value: function getInteracting() {
      return this.hints_[_ViewHint.default.INTERACTING] > 0;
    }

    /**
     * Cancel any ongoing animations.
     * @api
     */
  }, {
    key: "cancelAnimations",
    value: function cancelAnimations() {
      this.setHint(_ViewHint.default.ANIMATING, -this.hints_[_ViewHint.default.ANIMATING]);
      var anchor;
      for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
        var series = this.animations_[i];
        if (series[0].callback) {
          animationCallback(series[0].callback, false);
        }
        if (!anchor) {
          for (var j = 0, jj = series.length; j < jj; ++j) {
            var animation = series[j];
            if (!animation.complete) {
              anchor = animation.anchor;
              break;
            }
          }
        }
      }
      this.animations_.length = 0;
      this.cancelAnchor_ = anchor;
      this.nextCenter_ = null;
      this.nextResolution_ = NaN;
      this.nextRotation_ = NaN;
    }

    /**
     * Update all animations.
     */
  }, {
    key: "updateAnimations_",
    value: function updateAnimations_() {
      if (this.updateAnimationKey_ !== undefined) {
        cancelAnimationFrame(this.updateAnimationKey_);
        this.updateAnimationKey_ = undefined;
      }
      if (!this.getAnimating()) {
        return;
      }
      var now = Date.now();
      var more = false;
      for (var i = this.animations_.length - 1; i >= 0; --i) {
        var series = this.animations_[i];
        var seriesComplete = true;
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];
          if (animation.complete) {
            continue;
          }
          var elapsed = now - animation.start;
          var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
          if (fraction >= 1) {
            animation.complete = true;
            fraction = 1;
          } else {
            seriesComplete = false;
          }
          var progress = animation.easing(fraction);
          if (animation.sourceCenter) {
            var x0 = animation.sourceCenter[0];
            var y0 = animation.sourceCenter[1];
            var x1 = animation.targetCenter[0];
            var y1 = animation.targetCenter[1];
            this.nextCenter_ = animation.targetCenter;
            var x = x0 + progress * (x1 - x0);
            var y = y0 + progress * (y1 - y0);
            this.targetCenter_ = [x, y];
          }
          if (animation.sourceResolution && animation.targetResolution) {
            var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
            if (animation.anchor) {
              var size = this.getViewportSize_(this.getRotation());
              var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
              this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
            }
            this.nextResolution_ = animation.targetResolution;
            this.targetResolution_ = resolution;
            this.applyTargetState_(true);
          }
          if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
            var rotation = progress === 1 ? (0, _math.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
            if (animation.anchor) {
              var constrainedRotation = this.constraints_.rotation(rotation, true);
              this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
            }
            this.nextRotation_ = animation.targetRotation;
            this.targetRotation_ = rotation;
          }
          this.applyTargetState_(true);
          more = true;
          if (!animation.complete) {
            break;
          }
        }
        if (seriesComplete) {
          this.animations_[i] = null;
          this.setHint(_ViewHint.default.ANIMATING, -1);
          this.nextCenter_ = null;
          this.nextResolution_ = NaN;
          this.nextRotation_ = NaN;
          var callback = series[0].callback;
          if (callback) {
            animationCallback(callback, true);
          }
        }
      }
      // prune completed series
      this.animations_ = this.animations_.filter(Boolean);
      if (more && this.updateAnimationKey_ === undefined) {
        this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
      }
    }

    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
  }, {
    key: "calculateCenterRotate",
    value: function calculateCenterRotate(rotation, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();
      if (currentCenter !== undefined) {
        center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
        (0, _coordinate.rotate)(center, rotation - this.getRotation());
        (0, _coordinate.add)(center, anchor);
      }
      return center;
    }

    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
  }, {
    key: "calculateCenterZoom",
    value: function calculateCenterZoom(resolution, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();
      var currentResolution = this.getResolution();
      if (currentCenter !== undefined && currentResolution !== undefined) {
        var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
        var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
        center = [x, y];
      }
      return center;
    }

    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
  }, {
    key: "getViewportSize_",
    value: function getViewportSize_(rotation) {
      var size = this.viewportSize_;
      if (rotation) {
        var w = size[0];
        var h = size[1];
        return [Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)), Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))];
      }
      return size;
    }

    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
  }, {
    key: "setViewportSize",
    value: function setViewportSize(size) {
      this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
      if (!this.getAnimating()) {
        this.resolveConstraints(0);
      }
    }

    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
  }, {
    key: "getCenter",
    value: function getCenter() {
      var center = this.getCenterInternal();
      if (!center) {
        return center;
      }
      return (0, _proj.toUserCoordinate)(center, this.getProjection());
    }

    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
  }, {
    key: "getCenterInternal",
    value: function getCenterInternal() {
      return /** @type {import("./coordinate.js").Coordinate|undefined} */(
        this.get(_ViewProperty.default.CENTER)
      );
    }

    /**
     * @return {Constraints} Constraints.
     */
  }, {
    key: "getConstraints",
    value: function getConstraints() {
      return this.constraints_;
    }

    /**
     * @return {boolean} Resolution constraint is set
     */
  }, {
    key: "getConstrainResolution",
    value: function getConstrainResolution() {
      return this.get('constrainResolution');
    }

    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
  }, {
    key: "getHints",
    value: function getHints(hints) {
      if (hints !== undefined) {
        hints[0] = this.hints_[0];
        hints[1] = this.hints_[1];
        return hints;
      }
      return this.hints_.slice();
    }

    /**
     * Calculate the extent for the current view state and the passed box size.
     * @param {import("./size.js").Size} [size] The pixel dimensions of the box
     * into which the calculated extent should fit. Defaults to the size of the
     * map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired
     * box size (e.g. `map.getSize()`).
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "calculateExtent",
    value: function calculateExtent(size) {
      var extent = this.calculateExtentInternal(size);
      return (0, _proj.toUserExtent)(extent, this.getProjection());
    }

    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
  }, {
    key: "calculateExtentInternal",
    value: function calculateExtentInternal(size) {
      size = size || this.getViewportSizeMinusPadding_();
      var center = /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal();
      (0, _asserts.assert)(center, 'The view center is not defined');
      var resolution = /** @type {!number} */this.getResolution();
      (0, _asserts.assert)(resolution !== undefined, 'The view resolution is not defined');
      var rotation = /** @type {!number} */this.getRotation();
      (0, _asserts.assert)(rotation !== undefined, 'The view rotation is not defined');
      return (0, _extent2.getForViewAndSize)(center, resolution, rotation, size);
    }

    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
  }, {
    key: "getMaxResolution",
    value: function getMaxResolution() {
      return this.maxResolution_;
    }

    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
  }, {
    key: "getMinResolution",
    value: function getMinResolution() {
      return this.minResolution_;
    }

    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return /** @type {number} */(
        this.getZoomForResolution(this.minResolution_)
      );
    }

    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({
        maxZoom: zoom
      }));
    }

    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return /** @type {number} */(
        this.getZoomForResolution(this.maxResolution_)
      );
    }

    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
  }, {
    key: "setMinZoom",
    value: function setMinZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({
        minZoom: zoom
      }));
    }

    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
  }, {
    key: "setConstrainResolution",
    value: function setConstrainResolution(enabled) {
      this.applyOptions_(this.getUpdatedOptions_({
        constrainResolution: enabled
      }));
    }

    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
  }, {
    key: "getProjection",
    value: function getProjection() {
      return this.projection_;
    }

    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
  }, {
    key: "getResolution",
    value: function getResolution() {
      return /** @type {number|undefined} */this.get(_ViewProperty.default.RESOLUTION);
    }

    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
  }, {
    key: "getResolutions",
    value: function getResolutions() {
      return this.resolutions_;
    }

    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
  }, {
    key: "getResolutionForExtent",
    value: function getResolutionForExtent(extent, size) {
      return this.getResolutionForExtentInternal((0, _proj.fromUserExtent)(extent, this.getProjection()), size);
    }

    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
  }, {
    key: "getResolutionForExtentInternal",
    value: function getResolutionForExtentInternal(extent, size) {
      size = size || this.getViewportSizeMinusPadding_();
      var xResolution = (0, _extent2.getWidth)(extent) / size[0];
      var yResolution = (0, _extent2.getHeight)(extent) / size[1];
      return Math.max(xResolution, yResolution);
    }

    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
  }, {
    key: "getResolutionForValueFunction",
    value: function getResolutionForValueFunction(power) {
      power = power || 2;
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / Math.log(power);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function (value) {
          var resolution = maxResolution / Math.pow(power, value * max);
          return resolution;
        }
      );
    }

    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
  }, {
    key: "getRotation",
    value: function getRotation() {
      return /** @type {number} */this.get(_ViewProperty.default.ROTATION);
    }

    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
  }, {
    key: "getValueForResolutionFunction",
    value: function getValueForResolutionFunction(power) {
      var logPower = Math.log(power || 2);
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / logPower;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function (resolution) {
          var value = Math.log(maxResolution / resolution) / logPower / max;
          return value;
        }
      );
    }

    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
  }, {
    key: "getViewportSizeMinusPadding_",
    value: function getViewportSizeMinusPadding_(rotation) {
      var size = this.getViewportSize_(rotation);
      var padding = this.padding_;
      if (padding) {
        size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];
      }
      return size;
    }

    /**
     * @return {State} View state.
     */
  }, {
    key: "getState",
    value: function getState() {
      var projection = this.getProjection();
      var resolution = this.getResolution();
      var rotation = this.getRotation();
      var center = /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal();
      var padding = this.padding_;
      if (padding) {
        var reducedSize = this.getViewportSizeMinusPadding_();
        center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      }
      return {
        center: center.slice(0),
        projection: projection !== undefined ? projection : null,
        resolution: resolution,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: rotation,
        zoom: this.getZoom()
      };
    }

    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
  }, {
    key: "getViewStateAndExtent",
    value: function getViewStateAndExtent() {
      return {
        viewState: this.getState(),
        extent: this.calculateExtent()
      };
    }

    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
  }, {
    key: "getZoom",
    value: function getZoom() {
      var zoom;
      var resolution = this.getResolution();
      if (resolution !== undefined) {
        zoom = this.getZoomForResolution(resolution);
      }
      return zoom;
    }

    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
  }, {
    key: "getZoomForResolution",
    value: function getZoomForResolution(resolution) {
      var offset = this.minZoom_ || 0;
      var max, zoomFactor;
      if (this.resolutions_) {
        var nearest = (0, _array.linearFindNearest)(this.resolutions_, resolution, 1);
        offset = nearest;
        max = this.resolutions_[nearest];
        if (nearest == this.resolutions_.length - 1) {
          zoomFactor = 2;
        } else {
          zoomFactor = max / this.resolutions_[nearest + 1];
        }
      } else {
        max = this.maxResolution_;
        zoomFactor = this.zoomFactor_;
      }
      return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }

    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
  }, {
    key: "getResolutionForZoom",
    value: function getResolutionForZoom(zoom) {
      if (this.resolutions_) {
        if (this.resolutions_.length <= 1) {
          return 0;
        }
        var baseLevel = (0, _math.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
        var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
        return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _math.clamp)(zoom - baseLevel, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }

    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
  }, {
    key: "fit",
    value: function fit(geometryOrExtent, options) {
      /** @type {import("./geom/SimpleGeometry.js").default} */
      var geometry;
      (0, _asserts.assert)(Array.isArray(geometryOrExtent) || typeof ( /** @type {?} */geometryOrExtent.getSimplifiedGeometry) === 'function', 'Invalid extent or geometry provided as `geometry`');
      if (Array.isArray(geometryOrExtent)) {
        (0, _asserts.assert)(!(0, _extent2.isEmpty)(geometryOrExtent), 'Cannot fit empty extent provided as `geometry`');
        var extent = (0, _proj.fromUserExtent)(geometryOrExtent, this.getProjection());
        geometry = (0, _Polygon.fromExtent)(extent);
      } else if (geometryOrExtent.getType() === 'Circle') {
        var _extent = (0, _proj.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
        geometry = (0, _Polygon.fromExtent)(_extent);
        geometry.rotate(this.getRotation(), (0, _extent2.getCenter)(_extent));
      } else {
        var userProjection = (0, _proj.getUserProjection)();
        if (userProjection) {
          geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
          geometryOrExtent.clone().transform(userProjection, this.getProjection());
        } else {
          geometry = geometryOrExtent;
        }
      }
      this.fitInternal(geometry, options);
    }

    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
  }, {
    key: "rotatedExtentForGeometry",
    value: function rotatedExtentForGeometry(geometry) {
      var rotation = this.getRotation();
      var cosAngle = Math.cos(rotation);
      var sinAngle = Math.sin(-rotation);
      var coords = geometry.getFlatCoordinates();
      var stride = geometry.getStride();
      var minRotX = +Infinity;
      var minRotY = +Infinity;
      var maxRotX = -Infinity;
      var maxRotY = -Infinity;
      for (var i = 0, ii = coords.length; i < ii; i += stride) {
        var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
        var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
        minRotX = Math.min(minRotX, rotX);
        minRotY = Math.min(minRotY, rotY);
        maxRotX = Math.max(maxRotX, rotX);
        maxRotY = Math.max(maxRotY, rotY);
      }
      return [minRotX, minRotY, maxRotX, maxRotY];
    }

    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
  }, {
    key: "fitInternal",
    value: function fitInternal(geometry, options) {
      options = options || {};
      var size = options.size;
      if (!size) {
        size = this.getViewportSizeMinusPadding_();
      }
      var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
      var nearest = options.nearest !== undefined ? options.nearest : false;
      var minResolution;
      if (options.minResolution !== undefined) {
        minResolution = options.minResolution;
      } else if (options.maxZoom !== undefined) {
        minResolution = this.getResolutionForZoom(options.maxZoom);
      } else {
        minResolution = 0;
      }
      var rotatedExtent = this.rotatedExtentForGeometry(geometry);

      // calculate resolution
      var resolution = this.getResolutionForExtentInternal(rotatedExtent, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
      resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
      resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);

      // calculate center
      var rotation = this.getRotation();
      var sinAngle = Math.sin(rotation);
      var cosAngle = Math.cos(rotation);
      var centerRot = (0, _extent2.getCenter)(rotatedExtent);
      centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
      centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
      var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
      var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
      var center = this.getConstrainedCenter([centerX, centerY], resolution);
      var callback = options.callback ? options.callback : _functions.VOID;
      if (options.duration !== undefined) {
        this.animateInternal({
          resolution: resolution,
          center: center,
          duration: options.duration,
          easing: options.easing
        }, callback);
      } else {
        this.targetResolution_ = resolution;
        this.targetCenter_ = center;
        this.applyTargetState_(false, true);
        animationCallback(callback, true);
      }
    }

    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
  }, {
    key: "centerOn",
    value: function centerOn(coordinate, size, position) {
      this.centerOnInternal((0, _proj.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
    }

    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
  }, {
    key: "centerOnInternal",
    value: function centerOnInternal(coordinate, size, position) {
      this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }

    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
  }, {
    key: "calculateCenterShift",
    value: function calculateCenterShift(center, resolution, rotation, size) {
      var centerShift;
      var padding = this.padding_;
      if (padding && center) {
        var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
        var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
        centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];
      }
      return centerShift;
    }

    /**
     * @return {boolean} Is defined.
     */
  }, {
    key: "isDef",
    value: function isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }

    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
  }, {
    key: "adjustCenter",
    value: function adjustCenter(deltaCoordinates) {
      var center = (0, _proj.toUserCoordinate)(this.targetCenter_, this.getProjection());
      this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }

    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
  }, {
    key: "adjustCenterInternal",
    value: function adjustCenterInternal(deltaCoordinates) {
      var center = this.targetCenter_;
      this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }

    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
  }, {
    key: "adjustResolution",
    value: function adjustResolution(ratio, anchor) {
      anchor = anchor && (0, _proj.fromUserCoordinate)(anchor, this.getProjection());
      this.adjustResolutionInternal(ratio, anchor);
    }

    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
  }, {
    key: "adjustResolutionInternal",
    value: function adjustResolutionInternal(ratio, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var size = this.getViewportSize_(this.getRotation());
      var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
      if (anchor) {
        this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
      }
      this.targetResolution_ *= ratio;
      this.applyTargetState_();
    }

    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
  }, {
    key: "adjustZoom",
    value: function adjustZoom(delta, anchor) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }

    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
  }, {
    key: "adjustRotation",
    value: function adjustRotation(delta, anchor) {
      if (anchor) {
        anchor = (0, _proj.fromUserCoordinate)(anchor, this.getProjection());
      }
      this.adjustRotationInternal(delta, anchor);
    }

    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
  }, {
    key: "adjustRotationInternal",
    value: function adjustRotationInternal(delta, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
      if (anchor) {
        this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
      }
      this.targetRotation_ += delta;
      this.applyTargetState_();
    }

    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
  }, {
    key: "setCenter",
    value: function setCenter(center) {
      this.setCenterInternal(center ? (0, _proj.fromUserCoordinate)(center, this.getProjection()) : center);
    }

    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
  }, {
    key: "setCenterInternal",
    value: function setCenterInternal(center) {
      this.targetCenter_ = center;
      this.applyTargetState_();
    }

    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
  }, {
    key: "setHint",
    value: function setHint(hint, delta) {
      this.hints_[hint] += delta;
      this.changed();
      return this.hints_[hint];
    }

    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
  }, {
    key: "setResolution",
    value: function setResolution(resolution) {
      this.targetResolution_ = resolution;
      this.applyTargetState_();
    }

    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.targetRotation_ = rotation;
      this.applyTargetState_();
    }

    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.setResolution(this.getResolutionForZoom(zoom));
    }

    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
  }, {
    key: "applyTargetState_",
    value: function applyTargetState_(doNotCancelAnims, forceMoving) {
      var isMoving = this.getAnimating() || this.getInteracting() || forceMoving;

      // compute rotation
      var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
      if (this.get(_ViewProperty.default.ROTATION) !== newRotation) {
        this.set(_ViewProperty.default.ROTATION, newRotation);
      }
      if (this.get(_ViewProperty.default.RESOLUTION) !== newResolution) {
        this.set(_ViewProperty.default.RESOLUTION, newResolution);
        this.set('zoom', this.getZoom(), true);
      }
      if (!newCenter || !this.get(_ViewProperty.default.CENTER) || !(0, _coordinate.equals)(this.get(_ViewProperty.default.CENTER), newCenter)) {
        this.set(_ViewProperty.default.CENTER, newCenter);
      }
      if (this.getAnimating() && !doNotCancelAnims) {
        this.cancelAnimations();
      }
      this.cancelAnchor_ = undefined;
    }

    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
  }, {
    key: "resolveConstraints",
    value: function resolveConstraints(duration, resolutionDirection, anchor) {
      duration = duration !== undefined ? duration : 200;
      var direction = resolutionDirection || 0;
      var newRotation = this.constraints_.rotation(this.targetRotation_);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
      if (duration === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = newResolution;
        this.targetRotation_ = newRotation;
        this.targetCenter_ = newCenter;
        this.applyTargetState_();
        return;
      }
      anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
      this.cancelAnchor_ = undefined;
      if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinate.equals)(this.getCenterInternal(), newCenter)) {
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
        this.animateInternal({
          rotation: newRotation,
          center: newCenter,
          resolution: newResolution,
          duration: duration,
          easing: _easing.easeOut,
          anchor: anchor
        });
      }
    }

    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
  }, {
    key: "beginInteraction",
    value: function beginInteraction() {
      this.resolveConstraints(0);
      this.setHint(_ViewHint.default.INTERACTING, 1);
    }

    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
  }, {
    key: "endInteraction",
    value: function endInteraction(duration, resolutionDirection, anchor) {
      anchor = anchor && (0, _proj.fromUserCoordinate)(anchor, this.getProjection());
      this.endInteractionInternal(duration, resolutionDirection, anchor);
    }

    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
  }, {
    key: "endInteractionInternal",
    value: function endInteractionInternal(duration, resolutionDirection, anchor) {
      if (!this.getInteracting()) {
        return;
      }
      this.setHint(_ViewHint.default.INTERACTING, -1);
      this.resolveConstraints(duration, resolutionDirection, anchor);
    }

    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
  }, {
    key: "getConstrainedCenter",
    value: function getConstrainedCenter(targetCenter, targetResolution) {
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }

    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
  }, {
    key: "getConstrainedZoom",
    value: function getConstrainedZoom(targetZoom, direction) {
      var targetRes = this.getResolutionForZoom(targetZoom);
      return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }

    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
  }, {
    key: "getConstrainedResolution",
    value: function getConstrainedResolution(targetResolution, direction) {
      direction = direction || 0;
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(targetResolution, direction, size);
    }
  }]);
  return View;
}(_Object.default);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
    return (0, _centerconstraint.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }
  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0, _centerconstraint.createExtent)(extent, false, false);
  }
  return _centerconstraint.none;
}

/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    // calculate the default min and max resolution
    var size = !projExtent ?
    // use an extent that can fit the whole world if need be
    360 * _proj.METERS_PER_UNIT.degrees / projection.getMetersPerUnit() : Math.max((0, _extent2.getWidth)(projExtent), (0, _extent2.getHeight)(projExtent));
    var defaultMaxResolution = size / _common.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return (0, _rotationconstraint.createSnapToZero)();
    }
    if (constrainRotation === false) {
      return _rotationconstraint.none;
    }
    if (typeof constrainRotation === 'number') {
      return (0, _rotationconstraint.createSnapToN)(constrainRotation);
    }
    return _rotationconstraint.none;
  }
  return _rotationconstraint.disable;
}

/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0, _coordinate.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;

  // go back to original angle
  sinAngle = -sinAngle; // go back to original rotation
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var _default = exports.default = View;
},{"./Object.js":"node_modules/ol/Object.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./ViewProperty.js":"node_modules/ol/ViewProperty.js","./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./proj.js":"node_modules/ol/proj.js","./functions.js":"node_modules/ol/functions.js","./coordinate.js":"node_modules/ol/coordinate.js","./asserts.js":"node_modules/ol/asserts.js","./centerconstraint.js":"node_modules/ol/centerconstraint.js","./math.js":"node_modules/ol/math.js","./resolutionconstraint.js":"node_modules/ol/resolutionconstraint.js","./rotationconstraint.js":"node_modules/ol/rotationconstraint.js","./easing.js":"node_modules/ol/easing.js","./extent.js":"node_modules/ol/extent.js","./array.js":"node_modules/ol/array.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/layer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.inView = inView;
var _Base = _interopRequireDefault(require("./Base.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Property = _interopRequireDefault(require("./Property.js"));
var _EventType2 = _interopRequireDefault(require("../render/EventType.js"));
var _View = _interopRequireDefault(require("../View.js"));
var _asserts = require("../asserts.js");
var _extent = require("../extent.js");
var _events = require("../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Layer
 */
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */
/**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */
/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number | undefined} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */
/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */
var Layer = /*#__PURE__*/function (_BaseLayer) {
  _inherits(Layer, _BaseLayer);
  var _super = _createSuper(Layer);
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  function Layer(options) {
    var _this;
    _classCallCheck(this, Layer);
    var baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions);

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {LayerOnSignature<void>}
     */
    _this.un;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    _this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    _this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    _this.sourceChangeKey_ = null;

    /**
     * @private
     * @type {RendererType}
     */
    _this.renderer_ = null;

    /**
     * @private
     * @type {boolean}
     */
    _this.sourceReady_ = false;

    /**
     * @protected
     * @type {boolean}
     */
    _this.rendered = false;

    // Overwrite default render method with a custom one
    if (options.render) {
      _this.render = options.render;
    }
    if (options.map) {
      _this.setMap(options.map);
    }
    _this.addChangeListener(_Property.default.SOURCE, _this.handleSourcePropertyChange_);
    var source = options.source ? ( /** @type {SourceType} */options.source) : null;
    _this.setSource(source);
    return _this;
  }

  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  _createClass(Layer, [{
    key: "getLayersArray",
    value: function getLayersArray(array) {
      array = array ? array : [];
      array.push(this);
      return array;
    }

    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(states) {
      states = states ? states : [];
      states.push(this.getLayerState());
      return states;
    }

    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
  }, {
    key: "getSource",
    value: function getSource() {
      return /** @type {SourceType} */this.get(_Property.default.SOURCE) || null;
    }

    /**
     * @return {SourceType|null} The source being rendered.
     */
  }, {
    key: "getRenderSource",
    value: function getRenderSource() {
      return this.getSource();
    }

    /**
     * @return {import("../source/Source.js").State} Source state.
     */
  }, {
    key: "getSourceState",
    value: function getSourceState() {
      var source = this.getSource();
      return !source ? 'undefined' : source.getState();
    }

    /**
     * @private
     */
  }, {
    key: "handleSourceChange_",
    value: function handleSourceChange_() {
      this.changed();
      if (this.sourceReady_ || this.getSource().getState() !== 'ready') {
        return;
      }
      this.sourceReady_ = true;
      this.dispatchEvent('sourceready');
    }

    /**
     * @private
     */
  }, {
    key: "handleSourcePropertyChange_",
    value: function handleSourcePropertyChange_() {
      var _this2 = this;
      if (this.sourceChangeKey_) {
        (0, _events.unlistenByKey)(this.sourceChangeKey_);
        this.sourceChangeKey_ = null;
      }
      this.sourceReady_ = false;
      var source = this.getSource();
      if (source) {
        this.sourceChangeKey_ = (0, _events.listen)(source, _EventType.default.CHANGE, this.handleSourceChange_, this);
        if (source.getState() === 'ready') {
          this.sourceReady_ = true;
          setTimeout(function () {
            _this2.dispatchEvent('sourceready');
          }, 0);
        }
      }
      this.changed();
    }

    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      if (!this.renderer_) {
        return Promise.resolve([]);
      }
      return this.renderer_.getFeatures(pixel);
    }

    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      if (!this.renderer_ || !this.rendered) {
        return null;
      }
      return this.renderer_.getData(pixel);
    }

    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
  }, {
    key: "isVisible",
    value: function isVisible(view) {
      var _this3 = this;
      var frameState;
      var map = this.getMapInternal();
      if (!view && map) {
        view = map.getView();
      }
      if (view instanceof _View.default) {
        frameState = {
          viewState: view.getState(),
          extent: view.calculateExtent()
        };
      } else {
        frameState = view;
      }
      if (!frameState.layerStatesArray && map) {
        frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
      }
      var layerState;
      if (frameState.layerStatesArray) {
        layerState = frameState.layerStatesArray.find(function (layerState) {
          return layerState.layer === _this3;
        });
      } else {
        layerState = this.getLayerState();
      }
      var layerExtent = this.getExtent();
      return inView(layerState, frameState.viewState) && (!layerExtent || (0, _extent.intersects)(layerExtent, frameState.extent));
    }

    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
  }, {
    key: "getAttributions",
    value: function getAttributions(view) {
      if (!this.isVisible(view)) {
        return [];
      }
      var getAttributions;
      var source = this.getSource();
      if (source) {
        getAttributions = source.getAttributions();
      }
      if (!getAttributions) {
        return [];
      }
      var frameState = view instanceof _View.default ? view.getViewStateAndExtent() : view;
      var attributions = getAttributions(frameState);
      if (!Array.isArray(attributions)) {
        attributions = [attributions];
      }
      return attributions;
    }

    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
  }, {
    key: "render",
    value: function render(frameState, target) {
      var layerRenderer = this.getRenderer();
      if (layerRenderer.prepareFrame(frameState)) {
        this.rendered = true;
        return layerRenderer.renderFrame(frameState, target);
      }
      return null;
    }

    /**
     * Called when a layer is not visible during a map render.
     */
  }, {
    key: "unrender",
    value: function unrender() {
      this.rendered = false;
    }

    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
  }, {
    key: "setMapInternal",
    value: function setMapInternal(map) {
      if (!map) {
        this.unrender();
      }
      this.set(_Property.default.MAP, map);
    }

    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
  }, {
    key: "getMapInternal",
    value: function getMapInternal() {
      return this.get(_Property.default.MAP);
    }

    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.mapPrecomposeKey_) {
        (0, _events.unlistenByKey)(this.mapPrecomposeKey_);
        this.mapPrecomposeKey_ = null;
      }
      if (!map) {
        this.changed();
      }
      if (this.mapRenderKey_) {
        (0, _events.unlistenByKey)(this.mapRenderKey_);
        this.mapRenderKey_ = null;
      }
      if (map) {
        this.mapPrecomposeKey_ = (0, _events.listen)(map, _EventType2.default.PRECOMPOSE, function (evt) {
          var renderEvent = /** @type {import("../render/Event.js").default} */evt;
          var layerStatesArray = renderEvent.frameState.layerStatesArray;
          var layerState = this.getLayerState(false);
          (0, _asserts.assert)(!layerStatesArray.some(function (arrayLayerState) {
            return arrayLayerState.layer === layerState.layer;
          }), 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.');
          layerStatesArray.push(layerState);
        }, this);
        this.mapRenderKey_ = (0, _events.listen)(this, _EventType.default.CHANGE, map.render, map);
        this.changed();
      }
    }

    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
  }, {
    key: "setSource",
    value: function setSource(source) {
      this.set(_Property.default.SOURCE, source);
    }

    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
  }, {
    key: "getRenderer",
    value: function getRenderer() {
      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }
      return this.renderer_;
    }

    /**
     * @return {boolean} The layer has a renderer.
     */
  }, {
    key: "hasRenderer",
    value: function hasRenderer() {
      return !!this.renderer_;
    }

    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      return null;
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.renderer_) {
        this.renderer_.dispose();
        delete this.renderer_;
      }
      this.setSource(null);
      _get(_getPrototypeOf(Layer.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return Layer;
}(_Base.default);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  var resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var _default = exports.default = Layer;
},{"./Base.js":"node_modules/ol/layer/Base.js","../events/EventType.js":"node_modules/ol/events/EventType.js","./Property.js":"node_modules/ol/layer/Property.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../View.js":"node_modules/ol/View.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/rbush/rbush.min.js":[function(require,module,exports) {
var define;
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});

},{}],"node_modules/ol/ImageState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/ImageState
 */
/**
 * @enum {number}
 */
var _default = exports.default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
},{}],"node_modules/ol/size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;
exports.hasArea = hasArea;
exports.scale = scale;
exports.toSize = toSize;
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}

/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}

/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === undefined) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
},{}],"node_modules/ol/style/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = require("../util.js");
var _size = require("../size.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/style/Image
 */
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle = /*#__PURE__*/function () {
  /**
   * @param {Options} options Options.
   */
  function ImageStyle(options) {
    _classCallCheck(this, ImageStyle);
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;

    /**
     * @private
     * @type {boolean}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0, _size.toSize)(options.scale);

    /**
     * @private
     * @type {Array<number>}
     */
    this.displacement_ = options.displacement;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    this.declutterMode_ = options.declutterMode;
  }

  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  _createClass(ImageStyle, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      return new ImageStyle({
        opacity: this.getOpacity(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }

    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return this.opacity_;
    }

    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
  }, {
    key: "getRotateWithView",
    value: function getRotateWithView() {
      return this.rotateWithView_;
    }

    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation_;
    }

    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return this.scale_;
    }

    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
  }, {
    key: "getScaleArray",
    value: function getScaleArray() {
      return this.scaleArray_;
    }

    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
  }, {
    key: "getDisplacement",
    value: function getDisplacement() {
      return this.displacement_;
    }

    /**
     * Get the declutter mode of the shape
     * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
     * @api
     */
  }, {
    key: "getDeclutterMode",
    value: function getDeclutterMode() {
      return this.declutterMode_;
    }

    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
  }, {
    key: "getAnchor",
    value: function getAnchor() {
      return (0, _util.abstract)();
    }

    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      return (0, _util.abstract)();
    }

    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      return (0, _util.abstract)();
    }

    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return 1;
    }

    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
  }, {
    key: "getImageState",
    value: function getImageState() {
      return (0, _util.abstract)();
    }

    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return (0, _util.abstract)();
    }

    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return (0, _util.abstract)();
    }

    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return (0, _util.abstract)();
    }

    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
  }, {
    key: "setDisplacement",
    value: function setDisplacement(displacement) {
      this.displacement_ = displacement;
    }

    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this.opacity_ = opacity;
    }

    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
  }, {
    key: "setRotateWithView",
    value: function setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }

    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.rotation_ = rotation;
    }

    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
  }, {
    key: "setScale",
    value: function setScale(scale) {
      this.scale_ = scale;
      this.scaleArray_ = (0, _size.toSize)(scale);
    }

    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {
      (0, _util.abstract)();
    }

    /**
     * Load not yet loaded URI.
     * @abstract
     */
  }, {
    key: "load",
    value: function load() {
      (0, _util.abstract)();
    }

    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {
      (0, _util.abstract)();
    }
  }]);
  return ImageStyle;
}();
var _default = exports.default = ImageStyle;
},{"../util.js":"node_modules/ol/util.js","../size.js":"node_modules/ol/size.js"}],"node_modules/color-space/rgb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */
var _default = exports.default = {
  name: 'rgb',
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ['red', 'green', 'blue'],
  alias: ['RGB']
};
},{}],"node_modules/color-space/xyz.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rgb = _interopRequireDefault(require("./rgb.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * CIE XYZ
 *
 * @module  color-space/xyz
 */

var xyz = {
  name: 'xyz',
  min: [0, 0, 0],
  channel: ['X', 'Y', 'Z'],
  alias: ['XYZ', 'ciexyz', 'cie1931']
};

/**
 * Whitepoint reference values with observer/illuminant
 *
 * http://en.wikipedia.org/wiki/Standard_illuminant
 */
xyz.whitepoint = {
  //1931 2
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.370],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10
  10: {
    //incadescent
    A: [111.144, 100, 35.200],
    C: [97.285, 100, 116.145],
    D50: [96.720, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.280, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};

/**
 * Top values are the whitepoints top values, default are D65
 */
xyz.max = xyz.whitepoint[2].D65;

/**
 * Transform xyz to rgb
 *
 * @param {Array} xyz Array of xyz values
 *
 * @return {Array} RGB values
 */
xyz.rgb = function (_xyz, white) {
  //FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then
  white = white || xyz.whitepoint[2].E;
  var x = _xyz[0] / white[0],
    y = _xyz[1] / white[1],
    z = _xyz[2] / white[2],
    r,
    g,
    b;

  // assume sRGB
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
  g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
  b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

/**
 * RGB to XYZ
 *
 * @param {Array} rgb RGB channels
 *
 * @return {Array} XYZ channels
 */
_rgb.default.xyz = function (rgb, white) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
  var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
  var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
  white = white || xyz.whitepoint[2].E;
  return [x * white[0], y * white[1], z * white[2]];
};
var _default = exports.default = xyz;
},{"./rgb.js":"node_modules/color-space/rgb.js"}],"node_modules/color-space/luv.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _xyz = _interopRequireDefault(require("./xyz.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * CIE LUV (C'est la vie)
 *
 * @module color-space/luv
 */
var _default = exports.default = {
  name: 'luv',
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ['lightness', 'u', 'v'],
  alias: ['LUV', 'cieluv', 'cie1976'],
  xyz: function (arg, i, o) {
    var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
    l = arg[0], u = arg[1], v = arg[2];
    if (l === 0) return [0, 0, 0];

    //get constants
    //var e = 0.008856451679035631; //(6/29)^3
    var k = 0.0011070564598794539; //(3/29)^3

    //get illuminant/observer
    i = i || 'D65';
    o = o || 2;
    xn = _xyz.default.whitepoint[o][i][0];
    yn = _xyz.default.whitepoint[o][i][1];
    zn = _xyz.default.whitepoint[o][i][2];
    un = 4 * xn / (xn + 15 * yn + 3 * zn);
    vn = 9 * yn / (xn + 15 * yn + 3 * zn);
    // un = 0.19783000664283;
    // vn = 0.46831999493879;

    _u = u / (13 * l) + un || 0;
    _v = v / (13 * l) + vn || 0;
    y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;

    //wikipedia method
    x = y * 9 * _u / (4 * _v) || 0;
    z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;

    //boronine method
    //https://github.com/boronine/husl/blob/master/husl.coffee#L201
    // x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);
    // z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);

    return [x, y, z];
  }
}; // http://www.brucelindbloom.com/index.html?Equations.html
// https://github.com/boronine/husl/blob/master/husl.coffee
//i - illuminant
//o - observer
_xyz.default.luv = function (arg, i, o) {
  var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;

  //get constants
  var e = 0.008856451679035631; //(6/29)^3
  var k = 903.2962962962961; //(29/3)^3

  //get illuminant/observer coords
  i = i || 'D65';
  o = o || 2;
  xn = _xyz.default.whitepoint[o][i][0];
  yn = _xyz.default.whitepoint[o][i][1];
  zn = _xyz.default.whitepoint[o][i][2];
  un = 4 * xn / (xn + 15 * yn + 3 * zn);
  vn = 9 * yn / (xn + 15 * yn + 3 * zn);
  x = arg[0], y = arg[1], z = arg[2];
  _u = 4 * x / (x + 15 * y + 3 * z) || 0;
  _v = 9 * y / (x + 15 * y + 3 * z) || 0;
  var yr = y / yn;
  l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
  u = 13 * l * (_u - un);
  v = 13 * l * (_v - vn);
  return [l, u, v];
};
},{"./xyz.js":"node_modules/color-space/xyz.js"}],"node_modules/color-space/lchuv.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _luv = _interopRequireDefault(require("./luv.js"));
var _xyz = _interopRequireDefault(require("./xyz.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Cylindrical CIE LUV
 *
 * @module color-space/lchuv
 */

//cylindrical luv
var lchuv = {
  name: 'lchuv',
  channel: ['lightness', 'chroma', 'hue'],
  alias: ['LCHuv', 'cielchuv'],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function (luv) {
    var l = luv[0],
      c = luv[1],
      h = luv[2],
      u,
      v,
      hr;
    hr = h / 360 * 2 * Math.PI;
    u = c * Math.cos(hr);
    v = c * Math.sin(hr);
    return [l, u, v];
  },
  xyz: function (arg) {
    return _luv.default.xyz(lchuv.luv(arg));
  }
};
var _default = exports.default = lchuv;
_luv.default.lchuv = function (luv) {
  var l = luv[0],
    u = luv[1],
    v = luv[2];
  var c = Math.sqrt(u * u + v * v);
  var hr = Math.atan2(v, u);
  var h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  return [l, c, h];
};
_xyz.default.lchuv = function (arg) {
  return _luv.default.lchuv(_xyz.default.luv(arg));
};
},{"./luv.js":"node_modules/color-space/luv.js","./xyz.js":"node_modules/color-space/xyz.js"}],"node_modules/color-name/index.js":[function(require,module,exports) {
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],"node_modules/color-parse/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _colorName = _interopRequireDefault(require("color-name"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module color-parse
 */
var _default = exports.default = parse;
/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse(cstr) {
  var m,
    parts = [],
    alpha = 1,
    space;

  //numeric case
  if (typeof cstr === 'number') {
    return {
      space: 'rgb',
      values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff],
      alpha: 1
    };
  }
  if (typeof cstr === 'number') return {
    space: 'rgb',
    values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff],
    alpha: 1
  };
  cstr = String(cstr).toLowerCase();

  //keyword
  if (_colorName.default[cstr]) {
    parts = _colorName.default[cstr].slice();
    space = 'rgb';
  }

  //reserved words
  else if (cstr === 'transparent') {
    alpha = 0;
    space = 'rgb';
    parts = [0, 0, 0];
  }

  //hex
  else if (cstr[0] === '#') {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [parseInt(base[0] + base[0], 16), parseInt(base[1] + base[1], 16), parseInt(base[2] + base[2], 16)];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [parseInt(base[0] + base[1], 16), parseInt(base[2] + base[3], 16), parseInt(base[4] + base[5], 16)];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0]) parts[0] = 0;
    if (!parts[1]) parts[1] = 0;
    if (!parts[2]) parts[2] = 0;
    space = 'rgb';
  }

  // color space
  else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, '');
    var dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);

    // color(srgb-linear x x x) -> srgb-linear(x x x)
    if (space === 'color') space = parts.shift();
    parts = parts.map(function (x, i) {
      //<percentage>
      if (x[x.length - 1] === '%') {
        x = parseFloat(x) / 100;
        // alpha -> 0..1
        if (i === 3) return x;
        // rgb -> 0..255
        if (space === 'rgb') return x * 255;
        // hsl, hwb H -> 0..100
        if (space[0] === 'h') return x * 100;
        // lch, lab L -> 0..100
        if (space[0] === 'l' && !i) return x * 100;
        // lab A B -> -125..125
        if (space === 'lab') return x * 125;
        // lch C -> 0..150, H -> 0..360
        if (space === 'lch') return i < 2 ? x * 150 : x * 360;
        // oklch/oklab L -> 0..1
        if (space[0] === 'o' && !i) return x;
        // oklab A B -> -0.4..0.4
        if (space === 'oklab') return x * 0.4;
        // oklch C -> 0..0.4, H -> 0..360
        if (space === 'oklch') return i < 2 ? x * 0.4 : x * 360;
        // color(xxx) -> 0..1
        return x;
      }

      //hue
      if (space[i] === 'h' || i === 2 && space[space.length - 1] === 'h') {
        //<base-hue>
        if (baseHues[x] !== undefined) return baseHues[x];
        //<deg>
        if (x.endsWith('deg')) return parseFloat(x);
        //<turn>
        if (x.endsWith('turn')) return parseFloat(x) * 360;
        if (x.endsWith('grad')) return parseFloat(x) * 360 / 400;
        if (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI;
      }
      if (x === 'none') return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  }

  //named channels case
  else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function (value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb';
  }
  return {
    space,
    values: parts,
    alpha
  };
}
},{"color-name":"node_modules/color-name/index.js"}],"node_modules/color-space/hsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rgb = _interopRequireDefault(require("./rgb.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module color-space/hsl
 */
var _default = exports.default = {
  name: 'hsl',
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ['hue', 'saturation', 'lightness'],
  alias: ['HSL'],
  rgb: function (hsl) {
    var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1,
      t2,
      t3,
      rgb,
      val,
      i = 0;
    if (s === 0) return val = l * 255, [val, val, val];
    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (; i < 3;) {
      t3 = h + 1 / 3 * -(i - 1);
      t3 < 0 ? t3++ : t3 > 1 && t3--;
      val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
      rgb[i++] = val * 255;
    }
    return rgb;
  }
}; //extend rgb
_rgb.default.hsl = function (rgb) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    delta = max - min,
    h,
    s,
    l;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
},{"./rgb.js":"node_modules/color-space/rgb.js"}],"node_modules/color-rgba/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rgba;
var _colorParse = _interopRequireDefault(require("color-parse"));
var _rgb = _interopRequireDefault(require("color-space/rgb.js"));
var _hsl = _interopRequireDefault(require("color-space/hsl.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/** @module  color-rgba */

function rgba(color) {
  // template literals
  if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
  if (color instanceof Number) color = +color;
  var values, i, l;

  //attempt to parse non-array arguments
  var parsed = (0, _colorParse.default)(color);
  if (!parsed.space) return [];
  const min = parsed.space[0] === 'h' ? _hsl.default.min : _rgb.default.min;
  const max = parsed.space[0] === 'h' ? _hsl.default.max : _rgb.default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === 'h') {
    values = _hsl.default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}
},{"color-parse":"node_modules/color-parse/index.js","color-space/rgb.js":"node_modules/color-space/rgb.js","color-space/hsl.js":"node_modules/color-space/hsl.js"}],"node_modules/ol/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asArray = asArray;
exports.asString = asString;
exports.fromString = fromString;
exports.isStringColor = isStringColor;
exports.lchaToRgba = lchaToRgba;
exports.normalize = normalize;
exports.rgbaToLcha = rgbaToLcha;
exports.toString = toString;
exports.withAlpha = withAlpha;
var _lchuv = _interopRequireDefault(require("color-space/lchuv.js"));
var _colorRgba = _interopRequireDefault(require("color-rgba"));
var _rgb = _interopRequireDefault(require("color-space/rgb.js"));
var _xyz = _interopRequireDefault(require("color-space/xyz.js"));
var _math = require("./math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * @module ol/color
 */
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  }
  return toString(color);
}

/**
 * @type {number}
 */
var MAX_CACHE_SIZE = 1024;

/**
 * We maintain a small cache of parsed strings.  Whenever the cache grows too large,
 * we delete an arbitrary set of the entries.
 *
 * @type {Object<string, Color>}
 */
var cache = {};

/**
 * @type {number}
 */
var cacheSize = 0;

/**
 * @param {Color} color A color that may or may not have an alpha channel.
 * @return {Color} The input color with an alpha channel.  If the input color has
 * an alpha channel, the input color will be returned unchanged.  Otherwise, a new
 * array will be returned with the input color and an alpha channel of 1.
 */
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  var output = color.slice();
  output[3] = 1;
  return output;
}

/**
 * @param {Color} color RGBA color.
 * @return {Color} LCHuv color with alpha.
 */
function rgbaToLcha(color) {
  var output = _xyz.default.lchuv(_rgb.default.xyz(color));
  output[3] = color[3];
  return output;
}

/**
 * @param {Color} color LCHuv color with alpha.
 * @return {Color} RGBA color.
 */
function lchaToRgba(color) {
  var output = _xyz.default.rgb(_lchuv.default.xyz(color));
  output[3] = color[3];
  return output;
}

/**
 * @param {string} s String.
 * @return {Color} Color.
 */
function fromString(s) {
  if (cache.hasOwnProperty(s)) {
    return cache[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    var i = 0;
    for (var key in cache) {
      if ((i++ & 3) === 0) {
        delete cache[key];
        --cacheSize;
      }
    }
  }
  var color = (0, _colorRgba.default)(s);
  if (color.length !== 4) {
    throw new Error('Failed to parse "' + s + '" as color');
  }
  var _iterator = _createForOfIteratorHelper(color),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var c = _step.value;
      if (isNaN(c)) {
        throw new Error('Failed to parse "' + s + '" as color');
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  normalize(color);
  cache[s] = color;
  ++cacheSize;
  return color;
}

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}

/**
 * Exported for the tests.
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = (0, _math.clamp)(color[0] + 0.5 | 0, 0, 255);
  color[1] = (0, _math.clamp)(color[1] + 0.5 | 0, 0, 255);
  color[2] = (0, _math.clamp)(color[2] + 0.5 | 0, 0, 255);
  color[3] = (0, _math.clamp)(color[3], 0, 1);
  return color;
}

/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */
function isStringColor(s) {
  try {
    fromString(s);
    return true;
  } catch (_) {
    return false;
  }
}
},{"color-space/lchuv.js":"node_modules/color-space/lchuv.js","color-rgba":"node_modules/color-rgba/index.js","color-space/rgb.js":"node_modules/color-space/rgb.js","color-space/xyz.js":"node_modules/color-space/xyz.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/colorlike.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asColorLike = asColorLike;
var _color = require("./color.js");
/**
 * @module ol/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0, _color.toString)(color);
  }
  return color;
}
},{"./color.js":"node_modules/ol/color.js"}],"node_modules/ol/dom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvasContext2D = createCanvasContext2D;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.releaseCanvas = releaseCanvas;
exports.removeChildren = removeChildren;
exports.removeNode = removeNode;
exports.replaceChildren = replaceChildren;
exports.replaceNode = replaceNode;
var _has = require("./has.js");
/**
 * @module ol/dom
 */

//FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(width, height, canvasPool, settings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  var canvas;
  if (canvasPool && canvasPool.length) {
    canvas = /** @type {HTMLCanvasElement} */canvasPool.shift();
  } else if (_has.WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement('canvas');
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  //FIXME Allow OffscreenCanvasRenderingContext2D as return type
  return /** @type {CanvasRenderingContext2D} */(
    canvas.getContext('2d', settings)
  );
}

/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */
function releaseCanvas(context) {
  var canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */
function replaceChildren(node, children) {
  var oldChildren = node.childNodes;
  for (var i = 0; true; ++i) {
    var oldChild = oldChildren[i];
    var newChild = children[i];

    // check if our work is done
    if (!oldChild && !newChild) {
      break;
    }

    // check if children match
    if (oldChild === newChild) {
      continue;
    }

    // check if a new child needs to be added
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }

    // check if an old child needs to be removed
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }

    // reorder
    node.insertBefore(newChild, oldChild);
  }
}
},{"./has.js":"node_modules/ol/has.js"}],"node_modules/ol/css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFontParameters = exports.CLASS_UNSUPPORTED = exports.CLASS_UNSELECTABLE = exports.CLASS_SELECTABLE = exports.CLASS_HIDDEN = exports.CLASS_CONTROL = exports.CLASS_COLLAPSED = void 0;
/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = exports.CLASS_HIDDEN = 'ol-hidden';

/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = exports.CLASS_SELECTABLE = 'ol-selectable';

/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = exports.CLASS_UNSELECTABLE = 'ol-unselectable';

/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = exports.CLASS_UNSUPPORTED = 'ol-unsupported';

/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = exports.CLASS_CONTROL = 'ol-control';

/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = exports.CLASS_COLLAPSED = 'ol-collapsed';

/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */
var fontRegEx = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
/** @type {Array<'style'|'variant'|'weight'|'size'|'lineHeight'|'family'>} */
var fontRegExMatchIndex = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];

/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */
var getFontParameters = exports.getFontParameters = function getFontParameters(fontSpec) {
  var match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  var style = /** @type {FontParameters} */{
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal'
  };
  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match[i + 1];
    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};
},{}],"node_modules/ol/render/canvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultTextBaseline = exports.defaultTextAlign = exports.defaultStrokeStyle = exports.defaultPadding = exports.defaultMiterLimit = exports.defaultLineWidth = exports.defaultLineJoin = exports.defaultLineDashOffset = exports.defaultLineDash = exports.defaultLineCap = exports.defaultFont = exports.defaultFillStyle = exports.checkedFonts = void 0;
exports.drawImageOrLabel = drawImageOrLabel;
exports.getTextDimensions = getTextDimensions;
exports.measureAndCacheTextWidth = measureAndCacheTextWidth;
exports.measureTextHeight = void 0;
exports.measureTextWidth = measureTextWidth;
exports.registerFont = void 0;
exports.rotateAtOffset = rotateAtOffset;
exports.textHeights = void 0;
var _Object = _interopRequireDefault(require("../Object.js"));
var _has = require("../has.js");
var _obj = require("../obj.js");
var _dom = require("../dom.js");
var _css = require("../css.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/render/canvas
 */

/**
 * @typedef {'Circle' | 'Image' | 'LineString' | 'Polygon' | 'Text' | 'Default'} BuilderType
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */

/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */

/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {CanvasTextAlign} [textAlign] TextAlign.
 * @property {number} [repeat] Repeat.
 * @property {import("../style/Text.js").TextJustify} [justify] Justify.
 * @property {CanvasTextBaseline} textBaseline TextBaseline.
 * @property {import("../style/Text.js").TextPlacement} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */
var defaultFont = exports.defaultFont = '10px sans-serif';

/**
 * @const
 * @type {string}
 */
var defaultFillStyle = exports.defaultFillStyle = '#000';

/**
 * @const
 * @type {CanvasLineCap}
 */
var defaultLineCap = exports.defaultLineCap = 'round';

/**
 * @const
 * @type {Array<number>}
 */
var defaultLineDash = exports.defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = exports.defaultLineDashOffset = 0;

/**
 * @const
 * @type {CanvasLineJoin}
 */
var defaultLineJoin = exports.defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = exports.defaultMiterLimit = 10;

/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
var defaultStrokeStyle = exports.defaultStrokeStyle = '#000';

/**
 * @const
 * @type {CanvasTextAlign}
 */
var defaultTextAlign = exports.defaultTextAlign = 'center';

/**
 * @const
 * @type {CanvasTextBaseline}
 */
var defaultTextBaseline = exports.defaultTextBaseline = 'middle';

/**
 * @const
 * @type {Array<number>}
 */
var defaultPadding = exports.defaultPadding = [0, 0, 0, 0];

/**
 * @const
 * @type {number}
 */
var defaultLineWidth = exports.defaultLineWidth = 1;

/**
 * @type {BaseObject}
 */
var checkedFonts = exports.checkedFonts = new _Object.default();

/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;

/**
 * @type {string}
 */
var measureFont;

/**
 * @type {!Object<string, number>}
 */
var textHeights = exports.textHeights = {};

/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var registerFont = exports.registerFont = function () {
  var retries = 100;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  var interval, referenceWidth;

  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;
    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text);
        // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          (0, _obj.clear)(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }
  return function (fontSpec) {
    var font = (0, _css.getFontParameters)(fontSpec);
    if (!font) {
      return;
    }
    var families = font.families;
    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + '\n' + font.weight + '\n' + family;
      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();

/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
var measureTextHeight = exports.measureTextHeight = function () {
  /**
   * @type {HTMLDivElement}
   */
  var measureElement;
  return function (fontSpec) {
    var height = textHeights[fontSpec];
    if (height == undefined) {
      if (_has.WORKER_OFFSCREEN_CANVAS) {
        var font = (0, _css.getFontParameters)(fontSpec);
        var metrics = measureText(fontSpec, 'g');
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement('div');
          measureElement.innerHTML = 'M';
          measureElement.style.minHeight = '0';
          measureElement.style.maxHeight = 'none';
          measureElement.style.height = 'auto';
          measureElement.style.padding = '0';
          measureElement.style.border = 'none';
          measureElement.style.position = 'absolute';
          measureElement.style.display = 'block';
          measureElement.style.left = '-99999px';
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */
function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0, _dom.createCanvasContext2D)(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}

/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */
function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }
  var width = text.split('\n').reduce(function (prev, curr) {
    return Math.max(prev, measureTextWidth(font, curr));
  }, 0);
  cache[text] = width;
  return width;
}

/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */
function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight = 0;
  for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
    var text = chunks[i];
    if (text === '\n' || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    var font = chunks[i + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return {
    width: width,
    height: height,
    widths: widths,
    heights: heights,
    lineWidths: lineWidths
  };
}

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform) {
    context.transform.apply(context, transform);
  }
  if ( /** @type {*} */labelOrImage.contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions( /** @type {Label} */labelOrImage, context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage( /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, 0, 0, w, h);
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage( /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
  }
  context.restore();
}

/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */
function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;
  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
},{"../Object.js":"node_modules/ol/Object.js","../has.js":"node_modules/ol/has.js","../obj.js":"node_modules/ol/obj.js","../dom.js":"node_modules/ol/dom.js","../css.js":"node_modules/ol/css.js"}],"node_modules/ol/style/RegularShape.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _Image = _interopRequireDefault(require("./Image.js"));
var _color = require("../color.js");
var _colorlike = require("../colorlike.js");
var _dom = require("../dom.js");
var _canvas = require("../render/canvas.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/style/RegularShape
 */
/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */
/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike|undefined} strokeStyle StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */
/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape = /*#__PURE__*/function (_ImageStyle) {
  _inherits(RegularShape, _ImageStyle);
  var _super = _createSuper(RegularShape);
  /**
   * @param {Options} options Options.
   */
  function RegularShape(options) {
    var _this;
    _classCallCheck(this, RegularShape);
    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    _this.canvases_;

    /**
     * @private
     * @type {HTMLCanvasElement|null}
     */
    _this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    _this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    _this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    _this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    _this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    _this.size_;

    /**
     * @private
     * @type {RenderOptions}
     */
    _this.renderOptions_;
    _this.render();
    return _this;
  }

  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  _createClass(RegularShape, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      var style = new RegularShape({
        fill: this.getFill() ? this.getFill().clone() : undefined,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }

    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
  }, {
    key: "getAnchor",
    value: function getAnchor() {
      var size = this.size_;
      var displacement = this.getDisplacement();
      var scale = this.getScaleArray();
      // anchor is scaled by renderer but displacement should not be scaled
      // so divide by scale here
      return [size[0] / 2 - displacement[0] / scale[0], size[1] / 2 + displacement[1] / scale[1]];
    }

    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
  }, {
    key: "getAngle",
    value: function getAngle() {
      return this.angle_;
    }

    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }

    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
      this.render();
    }

    /**
     * @return {HTMLCanvasElement} Image element.
     */
  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      if (!this.hitDetectionCanvas_) {
        this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_);
      }
      return this.hitDetectionCanvas_;
    }

    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     */
  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      var image = this.canvases_[pixelRatio];
      if (!image) {
        var renderOptions = this.renderOptions_;
        var context = (0, _dom.createCanvasContext2D)(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
        this.draw_(renderOptions, context, pixelRatio);
        image = context.canvas;
        this.canvases_[pixelRatio] = image;
      }
      return image;
    }

    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return pixelRatio;
    }

    /**
     * @return {import("../size.js").Size} Image size.
     */
  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return this.size_;
    }

    /**
     * @return {import("../ImageState.js").default} Image state.
     */
  }, {
    key: "getImageState",
    value: function getImageState() {
      return _ImageState.default.LOADED;
    }

    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return this.origin_;
    }

    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
  }, {
    key: "getPoints",
    value: function getPoints() {
      return this.points_;
    }

    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
  }, {
    key: "getRadius",
    value: function getRadius() {
      return this.radius_;
    }

    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
  }, {
    key: "getRadius2",
    value: function getRadius2() {
      return this.radius2_;
    }

    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return this.size_;
    }

    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }

    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
      this.render();
    }

    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {}

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {}

    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {}

    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
  }, {
    key: "calculateLineJoinSize_",
    value: function calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') {
        return strokeWidth;
      }
      // m  | ^
      // i  | |\                  .
      // t >|  #\
      // e  | |\ \              .
      // r      \s\
      //      |  \t\          .                 .
      //          \r\                      .   .
      //      |    \o\      .          .  . . .
      //          e \k\            .  .    . .
      //      |      \e\  .    .  .       . .
      //       d      \ \  .  .          . .
      //      | _ _a_ _\#  .            . .
      //   r1          / `             . .
      //      |                       . .
      //       b     /               . .
      //      |                     . .
      //           / r2            . .
      //      |                        .   .
      //         /                           .   .
      //      |                                   .   .
      //       /                                         .   .
      //       center
      var r1 = this.radius_;
      var r2 = this.radius2_ === undefined ? r1 : this.radius2_;
      if (r1 < r2) {
        var tmp = r1;
        r1 = r2;
        r2 = tmp;
      }
      var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
      var alpha = 2 * Math.PI / points;
      var a = r2 * Math.sin(alpha);
      var b = Math.sqrt(r2 * r2 - a * a);
      var d = r1 - b;
      var e = Math.sqrt(a * a + d * d);
      var miterRatio = e / a;
      if (lineJoin === 'miter' && miterRatio <= miterLimit) {
        return miterRatio * strokeWidth;
      }
      // Calculate the distance from center to the stroke corner where
      // it was cut short because of the miter limit.
      //              l
      //        ----+---- <= distance from center to here is maxr
      //       /####|k ##\
      //      /#####^#####\
      //     /#### /+\# s #\
      //    /### h/+++\# t #\
      //   /### t/+++++\# r #\
      //  /### a/+++++++\# o #\
      // /### p/++ fill +\# k #\
      ///#### /+++++^+++++\# e #\
      //#####/+++++/+\+++++\#####\
      var k = strokeWidth / 2 / miterRatio;
      var l = strokeWidth / 2 * (d / e);
      var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
      var bevelAdd = maxr - r1;
      if (this.radius2_ === undefined || lineJoin === 'bevel') {
        return bevelAdd * 2;
      }
      // If outer miter is over the miter limit the inner miter may reach through the
      // center and be longer than the bevel, same calculation as above but swap r1 / r2.
      var aa = r1 * Math.sin(alpha);
      var bb = Math.sqrt(r1 * r1 - aa * aa);
      var dd = r2 - bb;
      var ee = Math.sqrt(aa * aa + dd * dd);
      var innerMiterRatio = ee / aa;
      if (innerMiterRatio <= miterLimit) {
        var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
        return 2 * Math.max(bevelAdd, innerLength);
      }
      return bevelAdd * 2;
    }

    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
  }, {
    key: "createRenderOptions",
    value: function createRenderOptions() {
      var lineCap = _canvas.defaultLineCap;
      var lineJoin = _canvas.defaultLineJoin;
      var miterLimit = 0;
      var lineDash = null;
      var lineDashOffset = 0;
      var strokeStyle;
      var strokeWidth = 0;
      if (this.stroke_) {
        var _this$stroke_$getColo, _this$stroke_$getWidt, _this$stroke_$getLine, _this$stroke_$getLine2, _this$stroke_$getLine3, _this$stroke_$getMite;
        strokeStyle = (0, _colorlike.asColorLike)((_this$stroke_$getColo = this.stroke_.getColor()) !== null && _this$stroke_$getColo !== void 0 ? _this$stroke_$getColo : _canvas.defaultStrokeStyle);
        strokeWidth = (_this$stroke_$getWidt = this.stroke_.getWidth()) !== null && _this$stroke_$getWidt !== void 0 ? _this$stroke_$getWidt : _canvas.defaultLineWidth;
        lineDash = this.stroke_.getLineDash();
        lineDashOffset = (_this$stroke_$getLine = this.stroke_.getLineDashOffset()) !== null && _this$stroke_$getLine !== void 0 ? _this$stroke_$getLine : 0;
        lineJoin = (_this$stroke_$getLine2 = this.stroke_.getLineJoin()) !== null && _this$stroke_$getLine2 !== void 0 ? _this$stroke_$getLine2 : _canvas.defaultLineJoin;
        lineCap = (_this$stroke_$getLine3 = this.stroke_.getLineCap()) !== null && _this$stroke_$getLine3 !== void 0 ? _this$stroke_$getLine3 : _canvas.defaultLineCap;
        miterLimit = (_this$stroke_$getMite = this.stroke_.getMiterLimit()) !== null && _this$stroke_$getMite !== void 0 ? _this$stroke_$getMite : _canvas.defaultMiterLimit;
      }
      var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
      var size = Math.ceil(2 * maxRadius + add);
      return {
        strokeStyle: strokeStyle,
        strokeWidth: strokeWidth,
        size: size,
        lineCap: lineCap,
        lineDash: lineDash,
        lineDashOffset: lineDashOffset,
        lineJoin: lineJoin,
        miterLimit: miterLimit
      };
    }

    /**
     * @protected
     */
  }, {
    key: "render",
    value: function render() {
      this.renderOptions_ = this.createRenderOptions();
      var size = this.renderOptions_.size;
      this.canvases_ = {};
      this.hitDetectionCanvas_ = null;
      this.size_ = [size, size];
    }

    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
  }, {
    key: "draw_",
    value: function draw_(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio);
      // set origin to canvas center
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      if (this.fill_) {
        var color = this.fill_.getColor();
        if (color === null) {
          color = _canvas.defaultFillStyle;
        }
        context.fillStyle = (0, _colorlike.asColorLike)(color);
        context.fill();
      }
      if (renderOptions.strokeStyle) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineCap = renderOptions.lineCap;
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }

    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @return {HTMLCanvasElement} Canvas containing the icon
     */
  }, {
    key: "createHitDetectionCanvas_",
    value: function createHitDetectionCanvas_(renderOptions) {
      var context;
      if (this.fill_) {
        var color = this.fill_.getColor();

        // determine if fill is transparent (or pattern or gradient)
        var opacity = 0;
        if (typeof color === 'string') {
          color = (0, _color.asArray)(color);
        }
        if (color === null) {
          opacity = 1;
        } else if (Array.isArray(color)) {
          opacity = color.length === 4 ? color[3] : 1;
        }
        if (opacity === 0) {
          // if a transparent fill style is set, create an extra hit-detection image
          // with a default fill style
          context = (0, _dom.createCanvasContext2D)(renderOptions.size, renderOptions.size);
          this.drawHitDetectionCanvas_(renderOptions, context);
        }
      }
      return context ? context.canvas : this.getImage(1);
    }

    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
  }, {
    key: "createPath_",
    value: function createPath_(context) {
      var points = this.points_;
      var radius = this.radius_;
      if (points === Infinity) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        var radius2 = this.radius2_ === undefined ? radius : this.radius2_;
        if (this.radius2_ !== undefined) {
          points *= 2;
        }
        var startAngle = this.angle_ - Math.PI / 2;
        var step = 2 * Math.PI / points;
        for (var i = 0; i < points; i++) {
          var angle0 = startAngle + i * step;
          var radiusC = i % 2 === 0 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }
        context.closePath();
      }
    }

    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
  }, {
    key: "drawHitDetectionCanvas_",
    value: function drawHitDetectionCanvas_(renderOptions, context) {
      // set origin to canvas center
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = _canvas.defaultFillStyle;
      context.fill();
      if (renderOptions.strokeStyle) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }
  }]);
  return RegularShape;
}(_Image.default);
var _default = exports.default = RegularShape;
},{"../ImageState.js":"node_modules/ol/ImageState.js","./Image.js":"node_modules/ol/style/Image.js","../color.js":"node_modules/ol/color.js","../colorlike.js":"node_modules/ol/colorlike.js","../dom.js":"node_modules/ol/dom.js","../render/canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/style/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _RegularShape2 = _interopRequireDefault(require("./RegularShape.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/style/Circle
 */
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */
/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = /*#__PURE__*/function (_RegularShape) {
  _inherits(CircleStyle, _RegularShape);
  var _super = _createSuper(CircleStyle);
  /**
   * @param {Options} [options] Options.
   */
  function CircleStyle(options) {
    _classCallCheck(this, CircleStyle);
    options = options ? options : {
      radius: 5
    };
    return _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }

  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  _createClass(CircleStyle, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      var style = new CircleStyle({
        fill: this.getFill() ? this.getFill().clone() : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        radius: this.getRadius(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }

    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this.radius_ = radius;
      this.render();
    }
  }]);
  return CircleStyle;
}(_RegularShape2.default);
var _default = exports.default = CircleStyle;
},{"./RegularShape.js":"node_modules/ol/style/RegularShape.js"}],"node_modules/ol/style/Fill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/style/Fill
 */
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */
/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Fill(options) {
    _classCallCheck(this, Fill);
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */
    this.color_ = options.color !== undefined ? options.color : null;
  }

  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  _createClass(Fill, [{
    key: "clone",
    value: function clone() {
      var color = this.getColor();
      return new Fill({
        color: Array.isArray(color) ? color.slice() : color || undefined
      });
    }

    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
     * @api
     */
  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }

    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
     * @api
     */
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color_ = color;
    }
  }]);
  return Fill;
}();
var _default = exports.default = Fill;
},{}],"node_modules/ol/style/Stroke.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/style/Stroke
 */
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */
/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Stroke(options) {
    _classCallCheck(this, Stroke);
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */
    this.color_ = options.color !== undefined ? options.color : null;

    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */
    this.lineCap_ = options.lineCap;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lineDashOffset_ = options.lineDashOffset;

    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */
    this.lineJoin_ = options.lineJoin;

    /**
     * @private
     * @type {number|undefined}
     */
    this.miterLimit_ = options.miterLimit;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = options.width;
  }

  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  _createClass(Stroke, [{
    key: "clone",
    value: function clone() {
      var color = this.getColor();
      return new Stroke({
        color: Array.isArray(color) ? color.slice() : color || undefined,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }

    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }

    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
  }, {
    key: "getLineCap",
    value: function getLineCap() {
      return this.lineCap_;
    }

    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
  }, {
    key: "getLineDash",
    value: function getLineDash() {
      return this.lineDash_;
    }

    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
  }, {
    key: "getLineDashOffset",
    value: function getLineDashOffset() {
      return this.lineDashOffset_;
    }

    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
  }, {
    key: "getLineJoin",
    value: function getLineJoin() {
      return this.lineJoin_;
    }

    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
  }, {
    key: "getMiterLimit",
    value: function getMiterLimit() {
      return this.miterLimit_;
    }

    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width_;
    }

    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color_ = color;
    }

    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
  }, {
    key: "setLineCap",
    value: function setLineCap(lineCap) {
      this.lineCap_ = lineCap;
    }

    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
  }, {
    key: "setLineDash",
    value: function setLineDash(lineDash) {
      this.lineDash_ = lineDash;
    }

    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
  }, {
    key: "setLineDashOffset",
    value: function setLineDashOffset(lineDashOffset) {
      this.lineDashOffset_ = lineDashOffset;
    }

    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
  }, {
    key: "setLineJoin",
    value: function setLineJoin(lineJoin) {
      this.lineJoin_ = lineJoin;
    }

    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
  }, {
    key: "setMiterLimit",
    value: function setMiterLimit(miterLimit) {
      this.miterLimit_ = miterLimit;
    }

    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this.width_ = width;
    }
  }]);
  return Stroke;
}();
var _default = exports.default = Stroke;
},{}],"node_modules/ol/style/Style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDefaultStyle = createDefaultStyle;
exports.createEditingStyle = createEditingStyle;
exports.default = void 0;
exports.toFunction = toFunction;
var _Circle = _interopRequireDefault(require("./Circle.js"));
var _Fill = _interopRequireDefault(require("./Fill.js"));
var _Stroke = _interopRequireDefault(require("./Stroke.js"));
var _asserts = require("../asserts.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/style/Style
 */
/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */
/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */
/**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */
/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */
/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */
/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */
var Style = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Style options.
   */
  function Style(options) {
    _classCallCheck(this, Style);
    options = options || {};

    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     */
    this.geometry_ = null;

    /**
     * @private
     * @type {!GeometryFunction}
     */
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {import("./Image.js").default|null}
     */
    this.image_ = options.image !== undefined ? options.image : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.renderer_ = options.renderer !== undefined ? options.renderer : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("./Text.js").default|null}
     */
    this.text_ = options.text !== undefined ? options.text : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.zIndex_ = options.zIndex;
  }

  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  _createClass(Style, [{
    key: "clone",
    value: function clone() {
      var _geometry, _this$getRenderer;
      var geometry = this.getGeometry();
      if (geometry && _typeof(geometry) === 'object') {
        geometry = /** @type {import("../geom/Geometry.js").default} */geometry.clone();
      }
      return new Style({
        geometry: (_geometry = geometry) !== null && _geometry !== void 0 ? _geometry : undefined,
        fill: this.getFill() ? this.getFill().clone() : undefined,
        image: this.getImage() ? this.getImage().clone() : undefined,
        renderer: (_this$getRenderer = this.getRenderer()) !== null && _this$getRenderer !== void 0 ? _this$getRenderer : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        text: this.getText() ? this.getText().clone() : undefined,
        zIndex: this.getZIndex()
      });
    }

    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
  }, {
    key: "getRenderer",
    value: function getRenderer() {
      return this.renderer_;
    }

    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      this.renderer_ = renderer;
    }

    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
  }, {
    key: "setHitDetectionRenderer",
    value: function setHitDetectionRenderer(renderer) {
      this.hitDetectionRenderer_ = renderer;
    }

    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
  }, {
    key: "getHitDetectionRenderer",
    value: function getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }

    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.geometry_;
    }

    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
  }, {
    key: "getGeometryFunction",
    value: function getGeometryFunction() {
      return this.geometryFunction_;
    }

    /**
     * Get the fill style.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }

    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
    }

    /**
     * Get the image style.
     * @return {import("./Image.js").default|null} Image style.
     * @api
     */
  }, {
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }

    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
  }, {
    key: "setImage",
    value: function setImage(image) {
      this.image_ = image;
    }

    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }

    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
    }

    /**
     * Get the text style.
     * @return {import("./Text.js").default|null} Text style.
     * @api
     */
  }, {
    key: "getText",
    value: function getText() {
      return this.text_;
    }

    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
  }, {
    key: "setText",
    value: function setText(text) {
      this.text_ = text;
    }

    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
  }, {
    key: "getZIndex",
    value: function getZIndex() {
      return this.zIndex_;
    }

    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      if (typeof geometry === 'function') {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === 'string') {
        this.geometryFunction_ = function (feature) {
          return /** @type {import("../geom/Geometry.js").default} */(
            feature.get(geometry)
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== undefined) {
        this.geometryFunction_ = function () {
          return /** @type {import("../geom/Geometry.js").default} */geometry;
        };
      }
      this.geometry_ = geometry;
    }

    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      this.zIndex_ = zIndex;
    }
  }]);
  return Style;
}();
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  var styleFunction;
  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      (0, _asserts.assert)(typeof ( /** @type {?} */obj.getZIndex) === 'function', 'Expected an `Style` or an array of `Style`');
      var style = /** @type {Style} */obj;
      styles = [style];
    }
    styleFunction = function styleFunction() {
      return styles;
    };
  }
  return styleFunction;
}

/**
 * @type {Array<Style>|null}
 */
var defaultStyles = null;

/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke.default({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [new Style({
      image: new _Circle.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }
  return defaultStyles;
}

/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles['Polygon'] = [new Style({
    fill: new _Fill.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles['MultiPolygon'] = styles['Polygon'];
  styles['LineString'] = [new Style({
    stroke: new _Stroke.default({
      color: white,
      width: width + 2
    })
  }), new Style({
    stroke: new _Stroke.default({
      color: blue,
      width: width
    })
  })];
  styles['MultiLineString'] = styles['LineString'];
  styles['Circle'] = styles['Polygon'].concat(styles['LineString']);
  styles['Point'] = [new Style({
    image: new _Circle.default({
      radius: width * 2,
      fill: new _Fill.default({
        color: blue
      }),
      stroke: new _Stroke.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles['MultiPoint'] = styles['Point'];
  styles['GeometryCollection'] = styles['Polygon'].concat(styles['LineString'], styles['Point']);
  return styles;
}

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var _default = exports.default = Style;
},{"./Circle.js":"node_modules/ol/style/Circle.js","./Fill.js":"node_modules/ol/style/Fill.js","./Stroke.js":"node_modules/ol/style/Stroke.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;
exports.decodeFallback = decodeFallback;
exports.default = void 0;
exports.listenImage = listenImage;
exports.load = load;
var _Target = _interopRequireDefault(require("./events/Target.js"));
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _ImageState = _interopRequireDefault(require("./ImageState.js"));
var _has = require("./has.js");
var _events = require("./events.js");
var _functions = require("./functions.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Image
 */
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */
/**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */
var ImageWrapper = /*#__PURE__*/function (_EventTarget) {
  _inherits(ImageWrapper, _EventTarget);
  var _super = _createSuper(ImageWrapper);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  function ImageWrapper(extent, resolution, pixelRatio, stateOrLoader) {
    var _this;
    _classCallCheck(this, ImageWrapper);
    _this = _super.call(this);

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    _this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    _this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|Array<number>|undefined}
     */
    _this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    _this.state = typeof stateOrLoader === 'function' ? _ImageState.default.IDLE : stateOrLoader;

    /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */
    _this.image_ = null;

    /**
     * @protected
     * @type {import("./Image.js").Loader}
     */
    _this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
    return _this;
  }

  /**
   * @protected
   */
  _createClass(ImageWrapper, [{
    key: "changed",
    value: function changed() {
      this.dispatchEvent(_EventType.default.CHANGE);
    }

    /**
     * @return {import("./extent.js").Extent} Extent.
     */
  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent;
    }

    /**
     * @return {import('./DataTile.js').ImageLike} Image.
     */
  }, {
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }

    /**
     * @return {number} PixelRatio.
     */
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio() {
      return this.pixelRatio_;
    }

    /**
     * @return {number|Array<number>} Resolution.
     */
  }, {
    key: "getResolution",
    value: function getResolution() {
      return /** @type {number} */this.resolution;
    }

    /**
     * @return {import("./ImageState.js").default} State.
     */
  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      var _this2 = this;
      if (this.state == _ImageState.default.IDLE) {
        if (this.loader) {
          this.state = _ImageState.default.LOADING;
          this.changed();
          var resolution = this.getResolution();
          var requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
          (0, _functions.toPromise)(function () {
            return _this2.loader(_this2.getExtent(), requestResolution, _this2.getPixelRatio());
          }).then(function (image) {
            if ('image' in image) {
              _this2.image_ = image.image;
            }
            if ('extent' in image) {
              _this2.extent = image.extent;
            }
            if ('resolution' in image) {
              _this2.resolution = image.resolution;
            }
            if ('pixelRatio' in image) {
              _this2.pixelRatio_ = image.pixelRatio;
            }
            if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {
              _this2.image_ = image;
            }
            _this2.state = _ImageState.default.LOADED;
          }).catch(function (error) {
            _this2.state = _ImageState.default.ERROR;
            console.error(error); // eslint-disable-line no-console
          }).finally(function () {
            return _this2.changed();
          });
        }
      }
    }

    /**
     * @param {import('./DataTile.js').ImageLike} image The image.
     */
  }, {
    key: "setImage",
    value: function setImage(image) {
      this.image_ = image;
    }

    /**
     * @param {number|Array<number>} resolution Resolution.
     */
  }, {
    key: "setResolution",
    value: function setResolution(resolution) {
      this.resolution = resolution;
    }
  }]);
  return ImageWrapper;
}(_Target.default);
/**
 * @param {import('./DataTile.js').ImageLike} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */
function listenImage(image, loadHandler, errorHandler) {
  var img = /** @type {HTMLImageElement} */image;
  var listening = true;
  var decoding = false;
  var loaded = false;
  var listenerKeys = [(0, _events.listenOnce)(img, _EventType.default.LOAD, function () {
    loaded = true;
    if (!decoding) {
      loadHandler();
    }
  })];
  if (img.src && _has.IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function () {
      if (listening) {
        loadHandler();
      }
    }).catch(function (error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push((0, _events.listenOnce)(img, _EventType.default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(_events.unlistenByKey);
  };
}

/**
 * Loads an image.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 * @api
 */
function load(image, src) {
  return new Promise(function (resolve, reject) {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error('Image load error'));
    }
    function unlisten() {
      image.removeEventListener('load', handleLoad);
      image.removeEventListener('error', handleError);
    }
    image.addEventListener('load', handleLoad);
    image.addEventListener('error', handleError);
    if (src) {
      image.src = src;
    }
  });
}

/**
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 */
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && _has.IMAGE_DECODE ? new Promise(function (resolve, reject) {
    return image.decode().then(function () {
      return resolve(image);
    }).catch(function (e) {
      return image.complete && image.width ? resolve(image) : reject(e);
    });
  }) : load(image);
}

/**
 * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns
 * the loaded image otherwise.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an
 * `HTMLImageElement` if `createImageBitmap()` is not supported.
 * @api
 */
function decode(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && _has.IMAGE_DECODE && _has.CREATE_IMAGE_BITMAP ? image.decode().then(function () {
    return createImageBitmap(image);
  }).catch(function (e) {
    if (image.complete && image.width) {
      return image;
    }
    throw e;
  }) : decodeFallback(image);
}
var _default = exports.default = ImageWrapper;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./ImageState.js":"node_modules/ol/ImageState.js","./has.js":"node_modules/ol/has.js","./events.js":"node_modules/ol/events.js","./functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/style/IconImageCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shared = exports.default = void 0;
var _color = require("../color.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/style/IconImageCache
 */
/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */
var IconImageCache = /*#__PURE__*/function () {
  function IconImageCache() {
    _classCallCheck(this, IconImageCache);
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};

    /**
     * @type {number}
     * @private
     */
    this.cacheSize_ = 0;

    /**
     * @type {number}
     * @private
     */
    this.maxCacheSize_ = 32;
  }

  /**
   * FIXME empty description for jsdoc
   */
  _createClass(IconImageCache, [{
    key: "clear",
    value: function clear() {
      this.cache_ = {};
      this.cacheSize_ = 0;
    }

    /**
     * @return {boolean} Can expire cache.
     */
  }, {
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }

    /**
     * FIXME empty description for jsdoc
     */
  }, {
    key: "expire",
    value: function expire() {
      if (this.canExpireCache()) {
        var i = 0;
        for (var key in this.cache_) {
          var iconImage = this.cache_[key];
          if ((i++ & 3) === 0 && !iconImage.hasListener()) {
            delete this.cache_[key];
            --this.cacheSize_;
          }
        }
      }
    }

    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
  }, {
    key: "get",
    value: function get(src, crossOrigin, color) {
      var key = getKey(src, crossOrigin, color);
      return key in this.cache_ ? this.cache_[key] : null;
    }

    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @param {import("./IconImage.js").default} iconImage Icon image.
     */
  }, {
    key: "set",
    value: function set(src, crossOrigin, color, iconImage) {
      var key = getKey(src, crossOrigin, color);
      this.cache_[key] = iconImage;
      ++this.cacheSize_;
    }

    /**
     * Set the cache size of the icon cache. Default is `32`. Change this value when
     * your map uses more than 32 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
  }, {
    key: "setSize",
    value: function setSize(maxCacheSize) {
      this.maxCacheSize_ = maxCacheSize;
      this.expire();
    }
  }]);
  return IconImageCache;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  var colorString = color ? (0, _color.asString)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}
var _default = exports.default = IconImageCache;
/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = exports.shared = new IconImageCache();
},{"../color.js":"node_modules/ol/color.js"}],"node_modules/ol/style/IconImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.get = get;
var _Target = _interopRequireDefault(require("../events/Target.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _color = require("../color.js");
var _dom = require("../dom.js");
var _Image = require("../Image.js");
var _IconImageCache = require("./IconImageCache.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/style/IconImage
 */
/**
 * @type {CanvasRenderingContext2D}
 */
var taintedTestContext = null;
var IconImage = /*#__PURE__*/function (_EventTarget) {
  _inherits(IconImage, _EventTarget);
  var _super = _createSuper(IconImage);
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  function IconImage(image, src, crossOrigin, imageState, color) {
    var _this;
    _classCallCheck(this, IconImage);
    _this = _super.call(this);

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    _this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    _this.image_ = image;

    /**
     * @private
     * @type {string|null}
     */
    _this.crossOrigin_ = crossOrigin;

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    _this.canvas_ = {};

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    _this.color_ = color;

    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    _this.imageState_ = imageState === undefined ? _ImageState.default.IDLE : imageState;

    /**
     * @private
     * @type {import("../size.js").Size|null}
     */
    _this.size_ = image && image.width && image.height ? [image.width, image.height] : null;

    /**
     * @private
     * @type {string|undefined}
     */
    _this.src_ = src;

    /**
     * @private
     */
    _this.tainted_;
    return _this;
  }

  /**
   * @private
   */
  _createClass(IconImage, [{
    key: "initializeImage_",
    value: function initializeImage_() {
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }

    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
  }, {
    key: "isTainted_",
    value: function isTainted_() {
      if (this.tainted_ === undefined && this.imageState_ === _ImageState.default.LOADED) {
        if (!taintedTestContext) {
          taintedTestContext = (0, _dom.createCanvasContext2D)(1, 1, undefined, {
            willReadFrequently: true
          });
        }
        taintedTestContext.drawImage(this.image_, 0, 0);
        try {
          taintedTestContext.getImageData(0, 0, 1, 1);
          this.tainted_ = false;
        } catch (e) {
          taintedTestContext = null;
          this.tainted_ = true;
        }
      }
      return this.tainted_ === true;
    }

    /**
     * @private
     */
  }, {
    key: "dispatchChangeEvent_",
    value: function dispatchChangeEvent_() {
      this.dispatchEvent(_EventType.default.CHANGE);
    }

    /**
     * @private
     */
  }, {
    key: "handleImageError_",
    value: function handleImageError_() {
      this.imageState_ = _ImageState.default.ERROR;
      this.dispatchChangeEvent_();
    }

    /**
     * @private
     */
  }, {
    key: "handleImageLoad_",
    value: function handleImageLoad_() {
      this.imageState_ = _ImageState.default.LOADED;
      this.size_ = [this.image_.width, this.image_.height];
      this.dispatchChangeEvent_();
    }

    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      if (!this.image_) {
        this.initializeImage_();
      }
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }

    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }

    /**
     * @return {import("../ImageState.js").default} Image state.
     */
  }, {
    key: "getImageState",
    value: function getImageState() {
      return this.imageState_;
    }

    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      if (!this.image_) {
        this.initializeImage_();
      }
      if (!this.hitDetectionImage_) {
        if (this.isTainted_()) {
          var width = this.size_[0];
          var height = this.size_[1];
          var context = (0, _dom.createCanvasContext2D)(width, height);
          context.fillRect(0, 0, width, height);
          this.hitDetectionImage_ = context.canvas;
        } else {
          this.hitDetectionImage_ = this.image_;
        }
      }
      return this.hitDetectionImage_;
    }

    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return this.size_;
    }

    /**
     * @return {string|undefined} Image src.
     */
  }, {
    key: "getSrc",
    value: function getSrc() {
      return this.src_;
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      var _this2 = this;
      if (this.imageState_ !== _ImageState.default.IDLE) {
        return;
      }
      if (!this.image_) {
        this.initializeImage_();
      }
      this.imageState_ = _ImageState.default.LOADING;
      try {
        if (this.src_ !== undefined) {
          /** @type {HTMLImageElement} */this.image_.src = this.src_;
        }
      } catch (e) {
        this.handleImageError_();
      }
      if (this.image_ instanceof HTMLImageElement) {
        (0, _Image.decodeFallback)(this.image_, this.src_).then(function (image) {
          _this2.image_ = image;
          _this2.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
      }
    }

    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
  }, {
    key: "replaceColor_",
    value: function replaceColor_(pixelRatio) {
      if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== _ImageState.default.LOADED) {
        return;
      }
      var image = this.image_;
      var canvas = document.createElement('canvas');
      canvas.width = Math.ceil(image.width * pixelRatio);
      canvas.height = Math.ceil(image.height * pixelRatio);
      var ctx = canvas.getContext('2d');
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(image, 0, 0);
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = (0, _color.asString)(this.color_);
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(image, 0, 0);
      this.canvas_[pixelRatio] = canvas;
    }
  }]);
  return IconImage;
}(_Target.default);
/**
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
 * @param {string} cacheKey Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */
function get(image, cacheKey, crossOrigin, imageState, color) {
  var iconImage = cacheKey === undefined ? undefined : _IconImageCache.shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, image instanceof HTMLImageElement ? image.src || undefined : cacheKey, crossOrigin, imageState, color);
    _IconImageCache.shared.set(cacheKey, crossOrigin, color, iconImage);
  }
  return iconImage;
}
var _default = exports.default = IconImage;
},{"../events/Target.js":"node_modules/ol/events/Target.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../color.js":"node_modules/ol/color.js","../dom.js":"node_modules/ol/dom.js","../Image.js":"node_modules/ol/Image.js","./IconImageCache.js":"node_modules/ol/style/IconImageCache.js"}],"node_modules/ol/style/Icon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _Image = _interopRequireDefault(require("./Image.js"));
var _color = require("../color.js");
var _asserts = require("../asserts.js");
var _IconImage = require("./IconImage.js");
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/style/Icon
 */
/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */

/**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */

/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement|ImageBitmap} [img] Image object for the icon.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== undefined && wantedHeight !== undefined) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== undefined) {
    return wantedWidth / width;
  }
  if (wantedHeight !== undefined) {
    return wantedHeight / height;
  }
  return 1;
}

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
var Icon = /*#__PURE__*/function (_ImageStyle) {
  _inherits(Icon, _ImageStyle);
  var _super = _createSuper(Icon);
  /**
   * @param {Options} [options] Options.
   */
  function Icon(options) {
    var _this;
    _classCallCheck(this, Icon);
    options = options || {};

    /**
     * @type {number}
     */
    var opacity = options.opacity !== undefined ? options.opacity : 1;

    /**
     * @type {number}
     */
    var rotation = options.rotation !== undefined ? options.rotation : 0;

    /**
     * @type {number|import("../size.js").Size}
     */
    var scale = options.scale !== undefined ? options.scale : 1;

    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView,
      declutterMode: options.declutterMode
    });

    /**
     * @private
     * @type {Array<number>}
     */
    _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

    /**
     * @private
     * @type {Array<number>}
     */
    _this.normalizedAnchor_ = null;

    /**
     * @private
     * @type {IconOrigin}
     */
    _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';

    /**
     * @private
     * @type {?string}
     */
    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    var image = options.img !== undefined ? options.img : null;
    var cacheKey = options.src;
    (0, _asserts.assert)(!(cacheKey !== undefined && image), '`image` and `src` cannot be provided at the same time');
    if ((cacheKey === undefined || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */image.src || (0, _util.getUid)(image);
    }
    (0, _asserts.assert)(cacheKey !== undefined && cacheKey.length > 0, 'A defined and non-empty `src` or `image` must be provided');
    (0, _asserts.assert)(!((options.width !== undefined || options.height !== undefined) && options.scale !== undefined), '`width` or `height` cannot be provided together with `scale`');
    var imageState;
    if (options.src !== undefined) {
      imageState = _ImageState.default.IDLE;
    } else if (image !== undefined) {
      if (image instanceof HTMLImageElement) {
        if (image.complete) {
          imageState = image.src ? _ImageState.default.LOADED : _ImageState.default.IDLE;
        } else {
          imageState = _ImageState.default.LOADING;
        }
      } else {
        imageState = _ImageState.default.LOADED;
      }
    }

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    _this.color_ = options.color !== undefined ? (0, _color.asArray)(options.color) : null;

    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    _this.iconImage_ = (0, _IconImage.get)(image, /** @type {string} */cacheKey, _this.crossOrigin_, imageState, _this.color_);

    /**
     * @private
     * @type {Array<number>}
     */
    _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {IconOrigin}
     */
    _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';

    /**
     * @private
     * @type {Array<number>}
     */
    _this.origin_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    _this.size_ = options.size !== undefined ? options.size : null;

    /**
     * Calculate the scale if width or height were given.
     */
    if (options.width !== undefined || options.height !== undefined) {
      var width, height;
      if (options.size) {
        var _options$size = _slicedToArray(options.size, 2);
        width = _options$size[0];
        height = _options$size[1];
      } else {
        var _image = _this.getImage(1);
        if (_image.width && _image.height) {
          width = _image.width;
          height = _image.height;
        } else if (_image instanceof HTMLImageElement) {
          _this.initialOptions_ = options;
          var onload = function onload() {
            _this.unlistenImageChange(onload);
            if (!_this.initialOptions_) {
              return;
            }
            var imageSize = _this.iconImage_.getSize();
            _this.setScale(calculateScale(imageSize[0], imageSize[1], options.width, options.height));
          };
          _this.listenImageChange(onload);
          return _possibleConstructorReturn(_this);
        }
      }
      if (width !== undefined) {
        _this.setScale(calculateScale(width, height, options.width, options.height));
      }
    }
    return _this;
  }

  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  _createClass(Icon, [{
    key: "clone",
    value: function clone() {
      var scale, width, height;
      if (this.initialOptions_) {
        width = this.initialOptions_.width;
        height = this.initialOptions_.height;
      } else {
        scale = this.getScale();
        scale = Array.isArray(scale) ? scale.slice() : scale;
      }
      return new Icon({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
        crossOrigin: this.crossOrigin_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: scale,
        width: width,
        height: height,
        size: this.size_ !== null ? this.size_.slice() : undefined,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }

    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
  }, {
    key: "getAnchor",
    value: function getAnchor() {
      var anchor = this.normalizedAnchor_;
      if (!anchor) {
        anchor = this.anchor_;
        var size = this.getSize();
        if (this.anchorXUnits_ == 'fraction' || this.anchorYUnits_ == 'fraction') {
          if (!size) {
            return null;
          }
          anchor = this.anchor_.slice();
          if (this.anchorXUnits_ == 'fraction') {
            anchor[0] *= size[0];
          }
          if (this.anchorYUnits_ == 'fraction') {
            anchor[1] *= size[1];
          }
        }
        if (this.anchorOrigin_ != 'top-left') {
          if (!size) {
            return null;
          }
          if (anchor === this.anchor_) {
            anchor = this.anchor_.slice();
          }
          if (this.anchorOrigin_ == 'top-right' || this.anchorOrigin_ == 'bottom-right') {
            anchor[0] = -anchor[0] + size[0];
          }
          if (this.anchorOrigin_ == 'bottom-left' || this.anchorOrigin_ == 'bottom-right') {
            anchor[1] = -anchor[1] + size[1];
          }
        }
        this.normalizedAnchor_ = anchor;
      }
      var displacement = this.getDisplacement();
      var scale = this.getScaleArray();
      // anchor is scaled by renderer but displacement should not be scaled
      // so divide by scale here
      return [anchor[0] - displacement[0] / scale[0], anchor[1] + displacement[1] / scale[1]];
    }

    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
  }, {
    key: "setAnchor",
    value: function setAnchor(anchor) {
      this.anchor_ = anchor;
      this.normalizedAnchor_ = null;
    }

    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }

    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     */
  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      return this.iconImage_.getImage(pixelRatio);
    }

    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     */
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return this.iconImage_.getPixelRatio(pixelRatio);
    }

    /**
     * @return {import("../size.js").Size} Image size.
     */
  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return this.iconImage_.getSize();
    }

    /**
     * @return {import("../ImageState.js").default} Image state.
     */
  }, {
    key: "getImageState",
    value: function getImageState() {
      return this.iconImage_.getImageState();
    }

    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }

    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      if (this.origin_) {
        return this.origin_;
      }
      var offset = this.offset_;
      if (this.offsetOrigin_ != 'top-left') {
        var size = this.getSize();
        var iconImageSize = this.iconImage_.getSize();
        if (!size || !iconImageSize) {
          return null;
        }
        offset = offset.slice();
        if (this.offsetOrigin_ == 'top-right' || this.offsetOrigin_ == 'bottom-right') {
          offset[0] = iconImageSize[0] - size[0] - offset[0];
        }
        if (this.offsetOrigin_ == 'bottom-left' || this.offsetOrigin_ == 'bottom-right') {
          offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
      }
      this.origin_ = offset;
      return this.origin_;
    }

    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
  }, {
    key: "getSrc",
    value: function getSrc() {
      return this.iconImage_.getSrc();
    }

    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }

    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      var scale = this.getScaleArray();
      if (this.size_) {
        return this.size_[0] * scale[0];
      }
      if (this.iconImage_.getImageState() == _ImageState.default.LOADED) {
        return this.iconImage_.getSize()[0] * scale[0];
      }
      return undefined;
    }

    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      var scale = this.getScaleArray();
      if (this.size_) {
        return this.size_[1] * scale[1];
      }
      if (this.iconImage_.getImageState() == _ImageState.default.LOADED) {
        return this.iconImage_.getSize()[1] * scale[1];
      }
      return undefined;
    }

    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
  }, {
    key: "setScale",
    value: function setScale(scale) {
      delete this.initialOptions_;
      _get(_getPrototypeOf(Icon.prototype), "setScale", this).call(this, scale);
    }

    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {
      this.iconImage_.addEventListener(_EventType.default.CHANGE, listener);
    }

    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     */
  }, {
    key: "load",
    value: function load() {
      this.iconImage_.load();
    }

    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {
      this.iconImage_.removeEventListener(_EventType.default.CHANGE, listener);
    }
  }]);
  return Icon;
}(_Image.default);
var _default = exports.default = Icon;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","./Image.js":"node_modules/ol/style/Image.js","../color.js":"node_modules/ol/color.js","../asserts.js":"node_modules/ol/asserts.js","./IconImage.js":"node_modules/ol/style/IconImage.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/style/Text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Fill = _interopRequireDefault(require("./Fill.js"));
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/style/Text
 */
/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */

/**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
var DEFAULT_FILL_COLOR = '#333';

/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45 (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
var Text = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Text(options) {
    _classCallCheck(this, Text);
    options = options || {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.font_ = options.font;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0, _size.toSize)(options.scale !== undefined ? options.scale : 1);

    /**
     * @private
     * @type {string|Array<string>|undefined}
     */
    this.text_ = options.text;

    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */
    this.textAlign_ = options.textAlign;

    /**
     * @private
     * @type {TextJustify|undefined}
     */
    this.justify_ = options.justify;

    /**
     * @private
     * @type {number|undefined}
     */
    this.repeat_ = options.repeat;

    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */
    this.textBaseline_ = options.textBaseline;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.fill_ = options.fill !== undefined ? options.fill : new _Fill.default({
      color: DEFAULT_FILL_COLOR
    });

    /**
     * @private
     * @type {number}
     */
    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;

    /**
     * @private
     * @type {TextPlacement}
     */
    this.placement_ = options.placement !== undefined ? options.placement : 'point';

    /**
     * @private
     * @type {boolean}
     */
    this.overflow_ = !!options.overflow;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {number}
     */
    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;

    /**
     * @private
     * @type {number}
     */
    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.padding_ = options.padding === undefined ? null : options.padding;
  }

  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  _createClass(Text, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      return new Text({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
        padding: this.getPadding() || undefined
      });
    }

    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
  }, {
    key: "getOverflow",
    value: function getOverflow() {
      return this.overflow_;
    }

    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
  }, {
    key: "getFont",
    value: function getFont() {
      return this.font_;
    }

    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
  }, {
    key: "getMaxAngle",
    value: function getMaxAngle() {
      return this.maxAngle_;
    }

    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
  }, {
    key: "getPlacement",
    value: function getPlacement() {
      return this.placement_;
    }

    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
  }, {
    key: "getRepeat",
    value: function getRepeat() {
      return this.repeat_;
    }

    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
  }, {
    key: "getOffsetX",
    value: function getOffsetX() {
      return this.offsetX_;
    }

    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
  }, {
    key: "getOffsetY",
    value: function getOffsetY() {
      return this.offsetY_;
    }

    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }

    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
  }, {
    key: "getRotateWithView",
    value: function getRotateWithView() {
      return this.rotateWithView_;
    }

    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation_;
    }

    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return this.scale_;
    }

    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
  }, {
    key: "getScaleArray",
    value: function getScaleArray() {
      return this.scaleArray_;
    }

    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }

    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
  }, {
    key: "getText",
    value: function getText() {
      return this.text_;
    }

    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
  }, {
    key: "getTextAlign",
    value: function getTextAlign() {
      return this.textAlign_;
    }

    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
  }, {
    key: "getJustify",
    value: function getJustify() {
      return this.justify_;
    }

    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
  }, {
    key: "getTextBaseline",
    value: function getTextBaseline() {
      return this.textBaseline_;
    }

    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
  }, {
    key: "getBackgroundFill",
    value: function getBackgroundFill() {
      return this.backgroundFill_;
    }

    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
  }, {
    key: "getBackgroundStroke",
    value: function getBackgroundStroke() {
      return this.backgroundStroke_;
    }

    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
  }, {
    key: "getPadding",
    value: function getPadding() {
      return this.padding_;
    }

    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
  }, {
    key: "setOverflow",
    value: function setOverflow(overflow) {
      this.overflow_ = overflow;
    }

    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
  }, {
    key: "setFont",
    value: function setFont(font) {
      this.font_ = font;
    }

    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
  }, {
    key: "setMaxAngle",
    value: function setMaxAngle(maxAngle) {
      this.maxAngle_ = maxAngle;
    }

    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
  }, {
    key: "setOffsetX",
    value: function setOffsetX(offsetX) {
      this.offsetX_ = offsetX;
    }

    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
  }, {
    key: "setOffsetY",
    value: function setOffsetY(offsetY) {
      this.offsetY_ = offsetY;
    }

    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
  }, {
    key: "setPlacement",
    value: function setPlacement(placement) {
      this.placement_ = placement;
    }

    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
  }, {
    key: "setRepeat",
    value: function setRepeat(repeat) {
      this.repeat_ = repeat;
    }

    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
  }, {
    key: "setRotateWithView",
    value: function setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }

    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
    }

    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.rotation_ = rotation;
    }

    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
  }, {
    key: "setScale",
    value: function setScale(scale) {
      this.scale_ = scale;
      this.scaleArray_ = (0, _size.toSize)(scale !== undefined ? scale : 1);
    }

    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
    }

    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
  }, {
    key: "setText",
    value: function setText(text) {
      this.text_ = text;
    }

    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
  }, {
    key: "setTextAlign",
    value: function setTextAlign(textAlign) {
      this.textAlign_ = textAlign;
    }

    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
  }, {
    key: "setJustify",
    value: function setJustify(justify) {
      this.justify_ = justify;
    }

    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
  }, {
    key: "setTextBaseline",
    value: function setTextBaseline(textBaseline) {
      this.textBaseline_ = textBaseline;
    }

    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
  }, {
    key: "setBackgroundFill",
    value: function setBackgroundFill(fill) {
      this.backgroundFill_ = fill;
    }

    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
  }, {
    key: "setBackgroundStroke",
    value: function setBackgroundStroke(stroke) {
      this.backgroundStroke_ = stroke;
    }

    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
  }, {
    key: "setPadding",
    value: function setPadding(padding) {
      this.padding_ = padding;
    }
  }]);
  return Text;
}();
var _default = exports.default = Text;
},{"./Fill.js":"node_modules/ol/style/Fill.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/expr/expression.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringType = exports.Ops = exports.NumberType = exports.NumberArrayType = exports.NoneType = exports.LiteralExpression = exports.ColorType = exports.CallExpression = exports.BooleanType = exports.AnyType = void 0;
exports.includesType = includesType;
exports.isType = isType;
exports.newParsingContext = newParsingContext;
exports.overlapsType = overlapsType;
exports.parse = parse;
exports.typeName = typeName;
var _array = require("../array.js");
var _color = require("../color.js");
var _parsers;
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/expr/expression
 */
/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */

/**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expression.js").ExpressionValue} arguments.
 *
 * The following operators can be used:
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.
 *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`
 *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which
 *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'
 *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection
 *   * `['resolution']` returns the current resolution
 *   * `['time']` returns the time in seconds since the creation of the layer
 *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   * `['zoom']` returns the current zoom level
 *
 * * Math operators:
 *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2, ...]` adds the values
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4.
 *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is
 *     optional; if not specified, it will be set to 1.
 *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range).
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module:ol/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */

var numTypes = 0;
var NoneType = exports.NoneType = 0;
var BooleanType = exports.BooleanType = 1 << numTypes++;
var NumberType = exports.NumberType = 1 << numTypes++;
var StringType = exports.StringType = 1 << numTypes++;
var ColorType = exports.ColorType = 1 << numTypes++;
var NumberArrayType = exports.NumberArrayType = 1 << numTypes++;
var AnyType = exports.AnyType = Math.pow(2, numTypes) - 1;
var typeNames = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, BooleanType, 'boolean'), NumberType, 'number'), StringType, 'string'), ColorType, 'color'), NumberArrayType, 'number[]');
var namedTypes = Object.keys(typeNames).map(Number).sort(_array.ascending);

/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */
function typeName(type) {
  var names = [];
  var _iterator = _createForOfIteratorHelper(namedTypes),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var namedType = _step.value;
      if (includesType(type, namedType)) {
        names.push(typeNames[namedType]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (names.length === 0) {
    return 'untyped';
  }
  if (names.length < 3) {
    return names.join(' or ');
  }
  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}

/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */
function includesType(broad, specific) {
  return (broad & specific) === specific;
}

/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}

/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */
function isType(type, expected) {
  return type === expected;
}

/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */
var LiteralExpression = exports.LiteralExpression = /*#__PURE__*/_createClass(
/**
 * @param {number} type The value type.
 * @param {LiteralValue} value The literal value.
 */
function LiteralExpression(type, value) {
  _classCallCheck(this, LiteralExpression);
  this.type = type;
  this.value = value;
});
var CallExpression = exports.CallExpression = /*#__PURE__*/_createClass(
/**
 * @param {number} type The return type.
 * @param {string} operator The operator.
 * @param {...Expression} args The arguments.
 */
function CallExpression(type, operator) {
  _classCallCheck(this, CallExpression);
  this.type = type;
  this.operator = operator;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  this.args = args;
});
/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */
/**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 * @property {boolean} featureId The style uses the feature id.
 * @property {import("../style/flat.js").FlatStyle|import("../style/webgl.js").WebGLStyle} style The style being parsed
 */
/**
 * @return {ParsingContext} A new parsing context.
 */
function newParsingContext() {
  return {
    variables: new Set(),
    properties: new Set(),
    featureId: false,
    style: {}
  };
}

/**
 * @param {string} typeHint Type hint
 * @return {number} Resulting value type (will be a single type)
 */
function getTypeFromHint(typeHint) {
  switch (typeHint) {
    case 'string':
      return StringType;
    case 'color':
      return ColorType;
    case 'number':
      return NumberType;
    case 'boolean':
      return BooleanType;
    case 'number[]':
      return NumberArrayType;
    default:
      throw new Error("Unrecognized type hint: ".concat(typeHint));
  }
}

/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */

/**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression result.
 */
function parse(encoded, context, typeHint) {
  switch (_typeof(encoded)) {
    case 'boolean':
      {
        return new LiteralExpression(BooleanType, encoded);
      }
    case 'number':
      {
        return new LiteralExpression(NumberType, encoded);
      }
    case 'string':
      {
        var _type = StringType;
        if ((0, _color.isStringColor)(encoded)) {
          _type |= ColorType;
        }
        // apply the given type hint only if it won't result in an empty type
        if (!isType(_type & typeHint, NoneType)) {
          _type &= typeHint;
        }
        return new LiteralExpression(_type, encoded);
      }
    default:
      {
        // pass
      }
  }
  if (!Array.isArray(encoded)) {
    throw new Error('Expression must be an array or a primitive value');
  }
  if (encoded.length === 0) {
    throw new Error('Empty expression');
  }
  if (typeof encoded[0] === 'string') {
    return parseCallExpression(encoded, context, typeHint);
  }
  var _iterator2 = _createForOfIteratorHelper(encoded),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var item = _step2.value;
      if (typeof item !== 'number') {
        throw new Error('Expected an array of numbers');
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var type = NumberArrayType;
  if (encoded.length === 3 || encoded.length === 4) {
    type |= ColorType;
  }
  if (typeHint) {
    type &= typeHint;
  }
  return new LiteralExpression(type, encoded);
}

/**
 * @type {Object<string, string>}
 */
var Ops = exports.Ops = {
  Get: 'get',
  Var: 'var',
  Concat: 'concat',
  GeometryType: 'geometry-type',
  Any: 'any',
  All: 'all',
  Not: '!',
  Resolution: 'resolution',
  Zoom: 'zoom',
  Time: 'time',
  Equal: '==',
  NotEqual: '!=',
  GreaterThan: '>',
  GreaterThanOrEqualTo: '>=',
  LessThan: '<',
  LessThanOrEqualTo: '<=',
  Multiply: '*',
  Divide: '/',
  Add: '+',
  Subtract: '-',
  Clamp: 'clamp',
  Mod: '%',
  Pow: '^',
  Abs: 'abs',
  Floor: 'floor',
  Ceil: 'ceil',
  Round: 'round',
  Sin: 'sin',
  Cos: 'cos',
  Atan: 'atan',
  Sqrt: 'sqrt',
  Match: 'match',
  Between: 'between',
  Interpolate: 'interpolate',
  Case: 'case',
  In: 'in',
  Number: 'number',
  String: 'string',
  Array: 'array',
  Color: 'color',
  Id: 'id',
  Band: 'band',
  Palette: 'palette'
};

/**
 * @typedef {function(Array, ParsingContext, number):Expression} Parser
 * Third argument is a type hint
 */

/**
 * @type {Object<string, Parser>}
 */
var parsers = (_parsers = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Get, createParser(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
    _ = _ref2[0],
    typeHint = _ref2[1];
  if (typeHint !== undefined) {
    return getTypeFromHint( /** @type {string} */
    /** @type {LiteralExpression} */typeHint.value);
  }
  return AnyType;
}, withArgsCount(1, 2), withGetArgs)), Ops.Var, createParser(function (_ref3) {
  var _ref4 = _slicedToArray(_ref3, 1),
    firstArg = _ref4[0];
  return firstArg.type;
}, withArgsCount(1, 1), withVarArgs)), Ops.Id, createParser(NumberType | StringType, withNoArgs, usesFeatureId)), Ops.Concat, createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType))), Ops.GeometryType, createParser(StringType, withNoArgs)), Ops.Resolution, createParser(NumberType, withNoArgs)), Ops.Zoom, createParser(NumberType, withNoArgs)), Ops.Time, createParser(NumberType, withNoArgs)), Ops.Any, createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType))), Ops.All, createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Not, createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType))), Ops.Equal, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.NotEqual, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.GreaterThan, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.GreaterThanOrEqualTo, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.LessThan, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.LessThanOrEqualTo, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.Multiply, createParser(function (parsedArgs) {
  var outputType = NumberType | ColorType;
  for (var i = 0; i < parsedArgs.length; i++) {
    outputType &= parsedArgs[i].type;
  }
  return outputType;
}, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType)), Ops.Divide, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Add, createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Subtract, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Clamp, createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType))), Ops.Mod, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Pow, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Abs, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Floor, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Ceil, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Round, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Sin, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Cos, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Atan, createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType))), Ops.Sqrt, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Match, createParser(function (parsedArgs) {
  var type = AnyType;
  for (var i = 2; i < parsedArgs.length; i += 2) {
    type &= parsedArgs[i].type;
  }
  type &= parsedArgs[parsedArgs.length - 1].type;
  return type;
}, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs)), Ops.Between, createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType))), Ops.Interpolate, createParser(function (parsedArgs) {
  var type = ColorType | NumberType;
  for (var i = 3; i < parsedArgs.length; i += 2) {
    type &= parsedArgs[i].type;
  }
  return type;
}, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs)), Ops.Case, createParser(function (parsedArgs) {
  var type = AnyType;
  for (var i = 1; i < parsedArgs.length; i += 2) {
    type &= parsedArgs[i].type;
  }
  type &= parsedArgs[parsedArgs.length - 1].type;
  return type;
}, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs)), Ops.In, createParser(BooleanType, withArgsCount(2, 2), parseInArgs)), Ops.Number, createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType))), Ops.String, createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType))), Ops.Array, createParser(function (parsedArgs) {
  return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
}, withArgsCount(1, Infinity), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Color, createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType))), Ops.Band, createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType))), Ops.Palette, createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)));

/**
 * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator
 * An argument validator applies various checks to an encoded expression arguments
 * Returns the parsed arguments if any.
 * Third argument is the array of parsed arguments from previous validators
 * Fourth argument is an optional type hint
 */

/**
 * @type ArgValidator
 */
function withGetArgs(encoded, context) {
  var arg = parse(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error('Expected a literal argument for get operation');
  }
  if (typeof arg.value !== 'string') {
    throw new Error('Expected a string argument for get operation');
  }
  context.properties.add(arg.value);
  if (encoded.length === 3) {
    var hint = parse(encoded[2], context);
    return [arg, hint];
  }
  return [arg];
}

/**
 * @type ArgValidator
 */
function withVarArgs(encoded, context, parsedArgs, typeHint) {
  var varName = encoded[1];
  if (typeof varName !== 'string') {
    throw new Error('Expected a string argument for var operation');
  }
  context.variables.add(varName);
  if (!('variables' in context.style) || context.style.variables[varName] === undefined) {
    return [new LiteralExpression(AnyType, varName)];
  }
  var initialValue = context.style.variables[varName];
  var arg = /** @type {LiteralExpression} */parse(initialValue, context);
  arg.value = varName;
  if (typeHint && !overlapsType(typeHint, arg.type)) {
    throw new Error("The variable ".concat(varName, " has type ").concat(typeName(arg.type), " but the following type was expected: ").concat(typeName(typeHint)));
  }
  return [arg];
}

/**
 * @type ArgValidator
 */
function usesFeatureId(encoded, context) {
  context.featureId = true;
}

/**
 * @type ArgValidator
 */
function withNoArgs(encoded, context) {
  var operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error("Expected no arguments for ".concat(operation, " operation"));
  }
  return [];
}

/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @return {ArgValidator} The argument validator
 */
function withArgsCount(minArgs, maxArgs) {
  return function (encoded, context) {
    var operation = encoded[0];
    var argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        var plural = minArgs === 1 ? '' : 's';
        throw new Error("Expected ".concat(minArgs, " argument").concat(plural, " for ").concat(operation, ", got ").concat(argCount));
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      var range = maxArgs === Infinity ? "".concat(minArgs, " or more") : "".concat(minArgs, " to ").concat(maxArgs);
      throw new Error("Expected ".concat(range, " arguments for ").concat(operation, ", got ").concat(argCount));
    }
  };
}

/**
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */
function parseArgsOfType(argType) {
  return function (encoded, context) {
    var operation = encoded[0];
    var argCount = encoded.length - 1;
    /**
     * @type {Array<Expression>}
     */
    var args = new Array(argCount);
    for (var i = 0; i < argCount; ++i) {
      var expression = parse(encoded[i + 1], context);
      if (!overlapsType(argType, expression.type)) {
        var gotType = typeName(argType);
        var expectedType = typeName(expression.type);
        throw new Error("Unexpected type for argument ".concat(i, " of ").concat(operation, " operation") + ", got ".concat(gotType, " but expected ").concat(expectedType));
      }
      expression.type &= argType;
      args[i] = expression;
    }
    return args;
  };
}

/**
 * @type {ArgValidator}
 */
function narrowArgsType(encoded, context, parsedArgs) {
  var operation = encoded[0];
  var argCount = encoded.length - 1;

  // first pass to determine a narrowed down type
  var sameType = AnyType;
  for (var i = 0; i < parsedArgs.length; ++i) {
    sameType &= parsedArgs[i].type;
  }
  if (sameType === NoneType) {
    throw new Error("No common type could be found for arguments of ".concat(operation, " operation"));
  }

  // re-parse args
  var args = new Array(argCount);
  for (var _i = 0; _i < argCount; ++_i) {
    args[_i] = parse(encoded[_i + 1], context, sameType);
  }
  return args;
}

/**
 * @type {ArgValidator}
 */
function withOddArgs(encoded, context) {
  var operation = encoded[0];
  var argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error("An odd amount of arguments was expected for operation ".concat(operation, ", got ").concat(JSON.stringify(argCount), " instead"));
  }
}

/**
 * @type {ArgValidator}
 */
function withEvenArgs(encoded, context) {
  var operation = encoded[0];
  var argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error("An even amount of arguments was expected for operation ".concat(operation, ", got ").concat(JSON.stringify(argCount), " instead"));
  }
}

/**
 * @type ArgValidator
 */
function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
  var argsCount = encoded.length - 1;
  var input = parse(encoded[1], context);
  var inputType = input.type;
  var fallback = parse(encoded[encoded.length - 1], context);
  var outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;

  // first parse args to figure out possible types
  var args = new Array(argsCount - 2);
  for (var i = 0; i < argsCount - 2; i += 2) {
    var match = parse(encoded[i + 2], context);
    var output = parse(encoded[i + 3], context);
    inputType &= match.type;
    outputType &= output.type;
    args[i] = match;
    args[i + 1] = output;
  }

  // check input and output types validity
  var expectedInputType = StringType | NumberType | BooleanType;
  if (!overlapsType(expectedInputType, inputType)) {
    throw new Error("Expected an input of type ".concat(typeName(expectedInputType), " for the interpolate operation") + ", got ".concat(typeName(inputType), " instead"));
  }
  if (isType(outputType, NoneType)) {
    throw new Error("Could not find a common output type for the following match operation: " + JSON.stringify(encoded));
  }

  // parse again inputs and outputs with common type
  for (var _i2 = 0; _i2 < argsCount - 2; _i2 += 2) {
    var _match = parse(encoded[_i2 + 2], context, inputType);
    var _output = parse(encoded[_i2 + 3], context, outputType);
    args[_i2] = _match;
    args[_i2 + 1] = _output;
  }
  return [parse(encoded[1], context, inputType)].concat(args, [parse(encoded[encoded.length - 1], context, outputType)]);
}

/**
 * @type ArgValidator
 */
function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
  var interpolationType = encoded[1];
  var interpolation;
  switch (interpolationType[0]) {
    case 'linear':
      interpolation = 1;
      break;
    case 'exponential':
      interpolation = interpolationType[1];
      if (typeof interpolation !== 'number') {
        throw new Error("Expected a number base for exponential interpolation" + ", got ".concat(JSON.stringify(interpolation), " instead"));
      }
      break;
    default:
      interpolation = null;
  }
  if (!interpolation) {
    throw new Error("Invalid interpolation type: ".concat(JSON.stringify(interpolationType)));
  }
  interpolation = parse(interpolation, context);

  // check input types
  var input = parse(encoded[2], context);
  if (!overlapsType(NumberType, input.type)) {
    throw new Error("Expected an input of type number for the interpolate operation" + ", got ".concat(typeName(input.type), " instead"));
  }
  input = parse(encoded[2], context, NumberType); // parse again with narrower output

  var args = new Array(encoded.length - 3);
  for (var i = 0; i < args.length; i += 2) {
    var stop = parse(encoded[i + 3], context);
    if (!overlapsType(NumberType, stop.type)) {
      throw new Error("Expected all stop input values in the interpolate operation to be of type number" + ", got ".concat(typeName(stop.type), " at position ").concat(i + 2, " instead"));
    }
    var output = parse(encoded[i + 4], context);
    if (!overlapsType(NumberType | ColorType, output.type)) {
      throw new Error("Expected all stop output values in the interpolate operation to be a number or color" + ", got ".concat(typeName(output.type), " at position ").concat(i + 3, " instead"));
    }
    // parse again with narrower types
    stop = parse(encoded[i + 3], context, NumberType);
    output = parse(encoded[i + 4], context, NumberType | ColorType);
    args[i] = stop;
    args[i + 1] = output;
  }
  return [interpolation, input].concat(args);
}

/**
 * @type ArgValidator
 */
function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
  var fallback = parse(encoded[encoded.length - 1], context);
  var outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;

  // first parse args to figure out possible types
  var args = new Array(encoded.length - 1);
  for (var i = 0; i < args.length - 1; i += 2) {
    var condition = parse(encoded[i + 1], context);
    var output = parse(encoded[i + 2], context);
    if (!overlapsType(BooleanType, condition.type)) {
      throw new Error("Expected all conditions in the case operation to be of type boolean" + ", got ".concat(typeName(condition.type), " at position ").concat(i, " instead"));
    }
    outputType &= output.type;
    args[i] = condition;
    args[i + 1] = output;
  }
  if (isType(outputType, NoneType)) {
    throw new Error("Could not find a common output type for the following case operation: " + JSON.stringify(encoded));
  }

  // parse again args with common output type
  for (var _i3 = 0; _i3 < args.length - 1; _i3 += 2) {
    args[_i3 + 1] = parse(encoded[_i3 + 2], context, outputType);
  }
  args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);
  return args;
}

/**
 * @type ArgValidator
 */
function parseInArgs(encoded, context) {
  /** @type {Array<number|string>} */
  var haystack = /** @type {any} */encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error("The \"in\" operator was provided a literal value which was not an array as second argument.");
  }
  if (typeof haystack[0] === 'string') {
    if (haystack[0] !== 'literal') {
      throw new Error("For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.");
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error("The \"in\" operator was provided a literal value which was not an array as second argument.");
    }
    haystack = haystack[1];
  }
  var needleType = StringType | NumberType;
  var args = new Array(haystack.length);
  for (var i = 0; i < args.length; i++) {
    var arg = parse(haystack[i], context);
    needleType &= arg.type;
    args[i] = arg;
  }
  if (isType(needleType, NoneType)) {
    throw new Error("Could not find a common type for the following in operation: " + JSON.stringify(encoded));
  }
  var needle = parse(encoded[1], context, needleType);
  return [needle].concat(args);
}

/**
 * @type ArgValidator
 */
function parsePaletteArgs(encoded, context) {
  var index = parse(encoded[1], context, NumberType);
  if (index.type !== NumberType) {
    throw new Error("The first argument of palette must be an number, got ".concat(typeName(index.type), " instead"));
  }
  var colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error('The second argument of palette must be an array');
  }
  var parsedColors = new Array(colors.length);
  for (var i = 0; i < parsedColors.length; i++) {
    var color = parse(colors[i], context, ColorType);
    if (!(color instanceof LiteralExpression)) {
      throw new Error("The palette color at index ".concat(i, " must be a literal value"));
    }
    if (!overlapsType(color.type, ColorType)) {
      throw new Error("The palette color at index ".concat(i, " should be of type color, got ").concat(typeName(color.type), " instead"));
    }
    parsedColors[i] = color;
  }
  return [index].concat(parsedColors);
}

/**
 * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed
 * arguments
 * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator
 * will be used as parsed arguments
 * @return {Parser} The parser.
 */
function createParser(returnType) {
  for (var _len2 = arguments.length, argValidators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    argValidators[_key2 - 1] = arguments[_key2];
  }
  return function (encoded, context, typeHint) {
    var operator = encoded[0];
    var parsedArgs = [];
    for (var i = 0; i < argValidators.length; i++) {
      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
    }
    var actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;
    if (typeHint !== undefined) {
      if (!overlapsType(actualType, typeHint)) {
        throw new Error("The following expression was expected to return ".concat(typeName(typeHint), ", but returns ").concat(typeName(actualType), " instead: ").concat(JSON.stringify(encoded)));
      }
      actualType &= typeHint;
    }
    if (actualType === NoneType) {
      throw new Error("No matching type was found for the following expression: ".concat(JSON.stringify(encoded)));
    }
    return _construct(CallExpression, [actualType, operator].concat(_toConsumableArray(parsedArgs)));
  };
}

/**
 * @param {Array} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression.
 */
function parseCallExpression(encoded, context, typeHint) {
  var operator = encoded[0];
  var parser = parsers[operator];
  if (!parser) {
    throw new Error("Unknown operator: ".concat(operator));
  }
  return parser(encoded, context, typeHint);
}
},{"../array.js":"node_modules/ol/array.js","../color.js":"node_modules/ol/color.js"}],"node_modules/ol/expr/cpu.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildExpression = buildExpression;
exports.newEvaluationContext = newEvaluationContext;
var _expression = require("./expression.js");
var _color = require("../color.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * @module ol/expr/cpu
 */
/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 * @property {string|number|null} featureId The feature id.
 */

/**
 * @return {EvaluationContext} A new evaluation context.
 */
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null
  };
}

/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */

/**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */

/**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */

/**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */

/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */
function buildExpression(encoded, type, context) {
  var expression = (0, _expression.parse)(encoded, context);
  if (!(0, _expression.overlapsType)(type, expression.type)) {
    var expected = (0, _expression.typeName)(type);
    var actual = (0, _expression.typeName)(expression.type);
    throw new Error("Expected expression to be of type ".concat(expected, ", got ").concat(actual));
  }
  return compileExpression(expression, context);
}

/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileExpression(expression, context) {
  if (expression instanceof _expression.LiteralExpression) {
    // convert colors to array if possible
    if (expression.type === _expression.ColorType && typeof expression.value === 'string') {
      var colorValue = (0, _color.fromString)(expression.value);
      return function () {
        return colorValue;
      };
    }
    return function () {
      return expression.value;
    };
  }
  var operator = expression.operator;
  switch (operator) {
    case _expression.Ops.Number:
    case _expression.Ops.String:
      {
        return compileAssertionExpression(expression, context);
      }
    case _expression.Ops.Get:
    case _expression.Ops.Var:
      {
        return compileAccessorExpression(expression, context);
      }
    case _expression.Ops.Id:
      {
        return function (expression) {
          return expression.featureId;
        };
      }
    case _expression.Ops.Concat:
      {
        var args = expression.args.map(function (e) {
          return compileExpression(e, context);
        });
        return function (context) {
          var _ref;
          return (_ref = '').concat.apply(_ref, _toConsumableArray(args.map(function (arg) {
            return arg(context).toString();
          })));
        };
      }
    case _expression.Ops.Resolution:
      {
        return function (context) {
          return context.resolution;
        };
      }
    case _expression.Ops.Any:
    case _expression.Ops.All:
    case _expression.Ops.Not:
      {
        return compileLogicalExpression(expression, context);
      }
    case _expression.Ops.Equal:
    case _expression.Ops.NotEqual:
    case _expression.Ops.LessThan:
    case _expression.Ops.LessThanOrEqualTo:
    case _expression.Ops.GreaterThan:
    case _expression.Ops.GreaterThanOrEqualTo:
      {
        return compileComparisonExpression(expression, context);
      }
    case _expression.Ops.Multiply:
    case _expression.Ops.Divide:
    case _expression.Ops.Add:
    case _expression.Ops.Subtract:
    case _expression.Ops.Clamp:
    case _expression.Ops.Mod:
    case _expression.Ops.Pow:
    case _expression.Ops.Abs:
    case _expression.Ops.Floor:
    case _expression.Ops.Ceil:
    case _expression.Ops.Round:
    case _expression.Ops.Sin:
    case _expression.Ops.Cos:
    case _expression.Ops.Atan:
    case _expression.Ops.Sqrt:
      {
        return compileNumericExpression(expression, context);
      }
    case _expression.Ops.Match:
      {
        return compileMatchExpression(expression, context);
      }
    case _expression.Ops.Interpolate:
      {
        return compileInterpolateExpression(expression, context);
      }
    default:
      {
        throw new Error("Unsupported operator ".concat(operator));
      }
    // TODO: unimplemented
    // Ops.GeometryType
    // Ops.Zoom
    // Ops.Time
    // Ops.Between
    // Ops.Case
    // Ops.In
    // Ops.Array
    // Ops.Color
    // Ops.Band
    // Ops.Palette
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAssertionExpression(expression, context) {
  var type = expression.operator;
  var length = expression.args.length;
  var args = new Array(length);
  for (var i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case _expression.Ops.Number:
    case _expression.Ops.String:
      {
        return function (context) {
          for (var _i = 0; _i < length; ++_i) {
            var value = args[_i](context);
            if (_typeof(value) === type) {
              return value;
            }
          }
          throw new Error("Expected one of the values to be a ".concat(type));
        };
      }
    default:
      {
        throw new Error("Unsupported assertion operator ".concat(type));
      }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAccessorExpression(expression, context) {
  var nameExpression = /** @type {LiteralExpression} */expression.args[0];
  var name = /** @type {string} */nameExpression.value;
  switch (expression.operator) {
    case _expression.Ops.Get:
      {
        return function (context) {
          return context.properties[name];
        };
      }
    case _expression.Ops.Var:
      {
        return function (context) {
          return context.variables[name];
        };
      }
    default:
      {
        throw new Error("Unsupported accessor operator ".concat(expression.operator));
      }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileComparisonExpression(expression, context) {
  var op = expression.operator;
  var left = compileExpression(expression.args[0], context);
  var right = compileExpression(expression.args[1], context);
  switch (op) {
    case _expression.Ops.Equal:
      {
        return function (context) {
          return left(context) === right(context);
        };
      }
    case _expression.Ops.NotEqual:
      {
        return function (context) {
          return left(context) !== right(context);
        };
      }
    case _expression.Ops.LessThan:
      {
        return function (context) {
          return left(context) < right(context);
        };
      }
    case _expression.Ops.LessThanOrEqualTo:
      {
        return function (context) {
          return left(context) <= right(context);
        };
      }
    case _expression.Ops.GreaterThan:
      {
        return function (context) {
          return left(context) > right(context);
        };
      }
    case _expression.Ops.GreaterThanOrEqualTo:
      {
        return function (context) {
          return left(context) >= right(context);
        };
      }
    default:
      {
        throw new Error("Unsupported comparison operator ".concat(op));
      }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileLogicalExpression(expression, context) {
  var op = expression.operator;
  var length = expression.args.length;
  var args = new Array(length);
  for (var i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression.Ops.Any:
      {
        return function (context) {
          for (var _i2 = 0; _i2 < length; ++_i2) {
            if (args[_i2](context)) {
              return true;
            }
          }
          return false;
        };
      }
    case _expression.Ops.All:
      {
        return function (context) {
          for (var _i3 = 0; _i3 < length; ++_i3) {
            if (!args[_i3](context)) {
              return false;
            }
          }
          return true;
        };
      }
    case _expression.Ops.Not:
      {
        return function (context) {
          return !args[0](context);
        };
      }
    default:
      {
        throw new Error("Unsupported logical operator ".concat(op));
      }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */
function compileNumericExpression(expression, context) {
  var op = expression.operator;
  var length = expression.args.length;
  var args = new Array(length);
  for (var i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression.Ops.Multiply:
      {
        return function (context) {
          var value = 1;
          for (var _i4 = 0; _i4 < length; ++_i4) {
            value *= args[_i4](context);
          }
          return value;
        };
      }
    case _expression.Ops.Divide:
      {
        return function (context) {
          return args[0](context) / args[1](context);
        };
      }
    case _expression.Ops.Add:
      {
        return function (context) {
          var value = 0;
          for (var _i5 = 0; _i5 < length; ++_i5) {
            value += args[_i5](context);
          }
          return value;
        };
      }
    case _expression.Ops.Subtract:
      {
        return function (context) {
          return args[0](context) - args[1](context);
        };
      }
    case _expression.Ops.Clamp:
      {
        return function (context) {
          var value = args[0](context);
          var min = args[1](context);
          if (value < min) {
            return min;
          }
          var max = args[2](context);
          if (value > max) {
            return max;
          }
          return value;
        };
      }
    case _expression.Ops.Mod:
      {
        return function (context) {
          return args[0](context) % args[1](context);
        };
      }
    case _expression.Ops.Pow:
      {
        return function (context) {
          return Math.pow(args[0](context), args[1](context));
        };
      }
    case _expression.Ops.Abs:
      {
        return function (context) {
          return Math.abs(args[0](context));
        };
      }
    case _expression.Ops.Floor:
      {
        return function (context) {
          return Math.floor(args[0](context));
        };
      }
    case _expression.Ops.Ceil:
      {
        return function (context) {
          return Math.ceil(args[0](context));
        };
      }
    case _expression.Ops.Round:
      {
        return function (context) {
          return Math.round(args[0](context));
        };
      }
    case _expression.Ops.Sin:
      {
        return function (context) {
          return Math.sin(args[0](context));
        };
      }
    case _expression.Ops.Cos:
      {
        return function (context) {
          return Math.cos(args[0](context));
        };
      }
    case _expression.Ops.Atan:
      {
        if (length === 2) {
          return function (context) {
            return Math.atan2(args[0](context), args[1](context));
          };
        }
        return function (context) {
          return Math.atan(args[0](context));
        };
      }
    case _expression.Ops.Sqrt:
      {
        return function (context) {
          return Math.sqrt(args[0](context));
        };
      }
    default:
      {
        throw new Error("Unsupported numeric operator ".concat(op));
      }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileMatchExpression(expression, context) {
  var length = expression.args.length;
  var args = new Array(length);
  for (var i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return function (context) {
    var value = args[0](context);
    for (var _i6 = 1; _i6 < length; _i6 += 2) {
      if (value === args[_i6](context)) {
        return args[_i6 + 1](context);
      }
    }
    return args[length - 1](context);
  };
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileInterpolateExpression(expression, context) {
  var length = expression.args.length;
  var args = new Array(length);
  for (var i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return function (context) {
    var base = args[0](context);
    var value = args[1](context);
    var previousInput;
    var previousOutput;
    for (var _i7 = 2; _i7 < length; _i7 += 2) {
      var input = args[_i7](context);
      var output = args[_i7 + 1](context);
      var isColor = Array.isArray(output);
      if (isColor) {
        output = (0, _color.withAlpha)(output);
      }
      if (input >= value) {
        if (_i7 === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(base, value, previousInput, previousOutput, input, output);
        }
        return interpolateNumber(base, value, previousInput, previousOutput, input, output);
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}

/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {number} output1 The first output value.
 * @param {number} input2 The second input value.
 * @param {number} output2 The second output value.
 * @return {number} The interpolated value.
 */
function interpolateNumber(base, value, input1, output1, input2, output2) {
  var delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  var along = value - input1;
  var factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}

/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {import('../color.js').Color} rgba1 The first output value.
 * @param {number} input2 The second input value.
 * @param {import('../color.js').Color} rgba2 The second output value.
 * @return {import('../color.js').Color} The interpolated color.
 */
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  var delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  var lcha1 = (0, _color.rgbaToLcha)(rgba1);
  var lcha2 = (0, _color.rgbaToLcha)(rgba2);
  var deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  var lcha = [interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]), interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]), lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue), interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])];
  return (0, _color.normalize)((0, _color.lchaToRgba)(lcha));
}
},{"./expression.js":"node_modules/ol/expr/expression.js","../color.js":"node_modules/ol/color.js"}],"node_modules/ol/render/canvas/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildRuleSet = buildRuleSet;
exports.buildStyle = buildStyle;
exports.flatStylesToStyleFunction = flatStylesToStyleFunction;
exports.rulesToStyleFunction = rulesToStyleFunction;
var _Circle = _interopRequireDefault(require("../../style/Circle.js"));
var _Fill = _interopRequireDefault(require("../../style/Fill.js"));
var _Icon = _interopRequireDefault(require("../../style/Icon.js"));
var _RegularShape = _interopRequireDefault(require("../../style/RegularShape.js"));
var _Stroke = _interopRequireDefault(require("../../style/Stroke.js"));
var _Style = _interopRequireDefault(require("../../style/Style.js"));
var _Text = _interopRequireDefault(require("../../style/Text.js"));
var _expression = require("../../expr/expression.js");
var _cpu = require("../../expr/cpu.js");
var _obj = require("../../obj.js");
var _size = require("../../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * @module ol/render/canvas/style
 */
/**
 * @fileoverview This module includes functions to build styles for the canvas renderer.  Building
 * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression
 * and returns an instance of one of the expression classes.  The compiling step takes the
 * expression instance and returns a function that can be evaluated to return a literal value.  The
 * evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {import("../../style/flat.js").FlatStyle} FlatStyle
 */

/**
 * @typedef {import("../../expr/expression.js").EncodedExpression} EncodedExpression
 */

/**
 * @typedef {import("../../expr/expression.js").ParsingContext} ParsingContext
 */

/**
 * @typedef {import("../../expr/expression.js").CallExpression} CallExpression
 */

/**
 * @typedef {import("../../expr/cpu.js").EvaluationContext} EvaluationContext
 */

/**
 * @typedef {import("../../expr/cpu.js").ExpressionEvaluator} ExpressionEvaluator
 */

/**
 * @param {EvaluationContext} context The evaluation context.
 * @return {boolean} Always true.
 */
function always(context) {
  return true;
}

/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function rulesToStyleFunction(rules) {
  var parsingContext = (0, _expression.newParsingContext)();
  var evaluator = buildRuleSet(rules, parsingContext);
  var evaluationContext = (0, _cpu.newEvaluationContext)();
  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      var id = feature.getId();
      if (id !== undefined) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    return evaluator(evaluationContext);
  };
}

/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function flatStylesToStyleFunction(flatStyles) {
  var parsingContext = (0, _expression.newParsingContext)();
  var length = flatStyles.length;

  /**
   * @type {Array<StyleEvaluator>}
   */
  var evaluators = new Array(length);
  for (var i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  var evaluationContext = (0, _cpu.newEvaluationContext)();

  /**
   * @type {Array<Style>}
   */
  var styles = new Array(length);
  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      var id = feature.getId();
      if (id !== undefined) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    var nonNullCount = 0;
    for (var _i = 0; _i < length; ++_i) {
      var style = evaluators[_i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */

/**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */

/**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */
function buildRuleSet(rules, context) {
  var length = rules.length;

  /**
   * @type {Array<CompiledRule>}
   */
  var compiledRules = new Array(length);
  for (var i = 0; i < length; ++i) {
    var rule = rules[i];
    var filter = 'filter' in rule ? (0, _cpu.buildExpression)(rule.filter, _expression.BooleanType, context) : always;

    /**
     * @type {Array<StyleEvaluator>}
     */
    var styles = void 0;
    if (Array.isArray(rule.style)) {
      var styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (var j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = {
      filter: filter,
      styles: styles
    };
  }
  return function (context) {
    /**
     * @type {Array<Style>}
     */
    var styles = [];
    var someMatched = false;
    for (var _i2 = 0; _i2 < length; ++_i2) {
      var filterEvaluator = compiledRules[_i2].filter;
      if (!filterEvaluator(context)) {
        continue;
      }
      if (rules[_i2].else && someMatched) {
        continue;
      }
      someMatched = true;
      var _iterator = _createForOfIteratorHelper(compiledRules[_i2].styles),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var styleEvaluator = _step.value;
          var style = styleEvaluator(context);
          if (!style) {
            continue;
          }
          styles.push(style);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Style|null} StyleEvaluator
 */

/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */
function buildStyle(flatStyle, context) {
  var evaluateFill = buildFill(flatStyle, '', context);
  var evaluateStroke = buildStroke(flatStyle, '', context);
  var evaluateText = buildText(flatStyle, context);
  var evaluateImage = buildImage(flatStyle, context);
  var evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !(0, _obj.isEmpty)(flatStyle)) {
    // assume this is a user error
    // would be nice to check the properties and suggest "did you mean..."
    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));
  }
  var style = new _Style.default();
  return function (context) {
    var empty = true;
    if (evaluateFill) {
      var fill = evaluateFill(context);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      var stroke = evaluateStroke(context);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      var text = evaluateText(context);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      var image = evaluateImage(context);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}

/**
 * @typedef {function(EvaluationContext):Fill|null} FillEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {FillEvaluator?} A function that evaluates to a fill.
 */
function buildFill(flatStyle, prefix, context) {
  var evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);
  if (!evaluateColor) {
    return null;
  }
  var fill = new _Fill.default();
  return function (context) {
    var color = evaluateColor(context);
    if (color === 'none') {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}

/**
 * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {StrokeEvaluator?} A function the evaluates to a stroke.
 */
function buildStroke(flatStyle, prefix, context) {
  var evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);
  var evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  var evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);
  var evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);
  var evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);
  var evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);
  var evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);
  var stroke = new _Stroke.default();
  return function (context) {
    if (evaluateColor) {
      var color = evaluateColor(context);
      if (color === 'none') {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context));
    }
    if (evaluateLineCap) {
      var lineCap = evaluateLineCap(context);
      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {
        throw new Error('Expected butt, round, or square line cap');
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      var lineJoin = evaluateLineJoin(context);
      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {
        throw new Error('Expected bevel, round, or miter line join');
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context));
    }
    return stroke;
  };
}

/**
 * @typedef {function(EvaluationContext):Text} TextEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {TextEvaluator?} A function that evaluates to a text symbolizer.
 */
function buildText(flatStyle, context) {
  var prefix = 'text-';

  // Currently, an Array<string> may be used for rich text support.  This doesn't
  // work with our expression syntax where arrays of strings are interpreted as
  // call expressions.  To support rich text, we could add a 'strings' operator
  // where all the following arguments would be string values.
  var evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);
  if (!evaluateValue) {
    return null;
  }
  var evaluateFill = buildFill(flatStyle, prefix, context);
  var evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);
  var evaluateStroke = buildStroke(flatStyle, prefix, context);
  var evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);
  var evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);
  var evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);
  var evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);
  var evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);
  var evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);
  var evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);
  var evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);
  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
  var evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);
  var evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);
  var evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);
  var evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);
  var text = new _Text.default({});
  return function (context) {
    text.setText(evaluateValue(context));
    if (evaluateFill) {
      text.setFill(evaluateFill(context));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context));
    }
    if (evaluatePlacement) {
      var placement = evaluatePlacement(context);
      if (placement !== 'point' && placement !== 'line') {
        throw new Error('Expected point or line for text-placement');
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context));
    }
    if (evaluateAlign) {
      var textAlign = evaluateAlign(context);
      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {
        throw new Error('Expected left, right, center, start, or end for text-align');
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      var justify = evaluateJustify(context);
      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {
        throw new Error('Expected left, right, or center for text-justify');
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      var textBaseline = evaluateBaseline(context);
      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {
        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context));
    }
    return text;
  };
}

/**
 * @typedef {function(EvaluationContext):import("../../style/Image.js").default} ImageEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.
 */
function buildImage(flatStyle, context) {
  if ('icon-src' in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ('shape-points' in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ('circle-radius' in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an image symbolizer.
 */
function buildIcon(flatStyle, context) {
  var prefix = 'icon-';

  // required property
  var srcName = prefix + 'src';
  var src = requireString(flatStyle[srcName], srcName);

  // settable properties
  var evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);
  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  var evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);
  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);

  // the remaining symbolizer properties are not currently settable
  var anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');
  var anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');
  var anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');
  var color = optionalColorLike(flatStyle, prefix + 'color');
  var crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');
  var offset = optionalNumberArray(flatStyle, prefix + 'offset');
  var offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');
  var width = optionalNumber(flatStyle, prefix + 'width');
  var height = optionalNumber(flatStyle, prefix + 'height');
  var size = optionalSize(flatStyle, prefix + 'size');
  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');
  var icon = new _Icon.default({
    src: src,
    anchorOrigin: anchorOrigin,
    anchorXUnits: anchorXUnits,
    anchorYUnits: anchorYUnits,
    color: color,
    crossOrigin: crossOrigin,
    offset: offset,
    offsetOrigin: offsetOrigin,
    height: height,
    width: width,
    size: size,
    declutterMode: declutterMode
  });
  return function (context) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context));
    }
    return icon;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.
 */
function buildShape(flatStyle, context) {
  var prefix = 'shape-';

  // required property
  var pointsName = prefix + 'points';
  var points = requireNumber(flatStyle[pointsName], pointsName);

  // settable properties
  var evaluateFill = buildFill(flatStyle, prefix, context);
  var evaluateStroke = buildStroke(flatStyle, prefix, context);
  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);

  // the remaining properties are not currently settable
  var radius = optionalNumber(flatStyle, prefix + 'radius');
  var radius1 = optionalNumber(flatStyle, prefix + 'radius1');
  var radius2 = optionalNumber(flatStyle, prefix + 'radius2');
  var angle = optionalNumber(flatStyle, prefix + 'angle');
  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
  var shape = new _RegularShape.default({
    points: points,
    radius: radius,
    radius1: radius1,
    radius2: radius2,
    angle: angle,
    declutterMode: declutterMode
  });
  return function (context) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context));
    }
    return shape;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.
 */
function buildCircle(flatStyle, context) {
  var prefix = 'circle-';

  // settable properties
  var evaluateFill = buildFill(flatStyle, prefix, context);
  var evaluateStroke = buildStroke(flatStyle, prefix, context);
  var evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);
  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);

  // the remaining properties are not currently settable
  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
  var circle = new _Circle.default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: declutterMode
  });
  return function (context) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context));
    }
    return circle;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.
 */
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return undefined;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.NumberType, context);
  return function (context) {
    return requireNumber(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.
 */
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.StringType, context);
  return function (context) {
    return requireString(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.
 */
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.BooleanType, context);
  return function (context) {
    var value = evaluator(context);
    if (typeof value !== 'boolean') {
      throw new Error("Expected a boolean for ".concat(name));
    }
    return value;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.
 */
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.ColorType | _expression.StringType, context);
  return function (context) {
    return requireColorLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.
 */
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.NumberArrayType, context);
  return function (context) {
    return requireNumberArray(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.
 */
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.NumberArrayType, context);
  return function (context) {
    var array = requireNumberArray(evaluator(context), name);
    if (array.length !== 2) {
      throw new Error("Expected two numbers for ".concat(name));
    }
    return array;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.
 */
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  var evaluator = (0, _cpu.buildExpression)(flatStyle[name], _expression.NumberArrayType | _expression.NumberType, context);
  return function (context) {
    return requireSizeLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {number|undefined} A number or undefined.
 */
function optionalNumber(flatStyle, property) {
  var value = flatStyle[property];
  if (value === undefined) {
    return undefined;
  }
  if (typeof value !== 'number') {
    throw new Error("Expected a number for ".concat(property));
  }
  return value;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../size.js").Size|undefined} A size or undefined.
 */
function optionalSize(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded === 'number') {
    return (0, _size.toSize)(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error("Expected a number or size array for ".concat(property));
  }
  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {
    throw new Error("Expected a number or size array for ".concat(property));
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|undefined} A string or undefined.
 */
function optionalString(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error("Expected a string for ".concat(property));
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconOrigin|undefined} An icon origin or undefined.
 */
function optionalIconOrigin(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {
    throw new Error("Expected bottom-left, bottom-right, top-left, or top-right for ".concat(property));
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconAnchorUnits|undefined} Icon anchor units or undefined.
 */
function optionalIconAnchorUnits(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (encoded !== 'pixels' && encoded !== 'fraction') {
    throw new Error("Expected pixels or fraction for ".concat(property));
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {Array<number>|undefined} An array of numbers or undefined.
 */
function optionalNumberArray(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireNumberArray(encoded, property);
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {"declutter"|"obstacle"|"none"|undefined} Icon declutter mode.
 */
function optionalDeclutterMode(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error("Expected a string for ".concat(property));
  }
  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {
    throw new Error("Expected declutter, obstacle, or none for ".concat(property));
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|Array<number>|undefined} A string or an array of color values or undefined.
 */
function optionalColorLike(flatStyle, property) {
  var encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireColorLike(encoded, property);
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} An array of numbers.
 */
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error("Expected an array for ".concat(property));
  }
  var length = value.length;
  for (var i = 0; i < length; ++i) {
    if (typeof value[i] !== 'number') {
      throw new Error("Expected an array of numbers for ".concat(property));
    }
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {string} A string.
 */
function requireString(value, property) {
  if (typeof value !== 'string') {
    throw new Error("Expected a string for ".concat(property));
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number} A number.
 */
function requireNumber(value, property) {
  if (typeof value !== 'number') {
    throw new Error("Expected a number for ".concat(property));
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>|string} A color.
 */
function requireColorLike(value, property) {
  if (typeof value === 'string') {
    return value;
  }
  var array = requireNumberArray(value, property);
  var length = array.length;
  if (length < 3 || length > 4) {
    throw new Error("Expected a color with 3 or 4 values for ".concat(property));
  }
  return array;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number|Array<number>} A number or an array of two numbers.
 */
function requireSizeLike(value, property) {
  if (typeof value === 'number') {
    return value;
  }
  var size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error("Expected an array of two numbers for ".concat(property));
  }
  return size;
}
},{"../../style/Circle.js":"node_modules/ol/style/Circle.js","../../style/Fill.js":"node_modules/ol/style/Fill.js","../../style/Icon.js":"node_modules/ol/style/Icon.js","../../style/RegularShape.js":"node_modules/ol/style/RegularShape.js","../../style/Stroke.js":"node_modules/ol/style/Stroke.js","../../style/Style.js":"node_modules/ol/style/Style.js","../../style/Text.js":"node_modules/ol/style/Text.js","../../expr/expression.js":"node_modules/ol/expr/expression.js","../../expr/cpu.js":"node_modules/ol/expr/cpu.js","../../obj.js":"node_modules/ol/obj.js","../../size.js":"node_modules/ol/size.js"}],"node_modules/ol/layer/BaseVector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer2 = _interopRequireDefault(require("./Layer.js"));
var _rbush = _interopRequireDefault(require("rbush"));
var _Style = _interopRequireWildcard(require("../style/Style.js"));
var _style = require("../render/canvas/style.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/BaseVector
 */
/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */
var BaseVectorLayer = /*#__PURE__*/function (_Layer) {
  _inherits(BaseVectorLayer, _Layer);
  var _super = _createSuper(BaseVectorLayer);
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  function BaseVectorLayer(options) {
    var _this;
    _classCallCheck(this, BaseVectorLayer);
    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions);

    /**
     * @private
     * @type {boolean}
     */
    _this.declutter_ = options.declutter !== undefined ? options.declutter : false;

    /**
     * @type {number}
     * @private
     */
    _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;

    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */
    _this.style_ = null;

    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */
    _this.styleFunction_ = undefined;
    _this.setStyle(options.style);

    /**
     * @type {boolean}
     * @private
     */
    _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;

    /**
     * @type {boolean}
     * @private
     */
    _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    return _this;
  }

  /**
   * @return {boolean} Declutter.
   */
  _createClass(BaseVectorLayer, [{
    key: "getDeclutter",
    value: function getDeclutter() {
      return this.declutter_;
    }

    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return _get(_getPrototypeOf(BaseVectorLayer.prototype), "getFeatures", this).call(this, pixel);
    }

    /**
     * @return {number|undefined} Render buffer.
     */
  }, {
    key: "getRenderBuffer",
    value: function getRenderBuffer() {
      return this.renderBuffer_;
    }

    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
  }, {
    key: "getRenderOrder",
    value: function getRenderOrder() {
      return /** @type {import("../render.js").OrderFunction|null|undefined} */(
        this.get(Property.RENDER_ORDER)
      );
    }

    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
     * @api
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style_;
    }

    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
  }, {
    key: "getStyleFunction",
    value: function getStyleFunction() {
      return this.styleFunction_;
    }

    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
  }, {
    key: "getUpdateWhileAnimating",
    value: function getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }

    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
  }, {
    key: "getUpdateWhileInteracting",
    value: function getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }

    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "renderDeclutter",
    value: function renderDeclutter(frameState) {
      if (!frameState.declutterTree) {
        frameState.declutterTree = new _rbush.default(9);
      }
      /** @type {*} */
      this.getRenderer().renderDeclutter(frameState);
    }

    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
  }, {
    key: "setRenderOrder",
    value: function setRenderOrder(renderOrder) {
      this.set(Property.RENDER_ORDER, renderOrder);
    }

    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.style_ = toStyleLike(style);
      this.styleFunction_ = style === null ? undefined : (0, _Style.toFunction)(this.style_);
      this.changed();
    }
  }]);
  return BaseVectorLayer;
}(_Layer2.default);
/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */
function toStyleLike(style) {
  if (style === undefined) {
    return _Style.createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === 'function') {
    return style;
  }
  if (style instanceof _Style.default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return (0, _style.flatStylesToStyleFunction)([style]);
  }
  if (style.length === 0) {
    return [];
  }
  var length = style.length;
  var first = style[0];
  if (first instanceof _Style.default) {
    /**
     * @type {Array<Style>}
     */
    var styles = new Array(length);
    for (var i = 0; i < length; ++i) {
      var candidate = style[i];
      if (!(candidate instanceof _Style.default)) {
        throw new Error('Expected a list of style instances');
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ('style' in first) {
    /**
     * @type Array<import("../style/flat.js").Rule>
     */
    var rules = new Array(length);
    for (var _i = 0; _i < length; ++_i) {
      var _candidate = style[_i];
      if (!('style' in _candidate)) {
        throw new Error('Expected a list of rules with a style property');
      }
      rules[_i] = _candidate;
    }
    return (0, _style.rulesToStyleFunction)(rules);
  }
  var flatStyles = /** @type {Array<import("../style/flat.js").FlatStyle>} */style;
  return (0, _style.flatStylesToStyleFunction)(flatStyles);
}
var _default = exports.default = BaseVectorLayer;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","rbush":"node_modules/rbush/rbush.min.js","../style/Style.js":"node_modules/ol/style/Style.js","../render/canvas/style.js":"node_modules/ol/render/canvas/style.js"}],"node_modules/ol/render/canvas/Instruction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strokeInstruction = exports.fillInstruction = exports.default = exports.closePathInstruction = exports.beginPathInstruction = void 0;
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};

/**
 * @type {Array<Instruction>}
 */
var fillInstruction = exports.fillInstruction = [Instruction.FILL];

/**
 * @type {Array<Instruction>}
 */
var strokeInstruction = exports.strokeInstruction = [Instruction.STROKE];

/**
 * @type {Array<Instruction>}
 */
var beginPathInstruction = exports.beginPathInstruction = [Instruction.BEGIN_PATH];

/**
 * @type {Array<Instruction>}
 */
var closePathInstruction = exports.closePathInstruction = [Instruction.CLOSE_PATH];
var _default = exports.default = Instruction;
},{}],"node_modules/ol/render/VectorContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/render/VectorContext
 */
/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = /*#__PURE__*/function () {
  function VectorContext() {
    _classCallCheck(this, VectorContext);
  }
  _createClass(VectorContext, [{
    key: "drawCustom",
    value:
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}

    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
  }, {
    key: "drawGeometry",
    value: function drawGeometry(geometry) {}

    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
  }, {
    key: "setStyle",
    value: function setStyle(style) {}

    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     */
  }, {
    key: "drawCircle",
    value: function drawCircle(circleGeometry, feature) {}

    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     */
  }, {
    key: "drawFeature",
    value: function drawFeature(feature, style) {}

    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     */
  }, {
    key: "drawGeometryCollection",
    value: function drawGeometryCollection(geometryCollectionGeometry, feature) {}

    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawLineString",
    value: function drawLineString(lineStringGeometry, feature) {}

    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(multiLineStringGeometry, feature) {}

    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(multiPointGeometry, feature) {}

    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(multiPolygonGeometry, feature) {}

    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawPoint",
    value: function drawPoint(pointGeometry, feature) {}

    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonGeometry, feature) {}

    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawText",
    value: function drawText(geometry, feature) {}

    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {}

    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle, declutterImageWithText) {}

    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle, declutterImageWithText) {}
  }]);
  return VectorContext;
}();
var _default = exports.default = VectorContext;
},{}],"node_modules/ol/render/canvas/Builder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Instruction = _interopRequireDefault(require("./Instruction.js"));
var _Relationship = _interopRequireDefault(require("../../extent/Relationship.js"));
var _VectorContext2 = _interopRequireDefault(require("../VectorContext.js"));
var _colorlike = require("../../colorlike.js");
var _extent = require("../../extent.js");
var _canvas = require("../canvas.js");
var _array = require("../../array.js");
var _inflate = require("../../geom/flat/inflate.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/Builder
 */
var CanvasBuilder = /*#__PURE__*/function (_VectorContext) {
  _inherits(CanvasBuilder, _VectorContext);
  var _super = _createSuper(CanvasBuilder);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;
    _classCallCheck(this, CanvasBuilder);
    _this = _super.call(this);

    /**
     * @protected
     * @type {number}
     */
    _this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    _this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {number}
     */
    _this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    _this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    _this.resolution = resolution;

    /**
     * @private
     * @type {Array<*>}
     */
    _this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array<*>}
     */
    _this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    _this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array<*>}
     */
    _this.instructions = [];

    /**
     * @protected
     * @type {Array<number>}
     */
    _this.coordinates = [];

    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */
    _this.tmpCoordinate_ = [];

    /**
     * @protected
     * @type {Array<*>}
     */
    _this.hitDetectionInstructions = [];

    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    _this.state = /** @type {import("../canvas.js").FillStrokeState} */{};
    return _this;
  }

  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  _createClass(CanvasBuilder, [{
    key: "applyPixelRatio",
    value: function applyPixelRatio(dashArray) {
      var pixelRatio = this.pixelRatio;
      return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
        return dash * pixelRatio;
      });
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
  }, {
    key: "appendFlatPointCoordinates",
    value: function appendFlatPointCoordinates(flatCoordinates, stride) {
      var extent = this.getBufferedMaxExtent();
      var tmpCoord = this.tmpCoordinate_;
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;
      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        tmpCoord[0] = flatCoordinates[i];
        tmpCoord[1] = flatCoordinates[i + 1];
        if ((0, _extent.containsCoordinate)(extent, tmpCoord)) {
          coordinates[myEnd++] = tmpCoord[0];
          coordinates[myEnd++] = tmpCoord[1];
        }
      }
      return myEnd;
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
  }, {
    key: "appendFlatLineCoordinates",
    value: function appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;
      var extent = this.getBufferedMaxExtent();
      if (skipFirst) {
        offset += stride;
      }
      var lastXCoord = flatCoordinates[offset];
      var lastYCoord = flatCoordinates[offset + 1];
      var nextCoord = this.tmpCoordinate_;
      var skipped = true;
      var i, lastRel, nextRel;
      for (i = offset + stride; i < end; i += stride) {
        nextCoord[0] = flatCoordinates[i];
        nextCoord[1] = flatCoordinates[i + 1];
        nextRel = (0, _extent.coordinateRelationship)(extent, nextCoord);
        if (nextRel !== lastRel) {
          if (skipped) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
            skipped = false;
          }
          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
        } else if (nextRel === _Relationship.default.INTERSECTING) {
          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
          skipped = false;
        } else {
          skipped = true;
        }
        lastXCoord = nextCoord[0];
        lastYCoord = nextCoord[1];
        lastRel = nextRel;
      }

      // Last coordinate equals first or only one point to append:
      if (closed && skipped || i === offset + stride) {
        coordinates[myEnd++] = lastXCoord;
        coordinates[myEnd++] = lastYCoord;
      }
      return myEnd;
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
  }, {
    key: "drawCustomCoordinates_",
    value: function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        builderEnds.push(builderEnd);
        offset = end;
      }
      return offset;
    }

    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
  }, {
    key: "drawCustom",
    value: function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
      this.beginGeometry(geometry, feature);
      var type = geometry.getType();
      var stride = geometry.getStride();
      var builderBegin = this.coordinates.length;
      var flatCoordinates, builderEnd, builderEnds, builderEndss;
      var offset;
      switch (type) {
        case 'MultiPolygon':
          flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */geometry.getOrientedFlatCoordinates();
          builderEndss = [];
          var endss = /** @type {import("../../geom/MultiPolygon.js").default} */geometry.getEndss();
          offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var myEnds = [];
            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
            builderEndss.push(myEnds);
          }
          this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEndss, geometry, renderer, _inflate.inflateMultiCoordinatesArray]);
          this.hitDetectionInstructions.push([_Instruction.default.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, _inflate.inflateMultiCoordinatesArray]);
          break;
        case 'Polygon':
        case 'MultiLineString':
          builderEnds = [];
          flatCoordinates = type == 'Polygon' ? /** @type {import("../../geom/Polygon.js").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
          offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */geometry.getEnds(), stride, builderEnds);
          this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnds, geometry, renderer, _inflate.inflateCoordinatesArray]);
          this.hitDetectionInstructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, _inflate.inflateCoordinatesArray]);
          break;
        case 'LineString':
        case 'Circle':
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer, _inflate.inflateCoordinates]);
          this.hitDetectionInstructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, _inflate.inflateCoordinates]);
          break;
        case 'MultiPoint':
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (builderEnd > builderBegin) {
            this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer, _inflate.inflateCoordinates]);
            this.hitDetectionInstructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, _inflate.inflateCoordinates]);
          }
          break;
        case 'Point':
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          builderEnd = this.coordinates.length;
          this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer]);
          this.hitDetectionInstructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);
          break;
        default:
      }
      this.endGeometry(feature);
    }

    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "beginGeometry",
    value: function beginGeometry(geometry, feature) {
      this.beginGeometryInstruction1_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, geometry];
      this.instructions.push(this.beginGeometryInstruction1_);
      this.beginGeometryInstruction2_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, geometry];
      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }

    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
  }, {
    key: "finish",
    value: function finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }

    /**
     * Reverse the hit detection instructions.
     */
  }, {
    key: "reverseHitDetectionInstructions",
    value: function reverseHitDetectionInstructions() {
      var hitDetectionInstructions = this.hitDetectionInstructions;
      // step 1 - reverse array
      hitDetectionInstructions.reverse();
      // step 2 - reverse instructions within geometry blocks
      var i;
      var n = hitDetectionInstructions.length;
      var instruction;
      var type;
      var begin = -1;
      for (i = 0; i < n; ++i) {
        instruction = hitDetectionInstructions[i];
        type = /** @type {import("./Instruction.js").default} */instruction[0];
        if (type == _Instruction.default.END_GEOMETRY) {
          begin = i;
        } else if (type == _Instruction.default.BEGIN_GEOMETRY) {
          instruction[2] = i;
          (0, _array.reverseSubArray)(this.hitDetectionInstructions, begin, i);
          begin = -1;
        }
      }
    }

    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {
      var state = this.state;
      if (fillStyle) {
        var fillStyleColor = fillStyle.getColor();
        state.fillStyle = (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle);
      } else {
        state.fillStyle = undefined;
      }
      if (strokeStyle) {
        var strokeStyleColor = strokeStyle.getColor();
        state.strokeStyle = (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle);
        var strokeStyleLineCap = strokeStyle.getLineCap();
        state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap;
        var strokeStyleLineDash = strokeStyle.getLineDash();
        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas.defaultLineDash;
        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset;
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin;
        var strokeStyleWidth = strokeStyle.getWidth();
        state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth;
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit;
        if (state.lineWidth > this.maxLineWidth) {
          this.maxLineWidth = state.lineWidth;
          // invalidate the buffered max extent cache
          this.bufferedMaxExtent_ = null;
        }
      } else {
        state.strokeStyle = undefined;
        state.lineCap = undefined;
        state.lineDash = null;
        state.lineDashOffset = undefined;
        state.lineJoin = undefined;
        state.lineWidth = undefined;
        state.miterLimit = undefined;
      }
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
  }, {
    key: "createFill",
    value: function createFill(state) {
      var fillStyle = state.fillStyle;
      /** @type {Array<*>} */
      var fillInstruction = [_Instruction.default.SET_FILL_STYLE, fillStyle];
      if (typeof fillStyle !== 'string') {
        // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
      }
      return fillInstruction;
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
  }, {
    key: "applyStroke",
    value: function applyStroke(state) {
      this.instructions.push(this.createStroke(state));
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
  }, {
    key: "createStroke",
    value: function createStroke(state) {
      return [_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
  }, {
    key: "updateFillStyle",
    value: function updateFillStyle(state, createFill) {
      var fillStyle = state.fillStyle;
      if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
        if (fillStyle !== undefined) {
          this.instructions.push(createFill.call(this, state));
        }
        state.currentFillStyle = fillStyle;
      }
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
  }, {
    key: "updateStrokeStyle",
    value: function updateStrokeStyle(state, applyStroke) {
      var strokeStyle = state.strokeStyle;
      var lineCap = state.lineCap;
      var lineDash = state.lineDash;
      var lineDashOffset = state.lineDashOffset;
      var lineJoin = state.lineJoin;
      var lineWidth = state.lineWidth;
      var miterLimit = state.miterLimit;
      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _array.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
        if (strokeStyle !== undefined) {
          applyStroke.call(this, state);
        }
        state.currentStrokeStyle = strokeStyle;
        state.currentLineCap = lineCap;
        state.currentLineDash = lineDash;
        state.currentLineDashOffset = lineDashOffset;
        state.currentLineJoin = lineJoin;
        state.currentLineWidth = lineWidth;
        state.currentMiterLimit = miterLimit;
      }
    }

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "endGeometry",
    value: function endGeometry(feature) {
      this.beginGeometryInstruction1_[2] = this.instructions.length;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
      this.beginGeometryInstruction2_ = null;
      var endGeometryInstruction = [_Instruction.default.END_GEOMETRY, feature];
      this.instructions.push(endGeometryInstruction);
      this.hitDetectionInstructions.push(endGeometryInstruction);
    }

    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
  }, {
    key: "getBufferedMaxExtent",
    value: function getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_) {
        this.bufferedMaxExtent_ = (0, _extent.clone)(this.maxExtent);
        if (this.maxLineWidth > 0) {
          var width = this.resolution * (this.maxLineWidth + 1) / 2;
          (0, _extent.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
      }
      return this.bufferedMaxExtent_;
    }
  }]);
  return CanvasBuilder;
}(_VectorContext2.default);
var _default = exports.default = CanvasBuilder;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../../extent/Relationship.js":"node_modules/ol/extent/Relationship.js","../VectorContext.js":"node_modules/ol/render/VectorContext.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../extent.js":"node_modules/ol/extent.js","../canvas.js":"node_modules/ol/render/canvas.js","../../array.js":"node_modules/ol/array.js","../../geom/flat/inflate.js":"node_modules/ol/geom/flat/inflate.js"}],"node_modules/ol/render/canvas/ImageBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Builder = _interopRequireDefault(require("./Builder.js"));
var _Instruction = _interopRequireDefault(require("./Instruction.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/ImageBuilder
 */
var CanvasImageBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasImageBuilder, _CanvasBuilder);
  var _super = _createSuper(CanvasImageBuilder);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;
    _classCallCheck(this, CanvasImageBuilder);
    _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    _this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    _this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.imagePixelRatio_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    _this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.rotation_ = undefined;

    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */
    _this.scale_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.width_ = undefined;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    _this.declutterMode_ = undefined;

    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    _this.declutterImageWithText_ = undefined;
    return _this;
  }

  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  _createClass(CanvasImageBuilder, [{
    key: "drawPoint",
    value: function drawPoint(pointGeometry, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(pointGeometry, feature);
      var flatCoordinates = pointGeometry.getFlatCoordinates();
      var stride = pointGeometry.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
      this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
      this.endGeometry(feature);
    }

    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(multiPointGeometry, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(multiPointGeometry, feature);
      var flatCoordinates = multiPointGeometry.getFlatCoordinates();
      var stride = multiPointGeometry.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
      this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
      this.endGeometry(feature);
    }

    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
  }, {
    key: "finish",
    value: function finish() {
      this.reverseHitDetectionInstructions();
      // FIXME this doesn't really protect us against further calls to draw*Geometry
      this.anchorX_ = undefined;
      this.anchorY_ = undefined;
      this.hitDetectionImage_ = null;
      this.image_ = null;
      this.imagePixelRatio_ = undefined;
      this.height_ = undefined;
      this.scale_ = undefined;
      this.opacity_ = undefined;
      this.originX_ = undefined;
      this.originY_ = undefined;
      this.rotateWithView_ = undefined;
      this.rotation_ = undefined;
      this.width_ = undefined;
      return _get(_getPrototypeOf(CanvasImageBuilder.prototype), "finish", this).call(this);
    }

    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     */
  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle, sharedData) {
      var anchor = imageStyle.getAnchor();
      var size = imageStyle.getSize();
      var origin = imageStyle.getOrigin();
      this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
      this.anchorX_ = anchor[0];
      this.anchorY_ = anchor[1];
      this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
      this.image_ = imageStyle.getImage(this.pixelRatio);
      this.height_ = size[1];
      this.opacity_ = imageStyle.getOpacity();
      this.originX_ = origin[0];
      this.originY_ = origin[1];
      this.rotateWithView_ = imageStyle.getRotateWithView();
      this.rotation_ = imageStyle.getRotation();
      this.scale_ = imageStyle.getScaleArray();
      this.width_ = size[0];
      this.declutterMode_ = imageStyle.getDeclutterMode();
      this.declutterImageWithText_ = sharedData;
    }
  }]);
  return CanvasImageBuilder;
}(_Builder.default);
var _default = exports.default = CanvasImageBuilder;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js"}],"node_modules/ol/render/canvas/LineStringBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Builder = _interopRequireDefault(require("./Builder.js"));
var _Instruction = _interopRequireWildcard(require("./Instruction.js"));
var _canvas = require("../canvas.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/LineStringBuilder
 */
var CanvasLineStringBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasLineStringBuilder, _CanvasBuilder);
  var _super = _createSuper(CanvasLineStringBuilder);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, CanvasLineStringBuilder);
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  _createClass(CanvasLineStringBuilder, [{
    key: "drawFlatCoordinates_",
    value: function drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
      var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      return end;
    }

    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawLineString",
    value: function drawLineString(lineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;
      if (strokeStyle === undefined || lineWidth === undefined) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(lineStringGeometry, feature);
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas.defaultLineDash, _canvas.defaultLineDashOffset], _Instruction.beginPathInstruction);
      var flatCoordinates = lineStringGeometry.getFlatCoordinates();
      var stride = lineStringGeometry.getStride();
      this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
      this.endGeometry(feature);
    }

    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(multiLineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;
      if (strokeStyle === undefined || lineWidth === undefined) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(multiLineStringGeometry, feature);
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas.defaultLineDash, _canvas.defaultLineDashOffset], _Instruction.beginPathInstruction);
      var ends = multiLineStringGeometry.getEnds();
      var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
      var stride = multiLineStringGeometry.getStride();
      var offset = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.drawFlatCoordinates_(flatCoordinates, offset, /** @type {number} */ends[i], stride);
      }
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
      this.endGeometry(feature);
    }

    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
  }, {
    key: "finish",
    value: function finish() {
      var state = this.state;
      if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
        this.instructions.push(_Instruction.strokeInstruction);
      }
      this.reverseHitDetectionInstructions();
      this.state = null;
      return _get(_getPrototypeOf(CanvasLineStringBuilder.prototype), "finish", this).call(this);
    }

    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
  }, {
    key: "applyStroke",
    value: function applyStroke(state) {
      if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
        this.instructions.push(_Instruction.strokeInstruction);
        state.lastStroke = this.coordinates.length;
      }
      state.lastStroke = 0;
      _get(_getPrototypeOf(CanvasLineStringBuilder.prototype), "applyStroke", this).call(this, state);
      this.instructions.push(_Instruction.beginPathInstruction);
    }
  }]);
  return CanvasLineStringBuilder;
}(_Builder.default);
var _default = exports.default = CanvasLineStringBuilder;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/render/canvas/PolygonBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Builder = _interopRequireDefault(require("./Builder.js"));
var _Instruction = _interopRequireWildcard(require("./Instruction.js"));
var _canvas = require("../canvas.js");
var _simplify = require("../../geom/flat/simplify.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/PolygonBuilder
 */
var CanvasPolygonBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasPolygonBuilder, _CanvasBuilder);
  var _super = _createSuper(CanvasPolygonBuilder);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, CanvasPolygonBuilder);
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  _createClass(CanvasPolygonBuilder, [{
    key: "drawFlatCoordinatess_",
    value: function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
      var state = this.state;
      var fill = state.fillStyle !== undefined;
      var stroke = state.strokeStyle !== undefined;
      var numEnds = ends.length;
      this.instructions.push(_Instruction.beginPathInstruction);
      this.hitDetectionInstructions.push(_Instruction.beginPathInstruction);
      for (var i = 0; i < numEnds; ++i) {
        var end = ends[i];
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
        var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        if (stroke) {
          // Performance optimization: only call closePath() when we have a stroke.
          // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
          this.instructions.push(_Instruction.closePathInstruction);
          this.hitDetectionInstructions.push(_Instruction.closePathInstruction);
        }
        offset = end;
      }
      if (fill) {
        this.instructions.push(_Instruction.fillInstruction);
        this.hitDetectionInstructions.push(_Instruction.fillInstruction);
      }
      if (stroke) {
        this.instructions.push(_Instruction.strokeInstruction);
        this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
      }
      return offset;
    }

    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     */
  }, {
    key: "drawCircle",
    value: function drawCircle(circleGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(circleGeometry, feature);
      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
      }
      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas.defaultLineDash, _canvas.defaultLineDashOffset]);
      }
      var flatCoordinates = circleGeometry.getFlatCoordinates();
      var stride = circleGeometry.getStride();
      var myBegin = this.coordinates.length;
      this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      var circleInstruction = [_Instruction.default.CIRCLE, myBegin];
      this.instructions.push(_Instruction.beginPathInstruction, circleInstruction);
      this.hitDetectionInstructions.push(_Instruction.beginPathInstruction, circleInstruction);
      if (state.fillStyle !== undefined) {
        this.instructions.push(_Instruction.fillInstruction);
        this.hitDetectionInstructions.push(_Instruction.fillInstruction);
      }
      if (state.strokeStyle !== undefined) {
        this.instructions.push(_Instruction.strokeInstruction);
        this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
      }
      this.endGeometry(feature);
    }

    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(polygonGeometry, feature);
      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
      }
      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas.defaultLineDash, _canvas.defaultLineDashOffset]);
      }
      var ends = polygonGeometry.getEnds();
      var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
      var stride = polygonGeometry.getStride();
      this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ends, stride);
      this.endGeometry(feature);
    }

    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(multiPolygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(multiPolygonGeometry, feature);
      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
      }
      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas.defaultLineDash, _canvas.defaultLineDashOffset]);
      }
      var endss = multiPolygonGeometry.getEndss();
      var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
      var stride = multiPolygonGeometry.getStride();
      var offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
      }
      this.endGeometry(feature);
    }

    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
  }, {
    key: "finish",
    value: function finish() {
      this.reverseHitDetectionInstructions();
      this.state = null;
      // We want to preserve topology when drawing polygons.  Polygons are
      // simplified using quantization and point elimination. However, we might
      // have received a mix of quantized and non-quantized geometries, so ensure
      // that all are quantized by quantizing all coordinates in the batch.
      var tolerance = this.tolerance;
      if (tolerance !== 0) {
        var coordinates = this.coordinates;
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          coordinates[i] = (0, _simplify.snap)(coordinates[i], tolerance);
        }
      }
      return _get(_getPrototypeOf(CanvasPolygonBuilder.prototype), "finish", this).call(this);
    }

    /**
     * @private
     */
  }, {
    key: "setFillStrokeStyles_",
    value: function setFillStrokeStyles_() {
      var state = this.state;
      var fillStyle = state.fillStyle;
      if (fillStyle !== undefined) {
        this.updateFillStyle(state, this.createFill);
      }
      if (state.strokeStyle !== undefined) {
        this.updateStrokeStyle(state, this.applyStroke);
      }
    }
  }]);
  return CanvasPolygonBuilder;
}(_Builder.default);
var _default = exports.default = CanvasPolygonBuilder;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../canvas.js":"node_modules/ol/render/canvas.js","../../geom/flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/geom/flat/linechunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineChunk = lineChunk;
var _math = require("../../math.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/**
 * Creates chunks of equal length from a linestring
 * @param {number} chunkLength Length of each chunk.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @return {Array<Array<number>>} Chunks of linestrings with stride 2.
 */
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  var chunks = [];
  var cursor = offset;
  var chunkM = 0;
  var currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    var _currentChunk$slice = currentChunk.slice(-2),
      _currentChunk$slice2 = _slicedToArray(_currentChunk$slice, 2),
      x1 = _currentChunk$slice2[0],
      y1 = _currentChunk$slice2[1];
    var x2 = flatCoordinates[cursor + stride];
    var y2 = flatCoordinates[cursor + stride + 1];
    var segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      var m = (chunkLength - chunkM + segmentLength) / segmentLength;
      var x = (0, _math.lerp)(x1, x2, m);
      var y = (0, _math.lerp)(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(flatCoordinates[cursor + stride], flatCoordinates[cursor + stride + 1]);
      cursor += stride;
    } else {
      var missing = segmentLength - chunkM;
      var _x = (0, _math.lerp)(x1, x2, missing / segmentLength);
      var _y = (0, _math.lerp)(y1, y2, missing / segmentLength);
      currentChunk.push(_x, _y);
      chunks.push(currentChunk);
      currentChunk = [_x, _y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/straightchunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchingChunk = matchingChunk;
/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
},{}],"node_modules/ol/render/canvas/TextBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TEXT_ALIGN = void 0;
var _Builder = _interopRequireDefault(require("./Builder.js"));
var _Instruction = _interopRequireDefault(require("./Instruction.js"));
var _colorlike = require("../../colorlike.js");
var _canvas = require("../canvas.js");
var _util = require("../../util.js");
var _extent = require("../../extent.js");
var _linechunk = require("../../geom/flat/linechunk.js");
var _straightchunk = require("../../geom/flat/straightchunk.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/TextBuilder
 */
/**
 * @const
 * @type {{left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1}}
 */
var TEXT_ALIGN = exports.TEXT_ALIGN = {
  'left': 0,
  'center': 0.5,
  'right': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1
};
var CanvasTextBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasTextBuilder, _CanvasBuilder);
  var _super = _createSuper(CanvasTextBuilder);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;
    _classCallCheck(this, CanvasTextBuilder);
    _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    _this.labels_ = null;

    /**
     * @private
     * @type {string|Array<string>}
     */
    _this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    _this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    _this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    _this.textRotation_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    _this.textFillState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    _this.fillStates = {};
    _this.fillStates[_canvas.defaultFillStyle] = {
      fillStyle: _canvas.defaultFillStyle
    };

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    _this.textStrokeState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    _this.strokeStates = {};

    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    _this.textState_ = /** @type {import("../canvas.js").TextState} */{};

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    _this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    _this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    _this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    _this.strokeKey_ = '';

    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    _this.declutterImageWithText_ = undefined;
    return _this;
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  _createClass(CanvasTextBuilder, [{
    key: "finish",
    value: function finish() {
      var instructions = _get(_getPrototypeOf(CanvasTextBuilder.prototype), "finish", this).call(this);
      instructions.textStates = this.textStates;
      instructions.fillStates = this.fillStates;
      instructions.strokeStates = this.strokeStates;
      return instructions;
    }

    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
  }, {
    key: "drawText",
    value: function drawText(geometry, feature) {
      var fillState = this.textFillState_;
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      if (this.text_ === '' || !textState || !fillState && !strokeState) {
        return;
      }
      var coordinates = this.coordinates;
      var begin = coordinates.length;
      var geometryType = geometry.getType();
      var flatCoordinates = null;
      var stride = geometry.getStride();
      if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {
        if (!(0, _extent.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
          return;
        }
        var ends;
        flatCoordinates = geometry.getFlatCoordinates();
        if (geometryType == 'LineString') {
          ends = [flatCoordinates.length];
        } else if (geometryType == 'MultiLineString') {
          ends = /** @type {import("../../geom/MultiLineString.js").default} */geometry.getEnds();
        } else if (geometryType == 'Polygon') {
          ends = /** @type {import("../../geom/Polygon.js").default} */geometry.getEnds().slice(0, 1);
        } else if (geometryType == 'MultiPolygon') {
          var endss = /** @type {import("../../geom/MultiPolygon.js").default} */geometry.getEndss();
          ends = [];
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            ends.push(endss[i][0]);
          }
        }
        this.beginGeometry(geometry, feature);
        var repeat = textState.repeat;
        var textAlign = repeat ? undefined : textState.textAlign;
        // No `justify` support for line placement.
        var flatOffset = 0;
        for (var o = 0, oo = ends.length; o < oo; ++o) {
          var chunks = void 0;
          if (repeat) {
            chunks = (0, _linechunk.lineChunk)(repeat * this.resolution, flatCoordinates, flatOffset, ends[o], stride);
          } else {
            chunks = [flatCoordinates.slice(flatOffset, ends[o])];
          }
          for (var c = 0, cc = chunks.length; c < cc; ++c) {
            var chunk = chunks[c];
            var chunkBegin = 0;
            var chunkEnd = chunk.length;
            if (textAlign == undefined) {
              var range = (0, _straightchunk.matchingChunk)(textState.maxAngle, chunk, 0, chunk.length, 2);
              chunkBegin = range[0];
              chunkEnd = range[1];
            }
            for (var _i = chunkBegin; _i < chunkEnd; _i += stride) {
              coordinates.push(chunk[_i], chunk[_i + 1]);
            }
            var end = coordinates.length;
            flatOffset = ends[o];
            this.drawChars_(begin, end);
            begin = end;
          }
        }
        this.endGeometry(feature);
      } else {
        var geometryWidths = textState.overflow ? null : [];
        switch (geometryType) {
          case 'Point':
          case 'MultiPoint':
            flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */geometry.getFlatCoordinates();
            break;
          case 'LineString':
            flatCoordinates = /** @type {import("../../geom/LineString.js").default} */geometry.getFlatMidpoint();
            break;
          case 'Circle':
            flatCoordinates = /** @type {import("../../geom/Circle.js").default} */geometry.getCenter();
            break;
          case 'MultiLineString':
            flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */geometry.getFlatMidpoints();
            stride = 2;
            break;
          case 'Polygon':
            flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */geometry.getFlatInteriorPoint();
            if (!textState.overflow) {
              geometryWidths.push(flatCoordinates[2] / this.resolution);
            }
            stride = 3;
            break;
          case 'MultiPolygon':
            var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */geometry.getFlatInteriorPoints();
            flatCoordinates = [];
            for (var _i2 = 0, _ii = interiorPoints.length; _i2 < _ii; _i2 += 3) {
              if (!textState.overflow) {
                geometryWidths.push(interiorPoints[_i2 + 2] / this.resolution);
              }
              flatCoordinates.push(interiorPoints[_i2], interiorPoints[_i2 + 1]);
            }
            if (flatCoordinates.length === 0) {
              return;
            }
            stride = 2;
            break;
          default:
        }
        var _end = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (_end === begin) {
          return;
        }
        if (geometryWidths && (_end - begin) / 2 !== flatCoordinates.length / stride) {
          var beg = begin / 2;
          geometryWidths = geometryWidths.filter(function (w, i) {
            var keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
            if (!keep) {
              --beg;
            }
            return keep;
          });
        }
        this.saveTextStates_();
        if (textState.backgroundFill || textState.backgroundStroke) {
          this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
          if (textState.backgroundFill) {
            this.updateFillStyle(this.state, this.createFill);
          }
          if (textState.backgroundStroke) {
            this.updateStrokeStyle(this.state, this.applyStroke);
            this.hitDetectionInstructions.push(this.createStroke(this.state));
          }
        }
        this.beginGeometry(geometry, feature);

        // adjust padding for negative scale
        var padding = textState.padding;
        if (padding != _canvas.defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
          var p0 = textState.padding[0];
          var p1 = textState.padding[1];
          var p2 = textState.padding[2];
          var p3 = textState.padding[3];
          if (textState.scale[0] < 0) {
            p1 = -p1;
            p3 = -p3;
          }
          if (textState.scale[1] < 0) {
            p0 = -p0;
            p2 = -p2;
          }
          padding = [p0, p1, p2, p3];
        }

        // The image is unknown at this stage so we pass null; it will be computed at render time.
        // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
        // render time.
        var pixelRatio = this.pixelRatio;
        this.instructions.push([_Instruction.default.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, undefined, this.declutterImageWithText_, padding == _canvas.defaultPadding ? _canvas.defaultPadding : padding.map(function (p) {
          return p * pixelRatio;
        }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
        var scale = 1 / pixelRatio;
        // Set default fill for hit detection background
        var currentFillStyle = this.state.fillStyle;
        if (textState.backgroundFill) {
          this.state.fillStyle = _canvas.defaultFillStyle;
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, undefined, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? _canvas.defaultFillStyle : this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
        // Reset previous fill
        if (textState.backgroundFill) {
          this.state.fillStyle = currentFillStyle;
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        this.endGeometry(feature);
      }
    }

    /**
     * @private
     */
  }, {
    key: "saveTextStates_",
    value: function saveTextStates_() {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var fillState = this.textFillState_;
      var strokeKey = this.strokeKey_;
      if (strokeState) {
        if (!(strokeKey in this.strokeStates)) {
          this.strokeStates[strokeKey] = {
            strokeStyle: strokeState.strokeStyle,
            lineCap: strokeState.lineCap,
            lineDashOffset: strokeState.lineDashOffset,
            lineWidth: strokeState.lineWidth,
            lineJoin: strokeState.lineJoin,
            miterLimit: strokeState.miterLimit,
            lineDash: strokeState.lineDash
          };
        }
      }
      var textKey = this.textKey_;
      if (!(textKey in this.textStates)) {
        this.textStates[textKey] = {
          font: textState.font,
          textAlign: textState.textAlign || _canvas.defaultTextAlign,
          justify: textState.justify,
          textBaseline: textState.textBaseline || _canvas.defaultTextBaseline,
          scale: textState.scale
        };
      }
      var fillKey = this.fillKey_;
      if (fillState) {
        if (!(fillKey in this.fillStates)) {
          this.fillStates[fillKey] = {
            fillStyle: fillState.fillStyle
          };
        }
      }
    }

    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
  }, {
    key: "drawChars_",
    value: function drawChars_(begin, end) {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var strokeKey = this.strokeKey_;
      var textKey = this.textKey_;
      var fillKey = this.fillKey_;
      this.saveTextStates_();
      var pixelRatio = this.pixelRatio;
      var baseline = TEXT_ALIGN[textState.textBaseline];
      var offsetY = this.textOffsetY_ * pixelRatio;
      var text = this.text_;
      var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
      this.instructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
      this.hitDetectionInstructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey ? _canvas.defaultFillStyle : fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1 / pixelRatio]);
    }

    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     */
  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle, sharedData) {
      var textState, fillState, strokeState;
      if (!textStyle) {
        this.text_ = '';
      } else {
        var textFillStyle = textStyle.getFill();
        if (!textFillStyle) {
          fillState = null;
          this.textFillState_ = fillState;
        } else {
          fillState = this.textFillState_;
          if (!fillState) {
            fillState = /** @type {import("../canvas.js").FillState} */{};
            this.textFillState_ = fillState;
          }
          fillState.fillStyle = (0, _colorlike.asColorLike)(textFillStyle.getColor() || _canvas.defaultFillStyle);
        }
        var textStrokeStyle = textStyle.getStroke();
        if (!textStrokeStyle) {
          strokeState = null;
          this.textStrokeState_ = strokeState;
        } else {
          strokeState = this.textStrokeState_;
          if (!strokeState) {
            strokeState = /** @type {import("../canvas.js").StrokeState} */{};
            this.textStrokeState_ = strokeState;
          }
          var lineDash = textStrokeStyle.getLineDash();
          var lineDashOffset = textStrokeStyle.getLineDashOffset();
          var lineWidth = textStrokeStyle.getWidth();
          var miterLimit = textStrokeStyle.getMiterLimit();
          strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas.defaultLineCap;
          strokeState.lineDash = lineDash ? lineDash.slice() : _canvas.defaultLineDash;
          strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas.defaultLineDashOffset : lineDashOffset;
          strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas.defaultLineJoin;
          strokeState.lineWidth = lineWidth === undefined ? _canvas.defaultLineWidth : lineWidth;
          strokeState.miterLimit = miterLimit === undefined ? _canvas.defaultMiterLimit : miterLimit;
          strokeState.strokeStyle = (0, _colorlike.asColorLike)(textStrokeStyle.getColor() || _canvas.defaultStrokeStyle);
        }
        textState = this.textState_;
        var font = textStyle.getFont() || _canvas.defaultFont;
        (0, _canvas.registerFont)(font);
        var textScale = textStyle.getScaleArray();
        textState.overflow = textStyle.getOverflow();
        textState.font = font;
        textState.maxAngle = textStyle.getMaxAngle();
        textState.placement = textStyle.getPlacement();
        textState.textAlign = textStyle.getTextAlign();
        textState.repeat = textStyle.getRepeat();
        textState.justify = textStyle.getJustify();
        textState.textBaseline = textStyle.getTextBaseline() || _canvas.defaultTextBaseline;
        textState.backgroundFill = textStyle.getBackgroundFill();
        textState.backgroundStroke = textStyle.getBackgroundStroke();
        textState.padding = textStyle.getPadding() || _canvas.defaultPadding;
        textState.scale = textScale === undefined ? [1, 1] : textScale;
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotateWithView = textStyle.getRotateWithView();
        var textRotation = textStyle.getRotation();
        this.text_ = textStyle.getText() || '';
        this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
        this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
        this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
        this.textRotation_ = textRotation === undefined ? 0 : textRotation;
        this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _util.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
        this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.repeat || '?') + (textState.justify || '?') + (textState.textBaseline || '?');
        this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _util.getUid)(fillState.fillStyle) : '';
      }
      this.declutterImageWithText_ = sharedData;
    }
  }]);
  return CanvasTextBuilder;
}(_Builder.default);
var _default = exports.default = CanvasTextBuilder;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../../colorlike.js":"node_modules/ol/colorlike.js","../canvas.js":"node_modules/ol/render/canvas.js","../../util.js":"node_modules/ol/util.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/linechunk.js":"node_modules/ol/geom/flat/linechunk.js","../../geom/flat/straightchunk.js":"node_modules/ol/geom/flat/straightchunk.js"}],"node_modules/ol/render/canvas/BuilderGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Builder = _interopRequireDefault(require("./Builder.js"));
var _ImageBuilder = _interopRequireDefault(require("./ImageBuilder.js"));
var _LineStringBuilder = _interopRequireDefault(require("./LineStringBuilder.js"));
var _PolygonBuilder = _interopRequireDefault(require("./PolygonBuilder.js"));
var _TextBuilder = _interopRequireDefault(require("./TextBuilder.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/render/canvas/BuilderGroup
 */
/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder.default,
  'Default': _Builder.default,
  'Image': _ImageBuilder.default,
  'LineString': _LineStringBuilder.default,
  'Polygon': _PolygonBuilder.default,
  'Text': _TextBuilder.default
};
var BuilderGroup = /*#__PURE__*/function () {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, BuilderGroup);
    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */
    this.buildersByZIndex_ = {};
  }

  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  _createClass(BuilderGroup, [{
    key: "finish",
    value: function finish() {
      var builderInstructions = {};
      for (var zKey in this.buildersByZIndex_) {
        builderInstructions[zKey] = builderInstructions[zKey] || {};
        var builders = this.buildersByZIndex_[zKey];
        for (var builderKey in builders) {
          var builderInstruction = builders[builderKey].finish();
          builderInstructions[zKey][builderKey] = builderInstruction;
        }
      }
      return builderInstructions;
    }

    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
  }, {
    key: "getBuilder",
    value: function getBuilder(zIndex, builderType) {
      var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
      var replays = this.buildersByZIndex_[zIndexKey];
      if (replays === undefined) {
        replays = {};
        this.buildersByZIndex_[zIndexKey] = replays;
      }
      var replay = replays[builderType];
      if (replay === undefined) {
        var Constructor = BATCH_CONSTRUCTORS[builderType];
        replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
        replays[builderType] = replay;
      }
      return replay;
    }
  }]);
  return BuilderGroup;
}();
var _default = exports.default = BuilderGroup;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./ImageBuilder.js":"node_modules/ol/render/canvas/ImageBuilder.js","./LineStringBuilder.js":"node_modules/ol/render/canvas/LineStringBuilder.js","./PolygonBuilder.js":"node_modules/ol/render/canvas/PolygonBuilder.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js"}],"node_modules/ol/renderer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _Observable2 = _interopRequireDefault(require("../Observable.js"));
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/Layer
 */
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
var LayerRenderer = /*#__PURE__*/function (_Observable) {
  _inherits(LayerRenderer, _Observable);
  var _super = _createSuper(LayerRenderer);
  /**
   * @param {LayerType} layer Layer.
   */
  function LayerRenderer(layer) {
    var _this;
    _classCallCheck(this, LayerRenderer);
    _this = _super.call(this);

    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */
    _this.ready = true;

    /** @private */
    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_assertThisInitialized(_this));

    /**
     * @protected
     * @type {LayerType}
     */
    _this.layer_ = layer;

    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */
    _this.declutterExecutorGroup = null;
    return _this;
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  _createClass(LayerRenderer, [{
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return (0, _util.abstract)();
    }

    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      return null;
    }

    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      return (0, _util.abstract)();
    }

    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      return (0, _util.abstract)();
    }

    /**
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */
  }, {
    key: "loadedTileCallback",
    value: function loadedTileCallback(tiles, zoom, tile) {
      if (!tiles[zoom]) {
        tiles[zoom] = {};
      }
      tiles[zoom][tile.tileCoord.toString()] = tile;
      return undefined;
    }

    /**
     * Create a function that adds loaded tiles to the tile lookup.
     * @param {import("../source/Tile.js").default} source Tile source.
     * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
     *     called with a zoom level and a tile range to add loaded tiles to the lookup.
     * @protected
     */
  }, {
    key: "createLoadedTileFinder",
    value: function createLoadedTileFinder(source, projection, tiles) {
      var _this2 = this;
      return (
        /**
         * @param {number} zoom Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @return {boolean} The tile range is fully loaded.
         */
        function (zoom, tileRange) {
          var callback = _this2.loadedTileCallback.bind(_this2, tiles, zoom);
          return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }
      );
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      return undefined;
    }

    /**
     * @return {LayerType} Layer.
     */
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this.layer_;
    }

    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {}

    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
  }, {
    key: "handleImageChange_",
    value: function handleImageChange_(event) {
      var image = /** @type {import("../Image.js").default} */event.target;
      if (image.getState() === _ImageState.default.LOADED || image.getState() === _ImageState.default.ERROR) {
        this.renderIfReadyAndVisible();
      }
    }

    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
  }, {
    key: "loadImage",
    value: function loadImage(image) {
      var imageState = image.getState();
      if (imageState != _ImageState.default.LOADED && imageState != _ImageState.default.ERROR) {
        image.addEventListener(_EventType.default.CHANGE, this.boundHandleImageChange_);
      }
      if (imageState == _ImageState.default.IDLE) {
        image.load();
        imageState = image.getState();
      }
      return imageState == _ImageState.default.LOADED;
    }

    /**
     * @protected
     */
  }, {
    key: "renderIfReadyAndVisible",
    value: function renderIfReadyAndVisible() {
      var layer = this.getLayer();
      if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
        layer.changed();
      }
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      delete this.layer_;
      _get(_getPrototypeOf(LayerRenderer.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return LayerRenderer;
}(_Observable2.default);
var _default = exports.default = LayerRenderer;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../Observable.js":"node_modules/ol/Observable.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/render/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/Event
 */
var RenderEvent = /*#__PURE__*/function (_Event) {
  _inherits(RenderEvent, _Event);
  var _super = _createSuper(RenderEvent);
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  function RenderEvent(type, inversePixelTransform, frameState, context) {
    var _this;
    _classCallCheck(this, RenderEvent);
    _this = _super.call(this, type);

    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */
    _this.inversePixelTransform = inversePixelTransform;

    /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */
    _this.frameState = frameState;

    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */
    _this.context = context;
    return _this;
  }
  return _createClass(RenderEvent);
}(_Event2.default);
var _default = exports.default = RenderEvent;
},{"../events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/renderer/canvas/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.canvasPool = void 0;
var _Layer = _interopRequireDefault(require("../Layer.js"));
var _Event = _interopRequireDefault(require("../../render/Event.js"));
var _EventType = _interopRequireDefault(require("../../render/EventType.js"));
var _transform = require("../../transform.js");
var _color = require("../../color.js");
var _dom = require("../../dom.js");
var _array = require("../../array.js");
var _extent = require("../../extent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/Layer
 */
/**
 * @type {Array<HTMLCanvasElement>}
 */
var canvasPool = exports.canvasPool = [];

/**
 * @type {CanvasRenderingContext2D}
 */
var pixelContext = null;
function createPixelContext() {
  pixelContext = (0, _dom.createCanvasContext2D)(1, 1, undefined, {
    willReadFrequently: true
  });
}

/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
var CanvasLayerRenderer = /*#__PURE__*/function (_LayerRenderer) {
  _inherits(CanvasLayerRenderer, _LayerRenderer);
  var _super = _createSuper(CanvasLayerRenderer);
  /**
   * @param {LayerType} layer Layer.
   */
  function CanvasLayerRenderer(layer) {
    var _this;
    _classCallCheck(this, CanvasLayerRenderer);
    _this = _super.call(this, layer);

    /**
     * @protected
     * @type {HTMLElement}
     */
    _this.container = null;

    /**
     * @protected
     * @type {number}
     */
    _this.renderedResolution;

    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    _this.tempTransform = (0, _transform.create)();

    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    _this.pixelTransform = (0, _transform.create)();

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    _this.inversePixelTransform = (0, _transform.create)();

    /**
     * @type {CanvasRenderingContext2D}
     */
    _this.context = null;

    /**
     * @type {boolean}
     */
    _this.containerReused = false;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    _this.pixelContext_ = null;

    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    _this.frameState = null;
    return _this;
  }

  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  _createClass(CanvasLayerRenderer, [{
    key: "getImageData",
    value: function getImageData(image, col, row) {
      if (!pixelContext) {
        createPixelContext();
      }
      pixelContext.clearRect(0, 0, 1, 1);
      var data;
      try {
        pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
        data = pixelContext.getImageData(0, 0, 1, 1).data;
      } catch (err) {
        pixelContext = null;
        return null;
      }
      return data;
    }

    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
  }, {
    key: "getBackground",
    value: function getBackground(frameState) {
      var layer = this.getLayer();
      var background = layer.getBackground();
      if (typeof background === 'function') {
        background = background(frameState.viewState.resolution);
      }
      return background || undefined;
    }

    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
  }, {
    key: "useContainer",
    value: function useContainer(target, transform, backgroundColor) {
      var layerClassName = this.getLayer().getClassName();
      var container, context;
      if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0, _array.equals)((0, _color.asArray)(target.style.backgroundColor), (0, _color.asArray)(backgroundColor)))) {
        var canvas = target.firstElementChild;
        if (canvas instanceof HTMLCanvasElement) {
          context = canvas.getContext('2d');
        }
      }
      if (context && context.canvas.style.transform === transform) {
        // Container of the previous layer renderer can be used.
        this.container = target;
        this.context = context;
        this.containerReused = true;
      } else if (this.containerReused) {
        // Previously reused container cannot be used any more.
        this.container = null;
        this.context = null;
        this.containerReused = false;
      } else if (this.container) {
        this.container.style.backgroundColor = null;
      }
      if (!this.container) {
        container = document.createElement('div');
        container.className = layerClassName;
        var style = container.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        context = (0, _dom.createCanvasContext2D)();
        var _canvas = context.canvas;
        container.appendChild(_canvas);
        style = _canvas.style;
        style.position = 'absolute';
        style.left = '0';
        style.transformOrigin = 'top left';
        this.container = container;
        this.context = context;
      }
      if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
        this.container.style.backgroundColor = backgroundColor;
      }
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
  }, {
    key: "clipUnrotated",
    value: function clipUnrotated(context, frameState, extent) {
      var topLeft = (0, _extent.getTopLeft)(extent);
      var topRight = (0, _extent.getTopRight)(extent);
      var bottomRight = (0, _extent.getBottomRight)(extent);
      var bottomLeft = (0, _extent.getBottomLeft)(extent);
      (0, _transform.apply)(frameState.coordinateToPixelTransform, topLeft);
      (0, _transform.apply)(frameState.coordinateToPixelTransform, topRight);
      (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomRight);
      (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomLeft);
      var inverted = this.inversePixelTransform;
      (0, _transform.apply)(inverted, topLeft);
      (0, _transform.apply)(inverted, topRight);
      (0, _transform.apply)(inverted, bottomRight);
      (0, _transform.apply)(inverted, bottomLeft);
      context.save();
      context.beginPath();
      context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
      context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
      context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
      context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
      context.clip();
    }

    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
  }, {
    key: "dispatchRenderEvent_",
    value: function dispatchRenderEvent_(type, context, frameState) {
      var layer = this.getLayer();
      if (layer.hasListener(type)) {
        var event = new _Event.default(type, this.inversePixelTransform, frameState, context);
        layer.dispatchEvent(event);
      }
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "preRender",
    value: function preRender(context, frameState) {
      this.frameState = frameState;
      this.dispatchRenderEvent_(_EventType.default.PRERENDER, context, frameState);
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "postRender",
    value: function postRender(context, frameState) {
      this.dispatchRenderEvent_(_EventType.default.POSTRENDER, context, frameState);
    }

    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
  }, {
    key: "getRenderTransform",
    value: function getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
      var dx1 = width / 2;
      var dy1 = height / 2;
      var sx = pixelRatio / resolution;
      var sy = -sx;
      var dx2 = -center[0] + offsetX;
      var dy2 = -center[1];
      return (0, _transform.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      delete this.frameState;
      _get(_getPrototypeOf(CanvasLayerRenderer.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return CanvasLayerRenderer;
}(_Layer.default);
var _default = exports.default = CanvasLayerRenderer;
},{"../Layer.js":"node_modules/ol/renderer/Layer.js","../../render/Event.js":"node_modules/ol/render/Event.js","../../render/EventType.js":"node_modules/ol/render/EventType.js","../../transform.js":"node_modules/ol/transform.js","../../color.js":"node_modules/ol/color.js","../../dom.js":"node_modules/ol/dom.js","../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/flat/textpath.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawTextOnPath = drawTextOnPath;
var _math = require("../../math.js");
var _transform = require("./transform.js");
/**
 * @module ol/geom/flat/textpath
 */

/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  var beginX = (0, _math.lerp)(x1, x2, interpolate);
  var beginY = (0, _math.lerp)(y1, y2, interpolate);
  var startOffset = offset - stride;
  var startLength = segmentM;
  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  var endX = (0, _math.lerp)(x1, x2, interpolate);
  var endY = (0, _math.lerp)(y1, y2, interpolate);

  // Keep text upright
  var reverse;
  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    (0, _transform.rotate)(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  var previousAngle;
  // All on the same segment
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    var x = (endX + beginX) / 2;
    var y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }

  // rendering across line segments
  text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines

  for (var i = 0, ii = text.length; i < ii;) {
    advance();
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    var iStart = i;
    var charLength = 0;
    for (; i < ii; ++i) {
      var index = reverse ? ii - i - 1 : i;
      var len = scale * measureAndCacheTextWidth(font, text[index], cache);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    var _x = (0, _math.lerp)(x1, x2, interpolate);
    var _y = (0, _math.lerp)(y1, y2, interpolate);
    result.push([_x, _y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}
},{"../../math.js":"node_modules/ol/math.js","./transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/render/canvas/Executor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Instruction = _interopRequireDefault(require("./Instruction.js"));
var _TextBuilder = require("./TextBuilder.js");
var _transform = require("../../transform.js");
var _extent = require("../../extent.js");
var _canvas = require("../canvas.js");
var _textpath = require("../../geom/flat/textpath.js");
var _array = require("../../array.js");
var _length = require("../../geom/flat/length.js");
var _transform2 = require("../../geom/flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/render/canvas/Executor
 */
/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = (0, _extent.createEmpty)();

/** @type {import("../../coordinate.js").Coordinate} */
var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var p4 = [];

/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp( /* eslint-disable prettier/prettier */
'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'
/* eslint-enable prettier/prettier */);

/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */
function horizontalTextAlign(text, align) {
  if (align === 'start') {
    align = rtlRegEx.test(text) ? 'right' : 'left';
  } else if (align === 'end') {
    align = rtlRegEx.test(text) ? 'left' : 'right';
  }
  return _TextBuilder.TEXT_ALIGN[align];
}

/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push('\n', '');
  }
  acc.push(line, '');
  return acc;
}
var Executor = /*#__PURE__*/function () {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  function Executor(resolution, pixelRatio, overlaps, instructions) {
    _classCallCheck(this, Executor);
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = instructions.instructions;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = instructions.coordinates;

    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    this.renderedTransform_ = (0, _transform.create)();

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = instructions.fillStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = instructions.strokeStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = instructions.textStates || {};

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.widths_ = {};

    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */
    this.labels_ = {};
  }

  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  _createClass(Executor, [{
    key: "createLabel",
    value: function createLabel(text, textKey, fillKey, strokeKey) {
      var key = text + textKey + fillKey + strokeKey;
      if (this.labels_[key]) {
        return this.labels_[key];
      }
      var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
      var fillState = fillKey ? this.fillStates[fillKey] : null;
      var textState = this.textStates[textKey];
      var pixelRatio = this.pixelRatio;
      var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];
      var textIsArray = Array.isArray(text);
      var align = textState.justify ? _TextBuilder.TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || _canvas.defaultTextAlign);
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
      var chunks = textIsArray ? text : text.split('\n').reduce(createTextChunks, []);
      var _getTextDimensions = (0, _canvas.getTextDimensions)(textState, chunks),
        width = _getTextDimensions.width,
        height = _getTextDimensions.height,
        widths = _getTextDimensions.widths,
        heights = _getTextDimensions.heights,
        lineWidths = _getTextDimensions.lineWidths;
      var renderWidth = width + strokeWidth;
      var contextInstructions = [];
      // make canvas 2 pixels wider to account for italic text width measurement errors
      var w = (renderWidth + 2) * scale[0];
      var h = (height + strokeWidth) * scale[1];
      /** @type {import("../canvas.js").Label} */
      var label = {
        width: w < 0 ? Math.floor(w) : Math.ceil(w),
        height: h < 0 ? Math.floor(h) : Math.ceil(h),
        contextInstructions: contextInstructions
      };
      if (scale[0] != 1 || scale[1] != 1) {
        contextInstructions.push('scale', scale);
      }
      if (strokeKey) {
        contextInstructions.push('strokeStyle', strokeState.strokeStyle);
        contextInstructions.push('lineWidth', strokeWidth);
        contextInstructions.push('lineCap', strokeState.lineCap);
        contextInstructions.push('lineJoin', strokeState.lineJoin);
        contextInstructions.push('miterLimit', strokeState.miterLimit);
        contextInstructions.push('setLineDash', [strokeState.lineDash]);
        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
      }
      if (fillKey) {
        contextInstructions.push('fillStyle', fillState.fillStyle);
      }
      contextInstructions.push('textBaseline', 'middle');
      contextInstructions.push('textAlign', 'center');
      var leftRight = 0.5 - align;
      var x = align * renderWidth + leftRight * strokeWidth;
      var strokeInstructions = [];
      var fillInstructions = [];
      var lineHeight = 0;
      var lineOffset = 0;
      var widthHeightIndex = 0;
      var lineWidthIndex = 0;
      var previousFont;
      for (var i = 0, ii = chunks.length; i < ii; i += 2) {
        var _text = chunks[i];
        if (_text === '\n') {
          lineOffset += lineHeight;
          lineHeight = 0;
          x = align * renderWidth + leftRight * strokeWidth;
          ++lineWidthIndex;
          continue;
        }
        var font = chunks[i + 1] || textState.font;
        if (font !== previousFont) {
          if (strokeKey) {
            strokeInstructions.push('font', font);
          }
          if (fillKey) {
            fillInstructions.push('font', font);
          }
          previousFont = font;
        }
        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
        var fillStrokeArgs = [_text, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];
        x += widths[widthHeightIndex];
        if (strokeKey) {
          strokeInstructions.push('strokeText', fillStrokeArgs);
        }
        if (fillKey) {
          fillInstructions.push('fillText', fillStrokeArgs);
        }
        ++widthHeightIndex;
      }
      Array.prototype.push.apply(contextInstructions, strokeInstructions);
      Array.prototype.push.apply(contextInstructions, fillInstructions);
      this.labels_[key] = label;
      return label;
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
  }, {
    key: "replayTextBackground_",
    value: function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
      context.beginPath();
      context.moveTo.apply(context, p1);
      context.lineTo.apply(context, p2);
      context.lineTo.apply(context, p3);
      context.lineTo.apply(context, p4);
      context.lineTo.apply(context, p1);
      if (fillInstruction) {
        this.alignFill_ = /** @type {boolean} */fillInstruction[2];
        this.fill_(context);
      }
      if (strokeInstruction) {
        this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);
        context.stroke();
      }
    }

    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
  }, {
    key: "calculateImageOrLabelDimensions_",
    value: function calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
      anchorX *= scale[0];
      anchorY *= scale[1];
      var x = centerX - anchorX;
      var y = centerY - anchorY;
      var w = width + originX > sheetWidth ? sheetWidth - originX : width;
      var h = height + originY > sheetHeight ? sheetHeight - originY : height;
      var boxW = padding[3] + w * scale[0] + padding[1];
      var boxH = padding[0] + h * scale[1] + padding[2];
      var boxX = x - padding[3];
      var boxY = y - padding[0];
      if (fillStroke || rotation !== 0) {
        p1[0] = boxX;
        p4[0] = boxX;
        p1[1] = boxY;
        p2[1] = boxY;
        p2[0] = boxX + boxW;
        p3[0] = p2[0];
        p3[1] = boxY + boxH;
        p4[1] = p3[1];
      }
      var transform;
      if (rotation !== 0) {
        transform = (0, _transform.compose)((0, _transform.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        (0, _transform.apply)(transform, p1);
        (0, _transform.apply)(transform, p2);
        (0, _transform.apply)(transform, p3);
        (0, _transform.apply)(transform, p4);
        (0, _extent.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
      } else {
        (0, _extent.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
      }
      if (snapToPixel) {
        x = Math.round(x);
        y = Math.round(y);
      }
      return {
        drawImageX: x,
        drawImageY: y,
        drawImageW: w,
        drawImageH: h,
        originX: originX,
        originY: originY,
        declutterBox: {
          minX: tmpExtent[0],
          minY: tmpExtent[1],
          maxX: tmpExtent[2],
          maxY: tmpExtent[3],
          value: feature
        },
        canvasTransform: transform,
        scale: scale
      };
    }

    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
  }, {
    key: "replayImageOrLabel_",
    value: function replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
      var fillStroke = !!(fillInstruction || strokeInstruction);
      var box = dimensions.declutterBox;
      var canvas = context.canvas;
      var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
      var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
      if (intersects) {
        if (fillStroke) {
          this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction);
        }
        (0, _canvas.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
      }
      return true;
    }

    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
  }, {
    key: "fill_",
    value: function fill_(context) {
      if (this.alignFill_) {
        var origin = (0, _transform.apply)(this.renderedTransform_, [0, 0]);
        var repeatSize = 512 * this.pixelRatio;
        context.save();
        context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
        context.rotate(this.viewRotation_);
      }
      context.fill();
      if (this.alignFill_) {
        context.restore();
      }
    }

    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
  }, {
    key: "setStrokeStyle_",
    value: function setStrokeStyle_(context, instruction) {
      context['strokeStyle'] = /** @type {import("../../colorlike.js").ColorLike} */instruction[1];
      context.lineWidth = /** @type {number} */instruction[2];
      context.lineCap = /** @type {CanvasLineCap} */instruction[3];
      context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];
      context.miterLimit = /** @type {number} */instruction[5];
      context.lineDashOffset = /** @type {number} */instruction[7];
      context.setLineDash( /** @type {Array<number>} */instruction[6]);
    }

    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
  }, {
    key: "drawLabelWithPointPlacement_",
    value: function drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
      var textState = this.textStates[textKey];
      var label = this.createLabel(text, textKey, fillKey, strokeKey);
      var strokeState = this.strokeStates[strokeKey];
      var pixelRatio = this.pixelRatio;
      var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || _canvas.defaultTextAlign);
      var baseline = _TextBuilder.TEXT_ALIGN[textState.textBaseline || _canvas.defaultTextBaseline];
      var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

      // Remove the 2 pixels we added in createLabel() for the anchor
      var width = label.width / pixelRatio - 2 * textState.scale[0];
      var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
      var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
      return {
        label: label,
        anchorX: anchorX,
        anchorY: anchorY
      };
    }

    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "execute_",
    value: function execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
      /** @type {Array<number>} */
      var pixelCoordinates;
      if (this.pixelCoordinates_ && (0, _array.equals)(transform, this.renderedTransform_)) {
        pixelCoordinates = this.pixelCoordinates_;
      } else {
        if (!this.pixelCoordinates_) {
          this.pixelCoordinates_ = [];
        }
        pixelCoordinates = (0, _transform2.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
        (0, _transform.setFromArray)(this.renderedTransform_, transform);
      }
      var i = 0; // instruction index
      var ii = instructions.length; // end of instructions
      var d = 0; // data index
      var dd; // end of per-instruction data
      var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
      var pendingFill = 0;
      var pendingStroke = 0;
      var lastFillInstruction = null;
      var lastStrokeInstruction = null;
      var coordinateCache = this.coordinateCache_;
      var viewRotation = this.viewRotation_;
      var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
      var state = /** @type {import("../../render.js").State} */{
        context: context,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: viewRotation
      };

      // When the batch size gets too big, performance decreases. 200 is a good
      // balance between batch size and number of fill/stroke instructions.
      var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
      var /** @type {import("../../Feature.js").FeatureLike} */feature;
      var x, y, currentGeometry;
      while (i < ii) {
        var instruction = instructions[i];
        var type = /** @type {import("./Instruction.js").default} */
        instruction[0];
        switch (type) {
          case _Instruction.default.BEGIN_GEOMETRY:
            feature = /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            currentGeometry = instruction[3];
            if (!feature.getGeometry()) {
              i = /** @type {number} */instruction[2];
            } else if (hitExtent !== undefined && !(0, _extent.intersects)(hitExtent, currentGeometry.getExtent())) {
              i = /** @type {number} */instruction[2] + 1;
            } else {
              ++i;
            }
            break;
          case _Instruction.default.BEGIN_PATH:
            if (pendingFill > batchSize) {
              this.fill_(context);
              pendingFill = 0;
            }
            if (pendingStroke > batchSize) {
              context.stroke();
              pendingStroke = 0;
            }
            if (!pendingFill && !pendingStroke) {
              context.beginPath();
              prevX = NaN;
              prevY = NaN;
            }
            ++i;
            break;
          case _Instruction.default.CIRCLE:
            d = /** @type {number} */instruction[1];
            var x1 = pixelCoordinates[d];
            var y1 = pixelCoordinates[d + 1];
            var x2 = pixelCoordinates[d + 2];
            var y2 = pixelCoordinates[d + 3];
            var dx = x2 - x1;
            var dy = y2 - y1;
            var r = Math.sqrt(dx * dx + dy * dy);
            context.moveTo(x1 + r, y1);
            context.arc(x1, y1, r, 0, 2 * Math.PI, true);
            ++i;
            break;
          case _Instruction.default.CLOSE_PATH:
            context.closePath();
            ++i;
            break;
          case _Instruction.default.CUSTOM:
            d = /** @type {number} */instruction[1];
            dd = instruction[2];
            var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */
            instruction[3];
            var renderer = instruction[4];
            var fn = instruction.length == 6 ? instruction[5] : undefined;
            state.geometry = geometry;
            state.feature = feature;
            if (!(i in coordinateCache)) {
              coordinateCache[i] = [];
            }
            var coords = coordinateCache[i];
            if (fn) {
              fn(pixelCoordinates, d, dd, 2, coords);
            } else {
              coords[0] = pixelCoordinates[d];
              coords[1] = pixelCoordinates[d + 1];
              coords.length = 2;
            }
            renderer(coords, state);
            ++i;
            break;
          case _Instruction.default.DRAW_IMAGE:
            d = /** @type {number} */instruction[1];
            dd = /** @type {number} */instruction[2];
            image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            instruction[3];

            // Remaining arguments in DRAW_IMAGE are in alphabetical order
            anchorX = /** @type {number} */instruction[4];
            anchorY = /** @type {number} */instruction[5];
            var height = /** @type {number} */instruction[6];
            var opacity = /** @type {number} */instruction[7];
            var originX = /** @type {number} */instruction[8];
            var originY = /** @type {number} */instruction[9];
            var rotateWithView = /** @type {boolean} */instruction[10];
            var rotation = /** @type {number} */instruction[11];
            var scale = /** @type {import("../../size.js").Size} */
            instruction[12];
            var width = /** @type {number} */instruction[13];
            var declutterMode = /** @type {"declutter"|"obstacle"|"none"|undefined} */
            instruction[14];
            var declutterImageWithText = /** @type {import("../canvas.js").DeclutterImageWithText} */
            instruction[15];
            if (!image && instruction.length >= 20) {
              // create label images
              text = /** @type {string} */instruction[19];
              textKey = /** @type {string} */instruction[20];
              strokeKey = /** @type {string} */instruction[21];
              fillKey = /** @type {string} */instruction[22];
              var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
              image = labelWithAnchor.label;
              instruction[3] = image;
              var textOffsetX = /** @type {number} */instruction[23];
              anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
              instruction[4] = anchorX;
              var textOffsetY = /** @type {number} */instruction[24];
              anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
              instruction[5] = anchorY;
              height = image.height;
              instruction[6] = height;
              width = image.width;
              instruction[13] = width;
            }
            var geometryWidths = void 0;
            if (instruction.length > 25) {
              geometryWidths = /** @type {number} */instruction[25];
            }
            var padding = void 0,
              backgroundFill = void 0,
              backgroundStroke = void 0;
            if (instruction.length > 17) {
              padding = /** @type {Array<number>} */instruction[16];
              backgroundFill = /** @type {boolean} */instruction[17];
              backgroundStroke = /** @type {boolean} */instruction[18];
            } else {
              padding = _canvas.defaultPadding;
              backgroundFill = false;
              backgroundStroke = false;
            }
            if (rotateWithView && viewRotationFromTransform) {
              // Canvas is expected to be rotated to reverse view rotation.
              rotation += viewRotation;
            } else if (!rotateWithView && !viewRotationFromTransform) {
              // Canvas is not rotated, images need to be rotated back to be north-up.
              rotation -= viewRotation;
            }
            var widthIndex = 0;
            for (; d < dd; d += 2) {
              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                continue;
              }
              var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
              /** @type {ReplayImageOrLabelArgs} */
              var args = [context, contextScale, image, dimensions, opacity, backgroundFill ? ( /** @type {Array<*>} */lastFillInstruction) : null, backgroundStroke ? ( /** @type {Array<*>} */lastStrokeInstruction) : null];
              if (declutterTree) {
                if (declutterMode === 'none') {
                  // not rendered in declutter group
                  continue;
                } else if (declutterMode === 'obstacle') {
                  // will always be drawn, thus no collision detection, but insert as obstacle
                  declutterTree.insert(dimensions.declutterBox);
                  continue;
                } else {
                  var imageArgs = void 0;
                  var imageDeclutterBox = void 0;
                  if (declutterImageWithText) {
                    var index = dd - d;
                    if (!declutterImageWithText[index]) {
                      // We now have the image for an image+text combination.
                      declutterImageWithText[index] = args;
                      // Don't render anything for now, wait for the text.
                      continue;
                    }
                    imageArgs = declutterImageWithText[index];
                    delete declutterImageWithText[index];
                    imageDeclutterBox = getDeclutterBox(imageArgs);
                    if (declutterTree.collides(imageDeclutterBox)) {
                      continue;
                    }
                  }
                  if (declutterTree.collides(dimensions.declutterBox)) {
                    continue;
                  }
                  if (imageArgs) {
                    // We now have image and text for an image+text combination.
                    declutterTree.insert(imageDeclutterBox);
                    // Render the image before we render the text.
                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }
                  declutterTree.insert(dimensions.declutterBox);
                }
              }
              this.replayImageOrLabel_.apply(this, args);
            }
            ++i;
            break;
          case _Instruction.default.DRAW_CHARS:
            var begin = /** @type {number} */instruction[1];
            var end = /** @type {number} */instruction[2];
            var baseline = /** @type {number} */instruction[3];
            var overflow = /** @type {number} */instruction[4];
            fillKey = /** @type {string} */instruction[5];
            var maxAngle = /** @type {number} */instruction[6];
            var measurePixelRatio = /** @type {number} */instruction[7];
            var offsetY = /** @type {number} */instruction[8];
            strokeKey = /** @type {string} */instruction[9];
            var strokeWidth = /** @type {number} */instruction[10];
            text = /** @type {string} */instruction[11];
            textKey = /** @type {string} */instruction[12];
            var pixelRatioScale = [( /** @type {number} */instruction[13]), ( /** @type {number} */instruction[13])];
            var textState = this.textStates[textKey];
            var font = textState.font;
            var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];
            var cachedWidths = void 0;
            if (font in this.widths_) {
              cachedWidths = this.widths_[font];
            } else {
              cachedWidths = {};
              this.widths_[font] = cachedWidths;
            }
            var pathLength = (0, _length.lineStringLength)(pixelCoordinates, begin, end, 2);
            var textLength = Math.abs(textScale[0]) * (0, _canvas.measureAndCacheTextWidth)(font, text, cachedWidths);
            if (overflow || textLength <= pathLength) {
              var textAlign = this.textStates[textKey].textAlign;
              var startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
              var parts = (0, _textpath.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), _canvas.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
              drawChars: if (parts) {
                /** @type {Array<ReplayImageOrLabelArgs>} */
                var replayImageOrLabelArgs = [];
                var c = void 0,
                  cc = void 0,
                  chars = void 0,
                  label = void 0,
                  part = void 0;
                if (strokeKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c]; // x, y, anchorX, rotation, chunk
                    chars = /** @type {string} */part[4];
                    label = this.createLabel(chars, textKey, '', strokeKey);
                    anchorX = /** @type {number} */part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                    var _dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas.defaultPadding, false, feature);
                    if (declutterTree && declutterTree.collides(_dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions, 1, null, null]);
                  }
                }
                if (fillKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c]; // x, y, anchorX, rotation, chunk
                    chars = /** @type {string} */part[4];
                    label = this.createLabel(chars, textKey, fillKey, '');
                    anchorX = /** @type {number} */part[2];
                    anchorY = baseline * label.height - offsetY;
                    var _dimensions2 = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas.defaultPadding, false, feature);
                    if (declutterTree && declutterTree.collides(_dimensions2.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions2, 1, null, null]);
                  }
                }
                if (declutterTree) {
                  declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                }
                for (var _i = 0, _ii = replayImageOrLabelArgs.length; _i < _ii; ++_i) {
                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[_i]);
                }
              }
            }
            ++i;
            break;
          case _Instruction.default.END_GEOMETRY:
            if (featureCallback !== undefined) {
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              var result = featureCallback(feature, currentGeometry);
              if (result) {
                return result;
              }
            }
            ++i;
            break;
          case _Instruction.default.FILL:
            if (batchSize) {
              pendingFill++;
            } else {
              this.fill_(context);
            }
            ++i;
            break;
          case _Instruction.default.MOVE_TO_LINE_TO:
            d = /** @type {number} */instruction[1];
            dd = /** @type {number} */instruction[2];
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;
            if (roundX !== prevX || roundY !== prevY) {
              context.moveTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
            for (d += 2; d < dd; d += 2) {
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = x + 0.5 | 0;
              roundY = y + 0.5 | 0;
              if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                context.lineTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
            }
            ++i;
            break;
          case _Instruction.default.SET_FILL_STYLE:
            lastFillInstruction = instruction;
            this.alignFill_ = instruction[2];
            if (pendingFill) {
              this.fill_(context);
              pendingFill = 0;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
            }
            context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
            instruction[1];
            ++i;
            break;
          case _Instruction.default.SET_STROKE_STYLE:
            lastStrokeInstruction = instruction;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
            this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);
            ++i;
            break;
          case _Instruction.default.STROKE:
            if (batchSize) {
              pendingStroke++;
            } else {
              context.stroke();
            }
            ++i;
            break;
          default:
            // consume the instruction anyway, to avoid an infinite loop
            ++i;
            break;
        }
      }
      if (pendingFill) {
        this.fill_(context);
      }
      if (pendingStroke) {
        context.stroke();
      }
      return undefined;
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */
  }, {
    key: "execute",
    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {
      this.viewRotation_ = viewRotation;
      this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "executeHitDetection",
    value: function executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
      this.viewRotation_ = viewRotation;
      return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);
    }
  }]);
  return Executor;
}();
var _default = exports.default = Executor;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../canvas.js":"node_modules/ol/render/canvas.js","../../geom/flat/textpath.js":"node_modules/ol/geom/flat/textpath.js","../../array.js":"node_modules/ol/array.js","../../geom/flat/length.js":"node_modules/ol/geom/flat/length.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/render/canvas/ExecutorGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getPixelIndexArray = getPixelIndexArray;
var _Executor = _interopRequireDefault(require("./Executor.js"));
var _array = require("../../array.js");
var _extent = require("../../extent.js");
var _transform = require("../../transform.js");
var _dom = require("../../dom.js");
var _obj = require("../../obj.js");
var _transform2 = require("../../geom/flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/render/canvas/ExecutorGroup
 */
/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */
var ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];
var ExecutorGroup = /*#__PURE__*/function () {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
    _classCallCheck(this, ExecutorGroup);
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = renderBuffer;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */
    this.executorsByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.hitDetectionTransform_ = (0, _transform.create)();
    this.createExecutors_(allInstructions);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  _createClass(ExecutorGroup, [{
    key: "clip",
    value: function clip(context, transform) {
      var flatClipCoords = this.getClipCoords(transform);
      context.beginPath();
      context.moveTo(flatClipCoords[0], flatClipCoords[1]);
      context.lineTo(flatClipCoords[2], flatClipCoords[3]);
      context.lineTo(flatClipCoords[4], flatClipCoords[5]);
      context.lineTo(flatClipCoords[6], flatClipCoords[7]);
      context.clip();
    }

    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     */
  }, {
    key: "createExecutors_",
    value: function createExecutors_(allInstructions) {
      for (var zIndex in allInstructions) {
        var executors = this.executorsByZIndex_[zIndex];
        if (executors === undefined) {
          executors = {};
          this.executorsByZIndex_[zIndex] = executors;
        }
        var instructionByZindex = allInstructions[zIndex];
        for (var builderType in instructionByZindex) {
          var instructions = instructionByZindex[builderType];
          executors[builderType] = new _Executor.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
        }
      }
    }

    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
  }, {
    key: "hasExecutors",
    value: function hasExecutors(executors) {
      for (var zIndex in this.executorsByZIndex_) {
        var candidates = this.executorsByZIndex_[zIndex];
        for (var i = 0, ii = executors.length; i < ii; ++i) {
          if (executors[i] in candidates) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
      hitTolerance = Math.round(hitTolerance);
      var contextSize = hitTolerance * 2 + 1;
      var transform = (0, _transform.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
      var newContext = !this.hitDetectionContext_;
      if (newContext) {
        this.hitDetectionContext_ = (0, _dom.createCanvasContext2D)(contextSize, contextSize, undefined, {
          willReadFrequently: true
        });
      }
      var context = this.hitDetectionContext_;
      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
        context.canvas.width = contextSize;
        context.canvas.height = contextSize;
      } else if (!newContext) {
        context.clearRect(0, 0, contextSize, contextSize);
      }

      /**
       * @type {import("../../extent.js").Extent}
       */
      var hitExtent;
      if (this.renderBuffer_ !== undefined) {
        hitExtent = (0, _extent.createEmpty)();
        (0, _extent.extendCoordinate)(hitExtent, coordinate);
        (0, _extent.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
      }
      var indexes = getPixelIndexArray(hitTolerance);
      var builderType;

      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @return {T|undefined} Callback result.
       */
      function featureCallback(feature, geometry) {
        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
        for (var _i = 0, ii = indexes.length; _i < ii; _i++) {
          if (imageData[indexes[_i]] > 0) {
            if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {
              var idx = (indexes[_i] - 3) / 4;
              var x = hitTolerance - idx % contextSize;
              var y = hitTolerance - (idx / contextSize | 0);
              var _result = callback(feature, geometry, x * x + y * y);
              if (_result) {
                return _result;
              }
            }
            context.clearRect(0, 0, contextSize, contextSize);
            break;
          }
        }
        return undefined;
      }

      /** @type {Array<number>} */
      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(_array.ascending);
      var i, j, executors, executor, result;
      for (i = zs.length - 1; i >= 0; --i) {
        var zIndexKey = zs[i].toString();
        executors = this.executorsByZIndex_[zIndexKey];
        for (j = ORDER.length - 1; j >= 0; --j) {
          builderType = ORDER[j];
          executor = executors[builderType];
          if (executor !== undefined) {
            result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
            if (result) {
              return result;
            }
          }
        }
      }
      return undefined;
    }

    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
  }, {
    key: "getClipCoords",
    value: function getClipCoords(transform) {
      var maxExtent = this.maxExtent_;
      if (!maxExtent) {
        return null;
      }
      var minX = maxExtent[0];
      var minY = maxExtent[1];
      var maxX = maxExtent[2];
      var maxY = maxExtent[3];
      var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
      (0, _transform2.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
      return flatClipCoords;
    }

    /**
     * @return {boolean} Is empty.
     */
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return (0, _obj.isEmpty)(this.executorsByZIndex_);
    }

    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ORDER}
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */
  }, {
    key: "execute",
    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
      /** @type {Array<number>} */
      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(_array.ascending);

      // setup clipping so that the parts of over-simplified geometries are not
      // visible outside the current extent when panning
      if (this.maxExtent_) {
        context.save();
        this.clip(context, transform);
      }
      builderTypes = builderTypes ? builderTypes : ORDER;
      var i, ii, j, jj, replays, replay;
      if (declutterTree) {
        zs.reverse();
      }
      for (i = 0, ii = zs.length; i < ii; ++i) {
        var zIndexKey = zs[i].toString();
        replays = this.executorsByZIndex_[zIndexKey];
        for (j = 0, jj = builderTypes.length; j < jj; ++j) {
          var builderType = builderTypes[j];
          replay = replays[builderType];
          if (replay !== undefined) {
            replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);
          }
        }
      }
      if (this.maxExtent_) {
        context.restore();
      }
    }
  }]);
  return ExecutorGroup;
}();
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */
var circlePixelIndexArrayCache = {};

/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }
  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);
  for (var i = 0; i <= radius; ++i) {
    for (var j = 0; j <= radius; ++j) {
      var distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      var distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  var pixelIndex = [];
  for (var _i2 = 0, ii = distances.length; _i2 < ii; ++_i2) {
    if (distances[_i2]) {
      pixelIndex.push.apply(pixelIndex, _toConsumableArray(distances[_i2]));
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var _default = exports.default = ExecutorGroup;
},{"./Executor.js":"node_modules/ol/render/canvas/Executor.js","../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js","../../transform.js":"node_modules/ol/transform.js","../../dom.js":"node_modules/ol/dom.js","../../obj.js":"node_modules/ol/obj.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/render/canvas/Immediate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _VectorContext2 = _interopRequireDefault(require("../VectorContext.js"));
var _colorlike = require("../../colorlike.js");
var _transform = require("../../transform.js");
var _canvas = require("../canvas.js");
var _array = require("../../array.js");
var _extent = require("../../extent.js");
var _math = require("../../math.js");
var _transform2 = require("../../geom/flat/transform.js");
var _SimpleGeometry = require("../../geom/SimpleGeometry.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/canvas/Immediate
 */ // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer = /*#__PURE__*/function (_VectorContext) {
  _inherits(CanvasImmediateRenderer, _VectorContext);
  var _super = _createSuper(CanvasImmediateRenderer);
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform) {
    var _this;
    _classCallCheck(this, CanvasImmediateRenderer);
    _this = _super.call(this);

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    _this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    _this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    _this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    _this.transformRotation_ = transform ? (0, _math.toFixed)(Math.atan2(transform[1], transform[0]), 10) : 0;

    /**
     * @private
     * @type {number}
     */
    _this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {number}
     */
    _this.squaredTolerance_ = squaredTolerance;

    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */
    _this.userTransform_ = userTransform;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    _this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    _this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    _this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    _this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    _this.strokeState_ = null;

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    _this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    _this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    _this.imageRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    _this.imageScale_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    _this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    _this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    _this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    _this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    _this.textRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    _this.textScale_ = [0, 0];

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    _this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    _this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    _this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    _this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.tmpLocalTransform_ = (0, _transform.create)();
    return _this;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  _createClass(CanvasImmediateRenderer, [{
    key: "drawImages_",
    value: function drawImages_(flatCoordinates, offset, end, stride) {
      if (!this.image_) {
        return;
      }
      var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      var context = this.context_;
      var localTransform = this.tmpLocalTransform_;
      var alpha = context.globalAlpha;
      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha * this.imageOpacity_;
      }
      var rotation = this.imageRotation_;
      if (this.transformRotation_ === 0) {
        rotation -= this.viewRotation_;
      }
      if (this.imageRotateWithView_) {
        rotation += this.viewRotation_;
      }
      for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
        var x = pixelCoordinates[i] - this.imageAnchorX_;
        var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
        if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          var centerX = x + this.imageAnchorX_;
          var centerY = y + this.imageAnchorY_;
          (0, _transform.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
          context.save();
          context.transform.apply(context, localTransform);
          context.translate(centerX, centerY);
          context.scale(this.imageScale_[0], this.imageScale_[1]);
          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
          context.restore();
        } else {
          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
      }
      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha;
      }
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
  }, {
    key: "drawText_",
    value: function drawText_(flatCoordinates, offset, end, stride) {
      if (!this.textState_ || this.text_ === '') {
        return;
      }
      if (this.textFillState_) {
        this.setContextFillState_(this.textFillState_);
      }
      if (this.textStrokeState_) {
        this.setContextStrokeState_(this.textStrokeState_);
      }
      this.setContextTextState_(this.textState_);
      var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      var context = this.context_;
      var rotation = this.textRotation_;
      if (this.transformRotation_ === 0) {
        rotation -= this.viewRotation_;
      }
      if (this.textRotateWithView_) {
        rotation += this.viewRotation_;
      }
      for (; offset < end; offset += stride) {
        var x = pixelCoordinates[offset] + this.textOffsetX_;
        var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
        if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
          context.save();
          context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
          context.rotate(rotation);
          context.translate(this.textOffsetX_, this.textOffsetY_);
          context.scale(this.textScale_[0], this.textScale_[1]);
          if (this.textStrokeState_) {
            context.strokeText(this.text_, 0, 0);
          }
          if (this.textFillState_) {
            context.fillText(this.text_, 0, 0);
          }
          context.restore();
        } else {
          if (this.textStrokeState_) {
            context.strokeText(this.text_, x, y);
          }
          if (this.textFillState_) {
            context.fillText(this.text_, x, y);
          }
        }
      }
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
  }, {
    key: "moveToLineTo_",
    value: function moveToLineTo_(flatCoordinates, offset, end, stride, close) {
      var context = this.context_;
      var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
      var length = pixelCoordinates.length;
      if (close) {
        length -= 2;
      }
      for (var i = 2; i < length; i += 2) {
        context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
      }
      if (close) {
        context.closePath();
      }
      return end;
    }

    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
  }, {
    key: "drawRings_",
    value: function drawRings_(flatCoordinates, offset, ends, stride) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
      }
      return offset;
    }

    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     */
  }, {
    key: "drawCircle",
    value: function drawCircle(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Circle.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.fillState_ || this.strokeState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        var pixelCoordinates = (0, _SimpleGeometry.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
        var dx = pixelCoordinates[2] - pixelCoordinates[0];
        var dy = pixelCoordinates[3] - pixelCoordinates[1];
        var radius = Math.sqrt(dx * dx + dy * dy);
        var context = this.context_;
        context.beginPath();
        context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== '') {
        this.drawText_(geometry.getCenter(), 0, 2, 2);
      }
    }

    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     */
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.setFillStrokeStyle(style.getFill(), style.getStroke());
      this.setImageStyle(style.getImage());
      this.setTextStyle(style.getText());
    }

    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      this.transform_ = transform;
    }

    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     */
  }, {
    key: "drawGeometry",
    value: function drawGeometry(geometry) {
      var type = geometry.getType();
      switch (type) {
        case 'Point':
          this.drawPoint( /** @type {import("../../geom/Point.js").default} */geometry);
          break;
        case 'LineString':
          this.drawLineString( /** @type {import("../../geom/LineString.js").default} */geometry);
          break;
        case 'Polygon':
          this.drawPolygon( /** @type {import("../../geom/Polygon.js").default} */geometry);
          break;
        case 'MultiPoint':
          this.drawMultiPoint( /** @type {import("../../geom/MultiPoint.js").default} */geometry);
          break;
        case 'MultiLineString':
          this.drawMultiLineString( /** @type {import("../../geom/MultiLineString.js").default} */
          geometry);
          break;
        case 'MultiPolygon':
          this.drawMultiPolygon( /** @type {import("../../geom/MultiPolygon.js").default} */geometry);
          break;
        case 'GeometryCollection':
          this.drawGeometryCollection( /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry);
          break;
        case 'Circle':
          this.drawCircle( /** @type {import("../../geom/Circle.js").default} */geometry);
          break;
        default:
      }
    }

    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     */
  }, {
    key: "drawFeature",
    value: function drawFeature(feature, style) {
      var geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
        return;
      }
      this.setStyle(style);
      this.drawGeometry(geometry);
    }

    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     */
  }, {
    key: "drawGeometryCollection",
    value: function drawGeometryCollection(geometry) {
      var geometries = geometry.getGeometriesArray();
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        this.drawGeometry(geometries[i]);
      }
    }

    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     */
  }, {
    key: "drawPoint",
    value: function drawPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Point.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      var flatCoordinates = geometry.getFlatCoordinates();
      var stride = geometry.getStride();
      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
      if (this.text_ !== '') {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }

    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     */
  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiPoint.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      var flatCoordinates = geometry.getFlatCoordinates();
      var stride = geometry.getStride();
      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
      if (this.text_ !== '') {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }

    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     */
  }, {
    key: "drawLineString",
    value: function drawLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/LineString.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        var context = this.context_;
        var flatCoordinates = geometry.getFlatCoordinates();
        context.beginPath();
        this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
        context.stroke();
      }
      if (this.text_ !== '') {
        var flatMidpoint = geometry.getFlatMidpoint();
        this.drawText_(flatMidpoint, 0, 2, 2);
      }
    }

    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     */
  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      var geometryExtent = geometry.getExtent();
      if (!(0, _extent.intersects)(this.extent_, geometryExtent)) {
        return;
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        var context = this.context_;
        var flatCoordinates = geometry.getFlatCoordinates();
        var offset = 0;
        var ends = /** @type {Array<number>} */geometry.getEnds();
        var stride = geometry.getStride();
        context.beginPath();
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
        }
        context.stroke();
      }
      if (this.text_ !== '') {
        var flatMidpoints = geometry.getFlatMidpoints();
        this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
      }
    }

    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     */
  }, {
    key: "drawPolygon",
    value: function drawPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Polygon.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        var context = this.context_;
        context.beginPath();
        this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, /** @type {Array<number>} */geometry.getEnds(), geometry.getStride());
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== '') {
        var flatInteriorPoint = geometry.getFlatInteriorPoint();
        this.drawText_(flatInteriorPoint, 0, 2, 2);
      }
    }

    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     */
  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }
      if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        var context = this.context_;
        var flatCoordinates = geometry.getOrientedFlatCoordinates();
        var offset = 0;
        var endss = geometry.getEndss();
        var stride = geometry.getStride();
        context.beginPath();
        for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          offset = this.drawRings_(flatCoordinates, offset, ends, stride);
        }
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== '') {
        var flatInteriorPoints = geometry.getFlatInteriorPoints();
        this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
      }
    }

    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
  }, {
    key: "setContextFillState_",
    value: function setContextFillState_(fillState) {
      var context = this.context_;
      var contextFillState = this.contextFillState_;
      if (!contextFillState) {
        context.fillStyle = fillState.fillStyle;
        this.contextFillState_ = {
          fillStyle: fillState.fillStyle
        };
      } else {
        if (contextFillState.fillStyle != fillState.fillStyle) {
          contextFillState.fillStyle = fillState.fillStyle;
          context.fillStyle = fillState.fillStyle;
        }
      }
    }

    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
  }, {
    key: "setContextStrokeState_",
    value: function setContextStrokeState_(strokeState) {
      var context = this.context_;
      var contextStrokeState = this.contextStrokeState_;
      if (!contextStrokeState) {
        context.lineCap = strokeState.lineCap;
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
        context.lineJoin = strokeState.lineJoin;
        context.lineWidth = strokeState.lineWidth;
        context.miterLimit = strokeState.miterLimit;
        context.strokeStyle = strokeState.strokeStyle;
        this.contextStrokeState_ = {
          lineCap: strokeState.lineCap,
          lineDash: strokeState.lineDash,
          lineDashOffset: strokeState.lineDashOffset,
          lineJoin: strokeState.lineJoin,
          lineWidth: strokeState.lineWidth,
          miterLimit: strokeState.miterLimit,
          strokeStyle: strokeState.strokeStyle
        };
      } else {
        if (contextStrokeState.lineCap != strokeState.lineCap) {
          contextStrokeState.lineCap = strokeState.lineCap;
          context.lineCap = strokeState.lineCap;
        }
        if (!(0, _array.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
        if (contextStrokeState.lineJoin != strokeState.lineJoin) {
          contextStrokeState.lineJoin = strokeState.lineJoin;
          context.lineJoin = strokeState.lineJoin;
        }
        if (contextStrokeState.lineWidth != strokeState.lineWidth) {
          contextStrokeState.lineWidth = strokeState.lineWidth;
          context.lineWidth = strokeState.lineWidth;
        }
        if (contextStrokeState.miterLimit != strokeState.miterLimit) {
          contextStrokeState.miterLimit = strokeState.miterLimit;
          context.miterLimit = strokeState.miterLimit;
        }
        if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
          contextStrokeState.strokeStyle = strokeState.strokeStyle;
          context.strokeStyle = strokeState.strokeStyle;
        }
      }
    }

    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
  }, {
    key: "setContextTextState_",
    value: function setContextTextState_(textState) {
      var context = this.context_;
      var contextTextState = this.contextTextState_;
      var textAlign = textState.textAlign ? textState.textAlign : _canvas.defaultTextAlign;
      if (!contextTextState) {
        context.font = textState.font;
        context.textAlign = textAlign;
        context.textBaseline = textState.textBaseline;
        this.contextTextState_ = {
          font: textState.font,
          textAlign: textAlign,
          textBaseline: textState.textBaseline
        };
      } else {
        if (contextTextState.font != textState.font) {
          contextTextState.font = textState.font;
          context.font = textState.font;
        }
        if (contextTextState.textAlign != textAlign) {
          contextTextState.textAlign = textAlign;
          context.textAlign = textAlign;
        }
        if (contextTextState.textBaseline != textState.textBaseline) {
          contextTextState.textBaseline = textState.textBaseline;
          context.textBaseline = textState.textBaseline;
        }
      }
    }

    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {
      var _this2 = this;
      if (!fillStyle) {
        this.fillState_ = null;
      } else {
        var fillStyleColor = fillStyle.getColor();
        this.fillState_ = {
          fillStyle: (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle)
        };
      }
      if (!strokeStyle) {
        this.strokeState_ = null;
      } else {
        var strokeStyleColor = strokeStyle.getColor();
        var strokeStyleLineCap = strokeStyle.getLineCap();
        var strokeStyleLineDash = strokeStyle.getLineDash();
        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        var strokeStyleWidth = strokeStyle.getWidth();
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        var lineDash = strokeStyleLineDash ? strokeStyleLineDash : _canvas.defaultLineDash;
        this.strokeState_ = {
          lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap,
          lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function (n) {
            return n * _this2.pixelRatio_;
          }),
          lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset) * this.pixelRatio_,
          lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin,
          lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth) * this.pixelRatio_,
          miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit,
          strokeStyle: (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle)
        };
      }
    }

    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     */
  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle) {
      var imageSize;
      if (!imageStyle || !(imageSize = imageStyle.getSize())) {
        this.image_ = null;
        return;
      }
      var imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
      var imageAnchor = imageStyle.getAnchor();
      var imageOrigin = imageStyle.getOrigin();
      this.image_ = imageStyle.getImage(this.pixelRatio_);
      this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
      this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
      this.imageHeight_ = imageSize[1] * imagePixelRatio;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      var imageScale = imageStyle.getScaleArray();
      this.imageScale_ = [imageScale[0] * this.pixelRatio_ / imagePixelRatio, imageScale[1] * this.pixelRatio_ / imagePixelRatio];
      this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }

    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     */
  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle) {
      if (!textStyle) {
        this.text_ = '';
      } else {
        var textFillStyle = textStyle.getFill();
        if (!textFillStyle) {
          this.textFillState_ = null;
        } else {
          var textFillStyleColor = textFillStyle.getColor();
          this.textFillState_ = {
            fillStyle: (0, _colorlike.asColorLike)(textFillStyleColor ? textFillStyleColor : _canvas.defaultFillStyle)
          };
        }
        var textStrokeStyle = textStyle.getStroke();
        if (!textStrokeStyle) {
          this.textStrokeState_ = null;
        } else {
          var textStrokeStyleColor = textStrokeStyle.getColor();
          var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
          var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
          var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
          var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
          var textStrokeStyleWidth = textStrokeStyle.getWidth();
          var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas.defaultLineCap,
            lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas.defaultLineDash,
            lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas.defaultLineDashOffset,
            lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas.defaultLineJoin,
            lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas.defaultLineWidth,
            miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas.defaultMiterLimit,
            strokeStyle: (0, _colorlike.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : _canvas.defaultStrokeStyle)
          };
        }
        var textFont = textStyle.getFont();
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotateWithView = textStyle.getRotateWithView();
        var textRotation = textStyle.getRotation();
        var textScale = textStyle.getScaleArray();
        var textText = textStyle.getText();
        var textTextAlign = textStyle.getTextAlign();
        var textTextBaseline = textStyle.getTextBaseline();
        this.textState_ = {
          font: textFont !== undefined ? textFont : _canvas.defaultFont,
          textAlign: textTextAlign !== undefined ? textTextAlign : _canvas.defaultTextAlign,
          textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas.defaultTextBaseline
        };
        this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce(function (acc, t, i) {
          return acc += i % 2 ? ' ' : t;
        }, '') : textText : '';
        this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
        this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
        this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
        this.textRotation_ = textRotation !== undefined ? textRotation : 0;
        this.textScale_ = [this.pixelRatio_ * textScale[0], this.pixelRatio_ * textScale[1]];
      }
    }
  }]);
  return CanvasImmediateRenderer;
}(_VectorContext2.default);
var _default = exports.default = CanvasImmediateRenderer;
},{"../VectorContext.js":"node_modules/ol/render/VectorContext.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../transform.js":"node_modules/ol/transform.js","../canvas.js":"node_modules/ol/render/canvas.js","../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js","../../math.js":"node_modules/ol/math.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js","../../geom/SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js"}],"node_modules/ol/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _Circle.default;
  }
});
Object.defineProperty(exports, "Fill", {
  enumerable: true,
  get: function () {
    return _Fill.default;
  }
});
Object.defineProperty(exports, "Icon", {
  enumerable: true,
  get: function () {
    return _Icon.default;
  }
});
Object.defineProperty(exports, "IconImage", {
  enumerable: true,
  get: function () {
    return _IconImage.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "RegularShape", {
  enumerable: true,
  get: function () {
    return _RegularShape.default;
  }
});
Object.defineProperty(exports, "Stroke", {
  enumerable: true,
  get: function () {
    return _Stroke.default;
  }
});
Object.defineProperty(exports, "Style", {
  enumerable: true,
  get: function () {
    return _Style.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _Text.default;
  }
});
var _Circle = _interopRequireDefault(require("./style/Circle.js"));
var _Fill = _interopRequireDefault(require("./style/Fill.js"));
var _Icon = _interopRequireDefault(require("./style/Icon.js"));
var _IconImage = _interopRequireDefault(require("./style/IconImage.js"));
var _Image = _interopRequireDefault(require("./style/Image.js"));
var _RegularShape = _interopRequireDefault(require("./style/RegularShape.js"));
var _Stroke = _interopRequireDefault(require("./style/Stroke.js"));
var _Style = _interopRequireDefault(require("./style/Style.js"));
var _Text = _interopRequireDefault(require("./style/Text.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./style/Circle.js":"node_modules/ol/style/Circle.js","./style/Fill.js":"node_modules/ol/style/Fill.js","./style/Icon.js":"node_modules/ol/style/Icon.js","./style/IconImage.js":"node_modules/ol/style/IconImage.js","./style/Image.js":"node_modules/ol/style/Image.js","./style/RegularShape.js":"node_modules/ol/style/RegularShape.js","./style/Stroke.js":"node_modules/ol/style/Stroke.js","./style/Style.js":"node_modules/ol/style/Style.js","./style/Text.js":"node_modules/ol/style/Text.js"}],"node_modules/ol/render/canvas/hitdetect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HIT_DETECT_RESOLUTION = void 0;
exports.createHitDetectionImageData = createHitDetectionImageData;
exports.hitDetect = hitDetect;
var _Immediate = _interopRequireDefault(require("./Immediate.js"));
var _style = require("../../style.js");
var _array = require("../../array.js");
var _math = require("../../math.js");
var _dom = require("../../dom.js");
var _extent = require("../../extent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/render/canvas/hitdetect
 */

var HIT_DETECT_RESOLUTION = exports.HIT_DETECT_RESOLUTION = 0.5;

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
  var width = size[0] * HIT_DETECT_RESOLUTION;
  var height = size[1] * HIT_DETECT_RESOLUTION;
  var context = (0, _dom.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new _Immediate.default(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
  var featureCount = features.length;
  // Stretch hit detection index to use the whole available color range
  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};
  for (var i = 1; i <= featureCount; ++i) {
    var feature = features[i - 1];
    var featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    var styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    var index = i * indexFactor;
    var color = index.toString(16).padStart(7, '#00000');
    for (var j = 0, jj = styles.length; j < jj; ++j) {
      var originalStyle = styles[j];
      var geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !(0, _extent.intersects)(extent, geometry.getExtent())) {
        continue;
      }
      var style = originalStyle.clone();
      var fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      var stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(undefined);
      var image = originalStyle.getImage();
      if (image) {
        var imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        var imgContext = (0, _dom.createCanvasContext2D)(imgSize[0], imgSize[1], undefined, {
          alpha: false
        });
        var img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(new _style.Icon({
          img: img,
          anchor: image.getAnchor(),
          anchorXUnits: 'pixels',
          anchorYUnits: 'pixels',
          offset: image.getOrigin(),
          opacity: 1,
          size: image.getSize(),
          scale: image.getScale(),
          rotation: image.getRotation(),
          rotateWithView: image.getRotateWithView()
        }));
      }
      var zIndex = style.getZIndex() || 0;
      var byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType['Polygon'] = [];
        byGeometryType['Circle'] = [];
        byGeometryType['LineString'] = [];
        byGeometryType['Point'] = [];
      }
      var type = geometry.getType();
      if (type === 'GeometryCollection') {
        var geometries = /** @type {import("../../geom/GeometryCollection.js").default} */geometry.getGeometriesArrayRecursive();
        for (var _i = 0, ii = geometries.length; _i < ii; ++_i) {
          var _geometry = geometries[_i];
          byGeometryType[_geometry.getType().replace('Multi', '')].push(_geometry, style);
        }
      } else {
        byGeometryType[type.replace('Multi', '')].push(geometry, style);
      }
    }
  }
  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array.ascending);
  for (var _i2 = 0, _ii = zIndexKeys.length; _i2 < _ii; ++_i2) {
    var _byGeometryType = featuresByZIndex[zIndexKeys[_i2]];
    for (var _type in _byGeometryType) {
      var geomAndStyle = _byGeometryType[_type];
      for (var _j = 0, _jj = geomAndStyle.length; _j < _jj; _j += 2) {
        renderer.setStyle(geomAndStyle[_j + 1]);
        for (var k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[_j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}

/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */
function hitDetect(pixel, features, imageData) {
  /** @type {Array<F>} */
  var resultFeatures = [];
  if (imageData) {
    var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    // The pixel coordinate is clamped down to the hit-detect canvas' size to account
    // for browsers returning coordinates slightly larger than the actual canvas size
    // due to a non-integer pixel ratio.
    var index = ((0, _math.clamp)(x, 0, imageData.width - 1) + (0, _math.clamp)(y, 0, imageData.height - 1) * imageData.width) * 4;
    var r = imageData.data[index];
    var g = imageData.data[index + 1];
    var b = imageData.data[index + 2];
    var i = b + 256 * (g + 256 * r);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
},{"./Immediate.js":"node_modules/ol/render/canvas/Immediate.js","../../style.js":"node_modules/ol/style.js","../../array.js":"node_modules/ol/array.js","../../math.js":"node_modules/ol/math.js","../../dom.js":"node_modules/ol/dom.js","../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/renderer/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOrder = defaultOrder;
exports.getSquaredTolerance = getSquaredTolerance;
exports.getTolerance = getTolerance;
exports.renderFeature = renderFeature;
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/renderer/vector
 */

/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;

/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */
var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};

/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return parseInt((0, _util.getUid)(feature1), 10) - parseInt((0, _util.getUid)(feature2), 10);
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutterBuilderGroup) {
  var loading = false;
  var imageStyle = style.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == _ImageState.default.LOADED || imageState == _ImageState.default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState.default.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup);
  return loading;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
  var renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature, declutterBuilderGroup);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == 'GeometryCollection') {
    var geometries = /** @type {import("../geom/GeometryCollection.js").default} */geometry.getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
  replay.drawCustom( /** @type {import("../geom/SimpleGeometry.js").default} */geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  var declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }
    var imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          var _imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
          _imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          _imageReplay.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  var declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }
    var imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          var _imageReplay2 = builderGroup.getBuilder(style.getZIndex(), 'Image');
          _imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          _imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
},{"../ImageState.js":"node_modules/ol/ImageState.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/renderer/canvas/VectorLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));
var _Layer = _interopRequireWildcard(require("./Layer.js"));
var _ExecutorGroup = _interopRequireDefault(require("../../render/canvas/ExecutorGroup.js"));
var _EventType = _interopRequireDefault(require("../../render/EventType.js"));
var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));
var _hitdetect = require("../../render/canvas/hitdetect.js");
var _transform = require("../../transform.js");
var _extent2 = require("../../extent.js");
var _dom = require("../../dom.js");
var _vector = require("../vector.js");
var _array = require("../../array.js");
var _proj = require("../../proj.js");
var _util = require("../../util.js");
var _coordinate = require("../../coordinate.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/VectorLayer
 */
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
  _inherits(CanvasVectorLayerRenderer, _CanvasLayerRenderer);
  var _super = _createSuper(CanvasVectorLayerRenderer);
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  function CanvasVectorLayerRenderer(vectorLayer) {
    var _this;
    _classCallCheck(this, CanvasVectorLayerRenderer);
    _this = _super.call(this, vectorLayer);

    /** @private */
    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_assertThisInitialized(_this));

    /**
     * @type {boolean}
     */
    _this.animatingOrInteracting_;

    /**
     * @type {ImageData|null}
     */
    _this.hitDetectionImageData_ = null;

    /**
     * @type {Array<import("../../Feature.js").default>}
     */
    _this.renderedFeatures_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    _this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    _this.renderedExtent_ = (0, _extent2.createEmpty)();

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    _this.wrappedRenderedExtent_ = (0, _extent2.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    _this.renderedRotation_;

    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */
    _this.renderedCenter_ = null;

    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */
    _this.renderedProjection_ = null;

    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    _this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    _this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    _this.replayGroupChanged = true;

    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    _this.declutterExecutorGroup = null;

    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */
    _this.clipping = true;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    _this.compositionContext_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.opacity_ = 1;
    return _this;
  }

  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  _createClass(CanvasVectorLayerRenderer, [{
    key: "renderWorlds",
    value: function renderWorlds(executorGroup, frameState, declutterTree) {
      var extent = frameState.extent;
      var viewState = frameState.viewState;
      var center = viewState.center;
      var resolution = viewState.resolution;
      var projection = viewState.projection;
      var rotation = viewState.rotation;
      var projectionExtent = projection.getExtent();
      var vectorSource = this.getLayer().getSource();
      var pixelRatio = frameState.pixelRatio;
      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
      var context = this.compositionContext_;
      var width = Math.round(frameState.size[0] * pixelRatio);
      var height = Math.round(frameState.size[1] * pixelRatio);
      var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
      var worldWidth = multiWorld ? (0, _extent2.getWidth)(projectionExtent) : null;
      var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
      var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
      do {
        var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
        executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterTree);
      } while (++world < endWorld);
    }
  }, {
    key: "setupCompositionContext_",
    value: function setupCompositionContext_() {
      if (this.opacity_ !== 1) {
        var compositionContext = (0, _dom.createCanvasContext2D)(this.context.canvas.width, this.context.canvas.height, _Layer.canvasPool);
        this.compositionContext_ = compositionContext;
      } else {
        this.compositionContext_ = this.context;
      }
    }
  }, {
    key: "releaseCompositionContext_",
    value: function releaseCompositionContext_() {
      if (this.opacity_ !== 1) {
        var alpha = this.context.globalAlpha;
        this.context.globalAlpha = this.opacity_;
        this.context.drawImage(this.compositionContext_.canvas, 0, 0);
        this.context.globalAlpha = alpha;
        (0, _dom.releaseCanvas)(this.compositionContext_);
        _Layer.canvasPool.push(this.compositionContext_.canvas);
        this.compositionContext_ = null;
      }
    }

    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "renderDeclutter",
    value: function renderDeclutter(frameState) {
      if (this.declutterExecutorGroup) {
        this.setupCompositionContext_();
        this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
        this.releaseCompositionContext_();
      }
    }

    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      var pixelRatio = frameState.pixelRatio;
      var layerState = frameState.layerStatesArray[frameState.layerIndex];

      // set forward and inverse pixel transforms
      (0, _transform.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
      (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
      var canvasTransform = (0, _transform.toString)(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      var context = this.context;
      var canvas = context.canvas;
      var replayGroup = this.replayGroup_;
      var declutterExecutorGroup = this.declutterExecutorGroup;
      var render = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
      if (!render) {
        var hasRenderListeners = this.getLayer().hasListener(_EventType.default.PRERENDER) || this.getLayer().hasListener(_EventType.default.POSTRENDER);
        if (!hasRenderListeners) {
          return null;
        }
      }

      // resize and clear
      var width = Math.round(frameState.size[0] * pixelRatio);
      var height = Math.round(frameState.size[1] * pixelRatio);
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
        if (canvas.style.transform !== canvasTransform) {
          canvas.style.transform = canvasTransform;
        }
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }
      this.preRender(context, frameState);
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      this.opacity_ = layerState.opacity;
      this.setupCompositionContext_();

      // clipped rendering if layer extent is set
      var clipped = false;
      if (render && layerState.extent && this.clipping) {
        var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, projection);
        render = (0, _extent2.intersects)(layerExtent, frameState.extent);
        clipped = render && !(0, _extent2.containsExtent)(layerExtent, frameState.extent);
        if (clipped) {
          this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
      }
      if (render) {
        this.renderWorlds(replayGroup, frameState);
      }
      if (clipped) {
        this.compositionContext_.restore();
      }
      this.releaseCompositionContext_();
      this.postRender(context, frameState);
      if (this.renderedRotation_ !== viewState.rotation) {
        this.renderedRotation_ = viewState.rotation;
        this.hitDetectionImageData_ = null;
      }
      return this.container;
    }

    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      var _this2 = this;
      return new Promise(function (resolve) {
        if (!_this2.hitDetectionImageData_ && !_this2.animatingOrInteracting_) {
          var size = [_this2.context.canvas.width, _this2.context.canvas.height];
          (0, _transform.apply)(_this2.pixelTransform, size);
          var center = _this2.renderedCenter_;
          var resolution = _this2.renderedResolution_;
          var rotation = _this2.renderedRotation_;
          var projection = _this2.renderedProjection_;
          var extent = _this2.wrappedRenderedExtent_;
          var layer = _this2.getLayer();
          var transforms = [];
          var width = size[0] * _hitdetect.HIT_DETECT_RESOLUTION;
          var height = size[1] * _hitdetect.HIT_DETECT_RESOLUTION;
          transforms.push(_this2.getRenderTransform(center, resolution, rotation, _hitdetect.HIT_DETECT_RESOLUTION, width, height, 0).slice());
          var source = layer.getSource();
          var projectionExtent = projection.getExtent();
          if (source.getWrapX() && projection.canWrapX() && !(0, _extent2.containsExtent)(projectionExtent, extent)) {
            var startX = extent[0];
            var worldWidth = (0, _extent2.getWidth)(projectionExtent);
            var world = 0;
            var offsetX;
            while (startX < projectionExtent[0]) {
              --world;
              offsetX = worldWidth * world;
              transforms.push(_this2.getRenderTransform(center, resolution, rotation, _hitdetect.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
              startX += worldWidth;
            }
            world = 0;
            startX = extent[2];
            while (startX > projectionExtent[2]) {
              ++world;
              offsetX = worldWidth * world;
              transforms.push(_this2.getRenderTransform(center, resolution, rotation, _hitdetect.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
              startX -= worldWidth;
            }
          }
          _this2.hitDetectionImageData_ = (0, _hitdetect.createHitDetectionImageData)(size, transforms, _this2.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
        }
        resolve((0, _hitdetect.hitDetect)(pixel, _this2.renderedFeatures_, _this2.hitDetectionImageData_));
      });
    }

    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      var _this3 = this;
      if (!this.replayGroup_) {
        return undefined;
      }
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer = this.getLayer();

      /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
      var features = {};

      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {number} distanceSq The squared distance to the click position
       * @return {T|undefined} Callback result.
       */
      var featureCallback = function featureCallback(feature, geometry, distanceSq) {
        var key = (0, _util.getUid)(feature);
        var match = features[key];
        if (!match) {
          if (distanceSq === 0) {
            features[key] = true;
            return callback(feature, layer, geometry);
          }
          matches.push(features[key] = {
            feature: feature,
            layer: layer,
            geometry: geometry,
            distanceSq: distanceSq,
            callback: callback
          });
        } else if (match !== true && distanceSq < match.distanceSq) {
          if (distanceSq === 0) {
            features[key] = true;
            matches.splice(matches.lastIndexOf(match), 1);
            return callback(feature, layer, geometry);
          }
          match.geometry = geometry;
          match.distanceSq = distanceSq;
        }
        return undefined;
      };
      var result;
      var executorGroups = [this.replayGroup_];
      if (this.declutterExecutorGroup) {
        executorGroups.push(this.declutterExecutorGroup);
      }
      executorGroups.some(function (executorGroup) {
        return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this3.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function (item) {
          return item.value;
        }) : null);
      });
      return result;
    }

    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */
  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {
      var layer = this.getLayer();
      if (layer.getVisible() && this.replayGroup_) {
        layer.changed();
      }
    }

    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
  }, {
    key: "handleStyleImageChange_",
    value: function handleStyleImageChange_(event) {
      this.renderIfReadyAndVisible();
    }

    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      var _this4 = this;
      var vectorLayer = this.getLayer();
      var vectorSource = vectorLayer.getSource();
      if (!vectorSource) {
        return false;
      }
      var animating = frameState.viewHints[_ViewHint.default.ANIMATING];
      var interacting = frameState.viewHints[_ViewHint.default.INTERACTING];
      var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
      var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
      if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
        this.animatingOrInteracting_ = true;
        return true;
      }
      this.animatingOrInteracting_ = false;
      var frameStateExtent = frameState.extent;
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var pixelRatio = frameState.pixelRatio;
      var vectorLayerRevision = vectorLayer.getRevision();
      var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
      var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
      if (vectorLayerRenderOrder === undefined) {
        vectorLayerRenderOrder = _vector.defaultOrder;
      }
      var center = viewState.center.slice();
      var extent = (0, _extent2.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
      var renderedExtent = extent.slice();
      var loadExtents = [extent.slice()];
      var projectionExtent = projection.getExtent();
      if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extent2.containsExtent)(projectionExtent, frameState.extent)) {
        // For the replay group, we need an extent that intersects the real world
        // (-180 to +180). To support geometries in a coordinate range from -540
        // to +540, we add at least 1 world width on each side of the projection
        // extent. If the viewport is wider than the world, we need to add half of
        // the viewport width to make sure we cover the whole viewport.
        var worldWidth = (0, _extent2.getWidth)(projectionExtent);
        var gutter = Math.max((0, _extent2.getWidth)(extent) / 2, worldWidth);
        extent[0] = projectionExtent[0] - gutter;
        extent[2] = projectionExtent[2] + gutter;
        (0, _coordinate.wrapX)(center, projection);
        var loadExtent = (0, _extent2.wrapX)(loadExtents[0], projection);
        // If the extent crosses the date line, we load data for both edges of the worlds
        if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
          loadExtents.push([loadExtent[0] + worldWidth, loadExtent[1], loadExtent[2] + worldWidth, loadExtent[3]]);
        } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
          loadExtents.push([loadExtent[0] - worldWidth, loadExtent[1], loadExtent[2] - worldWidth, loadExtent[3]]);
        }
      }
      if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extent2.containsExtent)(this.wrappedRenderedExtent_, extent)) {
        if (!(0, _array.equals)(this.renderedExtent_, renderedExtent)) {
          this.hitDetectionImageData_ = null;
          this.renderedExtent_ = renderedExtent;
        }
        this.renderedCenter_ = center;
        this.replayGroupChanged = false;
        return true;
      }
      this.replayGroup_ = null;
      var replayGroup = new _BuilderGroup.default((0, _vector.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
      var declutterBuilderGroup;
      if (this.getLayer().getDeclutter()) {
        declutterBuilderGroup = new _BuilderGroup.default((0, _vector.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
      }
      var userProjection = (0, _proj.getUserProjection)();
      var userTransform;
      if (userProjection) {
        for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
          var _extent = loadExtents[i];
          var _userExtent = (0, _proj.toUserExtent)(_extent, projection);
          vectorSource.loadFeatures(_userExtent, (0, _proj.toUserResolution)(resolution, projection), userProjection);
        }
        userTransform = (0, _proj.getTransformFromProjections)(userProjection, projection);
      } else {
        for (var _i = 0, _ii = loadExtents.length; _i < _ii; ++_i) {
          vectorSource.loadFeatures(loadExtents[_i], resolution, projection);
        }
      }
      var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);
      var ready = true;
      var render =
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       */
      function render(feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          var dirty = _this4.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
          ready = ready && !dirty;
        }
      };
      var userExtent = (0, _proj.toUserExtent)(extent, projection);
      /** @type {Array<import("../../Feature.js").default>} */
      var features = vectorSource.getFeaturesInExtent(userExtent);
      if (vectorLayerRenderOrder) {
        features.sort(vectorLayerRenderOrder);
      }
      for (var _i2 = 0, _ii2 = features.length; _i2 < _ii2; ++_i2) {
        render(features[_i2]);
      }
      this.renderedFeatures_ = features;
      this.ready = ready;
      var replayGroupInstructions = replayGroup.finish();
      var executorGroup = new _ExecutorGroup.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
      if (declutterBuilderGroup) {
        this.declutterExecutorGroup = new _ExecutorGroup.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
      }
      this.renderedResolution_ = resolution;
      this.renderedRevision_ = vectorLayerRevision;
      this.renderedRenderOrder_ = vectorLayerRenderOrder;
      this.renderedExtent_ = renderedExtent;
      this.wrappedRenderedExtent_ = extent;
      this.renderedCenter_ = center;
      this.renderedProjection_ = projection;
      this.replayGroup_ = executorGroup;
      this.hitDetectionImageData_ = null;
      this.replayGroupChanged = true;
      return true;
    }

    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
     * @return {boolean} `true` if an image is loading.
     */
  }, {
    key: "renderFeature",
    value: function renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutterBuilderGroup) {
      if (!styles) {
        return false;
      }
      var loading = false;
      if (Array.isArray(styles)) {
        for (var i = 0, ii = styles.length; i < ii; ++i) {
          loading = (0, _vector.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup) || loading;
        }
      } else {
        loading = (0, _vector.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup);
      }
      return loading;
    }
  }]);
  return CanvasVectorLayerRenderer;
}(_Layer.default);
var _default = exports.default = CanvasVectorLayerRenderer;
},{"../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","../../render/EventType.js":"node_modules/ol/render/EventType.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../dom.js":"node_modules/ol/dom.js","../vector.js":"node_modules/ol/renderer/vector.js","../../array.js":"node_modules/ol/array.js","../../proj.js":"node_modules/ol/proj.js","../../util.js":"node_modules/ol/util.js","../../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/layer/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));
var _VectorLayer = _interopRequireDefault(require("../renderer/canvas/VectorLayer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Vector
 */
/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */
var VectorLayer = /*#__PURE__*/function (_BaseVectorLayer) {
  _inherits(VectorLayer, _BaseVectorLayer);
  var _super = _createSuper(VectorLayer);
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  function VectorLayer(options) {
    _classCallCheck(this, VectorLayer);
    return _super.call(this, options);
  }
  _createClass(VectorLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new _VectorLayer.default(this);
    }
  }]);
  return VectorLayer;
}(_BaseVector.default);
var _default = exports.default = VectorLayer;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorLayer.js":"node_modules/ol/renderer/canvas/VectorLayer.js"}],"node_modules/ol/CollectionEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/CollectionEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
};
},{}],"node_modules/ol/Collection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CollectionEvent = void 0;
var _Object = _interopRequireDefault(require("./Object.js"));
var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));
var _Event2 = _interopRequireDefault(require("./events/Event.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Collection
 */
/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */
var CollectionEvent = exports.CollectionEvent = /*#__PURE__*/function (_Event) {
  _inherits(CollectionEvent, _Event);
  var _super = _createSuper(CollectionEvent);
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  function CollectionEvent(type, element, index) {
    var _this;
    _classCallCheck(this, CollectionEvent);
    _this = _super.call(this, type);

    /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */
    _this.element = element;

    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */
    _this.index = index;
    return _this;
  }
  return _createClass(CollectionEvent);
}(_Event2.default);
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */
/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection = /*#__PURE__*/function (_BaseObject) {
  _inherits(Collection, _BaseObject);
  var _super2 = _createSuper(Collection);
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  function Collection(array, options) {
    var _this2;
    _classCallCheck(this, Collection);
    _this2 = _super2.call(this);

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {CollectionOnSignature<T, void>}
     */
    _this2.un;
    options = options || {};

    /**
     * @private
     * @type {boolean}
     */
    _this2.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    _this2.array_ = array ? array : [];
    if (_this2.unique_) {
      for (var i = 0, ii = _this2.array_.length; i < ii; ++i) {
        _this2.assertUnique_(_this2.array_[i], i);
      }
    }
    _this2.updateLength_();
    return _this2;
  }

  /**
   * Remove all elements from the collection.
   * @api
   */
  _createClass(Collection, [{
    key: "clear",
    value: function clear() {
      while (this.getLength() > 0) {
        this.pop();
      }
    }

    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
  }, {
    key: "extend",
    value: function extend(arr) {
      for (var i = 0, ii = arr.length; i < ii; ++i) {
        this.push(arr[i]);
      }
      return this;
    }

    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
  }, {
    key: "forEach",
    value: function forEach(f) {
      var array = this.array_;
      for (var i = 0, ii = array.length; i < ii; ++i) {
        f(array[i], i, array);
      }
    }

    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
  }, {
    key: "getArray",
    value: function getArray() {
      return this.array_;
    }

    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
  }, {
    key: "item",
    value: function item(index) {
      return this.array_[index];
    }

    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
  }, {
    key: "getLength",
    value: function getLength() {
      return this.get(Property.LENGTH);
    }

    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
  }, {
    key: "insertAt",
    value: function insertAt(index, elem) {
      if (index < 0 || index > this.getLength()) {
        throw new Error('Index out of bounds: ' + index);
      }
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      this.array_.splice(index, 0, elem);
      this.updateLength_();
      this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
    }

    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
  }, {
    key: "pop",
    value: function pop() {
      return this.removeAt(this.getLength() - 1);
    }

    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
  }, {
    key: "push",
    value: function push(elem) {
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      var n = this.getLength();
      this.insertAt(n, elem);
      return this.getLength();
    }

    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
  }, {
    key: "remove",
    value: function remove(elem) {
      var arr = this.array_;
      for (var i = 0, ii = arr.length; i < ii; ++i) {
        if (arr[i] === elem) {
          return this.removeAt(i);
        }
      }
      return undefined;
    }

    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
  }, {
    key: "removeAt",
    value: function removeAt(index) {
      if (index < 0 || index >= this.getLength()) {
        return undefined;
      }
      var prev = this.array_[index];
      this.array_.splice(index, 1);
      this.updateLength_();
      this.dispatchEvent( /** @type {CollectionEvent<T>} */
      new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
      return prev;
    }

    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
  }, {
    key: "setAt",
    value: function setAt(index, elem) {
      var n = this.getLength();
      if (index >= n) {
        this.insertAt(index, elem);
        return;
      }
      if (index < 0) {
        throw new Error('Index out of bounds: ' + index);
      }
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent( /** @type {CollectionEvent<T>} */
      new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
      this.dispatchEvent( /** @type {CollectionEvent<T>} */
      new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
    }

    /**
     * @private
     */
  }, {
    key: "updateLength_",
    value: function updateLength_() {
      this.set(Property.LENGTH, this.array_.length);
    }

    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
  }, {
    key: "assertUnique_",
    value: function assertUnique_(elem, except) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        if (this.array_[i] === elem && i !== except) {
          throw new Error('Duplicate item added to a unique collection');
        }
      }
    }
  }]);
  return Collection;
}(_Object.default);
var _default = exports.default = Collection;
},{"./Object.js":"node_modules/ol/Object.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/structs/RBush.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rbush = _interopRequireDefault(require("rbush"));
var _extent = require("../extent.js");
var _util = require("../util.js");
var _obj = require("../obj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/structs/RBush
 */
/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */
/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = /*#__PURE__*/function () {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  function RBush(maxEntries) {
    _classCallCheck(this, RBush);
    /**
     * @private
     */
    this.rbush_ = new _rbush.default(maxEntries);

    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */
    this.items_ = {};
  }

  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  _createClass(RBush, [{
    key: "insert",
    value: function insert(extent, value) {
      /** @type {Entry} */
      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };
      this.rbush_.insert(item);
      this.items_[(0, _util.getUid)(value)] = item;
    }

    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
  }, {
    key: "load",
    value: function load(extents, values) {
      var items = new Array(values.length);
      for (var i = 0, l = values.length; i < l; i++) {
        var extent = extents[i];
        var value = values[i];

        /** @type {Entry} */
        var item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value: value
        };
        items[i] = item;
        this.items_[(0, _util.getUid)(value)] = item;
      }
      this.rbush_.load(items);
    }

    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
  }, {
    key: "remove",
    value: function remove(value) {
      var uid = (0, _util.getUid)(value);

      // get the object in which the value was wrapped when adding to the
      // internal rbush. then use that object to do the removal.
      var item = this.items_[uid];
      delete this.items_[uid];
      return this.rbush_.remove(item) !== null;
    }

    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
  }, {
    key: "update",
    value: function update(extent, value) {
      var item = this.items_[(0, _util.getUid)(value)];
      var bbox = [item.minX, item.minY, item.maxX, item.maxY];
      if (!(0, _extent.equals)(bbox, extent)) {
        this.remove(value);
        this.insert(extent, value);
      }
    }

    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
  }, {
    key: "getAll",
    value: function getAll() {
      var items = this.rbush_.all();
      return items.map(function (item) {
        return item.value;
      });
    }

    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
  }, {
    key: "getInExtent",
    value: function getInExtent(extent) {
      /** @type {Entry} */
      var bbox = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3]
      };
      var items = this.rbush_.search(bbox);
      return items.map(function (item) {
        return item.value;
      });
    }

    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
  }, {
    key: "forEach",
    value: function forEach(callback) {
      return this.forEach_(this.getAll(), callback);
    }

    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
  }, {
    key: "forEachInExtent",
    value: function forEachInExtent(extent, callback) {
      return this.forEach_(this.getInExtent(extent), callback);
    }

    /**
     * @param {Array<T>} values Values.
     * @param {function(T): *} callback Callback.
     * @private
     * @return {*} Callback return value.
     */
  }, {
    key: "forEach_",
    value: function forEach_(values, callback) {
      var result;
      for (var i = 0, l = values.length; i < l; i++) {
        result = callback(values[i]);
        if (result) {
          return result;
        }
      }
      return result;
    }

    /**
     * @return {boolean} Is empty.
     */
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return (0, _obj.isEmpty)(this.items_);
    }

    /**
     * Remove all values from the RBush.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.rbush_.clear();
      this.items_ = {};
    }

    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      var data = this.rbush_.toJSON();
      return (0, _extent.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
    }

    /**
     * @param {RBush} rbush R-Tree.
     */
  }, {
    key: "concat",
    value: function concat(rbush) {
      this.rbush_.load(rbush.rbush_.all());
      for (var i in rbush.items_) {
        this.items_[i] = rbush.items_[i];
      }
    }
  }]);
  return RBush;
}();
var _default = exports.default = RBush;
},{"rbush":"node_modules/rbush/rbush.min.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/geom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _Circle.default;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _Geometry.default;
  }
});
Object.defineProperty(exports, "GeometryCollection", {
  enumerable: true,
  get: function () {
    return _GeometryCollection.default;
  }
});
Object.defineProperty(exports, "LineString", {
  enumerable: true,
  get: function () {
    return _LineString.default;
  }
});
Object.defineProperty(exports, "LinearRing", {
  enumerable: true,
  get: function () {
    return _LinearRing.default;
  }
});
Object.defineProperty(exports, "MultiLineString", {
  enumerable: true,
  get: function () {
    return _MultiLineString.default;
  }
});
Object.defineProperty(exports, "MultiPoint", {
  enumerable: true,
  get: function () {
    return _MultiPoint.default;
  }
});
Object.defineProperty(exports, "MultiPolygon", {
  enumerable: true,
  get: function () {
    return _MultiPolygon.default;
  }
});
Object.defineProperty(exports, "Point", {
  enumerable: true,
  get: function () {
    return _Point.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function () {
    return _Polygon.default;
  }
});
Object.defineProperty(exports, "SimpleGeometry", {
  enumerable: true,
  get: function () {
    return _SimpleGeometry.default;
  }
});
var _Circle = _interopRequireDefault(require("./geom/Circle.js"));
var _Geometry = _interopRequireDefault(require("./geom/Geometry.js"));
var _GeometryCollection = _interopRequireDefault(require("./geom/GeometryCollection.js"));
var _LinearRing = _interopRequireDefault(require("./geom/LinearRing.js"));
var _LineString = _interopRequireDefault(require("./geom/LineString.js"));
var _MultiLineString = _interopRequireDefault(require("./geom/MultiLineString.js"));
var _MultiPoint = _interopRequireDefault(require("./geom/MultiPoint.js"));
var _MultiPolygon = _interopRequireDefault(require("./geom/MultiPolygon.js"));
var _Point = _interopRequireDefault(require("./geom/Point.js"));
var _Polygon = _interopRequireDefault(require("./geom/Polygon.js"));
var _SimpleGeometry = _interopRequireDefault(require("./geom/SimpleGeometry.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./geom/Circle.js":"node_modules/ol/geom/Circle.js","./geom/Geometry.js":"node_modules/ol/geom/Geometry.js","./geom/GeometryCollection.js":"node_modules/ol/geom/GeometryCollection.js","./geom/LinearRing.js":"node_modules/ol/geom/LinearRing.js","./geom/LineString.js":"node_modules/ol/geom/LineString.js","./geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","./geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","./geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","./geom/Point.js":"node_modules/ol/geom/Point.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./geom/SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js"}],"node_modules/ol/render/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.toFeature = toFeature;
exports.toGeometry = toGeometry;
var _Feature = _interopRequireDefault(require("../Feature.js"));
var _geom = require("../geom.js");
var _transform = require("../transform.js");
var _extent = require("../extent.js");
var _simplify = require("../geom/flat/simplify.js");
var _array = require("../array.js");
var _interiorpoint = require("../geom/flat/interiorpoint.js");
var _proj = require("../proj.js");
var _orient = require("../geom/flat/orient.js");
var _interpolate = require("../geom/flat/interpolate.js");
var _center = require("../geom/flat/center.js");
var _functions = require("../functions.js");
var _transform2 = require("../geom/flat/transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/render/Feature
 */
/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = (0, _transform.create)();

/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */
var RenderFeature = /*#__PURE__*/function () {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  function RenderFeature(type, flatCoordinates, ends, stride, properties, id) {
    _classCallCheck(this, RenderFeature);
    /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction;

    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */
    this.extent_;

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = id;

    /**
     * @private
     * @type {Type}
     */
    this.type_ = type;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatCoordinates_ = flatCoordinates;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatMidpoints_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.ends_ = ends;

    /**
     * @private
     * @type {Object<string, *>}
     */
    this.properties_ = properties;

    /**
     * @type {number}
     */
    this.squaredTolerance_;

    /**
     * @type {number}
     */
    this.stride_ = stride;

    /**
     * @private
     * @type {RenderFeature}
     */
    this.simplifiedGeometry_;
  }

  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  _createClass(RenderFeature, [{
    key: "get",
    value: function get(key) {
      return this.properties_[key];
    }

    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent() {
      if (!this.extent_) {
        this.extent_ = this.type_ === 'Point' ? (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
      }
      return this.extent_;
    }

    /**
     * @return {Array<number>} Flat interior points.
     */
  }, {
    key: "getFlatInteriorPoint",
    value: function getFlatInteriorPoint() {
      if (!this.flatInteriorPoints_) {
        var flatCenter = (0, _extent.getCenter)(this.getExtent());
        this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointOfArray)(this.flatCoordinates_, 0, /** @type {Array<number>} */this.ends_, 2, flatCenter, 0);
      }
      return this.flatInteriorPoints_;
    }

    /**
     * @return {Array<number>} Flat interior points.
     */
  }, {
    key: "getFlatInteriorPoints",
    value: function getFlatInteriorPoints() {
      if (!this.flatInteriorPoints_) {
        var ends = (0, _orient.inflateEnds)(this.flatCoordinates_, this.ends_);
        var flatCenters = (0, _center.linearRingss)(this.flatCoordinates_, 0, ends, 2);
        this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0, ends, 2, flatCenters);
      }
      return this.flatInteriorPoints_;
    }

    /**
     * @return {Array<number>} Flat midpoint.
     */
  }, {
    key: "getFlatMidpoint",
    value: function getFlatMidpoint() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = (0, _interpolate.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
      }
      return this.flatMidpoints_;
    }

    /**
     * @return {Array<number>} Flat midpoints.
     */
  }, {
    key: "getFlatMidpoints",
    value: function getFlatMidpoints() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = [];
        var flatCoordinates = this.flatCoordinates_;
        var offset = 0;
        var ends = /** @type {Array<number>} */this.ends_;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
          (0, _array.extend)(this.flatMidpoints_, midpoint);
          offset = end;
        }
      }
      return this.flatMidpoints_;
    }

    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
  }, {
    key: "getId",
    value: function getId() {
      return this.id_;
    }

    /**
     * @return {Array<number>} Flat coordinates.
     */
  }, {
    key: "getOrientedFlatCoordinates",
    value: function getOrientedFlatCoordinates() {
      return this.flatCoordinates_;
    }

    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this;
    }

    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      return this;
    }

    /**
     * Get a transformed and simplified version of the geometry.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
  }, {
    key: "simplifyTransformed",
    value: function simplifyTransformed(squaredTolerance, transform) {
      return this;
    }

    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
  }, {
    key: "getProperties",
    value: function getProperties() {
      return this.properties_;
    }

    /**
     * Get an object of all property names and values.  This has the same behavior as getProperties,
     * but is here to conform with the {@link module:ol/Feature~Feature} interface.
     * @return {Object<string, *>?} Object.
     */
  }, {
    key: "getPropertiesInternal",
    value: function getPropertiesInternal() {
      return this.properties_;
    }

    /**
     * @return {number} Stride.
     */
  }, {
    key: "getStride",
    value: function getStride() {
      return this.stride_;
    }

    /**
     * @return {import('../style/Style.js').StyleFunction|undefined} Style
     */
  }, {
    key: "getStyleFunction",
    value: function getStyleFunction() {
      return this.styleFunction;
    }

    /**
     * Get the type of this feature's geometry.
     * @return {Type} Geometry type.
     * @api
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.type_;
    }

    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
  }, {
    key: "transform",
    value: function transform(projection) {
      projection = (0, _proj.get)(projection);
      var pixelExtent = projection.getExtent();
      var projectedExtent = projection.getWorldExtent();
      if (pixelExtent && projectedExtent) {
        var scale = (0, _extent.getHeight)(projectedExtent) / (0, _extent.getHeight)(pixelExtent);
        (0, _transform.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
        (0, _transform2.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
      }
    }

    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     */
  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }

    /**
     * @return {RenderFeature} A cloned render feature.
     */
  }, {
    key: "clone",
    value: function clone() {
      return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);
    }

    /**
     * @return {Array<number>} Ends.
     */
  }, {
    key: "getEnds",
    value: function getEnds() {
      return this.ends_;
    }

    /**
     * Add transform and resolution based geometry simplification to this instance.
     * @return {RenderFeature} This render feature.
     */
  }, {
    key: "enableSimplifyTransformed",
    value: function enableSimplifyTransformed() {
      var _this = this;
      this.simplifyTransformed = (0, _functions.memoizeOne)(function (squaredTolerance, transform) {
        if (squaredTolerance === _this.squaredTolerance_) {
          return _this.simplifiedGeometry_;
        }
        _this.simplifiedGeometry_ = _this.clone();
        if (transform) {
          _this.simplifiedGeometry_.applyTransform(transform);
        }
        var simplifiedFlatCoordinates = _this.simplifiedGeometry_.getFlatCoordinates();
        var simplifiedEnds;
        switch (_this.type_) {
          case 'LineString':
            simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.flatCoordinates_.length, _this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);
            simplifiedEnds = [simplifiedFlatCoordinates.length];
            break;
          case 'MultiLineString':
            simplifiedEnds = [];
            simplifiedFlatCoordinates.length = (0, _simplify.douglasPeuckerArray)(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.ends_, _this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
            break;
          case 'Polygon':
            simplifiedEnds = [];
            simplifiedFlatCoordinates.length = (0, _simplify.quantizeArray)(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.ends_, _this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
            break;
          default:
        }
        if (simplifiedEnds) {
          _this.simplifiedGeometry_ = new RenderFeature(_this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, _this.properties_, _this.id_);
        }
        _this.squaredTolerance_ = squaredTolerance;
        return _this.simplifiedGeometry_;
      });
      return this;
    }
  }]);
  return RenderFeature;
}();
/**
 * @return {Array<number>} Flat coordinates.
 */
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;

/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */
function toGeometry(renderFeature) {
  var geometryType = renderFeature.getType();
  switch (geometryType) {
    case 'Point':
      return new _geom.Point(renderFeature.getFlatCoordinates());
    case 'MultiPoint':
      return new _geom.MultiPoint(renderFeature.getFlatCoordinates(), 'XY');
    case 'LineString':
      return new _geom.LineString(renderFeature.getFlatCoordinates(), 'XY');
    case 'MultiLineString':
      return new _geom.MultiLineString(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */renderFeature.getEnds());
    case 'Polygon':
      var flatCoordinates = renderFeature.getFlatCoordinates();
      var ends = /** @type {Array<number>} */renderFeature.getEnds();
      var endss = (0, _orient.inflateEnds)(flatCoordinates, ends);
      return endss.length > 1 ? new _geom.MultiPolygon(flatCoordinates, 'XY', endss) : new _geom.Polygon(flatCoordinates, 'XY', ends);
    default:
      throw new Error('Invalid geometry type:' + geometryType);
  }
}

/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */
function toFeature(renderFeature, geometryName) {
  var id = renderFeature.getId();
  var geometry = toGeometry(renderFeature);
  var properties = renderFeature.getProperties();
  var feature = new _Feature.default();
  if (geometryName !== undefined) {
    feature.setGeometryName(geometryName);
  }
  feature.setGeometry(geometry);
  if (id !== undefined) {
    feature.setId(id);
  }
  feature.setProperties(properties, true);
  return feature;
}
var _default = exports.default = RenderFeature;
},{"../Feature.js":"node_modules/ol/Feature.js","../geom.js":"node_modules/ol/geom.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../geom/flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../array.js":"node_modules/ol/array.js","../geom/flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","../proj.js":"node_modules/ol/proj.js","../geom/flat/orient.js":"node_modules/ol/geom/flat/orient.js","../geom/flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","../geom/flat/center.js":"node_modules/ol/geom/flat/center.js","../functions.js":"node_modules/ol/functions.js","../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/source/Source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("../Object.js"));
var _proj = require("../proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Source
 */
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */
/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `' Acme Inc.'`)
 * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */
/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source = /*#__PURE__*/function (_BaseObject) {
  _inherits(Source, _BaseObject);
  var _super = _createSuper(Source);
  /**
   * @param {Options} options Source options.
   */
  function Source(options) {
    var _this;
    _classCallCheck(this, Source);
    _this = _super.call(this);

    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */
    _this.projection = (0, _proj.get)(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    _this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    _this.loading = false;

    /**
     * @private
     * @type {import("./Source.js").State}
     */
    _this.state_ = options.state !== undefined ? options.state : 'ready';

    /**
     * @private
     * @type {boolean}
     */
    _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

    /**
     * @private
     * @type {boolean}
     */
    _this.interpolate_ = !!options.interpolate;

    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */
    _this.viewResolver = null;

    /**
     * @protected
     * @type {function(Error):void}
     */
    _this.viewRejector = null;
    var self = _assertThisInitialized(_this);
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */
    _this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
    return _this;
  }

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  _createClass(Source, [{
    key: "getAttributions",
    value: function getAttributions() {
      return this.attributions_;
    }

    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
  }, {
    key: "getAttributionsCollapsible",
    value: function getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }

    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
  }, {
    key: "getProjection",
    value: function getProjection() {
      return this.projection;
    }

    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
  }, {
    key: "getResolutions",
    value: function getResolutions(projection) {
      return null;
    }

    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
  }, {
    key: "getView",
    value: function getView() {
      return this.viewPromise_;
    }

    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
  }, {
    key: "getState",
    value: function getState() {
      return this.state_;
    }

    /**
     * @return {boolean|undefined} Wrap X.
     */
  }, {
    key: "getWrapX",
    value: function getWrapX() {
      return this.wrapX_;
    }

    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
  }, {
    key: "getInterpolate",
    value: function getInterpolate() {
      return this.interpolate_;
    }

    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
  }, {
    key: "refresh",
    value: function refresh() {
      this.changed();
    }

    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
  }, {
    key: "setAttributions",
    value: function setAttributions(attributions) {
      this.attributions_ = adaptAttributions(attributions);
      this.changed();
    }

    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
  }, {
    key: "setState",
    value: function setState(state) {
      this.state_ = state;
      this.changed();
    }
  }]);
  return Source;
}(_Object.default);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === 'function') {
    return attributionLike;
  }
  return function (frameState) {
    return [attributionLike];
  };
}
var _default = exports.default = Source;
},{"../Object.js":"node_modules/ol/Object.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source/VectorEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/source/VectorEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror'
};
/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */
},{}],"node_modules/ol/loadingstrategy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.bbox = bbox;
exports.tile = tile;
var _proj = require("./proj.js");
/**
 * @module ol/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}

/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
      var z = tileGrid.getZForResolution((0, _proj.fromUserResolution)(resolution, projection));
      var tileRange = tileGrid.getTileRangeForExtentAndZ((0, _proj.fromUserExtent)(extent, projection), z);
      /** @type {Array<import("./extent.js").Extent>} */
      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push((0, _proj.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection));
        }
      }
      return extents;
    }
  );
}
},{"./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/featureloader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFeaturesXhr = loadFeaturesXhr;
exports.setWithCredentials = setWithCredentials;
exports.xhr = xhr;
var _functions = require("./functions.js");
/**
 * @module ol/featureloader
 */

/**
 *
 * @type {boolean}
 * @private
 */
var withCredentials = false;

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
  if (format.getType() == 'arraybuffer') {
    xhr.responseType = 'arraybuffer';
  }
  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */
  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      var type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */
      var source;
      if (type == 'json') {
        source = JSON.parse(xhr.responseText);
      } else if (type == 'text') {
        source = xhr.responseText;
      } else if (type == 'xml') {
        source = xhr.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
      } else if (type == 'arraybuffer') {
        source = /** @type {ArrayBuffer} */xhr.response;
      }
      if (source) {
        success( /** @type {Array<import("./Feature.js").default>} */

        format.readFeatures(source, {
          extent: extent,
          featureProjection: projection
        }), format.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */
  xhr.onerror = failure;
  xhr.send();
}

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   */
  return function (extent, resolution, projection, success, failure) {
    var source = /** @type {import("./source/Vector").default} */this;
    loadFeaturesXhr(url, format, extent, resolution, projection,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     */
    function (features, dataProjection) {
      source.addFeatures(features);
      if (success !== undefined) {
        success(features);
      }
    }, /* FIXME handle error */failure ? failure : _functions.VOID);
  };
}

/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */
function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
},{"./functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/source/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VectorSourceEvent = void 0;
var _Collection = _interopRequireDefault(require("../Collection.js"));
var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));
var _RBush = _interopRequireDefault(require("../structs/RBush.js"));
var _Feature = _interopRequireDefault(require("../render/Feature.js"));
var _Source2 = _interopRequireDefault(require("./Source.js"));
var _VectorEventType = _interopRequireDefault(require("./VectorEventType.js"));
var _functions = require("../functions.js");
var _loadingstrategy = require("../loadingstrategy.js");
var _asserts = require("../asserts.js");
var _extent = require("../extent.js");
var _array = require("../array.js");
var _util = require("../util.js");
var _obj = require("../obj.js");
var _events = require("../events.js");
var _featureloader = require("../featureloader.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Vector
 */
/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */
var VectorSourceEvent = exports.VectorSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(VectorSourceEvent, _Event);
  var _super = _createSuper(VectorSourceEvent);
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  function VectorSourceEvent(type, feature, features) {
    var _this;
    _classCallCheck(this, VectorSourceEvent);
    _this = _super.call(this, type);

    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {FeatureClass|undefined}
     * @api
     */
    _this.feature = feature;

    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<FeatureClass>|undefined}
     * @api
     */
    _this.features = features;
    return _this;
  }
  return _createClass(VectorSourceEvent);
}(_Event2.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<FeatureClass>|Collection<FeatureClass>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180 and 180 meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */
/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */
var VectorSource = /*#__PURE__*/function (_Source) {
  _inherits(VectorSource, _Source);
  var _super2 = _createSuper(VectorSource);
  /**
   * @param {Options<FeatureClass>} [options] Vector source options.
   */
  function VectorSource(options) {
    var _this2;
    _classCallCheck(this, VectorSource);
    options = options || {};
    _this2 = _super2.call(this, {
      attributions: options.attributions,
      interpolate: true,
      projection: undefined,
      state: 'ready',
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {VectorSourceOnSignature<void>}
     */
    _this2.un;

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    _this2.loader_ = _functions.VOID;

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    _this2.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    _this2.overlaps_ = options.overlaps === undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    _this2.url_ = options.url;
    if (options.loader !== undefined) {
      _this2.loader_ = options.loader;
    } else if (_this2.url_ !== undefined) {
      (0, _asserts.assert)(_this2.format_, '`format` must be set when `url` is set');
      // create a XHR feature loader for "url" and "format"
      _this2.loader_ = (0, _featureloader.xhr)(_this2.url_, /** @type {import("../format/Feature.js").default} */_this2.format_);
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    _this2.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy.all;
    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<FeatureClass>}
     */
    _this2.featuresRtree_ = useSpatialIndex ? new _RBush.default() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    _this2.loadedExtentsRtree_ = new _RBush.default();

    /**
     * @type {number}
     * @private
     */
    _this2.loadingExtentsCount_ = 0;

    /**
     * @private
     * @type {!Object<string, FeatureClass>}
     */
    _this2.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, FeatureClass|Array<RenderFeature>>}
     */
    _this2.idIndex_ = {};

    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, FeatureClass>}
     */
    _this2.uidIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    _this2.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<FeatureClass>|null}
     */
    _this2.featuresCollection_ = null;

    /** @type {Collection<FeatureClass>} */
    var collection;
    /** @type {Array<FeatureClass>} */
    var features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection.default(features);
    }
    if (features !== undefined) {
      _this2.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      _this2.bindFeaturesCollection_(collection);
    }
    return _this2;
  }

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureClass} feature Feature to add.
   * @api
   */
  _createClass(VectorSource, [{
    key: "addFeature",
    value: function addFeature(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    }

    /**
     * Add a feature without firing a `change` event.
     * @param {FeatureClass} feature Feature.
     * @protected
     */
  }, {
    key: "addFeatureInternal",
    value: function addFeatureInternal(feature) {
      var featureKey = (0, _util.getUid)(feature);
      if (!this.addToIndex_(featureKey, feature)) {
        if (this.featuresCollection_) {
          this.featuresCollection_.remove(feature);
        }
        return;
      }
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, feature));
    }

    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureClass} feature The feature.
     * @private
     */
  }, {
    key: "setupChangeEvents_",
    value: function setupChangeEvents_(featureKey, feature) {
      if (feature instanceof _Feature.default) {
        return;
      }
      this.featureChangeKeys_[featureKey] = [(0, _events.listen)(feature, _EventType.default.CHANGE, this.handleFeatureChange_, this), (0, _events.listen)(feature, _ObjectEventType.default.PROPERTYCHANGE, this.handleFeatureChange_, this)];
    }

    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureClass} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
  }, {
    key: "addToIndex_",
    value: function addToIndex_(featureKey, feature) {
      var valid = true;
      if (feature.getId() !== undefined) {
        var id = String(feature.getId());
        if (!(id in this.idIndex_)) {
          this.idIndex_[id] = feature;
        } else if (feature instanceof _Feature.default) {
          var indexedFeature = this.idIndex_[id];
          if (!(indexedFeature instanceof _Feature.default)) {
            valid = false;
          } else {
            if (!Array.isArray(indexedFeature)) {
              this.idIndex_[id] = [indexedFeature, feature];
            } else {
              indexedFeature.push(feature);
            }
          }
        } else {
          valid = false;
        }
      }
      if (valid) {
        (0, _asserts.assert)(!(featureKey in this.uidIndex_), 'The passed `feature` was already added to the source');
        this.uidIndex_[featureKey] = feature;
      }
      return valid;
    }

    /**
     * Add a batch of features to the source.
     * @param {Array<FeatureClass>} features Features to add.
     * @api
     */
  }, {
    key: "addFeatures",
    value: function addFeatures(features) {
      this.addFeaturesInternal(features);
      this.changed();
    }

    /**
     * Add features without firing a `change` event.
     * @param {Array<FeatureClass>} features Features.
     * @protected
     */
  }, {
    key: "addFeaturesInternal",
    value: function addFeaturesInternal(features) {
      var extents = [];
      /** @type {Array<FeatureClass>} */
      var newFeatures = [];
      /** @type Array<FeatureClass> */
      var geometryFeatures = [];
      for (var i = 0, length = features.length; i < length; i++) {
        var feature = features[i];
        var featureKey = (0, _util.getUid)(feature);
        if (this.addToIndex_(featureKey, feature)) {
          newFeatures.push(feature);
        }
      }
      for (var _i = 0, _length = newFeatures.length; _i < _length; _i++) {
        var _feature = newFeatures[_i];
        var _featureKey = (0, _util.getUid)(_feature);
        this.setupChangeEvents_(_featureKey, _feature);
        var geometry = _feature.getGeometry();
        if (geometry) {
          var extent = geometry.getExtent();
          extents.push(extent);
          geometryFeatures.push(_feature);
        } else {
          this.nullGeometryFeatures_[_featureKey] = _feature;
        }
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.load(extents, geometryFeatures);
      }
      if (this.hasListener(_VectorEventType.default.ADDFEATURE)) {
        for (var _i2 = 0, _length2 = newFeatures.length; _i2 < _length2; _i2++) {
          this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, newFeatures[_i2]));
        }
      }
    }

    /**
     * @param {!Collection<FeatureClass>} collection Collection.
     * @private
     */
  }, {
    key: "bindFeaturesCollection_",
    value: function bindFeaturesCollection_(collection) {
      var _this3 = this;
      var modifyingCollection = false;
      this.addEventListener(_VectorEventType.default.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      });
      this.addEventListener(_VectorEventType.default.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      });
      collection.addEventListener(_CollectionEventType.default.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          _this3.addFeature(evt.element);
          modifyingCollection = false;
        }
      });
      collection.addEventListener(_CollectionEventType.default.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          _this3.removeFeature(evt.element);
          modifyingCollection = false;
        }
      });
      this.featuresCollection_ = collection;
    }

    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
  }, {
    key: "clear",
    value: function clear(fast) {
      var _this4 = this;
      if (fast) {
        for (var featureId in this.featureChangeKeys_) {
          var keys = this.featureChangeKeys_[featureId];
          keys.forEach(_events.unlistenByKey);
        }
        if (!this.featuresCollection_) {
          this.featureChangeKeys_ = {};
          this.idIndex_ = {};
          this.uidIndex_ = {};
        }
      } else {
        if (this.featuresRtree_) {
          var removeAndIgnoreReturn = function removeAndIgnoreReturn(feature) {
            _this4.removeFeatureInternal(feature);
          };
          this.featuresRtree_.forEach(removeAndIgnoreReturn);
          for (var id in this.nullGeometryFeatures_) {
            this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
          }
        }
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.clear();
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.clear();
      }
      this.nullGeometryFeatures_ = {};
      var clearEvent = new VectorSourceEvent(_VectorEventType.default.CLEAR);
      this.dispatchEvent(clearEvent);
      this.changed();
    }

    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(FeatureClass): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
  }, {
    key: "forEachFeature",
    value: function forEachFeature(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }

    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
     * called for all features.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureClass): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinateDirect",
    value: function forEachFeatureAtCoordinateDirect(coordinate, callback) {
      var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
      return this.forEachFeatureInExtent(extent, function (feature) {
        var geometry = feature.getGeometry();
        if (geometry instanceof _Feature.default || geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        }
        return undefined;
      });
    }

    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureClass): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
  }, {
    key: "forEachFeatureInExtent",
    value: function forEachFeatureInExtent(extent, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent, callback);
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }

    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureClass): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
  }, {
    key: "forEachFeatureIntersectingExtent",
    value: function forEachFeatureIntersectingExtent(extent, callback) {
      return this.forEachFeatureInExtent(extent,
      /**
       * @param {FeatureClass} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function (feature) {
        var geometry = feature.getGeometry();
        if (geometry instanceof _Feature.default || geometry.intersectsExtent(extent)) {
          var result = callback(feature);
          if (result) {
            return result;
          }
        }
      });
    }

    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<FeatureClass>|null} The collection of features.
     * @api
     */
  }, {
    key: "getFeaturesCollection",
    value: function getFeaturesCollection() {
      return this.featuresCollection_;
    }

    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<FeatureClass>} Features.
     * @api
     */
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      var features;
      if (this.featuresCollection_) {
        features = this.featuresCollection_.getArray().slice(0);
      } else if (this.featuresRtree_) {
        features = this.featuresRtree_.getAll();
        if (!(0, _obj.isEmpty)(this.nullGeometryFeatures_)) {
          (0, _array.extend)(features, Object.values(this.nullGeometryFeatures_));
        }
      }
      return features;
    }

    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     */
  }, {
    key: "getFeaturesAtCoordinate",
    value: function getFeaturesAtCoordinate(coordinate) {
      var features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
        features.push(feature);
      });
      return features;
    }

    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<FeatureClass>} Features.
     * @api
     */
  }, {
    key: "getFeaturesInExtent",
    value: function getFeaturesInExtent(extent, projection) {
      var _this5 = this;
      if (this.featuresRtree_) {
        var _ref;
        var multiWorld = projection && projection.canWrapX() && this.getWrapX();
        if (!multiWorld) {
          return this.featuresRtree_.getInExtent(extent);
        }
        var extents = (0, _extent.wrapAndSliceX)(extent, projection);
        return (_ref = []).concat.apply(_ref, _toConsumableArray(extents.map(function (anExtent) {
          return _this5.featuresRtree_.getInExtent(anExtent);
        })));
      }
      if (this.featuresCollection_) {
        return this.featuresCollection_.getArray().slice(0);
      }
      return [];
    }

    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false` and the features in this source are of type
     * {@link module:ol/Feature~Feature}.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureClass):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {FeatureClass} Closest feature.
     * @api
     */
  }, {
    key: "getClosestFeatureToCoordinate",
    value: function getClosestFeatureToCoordinate(coordinate, filter) {
      // Find the closest feature using branch and bound.  We start searching an
      // infinite extent, and find the distance from the first feature found.  This
      // becomes the closest feature.  We then compute a smaller extent which any
      // closer feature must intersect.  We continue searching with this smaller
      // extent, trying to find a closer feature.  Every time we find a closer
      // feature, we update the extent being searched so that any even closer
      // feature must intersect it.  We continue until we run out of features.
      var x = coordinate[0];
      var y = coordinate[1];
      var closestFeature = null;
      var closestPoint = [NaN, NaN];
      var minSquaredDistance = Infinity;
      var extent = [-Infinity, -Infinity, Infinity, Infinity];
      filter = filter ? filter : _functions.TRUE;
      this.featuresRtree_.forEachInExtent(extent,
      /**
       * @param {FeatureClass} feature Feature.
       */
      function (feature) {
        if (filter(feature)) {
          var geometry = feature.getGeometry();
          var previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry instanceof _Feature.default ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            var minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      });
      return closestFeature;
    }

    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      return this.featuresRtree_.getExtent(extent);
    }

    /**
     * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
     * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
     * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
     * `GeometryCollection` member.
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {FeatureClass|Array<RenderFeature>|null} The feature (or `null` if not found).
     * @api
     */
  }, {
    key: "getFeatureById",
    value: function getFeatureById(id) {
      var feature = this.idIndex_[id.toString()];
      return feature !== undefined ? feature : null;
    }

    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {FeatureClass|null} The feature (or `null` if not found).
     */
  }, {
    key: "getFeatureByUid",
    value: function getFeatureByUid(uid) {
      var feature = this.uidIndex_[uid];
      return feature !== undefined ? feature : null;
    }

    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default|undefined} The feature format.
     * @api
     */
  }, {
    key: "getFormat",
    value: function getFormat() {
      return this.format_;
    }

    /**
     * @return {boolean} The source can have overlapping geometries.
     */
  }, {
    key: "getOverlaps",
    value: function getOverlaps() {
      return this.overlaps_;
    }

    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.url_;
    }

    /**
     * @param {Event} event Event.
     * @private
     */
  }, {
    key: "handleFeatureChange_",
    value: function handleFeatureChange_(event) {
      var feature = /** @type {FeatureClass} */event.target;
      var featureKey = (0, _util.getUid)(feature);
      var geometry = feature.getGeometry();
      if (!geometry) {
        if (!(featureKey in this.nullGeometryFeatures_)) {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      } else {
        var extent = geometry.getExtent();
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.update(extent, feature);
          }
        }
      }
      var id = feature.getId();
      if (id !== undefined) {
        var sid = id.toString();
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      } else {
        this.removeFromIdIndex_(feature);
        this.uidIndex_[featureKey] = feature;
      }
      this.changed();
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.CHANGEFEATURE, feature));
    }

    /**
     * Returns true if the feature is contained within the source.
     * @param {FeatureClass} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
  }, {
    key: "hasFeature",
    value: function hasFeature(feature) {
      var id = feature.getId();
      if (id !== undefined) {
        return id in this.idIndex_;
      }
      return (0, _util.getUid)(feature) in this.uidIndex_;
    }

    /**
     * @return {boolean} Is empty.
     */
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      if (this.featuresRtree_) {
        return this.featuresRtree_.isEmpty() && (0, _obj.isEmpty)(this.nullGeometryFeatures_);
      }
      if (this.featuresCollection_) {
        return this.featuresCollection_.getLength() === 0;
      }
      return true;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
  }, {
    key: "loadFeatures",
    value: function loadFeatures(extent, resolution, projection) {
      var _this6 = this;
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var extentsToLoad = this.strategy_(extent, resolution, projection);
      var _loop = function _loop() {
        var extentToLoad = extentsToLoad[i];
        var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function (object) {
          return (0, _extent.containsExtent)(object.extent, extentToLoad);
        });
        if (!alreadyLoaded) {
          ++_this6.loadingExtentsCount_;
          _this6.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADSTART));
          _this6.loader_.call(_this6, extentToLoad, resolution, projection, function (features) {
            --_this6.loadingExtentsCount_;
            _this6.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADEND, undefined, features));
          }, function () {
            --_this6.loadingExtentsCount_;
            _this6.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADERROR));
          });
          loadedExtentsRtree.insert(extentToLoad, {
            extent: extentToLoad.slice()
          });
        }
      };
      for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
        _loop();
      }
      this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.clear(true);
      this.loadedExtentsRtree_.clear();
      _get(_getPrototypeOf(VectorSource.prototype), "refresh", this).call(this);
    }

    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
  }, {
    key: "removeLoadedExtent",
    value: function removeLoadedExtent(extent) {
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var obj;
      loadedExtentsRtree.forEachInExtent(extent, function (object) {
        if ((0, _extent.equals)(object.extent, extent)) {
          obj = object;
          return true;
        }
      });
      if (obj) {
        loadedExtentsRtree.remove(obj);
      }
    }

    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {FeatureClass} feature Feature to remove.
     * @api
     */
  }, {
    key: "removeFeature",
    value: function removeFeature(feature) {
      if (!feature) {
        return;
      }
      var featureKey = (0, _util.getUid)(feature);
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
      }
      var result = this.removeFeatureInternal(feature);
      if (result) {
        this.changed();
      }
    }

    /**
     * Remove feature without firing a `change` event.
     * @param {FeatureClass} feature Feature.
     * @return {FeatureClass|undefined} The removed feature
     *     (or undefined if the feature was not found).
     * @protected
     */
  }, {
    key: "removeFeatureInternal",
    value: function removeFeatureInternal(feature) {
      var featureKey = (0, _util.getUid)(feature);
      var featureChangeKeys = this.featureChangeKeys_[featureKey];
      if (!featureChangeKeys) {
        return;
      }
      featureChangeKeys.forEach(_events.unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      var id = feature.getId();
      if (id !== undefined) {
        delete this.idIndex_[id.toString()];
      }
      delete this.uidIndex_[featureKey];
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.REMOVEFEATURE, feature));
      return feature;
    }

    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {FeatureClass} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */
  }, {
    key: "removeFromIdIndex_",
    value: function removeFromIdIndex_(feature) {
      var removed = false;
      for (var id in this.idIndex_) {
        var indexedFeature = this.idIndex_[id];
        if (feature instanceof _Feature.default && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) {
          indexedFeature.splice(indexedFeature.indexOf(feature), 1);
        } else if (this.idIndex_[id] === feature) {
          delete this.idIndex_[id];
          removed = true;
          break;
        }
      }
      return removed;
    }

    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */
  }, {
    key: "setLoader",
    value: function setLoader(loader) {
      this.loader_ = loader;
    }

    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
  }, {
    key: "setUrl",
    value: function setUrl(url) {
      (0, _asserts.assert)(this.format_, '`format` must be set when `url` is set');
      this.url_ = url;
      this.setLoader((0, _featureloader.xhr)(url, this.format_));
    }
  }]);
  return VectorSource;
}(_Source2.default);
var _default = exports.default = VectorSource;
},{"../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","../render/Feature.js":"node_modules/ol/render/Feature.js","./Source.js":"node_modules/ol/source/Source.js","./VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../functions.js":"node_modules/ol/functions.js","../loadingstrategy.js":"node_modules/ol/loadingstrategy.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../array.js":"node_modules/ol/array.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js","../events.js":"node_modules/ol/events.js","../featureloader.js":"node_modules/ol/featureloader.js"}],"node_modules/ol/events/condition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.touchOnly = exports.targetNotEditable = exports.singleClick = exports.shiftKeyOnly = exports.primaryAction = exports.pointerMove = exports.platformModifierKeyOnly = exports.platformModifierKey = exports.penOnly = exports.noModifierKeys = exports.never = exports.mouseOnly = exports.mouseActionButton = exports.focusWithTabindex = exports.focus = exports.doubleClick = exports.click = exports.always = exports.altShiftKeysOnly = exports.altKeyOnly = void 0;
var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));
var _functions = require("../functions.js");
var _has = require("../has.js");
var _asserts = require("../asserts.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/events/condition
 */

/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
function all(var_args) {
  var conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */
  return function (event) {
    var pass = true;
    for (var i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = exports.altKeyOnly = function altKeyOnly(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
var altShiftKeysOnly = exports.altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
var focus = exports.focus = function focus(event) {
  var targetElement = event.map.getTargetElement();
  var activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};

/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */
var focusWithTabindex = exports.focusWithTabindex = function focusWithTabindex(event) {
  return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};

/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
var always = exports.always = _functions.TRUE;

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
var click = exports.click = function click(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.CLICK;
};

/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
var mouseActionButton = exports.mouseActionButton = function mouseActionButton(mapBrowserEvent) {
  var originalEvent = /** @type {MouseEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has.WEBKIT && _has.MAC && originalEvent.ctrlKey);
};

/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
var never = exports.never = _functions.FALSE;

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
var pointerMove = exports.pointerMove = function pointerMove(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
var singleClick = exports.singleClick = function singleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.SINGLECLICK;
};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
var doubleClick = exports.doubleClick = function doubleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK;
};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
var noModifierKeys = exports.noModifierKeys = function noModifierKeys(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
var platformModifierKeyOnly = exports.platformModifierKeyOnly = function platformModifierKeyOnly(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the platform modifier key is pressed.
 * @api
 */
var platformModifierKey = exports.platformModifierKey = function platformModifierKey(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return _has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
var shiftKeyOnly = exports.shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return `true` if the target element is not editable, i.e. not an `input`,
 * `select`, or `textarea` element and no `contenteditable` attribute is
 * set or inherited, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
var targetNotEditable = exports.targetNotEditable = function targetNotEditable(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  var tagName = /** @type {Element} */originalEvent.target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' &&
  // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};

/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
var mouseOnly = exports.mouseOnly = function mouseOnly(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserEvent").default} */mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvent.pointerType == 'mouse';
};

/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */
var touchOnly = exports.touchOnly = function touchOnly(mapBrowserEvent) {
  var pointerEvt = /** @type {import("../MapBrowserEvent").default} */mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'touch';
};

/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */
var penOnly = exports.penOnly = function penOnly(mapBrowserEvent) {
  var pointerEvt = /** @type {import("../MapBrowserEvent").default} */mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'pen';
};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
var primaryAction = exports.primaryAction = function primaryAction(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserEvent").default} */mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
},{"../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../functions.js":"node_modules/ol/functions.js","../has.js":"node_modules/ol/has.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/interaction/Draw.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawEvent = void 0;
exports.createBox = createBox;
exports.createRegularPolygon = createRegularPolygon;
exports.default = void 0;
var _Circle = _interopRequireDefault(require("../geom/Circle.js"));
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Feature = _interopRequireDefault(require("../Feature.js"));
var _GeometryCollection = _interopRequireDefault(require("../geom/GeometryCollection.js"));
var _Property = _interopRequireDefault(require("./Property.js"));
var _LineString = _interopRequireDefault(require("../geom/LineString.js"));
var _MapBrowserEvent = _interopRequireDefault(require("../MapBrowserEvent.js"));
var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));
var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));
var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));
var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));
var _Point = _interopRequireDefault(require("../geom/Point.js"));
var _Pointer = _interopRequireDefault(require("./Pointer.js"));
var _Polygon = _interopRequireWildcard(require("../geom/Polygon.js"));
var _Vector = _interopRequireDefault(require("../layer/Vector.js"));
var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));
var _functions = require("../functions.js");
var _condition = require("../events/condition.js");
var _extent = require("../extent.js");
var _math = require("../math.js");
var _Style = require("../style/Style.js");
var _coordinate = require("../coordinate.js");
var _proj = require("../proj.js");
var _SimpleGeometry = require("../geom/SimpleGeometry.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/Draw
 */
/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.
 * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.
 * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with
 * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.
 * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`
 * geometry that corresponds to the polygon between the already drawn points and the current cursor position
 * (note that this polygon has only two points if only one point is drawn).
 * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose
 * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */

/**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */

/**
 * @enum {string}
 */
var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort'
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
var DrawEvent = exports.DrawEvent = /*#__PURE__*/function (_Event) {
  _inherits(DrawEvent, _Event);
  var _super = _createSuper(DrawEvent);
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  function DrawEvent(type, feature) {
    var _this;
    _classCallCheck(this, DrawEvent);
    _this = _super.call(this, type);

    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    _this.feature = feature;
    return _this;
  }
  return _createClass(DrawEvent);
}(_Event2.default);
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */
function getTraceTargets(coordinate, features) {
  /**
   * @type {Array<TraceTarget>}
   */
  var targets = [];
  for (var i = 0; i < features.length; ++i) {
    var feature = features[i];
    var geometry = feature.getGeometry();
    appendGeometryTraceTargets(coordinate, geometry, targets);
  }
  return targets;
}

/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */
function getSquaredDistance(a, b) {
  return (0, _math.squaredDistance)(a[0], a[1], b[0], b[1]);
}

/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */
function getCoordinate(coordinates, index) {
  var count = coordinates.length;
  if (index < 0) {
    return coordinates[index + count];
  }
  if (index >= count) {
    return coordinates[index - count];
  }
  return coordinates[index];
}

/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */
function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
  var lowIndex, highIndex;
  if (startIndex < endIndex) {
    lowIndex = startIndex;
    highIndex = endIndex;
  } else {
    lowIndex = endIndex;
    highIndex = startIndex;
  }
  var lowWholeIndex = Math.ceil(lowIndex);
  var highWholeIndex = Math.floor(highIndex);
  if (lowWholeIndex > highWholeIndex) {
    // both start and end are on the same segment
    var start = interpolateCoordinate(coordinates, lowIndex);
    var end = interpolateCoordinate(coordinates, highIndex);
    return getSquaredDistance(start, end);
  }
  var sd = 0;
  if (lowIndex < lowWholeIndex) {
    var _start = interpolateCoordinate(coordinates, lowIndex);
    var _end = getCoordinate(coordinates, lowWholeIndex);
    sd += getSquaredDistance(_start, _end);
  }
  if (highWholeIndex < highIndex) {
    var _start2 = getCoordinate(coordinates, highWholeIndex);
    var _end2 = interpolateCoordinate(coordinates, highIndex);
    sd += getSquaredDistance(_start2, _end2);
  }
  for (var i = lowWholeIndex; i < highWholeIndex - 1; ++i) {
    var _start3 = getCoordinate(coordinates, i);
    var _end3 = getCoordinate(coordinates, i + 1);
    sd += getSquaredDistance(_start3, _end3);
  }
  return sd;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendGeometryTraceTargets(coordinate, geometry, targets) {
  if (geometry instanceof _LineString.default) {
    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
    return;
  }
  if (geometry instanceof _MultiLineString.default) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
      appendTraceTarget(coordinate, coordinates[i], false, targets);
    }
    return;
  }
  if (geometry instanceof _Polygon.default) {
    var _coordinates = geometry.getCoordinates();
    for (var _i = 0, _ii = _coordinates.length; _i < _ii; ++_i) {
      appendTraceTarget(coordinate, _coordinates[_i], true, targets);
    }
    return;
  }
  if (geometry instanceof _MultiPolygon.default) {
    var polys = geometry.getCoordinates();
    for (var _i2 = 0, _ii2 = polys.length; _i2 < _ii2; ++_i2) {
      var _coordinates2 = polys[_i2];
      for (var j = 0, jj = _coordinates2.length; j < jj; ++j) {
        appendTraceTarget(coordinate, _coordinates2[j], true, targets);
      }
    }
    return;
  }
  if (geometry instanceof _GeometryCollection.default) {
    var geometries = geometry.getGeometries();
    for (var _i3 = 0; _i3 < geometries.length; ++_i3) {
      appendGeometryTraceTargets(coordinate, geometries[_i3], targets);
    }
    return;
  }
  // other types cannot be traced
}

/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */

/**
 * @type {TraceTargetUpdateInfo}
 */
var sharedUpdateInfo = {
  index: -1,
  endIndex: NaN
};

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */
function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
  var x = coordinate[0];
  var y = coordinate[1];
  var closestTargetDistance = Infinity;
  var newTargetIndex = -1;
  var newEndIndex = NaN;
  for (var targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex) {
    var target = traceState.targets[targetIndex];
    var coordinates = target.coordinates;
    var minSegmentDistance = Infinity;
    var endIndex = void 0;
    for (var coordinateIndex = 0; coordinateIndex < coordinates.length - 1; ++coordinateIndex) {
      var start = coordinates[coordinateIndex];
      var end = coordinates[coordinateIndex + 1];
      var rel = getPointSegmentRelationship(x, y, start, end);
      if (rel.squaredDistance < minSegmentDistance) {
        minSegmentDistance = rel.squaredDistance;
        endIndex = coordinateIndex + rel.along;
      }
    }
    if (minSegmentDistance < closestTargetDistance) {
      closestTargetDistance = minSegmentDistance;
      if (target.ring && traceState.targetIndex === targetIndex) {
        // same target, maintain the same trace direction
        if (target.endIndex > target.startIndex) {
          // forward trace
          if (endIndex < target.startIndex) {
            endIndex += coordinates.length;
          }
        } else if (target.endIndex < target.startIndex) {
          // reverse trace
          if (endIndex > target.startIndex) {
            endIndex -= coordinates.length;
          }
        }
      }
      newEndIndex = endIndex;
      newTargetIndex = targetIndex;
    }
  }
  var newTarget = traceState.targets[newTargetIndex];
  var considerBothDirections = newTarget.ring;
  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
    // only consider switching trace direction if close to the start
    var newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);
    var pixel = map.getPixelFromCoordinate(newCoordinate);
    if ((0, _coordinate.distance)(pixel, traceState.startPx) > snapTolerance) {
      considerBothDirections = false;
    }
  }
  if (considerBothDirections) {
    var _coordinates3 = newTarget.coordinates;
    var count = _coordinates3.length;
    var startIndex = newTarget.startIndex;
    var _endIndex = newEndIndex;
    if (startIndex < _endIndex) {
      var forwardDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex);
      var reverseDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex - count);
      if (reverseDistance < forwardDistance) {
        newEndIndex -= count;
      }
    } else {
      var _reverseDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex);
      var _forwardDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex + count);
      if (_forwardDistance < _reverseDistance) {
        newEndIndex += count;
      }
    }
  }
  sharedUpdateInfo.index = newTargetIndex;
  sharedUpdateInfo.endIndex = newEndIndex;
  return sharedUpdateInfo;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendTraceTarget(coordinate, coordinates, ring, targets) {
  var x = coordinate[0];
  var y = coordinate[1];
  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    var start = coordinates[i];
    var end = coordinates[i + 1];
    var rel = getPointSegmentRelationship(x, y, start, end);
    if (rel.squaredDistance === 0) {
      var index = i + rel.along;
      targets.push({
        coordinates: coordinates,
        ring: ring,
        startIndex: index,
        endIndex: index
      });
      return;
    }
  }
}

/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */

/**
 * @type {PointSegmentRelationship}
 */
var sharedRel = {
  along: 0,
  squaredDistance: 0
};

/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */
function getPointSegmentRelationship(x, y, start, end) {
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = 0;
  var px = x1;
  var py = y1;
  if (dx !== 0 || dy !== 0) {
    along = (0, _math.clamp)(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
    px += dx * along;
    py += dy * along;
  }
  sharedRel.along = along;
  sharedRel.squaredDistance = (0, _math.toFixed)((0, _math.squaredDistance)(x, y, px, py), 10);
  return sharedRel;
}

/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */
function interpolateCoordinate(coordinates, index) {
  var count = coordinates.length;
  var startIndex = Math.floor(index);
  var along = index - startIndex;
  if (startIndex >= count) {
    startIndex -= count;
  } else if (startIndex < 0) {
    startIndex += count;
  }
  var endIndex = startIndex + 1;
  if (endIndex >= count) {
    endIndex -= count;
  }
  var start = coordinates[startIndex];
  var x0 = start[0];
  var y0 = start[1];
  var end = coordinates[endIndex];
  var dx = end[0] - x0;
  var dy = end[1] - y0;
  return [x0 + dx * along, y0 + dy * along];
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */

/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
var Draw = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(Draw, _PointerInteraction);
  var _super2 = _createSuper(Draw);
  /**
   * @param {Options} options Options.
   */
  function Draw(options) {
    var _this2;
    _classCallCheck(this, Draw);
    var pointerOptions = /** @type {import("./Pointer.js").Options} */
    options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }
    _this2 = _super2.call(this, pointerOptions);

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {DrawOnSignature<void>}
     */
    _this2.un;

    /**
     * @type {boolean}
     * @private
     */
    _this2.shouldHandle_ = false;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    _this2.downPx_ = null;

    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    _this2.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    _this2.lastDragTime_;

    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */
    _this2.pointerType_;

    /**
     * @type {boolean}
     * @private
     */
    _this2.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */
    _this2.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */
    _this2.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    _this2.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */
    _this2.type_ = /** @type {import("../geom/Geometry.js").Type} */
    options.type;

    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    _this2.mode_ = getMode(_this2.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    _this2.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    _this2.minPoints_ = options.minPoints ? options.minPoints : _this2.mode_ === 'Polygon' ? 3 : 2;

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    _this2.maxPoints_ = _this2.mode_ === 'Circle' ? 2 : options.maxPoints ? options.maxPoints : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this2.finishCondition_ = options.finishCondition ? options.finishCondition : _functions.TRUE;

    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    _this2.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';
    var geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      var mode = _this2.mode_;
      if (mode === 'Circle') {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function geometryFunction(coordinates, geometry, projection) {
          var circle = geometry ? ( /** @type {Circle} */geometry) : new _Circle.default([NaN, NaN]);
          var center = (0, _proj.fromUserCoordinate)(coordinates[0], projection);
          var squaredLength = (0, _coordinate.squaredDistance)(center, (0, _proj.fromUserCoordinate)(coordinates[coordinates.length - 1], projection));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);
          var userProjection = (0, _proj.getUserProjection)();
          if (userProjection) {
            circle.transform(projection, userProjection);
          }
          return circle;
        };
      } else {
        var Constructor;
        if (mode === 'Point') {
          Constructor = _Point.default;
        } else if (mode === 'LineString') {
          Constructor = _LineString.default;
        } else if (mode === 'Polygon') {
          Constructor = _Polygon.default;
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function geometryFunction(coordinates, geometry, projection) {
          if (geometry) {
            if (mode === 'Polygon') {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);
              } else {
                geometry.setCoordinates([], this.geometryLayout_);
              }
            } else {
              geometry.setCoordinates(coordinates, this.geometryLayout_);
            }
          } else {
            geometry = new Constructor(coordinates, this.geometryLayout_);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {GeometryFunction}
     * @private
     */
    _this2.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    _this2.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this2.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */
    _this2.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */
    _this2.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    _this2.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */
    _this2.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    _this2.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    _this2.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    _this2.overlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    _this2.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this2.condition_ = options.condition ? options.condition : _condition.noModifierKeys;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this2.freehandCondition_;
    if (options.freehand) {
      _this2.freehandCondition_ = _condition.always;
    } else {
      _this2.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _condition.shiftKeyOnly;
    }

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    _this2.traceCondition_;
    _this2.setTrace(options.trace || false);

    /**
     * @type {TraceState}
     * @private
     */
    _this2.traceState_ = {
      active: false
    };

    /**
     * @type {VectorSource|null}
     * @private
     */
    _this2.traceSource_ = options.traceSource || options.source || null;
    _this2.addChangeListener(_Property.default.ACTIVE, _this2.updateState_);
    return _this2;
  }

  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  _createClass(Draw, [{
    key: "setTrace",
    value: function setTrace(trace) {
      var condition;
      if (!trace) {
        condition = _condition.never;
      } else if (trace === true) {
        condition = _condition.always;
      } else {
        condition = trace;
      }
      this.traceCondition_ = condition;
    }

    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      _get(_getPrototypeOf(Draw.prototype), "setMap", this).call(this, map);
      this.updateState_();
    }

    /**
     * Get the overlay layer that this interaction renders sketch features to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
  }, {
    key: "getOverlay",
    value: function getOverlay() {
      return this.overlay_;
    }

    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (event.originalEvent.type === _EventType.default.CONTEXTMENU) {
        // Avoid context menu for long taps when drawing on mobile
        event.originalEvent.preventDefault();
      }
      this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
      var move = event.type === _MapBrowserEventType.default.POINTERMOVE;
      var pass = true;
      if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType.default.POINTERDRAG) {
        var now = Date.now();
        if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
          this.downPx_ = event.pixel;
          this.shouldHandle_ = !this.freehand_;
          move = true;
        } else {
          this.lastDragTime_ = undefined;
        }
        if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
          clearTimeout(this.downTimeout_);
          this.downTimeout_ = undefined;
        }
      }
      if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDRAG && this.sketchFeature_ !== null) {
        this.addToDrawing_(event.coordinate);
        pass = false;
      } else if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDOWN) {
        pass = false;
      } else if (move && this.getPointerCount() < 2) {
        pass = event.type === _MapBrowserEventType.default.POINTERMOVE;
        if (pass && this.freehand_) {
          this.handlePointerMove_(event);
          if (this.shouldHandle_) {
            // Avoid page scrolling when freehand drawing on mobile
            event.originalEvent.preventDefault();
          }
        } else if (event.originalEvent.pointerType === 'mouse' || event.type === _MapBrowserEventType.default.POINTERDRAG && this.downTimeout_ === undefined) {
          this.handlePointerMove_(event);
        }
      } else if (event.type === _MapBrowserEventType.default.DBLCLICK) {
        pass = false;
      }
      return _get(_getPrototypeOf(Draw.prototype), "handleEvent", this).call(this, event) && pass;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(event) {
      var _this3 = this;
      this.shouldHandle_ = !this.freehand_;
      if (this.freehand_) {
        this.downPx_ = event.pixel;
        if (!this.finishCoordinate_) {
          this.startDrawing_(event.coordinate);
        }
        return true;
      }
      if (!this.condition_(event)) {
        this.lastDragTime_ = undefined;
        return false;
      }
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function () {
        _this3.handlePointerMove_(new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
      }, this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    }

    /**
     * @private
     */
  }, {
    key: "deactivateTrace_",
    value: function deactivateTrace_() {
      this.traceState_ = {
        active: false
      };
    }

    /**
     * Activate or deactivate trace state based on a browser event.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
  }, {
    key: "toggleTraceState_",
    value: function toggleTraceState_(event) {
      if (!this.traceSource_ || !this.traceCondition_(event)) {
        return;
      }
      if (this.traceState_.active) {
        this.deactivateTrace_();
        return;
      }
      var map = this.getMap();
      var lowerLeft = map.getCoordinateFromPixel([event.pixel[0] - this.snapTolerance_, event.pixel[1] + this.snapTolerance_]);
      var upperRight = map.getCoordinateFromPixel([event.pixel[0] + this.snapTolerance_, event.pixel[1] - this.snapTolerance_]);
      var extent = (0, _extent.boundingExtent)([lowerLeft, upperRight]);
      var features = this.traceSource_.getFeaturesInExtent(extent);
      if (features.length === 0) {
        return;
      }
      var targets = getTraceTargets(event.coordinate, features);
      if (targets.length) {
        this.traceState_ = {
          active: true,
          startPx: event.pixel.slice(),
          targets: targets,
          targetIndex: -1
        };
      }
    }

    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} endIndex The new end index of the trace.
     * @private
     */
  }, {
    key: "addOrRemoveTracedCoordinates_",
    value: function addOrRemoveTracedCoordinates_(target, endIndex) {
      // three cases to handle:
      //  1. traced in the same direction and points need adding
      //  2. traced in the same direction and points need removing
      //  3. traced in a new direction
      var previouslyForward = target.startIndex <= target.endIndex;
      var currentlyForward = target.startIndex <= endIndex;
      if (previouslyForward === currentlyForward) {
        // same direction
        if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) {
          // case 1 - add new points
          this.addTracedCoordinates_(target, target.endIndex, endIndex);
        } else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) {
          // case 2 - remove old points
          this.removeTracedCoordinates_(endIndex, target.endIndex);
        }
      } else {
        // case 3 - remove old points, add new points
        this.removeTracedCoordinates_(target.startIndex, target.endIndex);
        this.addTracedCoordinates_(target, target.startIndex, endIndex);
      }
    }

    /**
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
  }, {
    key: "removeTracedCoordinates_",
    value: function removeTracedCoordinates_(fromIndex, toIndex) {
      if (fromIndex === toIndex) {
        return;
      }
      var remove = 0;
      if (fromIndex < toIndex) {
        var start = Math.ceil(fromIndex);
        var end = Math.floor(toIndex);
        if (end === toIndex) {
          end -= 1;
        }
        remove = end - start + 1;
      } else {
        var _start4 = Math.floor(fromIndex);
        var _end4 = Math.ceil(toIndex);
        if (_end4 === toIndex) {
          _end4 += 1;
        }
        remove = _start4 - _end4 + 1;
      }
      if (remove > 0) {
        this.removeLastPoints_(remove);
      }
    }

    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
  }, {
    key: "addTracedCoordinates_",
    value: function addTracedCoordinates_(target, fromIndex, toIndex) {
      if (fromIndex === toIndex) {
        return;
      }
      var coordinates = [];
      if (fromIndex < toIndex) {
        // forward trace
        var start = Math.ceil(fromIndex);
        var end = Math.floor(toIndex);
        if (end === toIndex) {
          // if end is snapped to a vertex, it will be added later
          end -= 1;
        }
        for (var i = start; i <= end; ++i) {
          coordinates.push(getCoordinate(target.coordinates, i));
        }
      } else {
        // reverse trace
        var _start5 = Math.floor(fromIndex);
        var _end5 = Math.ceil(toIndex);
        if (_end5 === toIndex) {
          _end5 += 1;
        }
        for (var _i4 = _start5; _i4 >= _end5; --_i4) {
          coordinates.push(getCoordinate(target.coordinates, _i4));
        }
      }
      if (coordinates.length) {
        this.appendCoordinates(coordinates);
      }
    }

    /**
     * Update the trace.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
  }, {
    key: "updateTrace_",
    value: function updateTrace_(event) {
      var traceState = this.traceState_;
      if (!traceState.active) {
        return;
      }
      if (traceState.targetIndex === -1) {
        // check if we are ready to pick a target
        if ((0, _coordinate.distance)(traceState.startPx, event.pixel) < this.snapTolerance_) {
          return;
        }
      }
      var updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);
      if (traceState.targetIndex !== updatedTraceTarget.index) {
        // target changed
        if (traceState.targetIndex !== -1) {
          // remove points added during previous trace
          var oldTarget = traceState.targets[traceState.targetIndex];
          this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
        }
        // add points for the new target
        var newTarget = traceState.targets[updatedTraceTarget.index];
        this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);
      } else {
        // target stayed the same
        var _target = traceState.targets[traceState.targetIndex];
        this.addOrRemoveTracedCoordinates_(_target, updatedTraceTarget.endIndex);
      }

      // modify the state with updated info
      traceState.targetIndex = updatedTraceTarget.index;
      var target = traceState.targets[traceState.targetIndex];
      target.endIndex = updatedTraceTarget.endIndex;

      // update event coordinate and pixel to match end point of final segment
      var coordinate = interpolateCoordinate(target.coordinates, target.endIndex);
      var pixel = this.getMap().getPixelFromCoordinate(coordinate);
      event.coordinate = coordinate;
      event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(event) {
      var pass = true;
      if (this.getPointerCount() === 0) {
        if (this.downTimeout_) {
          clearTimeout(this.downTimeout_);
          this.downTimeout_ = undefined;
        }
        this.handlePointerMove_(event);
        var tracing = this.traceState_.active;
        this.toggleTraceState_(event);
        if (this.shouldHandle_) {
          var startingToDraw = !this.finishCoordinate_;
          if (startingToDraw) {
            this.startDrawing_(event.coordinate);
          }
          if (!startingToDraw && this.freehand_) {
            this.finishDrawing();
          } else if (!this.freehand_ && (!startingToDraw || this.mode_ === 'Point')) {
            if (this.atFinish_(event.pixel, tracing)) {
              if (this.finishCondition_(event)) {
                this.finishDrawing();
              }
            } else {
              this.addToDrawing_(event.coordinate);
            }
          }
          pass = false;
        } else if (this.freehand_) {
          this.abortDrawing();
        }
      }
      if (!pass && this.stopClick_) {
        event.preventDefault();
      }
      return pass;
    }

    /**
     * Handle move events.
     * @param {import("../MapBrowserEvent.js").default} event A move event.
     * @private
     */
  }, {
    key: "handlePointerMove_",
    value: function handlePointerMove_(event) {
      this.pointerType_ = event.originalEvent.pointerType;
      if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
        var downPx = this.downPx_;
        var clickPx = event.pixel;
        var dx = downPx[0] - clickPx[0];
        var dy = downPx[1] - clickPx[1];
        var _squaredDistance = dx * dx + dy * dy;
        this.shouldHandle_ = this.freehand_ ? _squaredDistance > this.squaredClickTolerance_ : _squaredDistance <= this.squaredClickTolerance_;
        if (!this.shouldHandle_) {
          return;
        }
      }
      if (!this.finishCoordinate_) {
        this.createOrUpdateSketchPoint_(event.coordinate.slice());
        return;
      }
      this.updateTrace_(event);
      this.modifyDrawing_(event.coordinate);
    }

    /**
     * Determine if an event is within the snapping tolerance of the start coord.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
     * @return {boolean} The event is within the snapping tolerance of the start.
     * @private
     */
  }, {
    key: "atFinish_",
    value: function atFinish_(pixel, tracing) {
      var at = false;
      if (this.sketchFeature_) {
        var potentiallyDone = false;
        var potentiallyFinishCoordinates = [this.finishCoordinate_];
        var mode = this.mode_;
        if (mode === 'Point') {
          at = true;
        } else if (mode === 'Circle') {
          at = this.sketchCoords_.length === 2;
        } else if (mode === 'LineString') {
          potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
        } else if (mode === 'Polygon') {
          var sketchCoords = /** @type {PolyCoordType} */this.sketchCoords_;
          potentiallyDone = sketchCoords[0].length > this.minPoints_;
          potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
          if (tracing) {
            potentiallyFinishCoordinates = [sketchCoords[0][0]];
          } else {
            potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
          }
        }
        if (potentiallyDone) {
          var map = this.getMap();
          for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
            var finishCoordinate = potentiallyFinishCoordinates[i];
            var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
            var dx = pixel[0] - finishPixel[0];
            var dy = pixel[1] - finishPixel[1];
            var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
            at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
            if (at) {
              this.finishCoordinate_ = finishCoordinate;
              break;
            }
          }
        }
      }
      return at;
    }

    /**
     * @param {import("../coordinate").Coordinate} coordinates Coordinate.
     * @private
     */
  }, {
    key: "createOrUpdateSketchPoint_",
    value: function createOrUpdateSketchPoint_(coordinates) {
      if (!this.sketchPoint_) {
        this.sketchPoint_ = new _Feature.default(new _Point.default(coordinates));
        this.updateSketchFeatures_();
      } else {
        var sketchPointGeom = this.sketchPoint_.getGeometry();
        sketchPointGeom.setCoordinates(coordinates);
      }
    }

    /**
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @private
     */
  }, {
    key: "createOrUpdateCustomSketchLine_",
    value: function createOrUpdateCustomSketchLine_(geometry) {
      if (!this.sketchLine_) {
        this.sketchLine_ = new _Feature.default();
      }
      var ring = geometry.getLinearRing(0);
      var sketchLineGeom = this.sketchLine_.getGeometry();
      if (!sketchLineGeom) {
        sketchLineGeom = new _LineString.default(ring.getFlatCoordinates(), ring.getLayout());
        this.sketchLine_.setGeometry(sketchLineGeom);
      } else {
        sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
        sketchLineGeom.changed();
      }
    }

    /**
     * Start the drawing.
     * @param {import("../coordinate.js").Coordinate} start Start coordinate.
     * @private
     */
  }, {
    key: "startDrawing_",
    value: function startDrawing_(start) {
      var projection = this.getMap().getView().getProjection();
      var stride = (0, _SimpleGeometry.getStrideForLayout)(this.geometryLayout_);
      while (start.length < stride) {
        start.push(0);
      }
      this.finishCoordinate_ = start;
      if (this.mode_ === 'Point') {
        this.sketchCoords_ = start.slice();
      } else if (this.mode_ === 'Polygon') {
        this.sketchCoords_ = [[start.slice(), start.slice()]];
        this.sketchLineCoords_ = this.sketchCoords_[0];
      } else {
        this.sketchCoords_ = [start.slice(), start.slice()];
      }
      if (this.sketchLineCoords_) {
        this.sketchLine_ = new _Feature.default(new _LineString.default(this.sketchLineCoords_));
      }
      var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
      this.sketchFeature_ = new _Feature.default();
      if (this.geometryName_) {
        this.sketchFeature_.setGeometryName(this.geometryName_);
      }
      this.sketchFeature_.setGeometry(geometry);
      this.updateSketchFeatures_();
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }

    /**
     * Modify the drawing.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @private
     */
  }, {
    key: "modifyDrawing_",
    value: function modifyDrawing_(coordinate) {
      var map = this.getMap();
      var geometry = this.sketchFeature_.getGeometry();
      var projection = map.getView().getProjection();
      var stride = (0, _SimpleGeometry.getStrideForLayout)(this.geometryLayout_);
      var coordinates, last;
      while (coordinate.length < stride) {
        coordinate.push(0);
      }
      if (this.mode_ === 'Point') {
        last = this.sketchCoords_;
      } else if (this.mode_ === 'Polygon') {
        coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];
        last = coordinates[coordinates.length - 1];
        if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
          // snap to finish
          coordinate = this.finishCoordinate_.slice();
        }
      } else {
        coordinates = this.sketchCoords_;
        last = coordinates[coordinates.length - 1];
      }
      last[0] = coordinate[0];
      last[1] = coordinate[1];
      this.geometryFunction_( /** @type {!LineCoordType} */this.sketchCoords_, geometry, projection);
      if (this.sketchPoint_) {
        var sketchPointGeom = this.sketchPoint_.getGeometry();
        sketchPointGeom.setCoordinates(coordinate);
      }
      if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {
        this.createOrUpdateCustomSketchLine_( /** @type {Polygon} */geometry);
      } else if (this.sketchLineCoords_) {
        var sketchLineGeom = this.sketchLine_.getGeometry();
        sketchLineGeom.setCoordinates(this.sketchLineCoords_);
      }
      this.updateSketchFeatures_();
    }

    /**
     * Add a new coordinate to the drawing.
     * @param {!PointCoordType} coordinate Coordinate
     * @private
     */
  }, {
    key: "addToDrawing_",
    value: function addToDrawing_(coordinate) {
      var geometry = this.sketchFeature_.getGeometry();
      var projection = this.getMap().getView().getProjection();
      var done;
      var coordinates;
      var mode = this.mode_;
      if (mode === 'LineString' || mode === 'Circle') {
        this.finishCoordinate_ = coordinate.slice();
        coordinates = /** @type {LineCoordType} */this.sketchCoords_;
        if (coordinates.length >= this.maxPoints_) {
          if (this.freehand_) {
            coordinates.pop();
          } else {
            done = true;
          }
        }
        coordinates.push(coordinate.slice());
        this.geometryFunction_(coordinates, geometry, projection);
      } else if (mode === 'Polygon') {
        coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];
        if (coordinates.length >= this.maxPoints_) {
          if (this.freehand_) {
            coordinates.pop();
          } else {
            done = true;
          }
        }
        coordinates.push(coordinate.slice());
        if (done) {
          this.finishCoordinate_ = coordinates[0];
        }
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
      }
      this.createOrUpdateSketchPoint_(coordinate.slice());
      this.updateSketchFeatures_();
      if (done) {
        this.finishDrawing();
      }
    }

    /**
     * @param {number} n The number of points to remove.
     */
  }, {
    key: "removeLastPoints_",
    value: function removeLastPoints_(n) {
      if (!this.sketchFeature_) {
        return;
      }
      var geometry = this.sketchFeature_.getGeometry();
      var projection = this.getMap().getView().getProjection();
      var mode = this.mode_;
      for (var i = 0; i < n; ++i) {
        var coordinates = void 0;
        if (mode === 'LineString' || mode === 'Circle') {
          coordinates = /** @type {LineCoordType} */this.sketchCoords_;
          coordinates.splice(-2, 1);
          if (coordinates.length >= 2) {
            this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
            var finishCoordinate = this.finishCoordinate_.slice();
            coordinates[coordinates.length - 1] = finishCoordinate;
            this.createOrUpdateSketchPoint_(finishCoordinate);
          }
          this.geometryFunction_(coordinates, geometry, projection);
          if (geometry.getType() === 'Polygon' && this.sketchLine_) {
            this.createOrUpdateCustomSketchLine_( /** @type {Polygon} */geometry);
          }
        } else if (mode === 'Polygon') {
          coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];
          coordinates.splice(-2, 1);
          var sketchLineGeom = this.sketchLine_.getGeometry();
          if (coordinates.length >= 2) {
            var _finishCoordinate = coordinates[coordinates.length - 2].slice();
            coordinates[coordinates.length - 1] = _finishCoordinate;
            this.createOrUpdateSketchPoint_(_finishCoordinate);
          }
          sketchLineGeom.setCoordinates(coordinates);
          this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        if (coordinates.length === 1) {
          this.abortDrawing();
          break;
        }
      }
      this.updateSketchFeatures_();
    }

    /**
     * Remove last point of the feature currently being drawn. Does not do anything when
     * drawing POINT or MULTI_POINT geometries.
     * @api
     */
  }, {
    key: "removeLastPoint",
    value: function removeLastPoint() {
      this.removeLastPoints_(1);
    }

    /**
     * Stop drawing and add the sketch feature to the target layer.
     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
     * dispatched before inserting the feature.
     * @api
     */
  }, {
    key: "finishDrawing",
    value: function finishDrawing() {
      var sketchFeature = this.abortDrawing_();
      if (!sketchFeature) {
        return;
      }
      var coordinates = this.sketchCoords_;
      var geometry = sketchFeature.getGeometry();
      var projection = this.getMap().getView().getProjection();
      if (this.mode_ === 'LineString') {
        // remove the redundant last point
        coordinates.pop();
        this.geometryFunction_(coordinates, geometry, projection);
      } else if (this.mode_ === 'Polygon') {
        // remove the redundant last point in ring
        /** @type {PolyCoordType} */
        coordinates[0].pop();
        this.geometryFunction_(coordinates, geometry, projection);
        coordinates = geometry.getCoordinates();
      }

      // cast multi-part geometries
      if (this.type_ === 'MultiPoint') {
        sketchFeature.setGeometry(new _MultiPoint.default([( /** @type {PointCoordType} */coordinates)]));
      } else if (this.type_ === 'MultiLineString') {
        sketchFeature.setGeometry(new _MultiLineString.default([( /** @type {LineCoordType} */coordinates)]));
      } else if (this.type_ === 'MultiPolygon') {
        sketchFeature.setGeometry(new _MultiPolygon.default([( /** @type {PolyCoordType} */coordinates)]));
      }

      // First dispatch event to allow full set up of feature
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

      // Then insert feature
      if (this.features_) {
        this.features_.push(sketchFeature);
      }
      if (this.source_) {
        this.source_.addFeature(sketchFeature);
      }
    }

    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
     * @private
     */
  }, {
    key: "abortDrawing_",
    value: function abortDrawing_() {
      this.finishCoordinate_ = null;
      var sketchFeature = this.sketchFeature_;
      this.sketchFeature_ = null;
      this.sketchPoint_ = null;
      this.sketchLine_ = null;
      this.overlay_.getSource().clear(true);
      this.deactivateTrace_();
      return sketchFeature;
    }

    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @api
     */
  }, {
    key: "abortDrawing",
    value: function abortDrawing() {
      var sketchFeature = this.abortDrawing_();
      if (sketchFeature) {
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
      }
    }

    /**
     * Append coordinates to the end of the geometry that is currently being drawn.
     * This can be used when drawing LineStrings or Polygons. Coordinates will
     * either be appended to the current LineString or the outer ring of the current
     * Polygon. If no geometry is being drawn, a new one will be created.
     * @param {!LineCoordType} coordinates Linear coordinates to be appended to
     * the coordinate array.
     * @api
     */
  }, {
    key: "appendCoordinates",
    value: function appendCoordinates(coordinates) {
      var mode = this.mode_;
      var newDrawing = !this.sketchFeature_;
      if (newDrawing) {
        this.startDrawing_(coordinates[0]);
      }
      /** @type {LineCoordType} */
      var sketchCoords;
      if (mode === 'LineString' || mode === 'Circle') {
        sketchCoords = /** @type {LineCoordType} */this.sketchCoords_;
      } else if (mode === 'Polygon') {
        sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */this.sketchCoords_[0] : [];
      } else {
        return;
      }
      if (newDrawing) {
        sketchCoords.shift();
      }

      // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
      sketchCoords.pop();

      // Append coordinate list
      for (var i = 0; i < coordinates.length; i++) {
        this.addToDrawing_(coordinates[i]);
      }
      var ending = coordinates[coordinates.length - 1];
      // Duplicate last coordinate for sketch drawing (cursor position)
      this.addToDrawing_(ending);
      this.modifyDrawing_(ending);
    }

    /**
     * Initiate draw mode by starting from an existing geometry which will
     * receive new additional points. This only works on features with
     * `LineString` geometries, where the interaction will extend lines by adding
     * points to the end of the coordinates array.
     * This will change the original feature, instead of drawing a copy.
     *
     * The function will dispatch a `drawstart` event.
     *
     * @param {!Feature<LineString>} feature Feature to be extended.
     * @api
     */
  }, {
    key: "extend",
    value: function extend(feature) {
      var geometry = feature.getGeometry();
      var lineString = geometry;
      this.sketchFeature_ = feature;
      this.sketchCoords_ = lineString.getCoordinates();
      var last = this.sketchCoords_[this.sketchCoords_.length - 1];
      this.finishCoordinate_ = last.slice();
      this.sketchCoords_.push(last.slice());
      this.sketchPoint_ = new _Feature.default(new _Point.default(last));
      this.updateSketchFeatures_();
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }

    /**
     * Redraw the sketch features.
     * @private
     */
  }, {
    key: "updateSketchFeatures_",
    value: function updateSketchFeatures_() {
      var sketchFeatures = [];
      if (this.sketchFeature_) {
        sketchFeatures.push(this.sketchFeature_);
      }
      if (this.sketchLine_) {
        sketchFeatures.push(this.sketchLine_);
      }
      if (this.sketchPoint_) {
        sketchFeatures.push(this.sketchPoint_);
      }
      var overlaySource = this.overlay_.getSource();
      overlaySource.clear(true);
      overlaySource.addFeatures(sketchFeatures);
    }

    /**
     * @private
     */
  }, {
    key: "updateState_",
    value: function updateState_() {
      var map = this.getMap();
      var active = this.getActive();
      if (!map || !active) {
        this.abortDrawing();
      }
      this.overlay_.setMap(active ? map : null);
    }
  }]);
  return Draw;
}(_Pointer.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}

/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */
function createRegularPolygon(sides, angle) {
  return function (coordinates, geometry, projection) {
    var center = (0, _proj.fromUserCoordinate)( /** @type {LineCoordType} */coordinates[0], projection);
    var end = (0, _proj.fromUserCoordinate)( /** @type {LineCoordType} */coordinates[coordinates.length - 1], projection);
    var radius = Math.sqrt((0, _coordinate.squaredDistance)(center, end));
    geometry = geometry || (0, _Polygon.fromCircle)(new _Circle.default(center), sides);
    var internalAngle = angle;
    if (!angle && angle !== 0) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      internalAngle = Math.atan2(y, x);
    }
    (0, _Polygon.makeRegular)( /** @type {Polygon} */geometry, center, radius, internalAngle);
    var userProjection = (0, _proj.getUserProjection)();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return function (coordinates, geometry, projection) {
    var extent = (0, _extent.boundingExtent)( /** @type {LineCoordType} */[coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {
      return (0, _proj.fromUserCoordinate)(coordinate, projection);
    }));
    var boxCoordinates = [[(0, _extent.getBottomLeft)(extent), (0, _extent.getBottomRight)(extent), (0, _extent.getTopRight)(extent), (0, _extent.getTopLeft)(extent), (0, _extent.getBottomLeft)(extent)]];
    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _Polygon.default(boxCoordinates);
    }
    var userProjection = (0, _proj.getUserProjection)();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
  switch (type) {
    case 'Point':
    case 'MultiPoint':
      return 'Point';
    case 'LineString':
    case 'MultiLineString':
      return 'LineString';
    case 'Polygon':
    case 'MultiPolygon':
      return 'Polygon';
    case 'Circle':
      return 'Circle';
    default:
      throw new Error('Invalid type: ' + type);
  }
}
var _default = exports.default = Draw;
},{"../geom/Circle.js":"node_modules/ol/geom/Circle.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../geom/GeometryCollection.js":"node_modules/ol/geom/GeometryCollection.js","./Property.js":"node_modules/ol/interaction/Property.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","../geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","../geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../style/Style.js":"node_modules/ol/style/Style.js","../coordinate.js":"node_modules/ol/coordinate.js","../proj.js":"node_modules/ol/proj.js","../geom/SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js"}],"node_modules/ol/MapEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/MapEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend',
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: 'loadstart',
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: 'loadend'
};
/***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */
},{}],"node_modules/ol/Overlay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("./Object.js"));
var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));
var _css = require("./css.js");
var _extent = require("./extent.js");
var _events = require("./events.js");
var _dom = require("./dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Overlay
 */
/**
 * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning
 * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, or `'top-right'`.
 */

/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {Positioning} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */

/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing.inAndOut}.
 */

/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */

/**
 * @enum {string}
 * @protected
 */
var Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};

/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */

/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay.js';
 *
 *     // ...
 *     const popup = new Overlay({
 *       element: document.getElementById('popup'),
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */
var Overlay = /*#__PURE__*/function (_BaseObject) {
  _inherits(Overlay, _BaseObject);
  var _super = _createSuper(Overlay);
  /**
   * @param {Options} options Overlay options.
   */
  function Overlay(options) {
    var _this;
    _classCallCheck(this, Overlay);
    _this = _super.call(this);

    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */
    _this.on;

    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */
    _this.once;

    /***
     * @type {OverlayOnSignature<void>}
     */
    _this.un;

    /**
     * @protected
     * @type {Options}
     */
    _this.options = options;

    /**
     * @protected
     * @type {number|string|undefined}
     */
    _this.id = options.id;

    /**
     * @protected
     * @type {boolean}
     */
    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;

    /**
     * @protected
     * @type {boolean}
     */
    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;

    /**
     * @protected
     * @type {HTMLElement}
     */
    _this.element = document.createElement('div');
    _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _css.CLASS_SELECTABLE;
    _this.element.style.position = 'absolute';
    _this.element.style.pointerEvents = 'auto';

    /**
     * @protected
     * @type {PanIntoViewOptions|undefined}
     */
    _this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;

    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */
    _this.rendered = {
      transform_: '',
      visible: true
    };

    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */
    _this.mapPostrenderListenerKey = null;
    _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);
    _this.addChangeListener(Property.MAP, _this.handleMapChanged);
    _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);
    _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);
    _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);
    if (options.element !== undefined) {
      _this.setElement(options.element);
    }
    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
    _this.setPositioning(options.positioning || 'top-left');
    if (options.position !== undefined) {
      _this.setPosition(options.position);
    }
    return _this;
  }

  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  _createClass(Overlay, [{
    key: "getElement",
    value: function getElement() {
      return /** @type {HTMLElement|undefined} */this.get(Property.ELEMENT);
    }

    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }

    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
  }, {
    key: "getMap",
    value: function getMap() {
      return /** @type {import("./Map.js").default|null} */(
        this.get(Property.MAP) || null
      );
    }

    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
  }, {
    key: "getOffset",
    value: function getOffset() {
      return /** @type {Array<number>} */this.get(Property.OFFSET);
    }

    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      return /** @type {import("./coordinate.js").Coordinate|undefined} */(
        this.get(Property.POSITION)
      );
    }

    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
  }, {
    key: "getPositioning",
    value: function getPositioning() {
      return /** @type {Positioning} */this.get(Property.POSITIONING);
    }

    /**
     * @protected
     */
  }, {
    key: "handleElementChanged",
    value: function handleElementChanged() {
      (0, _dom.removeChildren)(this.element);
      var element = this.getElement();
      if (element) {
        this.element.appendChild(element);
      }
    }

    /**
     * @protected
     */
  }, {
    key: "handleMapChanged",
    value: function handleMapChanged() {
      if (this.mapPostrenderListenerKey) {
        (0, _dom.removeNode)(this.element);
        (0, _events.unlistenByKey)(this.mapPostrenderListenerKey);
        this.mapPostrenderListenerKey = null;
      }
      var map = this.getMap();
      if (map) {
        this.mapPostrenderListenerKey = (0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this);
        this.updatePixelPosition();
        var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
        if (this.insertFirst) {
          container.insertBefore(this.element, container.childNodes[0] || null);
        } else {
          container.appendChild(this.element);
        }
        this.performAutoPan();
      }
    }

    /**
     * @protected
     */
  }, {
    key: "render",
    value: function render() {
      this.updatePixelPosition();
    }

    /**
     * @protected
     */
  }, {
    key: "handleOffsetChanged",
    value: function handleOffsetChanged() {
      this.updatePixelPosition();
    }

    /**
     * @protected
     */
  }, {
    key: "handlePositionChanged",
    value: function handlePositionChanged() {
      this.updatePixelPosition();
      this.performAutoPan();
    }

    /**
     * @protected
     */
  }, {
    key: "handlePositioningChanged",
    value: function handlePositioningChanged() {
      this.updatePixelPosition();
    }

    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
  }, {
    key: "setElement",
    value: function setElement(element) {
      this.set(Property.ELEMENT, element);
    }

    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      this.set(Property.MAP, map);
    }

    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      this.set(Property.OFFSET, offset);
    }

    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.set(Property.POSITION, position);
    }

    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
  }, {
    key: "performAutoPan",
    value: function performAutoPan() {
      if (this.autoPan) {
        this.panIntoView(this.autoPan);
      }
    }

    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */
  }, {
    key: "panIntoView",
    value: function panIntoView(panIntoViewOptions) {
      var map = this.getMap();
      if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
        return;
      }
      var mapRect = this.getRect(map.getTargetElement(), map.getSize());
      var element = this.getElement();
      var overlayRect = this.getRect(element, [(0, _dom.outerWidth)(element), (0, _dom.outerHeight)(element)]);
      panIntoViewOptions = panIntoViewOptions || {};
      var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
      if (!(0, _extent.containsExtent)(mapRect, overlayRect)) {
        // the overlay is not completely inside the viewport, so pan the map
        var offsetLeft = overlayRect[0] - mapRect[0];
        var offsetRight = mapRect[2] - overlayRect[2];
        var offsetTop = overlayRect[1] - mapRect[1];
        var offsetBottom = mapRect[3] - overlayRect[3];
        var delta = [0, 0];
        if (offsetLeft < 0) {
          // move map to the left
          delta[0] = offsetLeft - myMargin;
        } else if (offsetRight < 0) {
          // move map to the right
          delta[0] = Math.abs(offsetRight) + myMargin;
        }
        if (offsetTop < 0) {
          // move map up
          delta[1] = offsetTop - myMargin;
        } else if (offsetBottom < 0) {
          // move map down
          delta[1] = Math.abs(offsetBottom) + myMargin;
        }
        if (delta[0] !== 0 || delta[1] !== 0) {
          var center = /** @type {import("./coordinate.js").Coordinate} */
          map.getView().getCenterInternal();
          var centerPx = map.getPixelFromCoordinateInternal(center);
          if (!centerPx) {
            return;
          }
          var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
          var panOptions = panIntoViewOptions.animation || {};
          map.getView().animateInternal({
            center: map.getCoordinateFromPixelInternal(newCenterPx),
            duration: panOptions.duration,
            easing: panOptions.easing
          });
        }
      }
    }

    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
  }, {
    key: "getRect",
    value: function getRect(element, size) {
      var box = element.getBoundingClientRect();
      var offsetX = box.left + window.pageXOffset;
      var offsetY = box.top + window.pageYOffset;
      return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
    }

    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
  }, {
    key: "setPositioning",
    value: function setPositioning(positioning) {
      this.set(Property.POSITIONING, positioning);
    }

    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (this.rendered.visible !== visible) {
        this.element.style.display = visible ? '' : 'none';
        this.rendered.visible = visible;
      }
    }

    /**
     * Update pixel position.
     * @protected
     */
  }, {
    key: "updatePixelPosition",
    value: function updatePixelPosition() {
      var map = this.getMap();
      var position = this.getPosition();
      if (!map || !map.isRendered() || !position) {
        this.setVisible(false);
        return;
      }
      var pixel = map.getPixelFromCoordinate(position);
      var mapSize = map.getSize();
      this.updateRenderedPosition(pixel, mapSize);
    }

    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
  }, {
    key: "updateRenderedPosition",
    value: function updateRenderedPosition(pixel, mapSize) {
      var style = this.element.style;
      var offset = this.getOffset();
      var positioning = this.getPositioning();
      this.setVisible(true);
      var x = Math.round(pixel[0] + offset[0]) + 'px';
      var y = Math.round(pixel[1] + offset[1]) + 'px';
      var posX = '0%';
      var posY = '0%';
      if (positioning == 'bottom-right' || positioning == 'center-right' || positioning == 'top-right') {
        posX = '-100%';
      } else if (positioning == 'bottom-center' || positioning == 'center-center' || positioning == 'top-center') {
        posX = '-50%';
      }
      if (positioning == 'bottom-left' || positioning == 'bottom-center' || positioning == 'bottom-right') {
        posY = '-100%';
      } else if (positioning == 'center-left' || positioning == 'center-center' || positioning == 'center-right') {
        posY = '-50%';
      }
      var transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x, ", ").concat(y, ")");
      if (this.rendered.transform_ != transform) {
        this.rendered.transform_ = transform;
        style.transform = transform;
      }
    }

    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this.options;
    }
  }]);
  return Overlay;
}(_Object.default);
var _default = exports.default = Overlay;
},{"./Object.js":"node_modules/ol/Object.js","./MapEventType.js":"node_modules/ol/MapEventType.js","./css.js":"node_modules/ol/css.js","./extent.js":"node_modules/ol/extent.js","./events.js":"node_modules/ol/events.js","./dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/structs/LRUCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asserts = require("../asserts.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/structs/LRUCache
 */
/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Entry|null} newer Newer.
 * @property {Entry|null} older Older.
 * @property {*} value_ Value.
 */
/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
var LRUCache = /*#__PURE__*/function () {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  function LRUCache(highWaterMark) {
    _classCallCheck(this, LRUCache);
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  _createClass(LRUCache, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }

    /**
     * Expire the cache.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
  }, {
    key: "expireCache",
    value: function expireCache(keep) {
      while (this.canExpireCache()) {
        this.pop();
      }
    }

    /**
     * FIXME empty description for jsdoc
     */
  }, {
    key: "clear",
    value: function clear() {
      this.count_ = 0;
      this.entries_ = {};
      this.oldest_ = null;
      this.newest_ = null;
    }

    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
  }, {
    key: "containsKey",
    value: function containsKey(key) {
      return this.entries_.hasOwnProperty(key);
    }

    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
  }, {
    key: "forEach",
    value: function forEach(f) {
      var entry = this.oldest_;
      while (entry) {
        f(entry.value_, entry.key_, this);
        entry = entry.newer;
      }
    }

    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */
  }, {
    key: "get",
    value: function get(key, options) {
      var entry = this.entries_[key];
      (0, _asserts.assert)(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');
      if (entry === this.newest_) {
        return entry.value_;
      }
      if (entry === this.oldest_) {
        this.oldest_ = /** @type {Entry} */this.oldest_.newer;
        this.oldest_.older = null;
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }
      entry.newer = null;
      entry.older = this.newest_;
      this.newest_.newer = entry;
      this.newest_ = entry;
      return entry.value_;
    }

    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
  }, {
    key: "remove",
    value: function remove(key) {
      var entry = this.entries_[key];
      (0, _asserts.assert)(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');
      if (entry === this.newest_) {
        this.newest_ = /** @type {Entry} */entry.older;
        if (this.newest_) {
          this.newest_.newer = null;
        }
      } else if (entry === this.oldest_) {
        this.oldest_ = /** @type {Entry} */entry.newer;
        if (this.oldest_) {
          this.oldest_.older = null;
        }
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }
      delete this.entries_[key];
      --this.count_;
      return entry.value_;
    }

    /**
     * @return {number} Count.
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.count_;
    }

    /**
     * @return {Array<string>} Keys.
     */
  }, {
    key: "getKeys",
    value: function getKeys() {
      var keys = new Array(this.count_);
      var i = 0;
      var entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        keys[i++] = entry.key_;
      }
      return keys;
    }

    /**
     * @return {Array<T>} Values.
     */
  }, {
    key: "getValues",
    value: function getValues() {
      var values = new Array(this.count_);
      var i = 0;
      var entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        values[i++] = entry.value_;
      }
      return values;
    }

    /**
     * @return {T} Last value.
     */
  }, {
    key: "peekLast",
    value: function peekLast() {
      return this.oldest_.value_;
    }

    /**
     * @return {string} Last key.
     */
  }, {
    key: "peekLastKey",
    value: function peekLastKey() {
      return this.oldest_.key_;
    }

    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
  }, {
    key: "peekFirstKey",
    value: function peekFirstKey() {
      return this.newest_.key_;
    }

    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T|undefined} Value.
     */
  }, {
    key: "peek",
    value: function peek(key) {
      var _this$entries_$key;
      return (_this$entries_$key = this.entries_[key]) === null || _this$entries_$key === void 0 ? void 0 : _this$entries_$key.value_;
    }

    /**
     * @return {T} value Value.
     */
  }, {
    key: "pop",
    value: function pop() {
      var entry = this.oldest_;
      delete this.entries_[entry.key_];
      if (entry.newer) {
        entry.newer.older = null;
      }
      this.oldest_ = /** @type {Entry} */entry.newer;
      if (!this.oldest_) {
        this.newest_ = null;
      }
      --this.count_;
      return entry.value_;
    }

    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
  }, {
    key: "replace",
    value: function replace(key, value) {
      this.get(key); // update `newest_`
      this.entries_[key].value_ = value;
    }

    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
  }, {
    key: "set",
    value: function set(key, value) {
      (0, _asserts.assert)(!(key in this.entries_), 'Tried to set a value for a key that is used already');
      var entry = {
        key_: key,
        newer: null,
        older: this.newest_,
        value_: value
      };
      if (!this.newest_) {
        this.oldest_ = entry;
      } else {
        this.newest_.newer = entry;
      }
      this.newest_ = entry;
      this.entries_[key] = entry;
      ++this.count_;
    }

    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
  }, {
    key: "setSize",
    value: function setSize(size) {
      this.highWaterMark = size;
    }
  }]);
  return LRUCache;
}();
var _default = exports.default = LRUCache;
},{"../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/TileState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/TileState
 */
/**
 * @enum {number}
 */
var _default = exports.default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
},{}],"node_modules/ol/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Target = _interopRequireDefault(require("./events/Target.js"));
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _TileState = _interopRequireDefault(require("./TileState.js"));
var _util = require("./util.js");
var _easing = require("./easing.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Tile
 */
/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */
/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */
/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */
/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile = /*#__PURE__*/function (_EventTarget) {
  _inherits(Tile, _EventTarget);
  var _super = _createSuper(Tile);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  function Tile(tileCoord, state, options) {
    var _this;
    _classCallCheck(this, Tile);
    _this = _super.call(this);
    options = options ? options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    _this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {import("./TileState.js").default}
     */
    _this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile|null}
     */
    _this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    _this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    _this.transition_ = options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    _this.transitionStarts_ = {};

    /**
     * @type {boolean}
     */
    _this.interpolate = !!options.interpolate;
    return _this;
  }

  /**
   * @protected
   */
  _createClass(Tile, [{
    key: "changed",
    value: function changed() {
      this.dispatchEvent(_EventType.default.CHANGE);
    }

    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
  }, {
    key: "release",
    value: function release() {
      if (this.state === _TileState.default.ERROR) {
        // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
        this.setState(_TileState.default.EMPTY);
      }
    }

    /**
     * @return {string} Key.
     */
  }, {
    key: "getKey",
    value: function getKey() {
      return this.key + '/' + this.tileCoord;
    }

    /**
     * Get the interim tile most suitable for rendering using the chain of interim
     * tiles. This corresponds to the  most recent tile that has been loaded, if no
     * such tile exists, the original tile is returned.
     * @return {!Tile} Best tile for rendering.
     */
  }, {
    key: "getInterimTile",
    value: function getInterimTile() {
      var tile = this.interimTile;
      if (!tile) {
        //empty chain
        return this;
      }

      // find the first loaded tile and return it. Since the chain is sorted in
      // decreasing order of creation time, there is no need to search the remainder
      // of the list (all those tiles correspond to older requests and will be
      // cleaned up by refreshInterimChain)
      do {
        if (tile.getState() == _TileState.default.LOADED) {
          // Show tile immediately instead of fading it in after loading, because
          // the interim tile is in place already
          this.transition_ = 0;
          return tile;
        }
        tile = tile.interimTile;
      } while (tile);

      // we can not find a better tile
      return this;
    }

    /**
     * Goes through the chain of interim tiles and discards sections of the chain
     * that are no longer relevant.
     */
  }, {
    key: "refreshInterimChain",
    value: function refreshInterimChain() {
      var tile = this.interimTile;
      if (!tile) {
        return;
      }

      /** @type {Tile} */
      var prev = this;
      do {
        if (tile.getState() == _TileState.default.LOADED) {
          //we have a loaded tile, we can discard the rest of the list
          //we would could abort any LOADING tile request
          //older than this tile (i.e. any LOADING tile following this entry in the chain)
          tile.interimTile = null;
          break;
        }
        if (tile.getState() == _TileState.default.LOADING) {
          //keep this LOADING tile any loaded tiles later in the chain are
          //older than this tile, so we're still interested in the request
          prev = tile;
        } else if (tile.getState() == _TileState.default.IDLE) {
          //the head of the list is the most current tile, we don't need
          //to start any other requests for this chain
          prev.interimTile = tile.interimTile;
        } else {
          prev = tile;
        }
        tile = prev.interimTile;
      } while (tile);
    }

    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
  }, {
    key: "getTileCoord",
    value: function getTileCoord() {
      return this.tileCoord;
    }

    /**
     * @return {import("./TileState.js").default} State.
     */
  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }

    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
  }, {
    key: "setState",
    value: function setState(state) {
      if (this.state !== _TileState.default.ERROR && this.state > state) {
        throw new Error('Tile load sequence violation');
      }
      this.state = state;
      this.changed();
    }

    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
  }, {
    key: "load",
    value: function load() {
      (0, _util.abstract)();
    }

    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
  }, {
    key: "getAlpha",
    value: function getAlpha(id, time) {
      if (!this.transition_) {
        return 1;
      }
      var start = this.transitionStarts_[id];
      if (!start) {
        start = time;
        this.transitionStarts_[id] = start;
      } else if (start === -1) {
        return 1;
      }
      var delta = time - start + 1000 / 60; // avoid rendering at 0
      if (delta >= this.transition_) {
        return 1;
      }
      return (0, _easing.easeIn)(delta / this.transition_);
    }

    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
  }, {
    key: "inTransition",
    value: function inTransition(id) {
      if (!this.transition_) {
        return false;
      }
      return this.transitionStarts_[id] !== -1;
    }

    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
  }, {
    key: "endTransition",
    value: function endTransition(id) {
      if (this.transition_) {
        this.transitionStarts_[id] = -1;
      }
    }
  }]);
  return Tile;
}(_Target.default);
var _default = exports.default = Tile;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./TileState.js":"node_modules/ol/TileState.js","./util.js":"node_modules/ol/util.js","./easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/ImageTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Tile2 = _interopRequireDefault(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("./TileState.js"));
var _dom = require("./dom.js");
var _Image = require("./Image.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/ImageTile
 */
var ImageTile = /*#__PURE__*/function (_Tile) {
  _inherits(ImageTile, _Tile);
  var _super = _createSuper(ImageTile);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    var _this;
    _classCallCheck(this, ImageTile);
    _this = _super.call(this, tileCoord, state, options);

    /**
     * @private
     * @type {?string}
     */
    _this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    _this.src_ = src;
    _this.key = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    _this.image_ = new Image();
    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {?function():void}
     */
    _this.unlisten_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  _createClass(ImageTile, [{
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }

    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
  }, {
    key: "setImage",
    value: function setImage(element) {
      this.image_ = element;
      this.state = _TileState.default.LOADED;
      this.unlistenImage_();
      this.changed();
    }

    /**
     * Tracks loading or read errors.
     *
     * @private
     */
  }, {
    key: "handleImageError_",
    value: function handleImageError_() {
      this.state = _TileState.default.ERROR;
      this.unlistenImage_();
      this.image_ = getBlankImage();
      this.changed();
    }

    /**
     * Tracks successful image load.
     *
     * @private
     */
  }, {
    key: "handleImageLoad_",
    value: function handleImageLoad_() {
      var image = /** @type {HTMLImageElement} */this.image_;
      if (image.naturalWidth && image.naturalHeight) {
        this.state = _TileState.default.LOADED;
      } else {
        this.state = _TileState.default.EMPTY;
      }
      this.unlistenImage_();
      this.changed();
    }

    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     *
     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
     * that checks for error status codes and reloads only when the status code is
     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
     * made already:
     *
     * ```js
     * const retryCodes = [408, 429, 500, 502, 503, 504];
     * const retries = {};
     * source.setTileLoadFunction((tile, src) => {
     *   const image = tile.getImage();
     *   fetch(src)
     *     .then((response) => {
     *       if (retryCodes.includes(response.status)) {
     *         retries[src] = (retries[src] || 0) + 1;
     *         if (retries[src] <= 3) {
     *           setTimeout(() => tile.load(), retries[src] * 1000);
     *         }
     *         return Promise.reject();
     *       }
     *       return response.blob();
     *     })
     *     .then((blob) => {
     *       const imageUrl = URL.createObjectURL(blob);
     *       image.src = imageUrl;
     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
     *     })
     *     .catch(() => tile.setState(3)); // error
     * });
     * ```
     *
     * @api
     */
  }, {
    key: "load",
    value: function load() {
      if (this.state == _TileState.default.ERROR) {
        this.state = _TileState.default.IDLE;
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      if (this.state == _TileState.default.IDLE) {
        this.state = _TileState.default.LOADING;
        this.changed();
        this.tileLoadFunction_(this, this.src_);
        this.unlisten_ = (0, _Image.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
      }
    }

    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
  }, {
    key: "unlistenImage_",
    value: function unlistenImage_() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    }
  }]);
  return ImageTile;
}(_Tile2.default);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = (0, _dom.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var _default = exports.default = ImageTile;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js","./dom.js":"node_modules/ol/dom.js","./Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/reproj/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_THRESHOLD = void 0;
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = exports.ERROR_THRESHOLD = 0.5;
},{}],"node_modules/ol/reproj/Triangulation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extent = require("../extent.js");
var _proj = require("../proj.js");
var _math = require("../math.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/reproj/Triangulation
 */
/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = /*#__PURE__*/function () {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    var _this = this;
    _classCallCheck(this, Triangulation);
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;

    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.targetProj_ = targetProj;

    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
    var transformInvCache = {};
    var transformInv = (0, _proj.getTransform)(this.targetProj_, this.sourceProj_);

    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */
    this.transformInv_ = function (c) {
      var key = c[0] + '/' + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };

    /**
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @type {number}
     * @private
     */
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;

    /**
     * @type {Array<Triangle>}
     * @private
     */
    this.triangles_ = [];

    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */
    this.wrapsXInSource_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extent.getWidth)(maxSourceExtent) >= (0, _extent.getWidth)(this.sourceProj_.getExtent());

    /**
     * @type {?number}
     * @private
     */
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extent.getWidth)(this.sourceProj_.getExtent()) : null;

    /**
     * @type {?number}
     * @private
     */
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extent.getWidth)(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = (0, _extent.getTopLeft)(targetExtent);
    var destinationTopRight = (0, _extent.getTopRight)(targetExtent);
    var destinationBottomRight = (0, _extent.getBottomRight)(targetExtent);
    var destinationBottomLeft = (0, _extent.getBottomLeft)(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overall reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */
    var maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2((0, _extent.getArea)(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
    if (this.wrapsXInSource_) {
      var leftBound = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      });

      // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.
      this.triangles_.forEach(function (triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > _this.sourceWorldWidth_ / 2) {
          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
          if (newTriangle[0][0] - leftBound > _this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= _this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > _this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= _this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > _this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= _this.sourceWorldWidth_;
          }

          // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.
          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          if (maxX - minX < _this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }

  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  _createClass(Triangulation, [{
    key: "addTriangle_",
    value: function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
      this.triangles_.push({
        source: [aSrc, bSrc, cSrc],
        target: [a, b, c]
      });
    }

    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
  }, {
    key: "addQuad_",
    value: function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
      var sourceQuadExtent = (0, _extent.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
      var sourceCoverageX = this.sourceWorldWidth_ ? (0, _extent.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
      var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;

      // when the quad is wrapped in the source projection
      // it covers most of the projection extent, but not fully
      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
      var needsSubdivision = false;
      if (maxSubdivision > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          var targetQuadExtent = (0, _extent.boundingExtent)([a, b, c, d]);
          var targetCoverageX = (0, _extent.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
      }
      if (!needsSubdivision && this.maxSourceExtent_) {
        if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
          if (!(0, _extent.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
            // whole quad outside source projection extent -> ignore
            return;
          }
        }
      }
      var isNotFinite = 0;
      if (!needsSubdivision) {
        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
          if (maxSubdivision > 0) {
            needsSubdivision = true;
          } else {
            // It might be the case that only 1 of the points is infinite. In this case
            // we can draw a single triangle with the other three points
            isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
            if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
              return;
            }
          }
        }
      }
      if (maxSubdivision > 0) {
        if (!needsSubdivision) {
          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
          var centerSrc = this.transformInv_(center);
          var dx;
          if (wrapsX) {
            var centerSrcEstimX = ((0, _math.modulo)(aSrc[0], sourceWorldWidth) + (0, _math.modulo)(cSrc[0], sourceWorldWidth)) / 2;
            dx = centerSrcEstimX - (0, _math.modulo)(centerSrc[0], sourceWorldWidth);
          } else {
            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
          }
          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
          var centerSrcErrorSquared = dx * dx + dy * dy;
          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
        }
        if (needsSubdivision) {
          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
            // split horizontally (top & bottom)
            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
            var bcSrc = this.transformInv_(bc);
            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
            var daSrc = this.transformInv_(da);
            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
          } else {
            // split vertically (left & right)
            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
            var abSrc = this.transformInv_(ab);
            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
            var cdSrc = this.transformInv_(cd);
            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
          }
          return;
        }
      }
      if (wrapsX) {
        if (!this.canWrapXInSource_) {
          return;
        }
        this.wrapsXInSource_ = true;
      }

      // Exactly zero or one of *Src is not finite
      // The triangles must have the diagonal line as the first side
      // This is to allow easy code in reproj.s to make it straight for broken
      // browsers that can't handle diagonal clipping
      if ((isNotFinite & 0xb) == 0) {
        this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
      }
      if ((isNotFinite & 0xe) == 0) {
        this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
      }
      if (isNotFinite) {
        // Try the other two triangles
        if ((isNotFinite & 0xd) == 0) {
          this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
        }
        if ((isNotFinite & 0x7) == 0) {
          this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
        }
      }
    }

    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
  }, {
    key: "calculateSourceExtent",
    value: function calculateSourceExtent() {
      var extent = (0, _extent.createEmpty)();
      this.triangles_.forEach(function (triangle, i, arr) {
        var src = triangle.source;
        (0, _extent.extendCoordinate)(extent, src[0]);
        (0, _extent.extendCoordinate)(extent, src[1]);
        (0, _extent.extendCoordinate)(extent, src[2]);
      });
      return extent;
    }

    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
  }, {
    key: "getTriangles",
    value: function getTriangles() {
      return this.triangles_;
    }
  }]);
  return Triangulation;
}();
var _default = exports.default = Triangulation;
},{"../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/reproj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSourceExtentResolution = calculateSourceExtentResolution;
exports.calculateSourceResolution = calculateSourceResolution;
exports.canvasPool = void 0;
exports.render = render;
var _extent = require("./extent.js");
var _dom = require("./dom.js");
var _proj = require("./proj.js");
var _math = require("./math.js");
/**
 * @module ol/reproj
 */

var brokenDiagonalRendering_;

/**
 * @type {Array<HTMLCanvasElement>}
 */
var canvasPool = exports.canvasPool = [];

/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}

/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */
function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}

/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    var ctx = (0, _dom.createCanvasContext2D)(6, 6, canvasPool);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    (0, _dom.releaseCanvas)(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = (0, _proj.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = (0, _proj.getPointResolution)(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0, _extent.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0, _proj.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = (0, _extent.getCenter)(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0, _extent.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}

/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle) {
  var context = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = 'lighter';
  var sourceDataExtent = (0, _extent.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0, _extent.extend)(sourceDataExtent, src.extent);
  });
  var stitchContext;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    var canvasWidthInUnits = (0, _extent.getWidth)(sourceDataExtent);
    var canvasHeightInUnits = (0, _extent.getHeight)(sourceDataExtent);
    stitchContext = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution), canvasPool);
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    var stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function (src, i, arr) {
      var xPos = src.extent[0] - sourceDataExtent[0];
      var yPos = -(src.extent[3] - sourceDataExtent[3]);
      var srcWidth = (0, _extent.getWidth)(src.extent);
      var srcHeight = (0, _extent.getHeight)(src.extent);

      // This test should never fail -- but it does. Need to find a fix the upstream condition
      if (src.image.width > 0 && src.image.height > 0) {
        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
      }
    });
  }
  var targetTopLeft = (0, _extent.getTopLeft)(targetExtent);
  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
      y0 = source[0][1];
    var x1 = source[1][0],
      y1 = source[1][1];
    var x2 = source[2][0],
      y2 = source[2][1];
    // Make sure that everything is on pixel boundaries
    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0, _math.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1);
      // This is the diagonal line. Do it in 4 steps
      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;
      for (var step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
        // Go vertically
        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      }
      // We are almost at u0r, v0r
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    var image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    } else {
      var _source = sources[0];
      var extent = _source.extent;
      image = _source.image;
      context.scale((0, _extent.getWidth)(extent) / image.width, -(0, _extent.getHeight)(extent) / image.height);
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    (0, _dom.releaseCanvas)(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}
},{"./extent.js":"node_modules/ol/extent.js","./dom.js":"node_modules/ol/dom.js","./proj.js":"node_modules/ol/proj.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/reproj/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _common = require("./common.js");
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Tile2 = _interopRequireDefault(require("../Tile.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));
var _reproj = require("../reproj.js");
var _math = require("../math.js");
var _extent = require("../extent.js");
var _events = require("../events.js");
var _dom = require("../dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/reproj/Tile
 */
/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */
/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = /*#__PURE__*/function (_Tile) {
  _inherits(ReprojTile, _Tile);
  var _super = _createSuper(ReprojTile);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    var _this;
    _classCallCheck(this, ReprojTile);
    _this = _super.call(this, tileCoord, _TileState.default.IDLE, options);

    /**
     * @private
     * @type {boolean}
     */
    _this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    _this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    _this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    _this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    _this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    _this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../ImageTile.js").default>}
     */
    _this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    _this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
    var maxTargetExtent = _this.targetTileGrid_.getExtent();
    var maxSourceExtent = _this.sourceTileGrid_.getExtent();
    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
    if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }
    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var sourceResolution = (0, _reproj.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    var errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : _common.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    _this.triangulation_ = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = _this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }
    if (!(0, _extent.getArea)(sourceExtent)) {
      _this.state = _TileState.default.EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }
      if (_this.sourceTiles_.length === 0) {
        _this.state = _TileState.default.EMPTY;
      }
    }
    return _this;
  }

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  _createClass(ReprojTile, [{
    key: "getImage",
    value: function getImage() {
      return this.canvas_;
    }

    /**
     * @private
     */
  }, {
    key: "reproject_",
    value: function reproject_() {
      var _this2 = this;
      var sources = [];
      this.sourceTiles_.forEach(function (tile) {
        if (tile && tile.getState() == _TileState.default.LOADED) {
          sources.push({
            extent: _this2.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
            image: tile.getImage()
          });
        }
      });
      this.sourceTiles_.length = 0;
      if (sources.length === 0) {
        this.state = _TileState.default.ERROR;
      } else {
        var z = this.wrappedTileCoord_[0];
        var size = this.targetTileGrid_.getTileSize(z);
        var width = typeof size === 'number' ? size : size[0];
        var height = typeof size === 'number' ? size : size[1];
        var targetResolution = this.targetTileGrid_.getResolution(z);
        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
        this.state = _TileState.default.LOADED;
      }
      this.changed();
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      var _this3 = this;
      if (this.state == _TileState.default.IDLE) {
        this.state = _TileState.default.LOADING;
        this.changed();
        var leftToLoad = 0;
        this.sourcesListenerKeys_ = [];
        this.sourceTiles_.forEach(function (tile) {
          var state = tile.getState();
          if (state == _TileState.default.IDLE || state == _TileState.default.LOADING) {
            leftToLoad++;
            var sourceListenKey = (0, _events.listen)(tile, _EventType.default.CHANGE, function (e) {
              var state = tile.getState();
              if (state == _TileState.default.LOADED || state == _TileState.default.ERROR || state == _TileState.default.EMPTY) {
                (0, _events.unlistenByKey)(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, _this3);
            _this3.sourcesListenerKeys_.push(sourceListenKey);
          }
        });
        if (leftToLoad === 0) {
          setTimeout(this.reproject_.bind(this), 0);
        } else {
          this.sourceTiles_.forEach(function (tile, i, arr) {
            var state = tile.getState();
            if (state == _TileState.default.IDLE) {
              tile.load();
            }
          });
        }
      }
    }

    /**
     * @private
     */
  }, {
    key: "unlistenSources_",
    value: function unlistenSources_() {
      this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
      this.sourcesListenerKeys_ = null;
    }

    /**
     * Remove from the cache due to expiry
     */
  }, {
    key: "release",
    value: function release() {
      if (this.canvas_) {
        (0, _dom.releaseCanvas)(this.canvas_.getContext('2d'));
        _reproj.canvasPool.push(this.canvas_);
        this.canvas_ = null;
      }
      _get(_getPrototypeOf(ReprojTile.prototype), "release", this).call(this);
    }
  }]);
  return ReprojTile;
}(_Tile2.default);
var _default = exports.default = ReprojTile;
},{"./common.js":"node_modules/ol/reproj/common.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Tile.js":"node_modules/ol/Tile.js","../TileState.js":"node_modules/ol/TileState.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js","../reproj.js":"node_modules/ol/reproj.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/tilecoord.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.fromKey = fromKey;
exports.getCacheKeyForTileKey = getCacheKeyForTileKey;
exports.getKey = getKey;
exports.getKeyZXY = getKeyZXY;
exports.hash = hash;
exports.withinExtentAndZ = withinExtentAndZ;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== undefined) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
function getCacheKeyForTileKey(tileKey) {
  var _tileKey$substring$sp = tileKey.substring(tileKey.lastIndexOf('/') + 1, tileKey.length).split(',').map(Number),
    _tileKey$substring$sp2 = _slicedToArray(_tileKey$substring$sp, 3),
    z = _tileKey$substring$sp2[0],
    x = _tileKey$substring$sp2[1],
    y = _tileKey$substring$sp2[2];
  return getKeyZXY(z, x, y);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}

/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}
},{}],"node_modules/ol/TileCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _LRUCache2 = _interopRequireDefault(require("./structs/LRUCache.js"));
var _tilecoord = require("./tilecoord.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/TileCache
 */
var TileCache = /*#__PURE__*/function (_LRUCache) {
  _inherits(TileCache, _LRUCache);
  var _super = _createSuper(TileCache);
  function TileCache() {
    _classCallCheck(this, TileCache);
    return _super.apply(this, arguments);
  }
  _createClass(TileCache, [{
    key: "clear",
    value: function clear() {
      while (this.getCount() > 0) {
        this.pop().release();
      }
      _get(_getPrototypeOf(TileCache.prototype), "clear", this).call(this);
    }

    /**
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
  }, {
    key: "expireCache",
    value: function expireCache(usedTiles) {
      while (this.canExpireCache()) {
        var tile = this.peekLast();
        if (tile.getKey() in usedTiles) {
          break;
        } else {
          this.pop().release();
        }
      }
    }

    /**
     * Prune all tiles from the cache that don't have the same z as the newest tile.
     */
  }, {
    key: "pruneExceptNewestZ",
    value: function pruneExceptNewestZ() {
      var _this = this;
      if (this.getCount() === 0) {
        return;
      }
      var key = this.peekFirstKey();
      var tileCoord = (0, _tilecoord.fromKey)(key);
      var z = tileCoord[0];
      this.forEach(function (tile) {
        if (tile.tileCoord[0] !== z) {
          _this.remove((0, _tilecoord.getKey)(tile.tileCoord));
          tile.release();
        }
      });
    }
  }]);
  return TileCache;
}(_LRUCache2.default);
var _default = exports.default = TileCache;
},{"./structs/LRUCache.js":"node_modules/ol/structs/LRUCache.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/TileEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/source/TileEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
};
/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */
},{}],"node_modules/ol/TileRange.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/TileRange
 */
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = /*#__PURE__*/function () {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  function TileRange(minX, maxX, minY, maxY) {
    _classCallCheck(this, TileRange);
    /**
     * @type {number}
     */
    this.minX = minX;

    /**
     * @type {number}
     */
    this.maxX = maxX;

    /**
     * @type {number}
     */
    this.minY = minY;

    /**
     * @type {number}
     */
    this.maxY = maxY;
  }

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  _createClass(TileRange, [{
    key: "contains",
    value: function contains(tileCoord) {
      return this.containsXY(tileCoord[1], tileCoord[2]);
    }

    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
  }, {
    key: "containsTileRange",
    value: function containsTileRange(tileRange) {
      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    }

    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    }

    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
  }, {
    key: "equals",
    value: function equals(tileRange) {
      return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    }

    /**
     * @param {TileRange} tileRange Tile range.
     */
  }, {
    key: "extend",
    value: function extend(tileRange) {
      if (tileRange.minX < this.minX) {
        this.minX = tileRange.minX;
      }
      if (tileRange.maxX > this.maxX) {
        this.maxX = tileRange.maxX;
      }
      if (tileRange.minY < this.minY) {
        this.minY = tileRange.minY;
      }
      if (tileRange.maxY > this.maxY) {
        this.maxY = tileRange.maxY;
      }
    }

    /**
     * @return {number} Height.
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.maxY - this.minY + 1;
    }

    /**
     * @return {import("./size.js").Size} Size.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return [this.getWidth(), this.getHeight()];
    }

    /**
     * @return {number} Width.
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.maxX - this.minX + 1;
    }

    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
  }, {
    key: "intersects",
    value: function intersects(tileRange) {
      return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    }
  }]);
  return TileRange;
}();
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var _default = exports.default = TileRange;
},{}],"node_modules/ol/tilegrid/TileGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileRange = _interopRequireWildcard(require("../TileRange.js"));
var _common = require("./common.js");
var _asserts = require("../asserts.js");
var _math = require("../math.js");
var _extent = require("../extent.js");
var _tilecoord = require("../tilecoord.js");
var _intersectsextent = require("../geom/flat/intersectsextent.js");
var _array = require("../array.js");
var _size = require("../size.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/tilegrid/TileGrid
 */
/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];

/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
var DECIMALS = 5;

/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = /*#__PURE__*/function () {
  /**
   * @param {Options} options Tile grid options.
   */
  function TileGrid(options) {
    var _this = this;
    _classCallCheck(this, TileGrid);
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

    /**
     * @private
     * @type {!Array<number>}
     */
    this.resolutions_ = options.resolutions;
    (0, _asserts.assert)((0, _array.isSorted)(this.resolutions_,
    /**
     * @param {number} a First resolution
     * @param {number} b Second resolution
     * @return {number} Comparison result
     */
    function (a, b) {
      return b - a;
    }, true), '`resolutions` must be sorted in descending order');

    // check if we've got a consistent zoom factor and origin
    var zoomFactor;
    if (!options.origins) {
      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }

    /**
     * @private
     * @type {number|undefined}
     */
    this.zoomFactor_ = zoomFactor;

    /**
     * @protected
     * @type {number}
     */
    this.maxZoom = this.resolutions_.length - 1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.origin_ = options.origin !== undefined ? options.origin : null;

    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */
    this.origins_ = null;
    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0, _asserts.assert)(this.origins_.length == this.resolutions_.length, 'Number of `origins` and `resolutions` must be equal');
    }
    var extent = options.extent;
    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0, _extent.getTopLeft)(extent);
    }
    (0, _asserts.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 'Either `origin` or `origins` must be configured, never both');

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */
    this.tileSizes_ = null;
    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0, _asserts.assert)(this.tileSizes_.length == this.resolutions_.length, 'Number of `tileSizes` and `resolutions` must be equal');
    }

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common.DEFAULT_TILE_SIZE : null;
    (0, _asserts.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 'Either `tileSize` or `tileSizes` must be configured, never both');

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = extent !== undefined ? extent : null;

    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */
    this.fullTileRanges_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.tmpSize_ = [0, 0];

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        var tileRange = new _TileRange.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
        if (extent) {
          var restrictedTileRange = _this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }

  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  _createClass(TileGrid, [{
    key: "forEachTileCoord",
    value: function forEachTileCoord(extent, zoom, callback) {
      var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
      for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
        for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
          callback([zoom, i, j]);
        }
      }
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
  }, {
    key: "forEachTileCoordParentTileRange",
    value: function forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
      var tileRange, x, y;
      var tileCoordExtent = null;
      var z = tileCoord[0] - 1;
      if (this.zoomFactor_ === 2) {
        x = tileCoord[1];
        y = tileCoord[2];
      } else {
        tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
      }
      while (z >= this.minZoom) {
        if (x !== undefined && y !== undefined) {
          x = Math.floor(x / 2);
          y = Math.floor(y / 2);
          tileRange = (0, _TileRange.createOrUpdate)(x, x, y, y, tempTileRange);
        } else {
          tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
        }
        if (callback(z, tileRange)) {
          return true;
        }
        --z;
      }
      return false;
    }

    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent_;
    }

    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return this.maxZoom;
    }

    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return this.minZoom;
    }

    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
  }, {
    key: "getOrigin",
    value: function getOrigin(z) {
      if (this.origin_) {
        return this.origin_;
      }
      return this.origins_[z];
    }

    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
  }, {
    key: "getResolution",
    value: function getResolution(z) {
      return this.resolutions_[z];
    }

    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
  }, {
    key: "getResolutions",
    value: function getResolutions() {
      return this.resolutions_;
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
  }, {
    key: "getTileCoordChildTileRange",
    value: function getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
      if (tileCoord[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          var minX = tileCoord[1] * 2;
          var minY = tileCoord[2] * 2;
          return (0, _TileRange.createOrUpdate)(minX, minX + 1, minY, minY + 1, tempTileRange);
        }
        var tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
      }
      return null;
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
  }, {
    key: "getTileRangeForTileCoordAndZ",
    value: function getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
      if (z > this.maxZoom || z < this.minZoom) {
        return null;
      }
      var tileCoordZ = tileCoord[0];
      var tileCoordX = tileCoord[1];
      var tileCoordY = tileCoord[2];
      if (z === tileCoordZ) {
        return (0, _TileRange.createOrUpdate)(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
      }
      if (this.zoomFactor_) {
        var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
        var minX = Math.floor(tileCoordX * factor);
        var minY = Math.floor(tileCoordY * factor);
        if (z < tileCoordZ) {
          return (0, _TileRange.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
        }
        var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
        var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
        return (0, _TileRange.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
      }
      var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
    }

    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
  }, {
    key: "getTileRangeForExtentAndZ",
    value: function getTileRangeForExtentAndZ(extent, z, tempTileRange) {
      this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
      var minX = tmpTileCoord[1];
      var minY = tmpTileCoord[2];
      this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
      var maxX = tmpTileCoord[1];
      var maxY = tmpTileCoord[2];
      return (0, _TileRange.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
  }, {
    key: "getTileCoordCenter",
    value: function getTileCoordCenter(tileCoord) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
      return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
    }

    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
  }, {
    key: "getTileCoordExtent",
    value: function getTileCoordExtent(tileCoord, tempExtent) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
      var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
      var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
      var maxX = minX + tileSize[0] * resolution;
      var maxY = minY + tileSize[1] * resolution;
      return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
    }

    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
  }, {
    key: "getTileCoordForCoordAndResolution",
    value: function getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
      return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    }

    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
  }, {
    key: "getTileCoordForXYAndResolution_",
    value: function getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
      var z = this.getZForResolution(resolution);
      var scale = resolution / this.getResolution(z);
      var origin = this.getOrigin(z);
      var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];
      if (reverseIntersectionPolicy) {
        tileCoordX = (0, _math.ceil)(tileCoordX, DECIMALS) - 1;
        tileCoordY = (0, _math.ceil)(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = (0, _math.floor)(tileCoordX, DECIMALS);
        tileCoordY = (0, _math.floor)(tileCoordY, DECIMALS);
      }
      return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }

    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
  }, {
    key: "getTileCoordForXYAndZ_",
    value: function getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = (origin[1] - y) / resolution / tileSize[1];
      if (reverseIntersectionPolicy) {
        tileCoordX = (0, _math.ceil)(tileCoordX, DECIMALS) - 1;
        tileCoordY = (0, _math.ceil)(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = (0, _math.floor)(tileCoordX, DECIMALS);
        tileCoordY = (0, _math.floor)(tileCoordY, DECIMALS);
      }
      return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }

    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
  }, {
    key: "getTileCoordForCoordAndZ",
    value: function getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
      return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
  }, {
    key: "getTileCoordResolution",
    value: function getTileCoordResolution(tileCoord) {
      return this.resolutions_[tileCoord[0]];
    }

    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
  }, {
    key: "getTileSize",
    value: function getTileSize(z) {
      if (this.tileSize_) {
        return this.tileSize_;
      }
      return this.tileSizes_[z];
    }

    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
     */
  }, {
    key: "getFullTileRange",
    value: function getFullTileRange(z) {
      if (!this.fullTileRanges_) {
        return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
      }
      return this.fullTileRanges_[z];
    }

    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
  }, {
    key: "getZForResolution",
    value: function getZForResolution(resolution, opt_direction) {
      var z = (0, _array.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
      return (0, _math.clamp)(z, this.minZoom, this.maxZoom);
    }

    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */
  }, {
    key: "tileCoordIntersectsViewport",
    value: function tileCoordIntersectsViewport(tileCoord, viewport) {
      return (0, _intersectsextent.intersectsLinearRing)(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    }

    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
  }, {
    key: "calculateTileRanges_",
    value: function calculateTileRanges_(extent) {
      var length = this.resolutions_.length;
      var fullTileRanges = new Array(length);
      for (var z = this.minZoom; z < length; ++z) {
        fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
      }
      this.fullTileRanges_ = fullTileRanges;
    }
  }]);
  return TileGrid;
}();
var _default = exports.default = TileGrid;
},{"../TileRange.js":"node_modules/ol/TileRange.js","./common.js":"node_modules/ol/tilegrid/common.js","../asserts.js":"node_modules/ol/asserts.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../geom/flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","../array.js":"node_modules/ol/array.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/tilegrid/WMTS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromCapabilitiesMatrixSet = createFromCapabilitiesMatrixSet;
exports.default = void 0;
var _TileGrid2 = _interopRequireDefault(require("./TileGrid.js"));
var _proj = require("../proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/tilegrid/WMTS
 */
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */
/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */
var WMTSTileGrid = /*#__PURE__*/function (_TileGrid) {
  _inherits(WMTSTileGrid, _TileGrid);
  var _super = _createSuper(WMTSTileGrid);
  /**
   * @param {Options} options WMTS options.
   */
  function WMTSTileGrid(options) {
    var _this;
    _classCallCheck(this, WMTSTileGrid);
    _this = _super.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    });

    /**
     * @private
     * @type {!Array<string>}
     */
    _this.matrixIds_ = options.matrixIds;
    return _this;
  }

  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  _createClass(WMTSTileGrid, [{
    key: "getMatrixId",
    value: function getMatrixId(z) {
      return this.matrixIds_[z];
    }

    /**
     * Get the list of matrix identifiers.
     * @return {Array<string>} MatrixIds.
     * @api
     */
  }, {
    key: "getMatrixIds",
    value: function getMatrixIds() {
      return this.matrixIds_;
    }
  }]);
  return WMTSTileGrid;
}(_TileGrid2.default);
var _default = exports.default = WMTSTileGrid;
/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent} [extent] An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>} [matrixLimits] An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */
function createFromCapabilitiesMatrixSet(matrixSet, extent, matrixLimits) {
  /** @type {!Array<number>} */
  var resolutions = [];
  /** @type {!Array<string>} */
  var matrixIds = [];
  /** @type {!Array<import("../coordinate.js").Coordinate>} */
  var origins = [];
  /** @type {!Array<number|import("../size.js").Size>} */
  var tileSizes = [];
  /** @type {!Array<import("../size.js").Size>} */
  var sizes = [];
  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];
  var supportedCRSPropName = 'SupportedCRS';
  var matrixIdsPropName = 'TileMatrix';
  var identifierPropName = 'Identifier';
  var scaleDenominatorPropName = 'ScaleDenominator';
  var topLeftCornerPropName = 'TopLeftCorner';
  var tileWidthPropName = 'TileWidth';
  var tileHeightPropName = 'TileHeight';
  var code = matrixSet[supportedCRSPropName];
  var projection = (0, _proj.get)(code);
  var metersPerUnit = projection.getMetersPerUnit();
  // swap origin x and y coordinates if axis orientation is lat/long
  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  matrixSet[matrixIdsPropName].sort(function (a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });
  matrixSet[matrixIdsPropName].forEach(function (elt) {
    var matrixAvailable;
    // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.
    if (matrixLimits.length > 0) {
      matrixAvailable = matrixLimits.find(function (elt_ml) {
        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
          return true;
        }
        // Fallback for tileMatrix identifiers that don't get prefixed
        // by their tileMatrixSet identifiers.
        if (!elt[identifierPropName].includes(':')) {
          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];
        }
        return false;
      });
    } else {
      matrixAvailable = true;
    }
    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];
      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }
      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);
    }
  });
  return new WMTSTileGrid({
    extent: extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes
  });
}
},{"./TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/tilegrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TileGrid", {
  enumerable: true,
  get: function () {
    return _TileGrid.default;
  }
});
Object.defineProperty(exports, "WMTS", {
  enumerable: true,
  get: function () {
    return _WMTS.default;
  }
});
exports.createForExtent = createForExtent;
exports.createForProjection = createForProjection;
exports.createXYZ = createXYZ;
exports.extentFromProjection = extentFromProjection;
exports.getForProjection = getForProjection;
exports.wrapX = wrapX;
var _TileGrid = _interopRequireDefault(require("./tilegrid/TileGrid.js"));
var _common = require("./tilegrid/common.js");
var _proj = require("./proj.js");
var _extent = require("./extent.js");
var _size = require("./size.js");
var _WMTS = _interopRequireDefault(require("./tilegrid/WMTS.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/tilegrid
 */

/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!(0, _extent.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== undefined ? corner : 'top-left';
  var resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new _TileGrid.default({
    extent: extent,
    origin: (0, _extent.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: tileSize
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(options) {
  var xyzOptions = options || {};
  var extent = xyzOptions.extent || (0, _proj.get)('EPSG:3857').getExtent();
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new _TileGrid.default(gridOptions);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : _common.DEFAULT_MAX_ZOOM;
  tileSize = (0, _size.toSize)(tileSize !== undefined ? tileSize : _common.DEFAULT_TILE_SIZE);
  var height = (0, _extent.getHeight)(extent);
  var width = (0, _extent.getWidth)(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, maxZoom, tileSize, corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0, _proj.get)(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj.METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = (0, _extent.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}
},{"./tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./proj.js":"node_modules/ol/proj.js","./extent.js":"node_modules/ol/extent.js","./size.js":"node_modules/ol/size.js","./tilegrid/WMTS.js":"node_modules/ol/tilegrid/WMTS.js"}],"node_modules/ol/source/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TileSourceEvent = void 0;
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _Source2 = _interopRequireDefault(require("./Source.js"));
var _TileCache = _interopRequireDefault(require("../TileCache.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _util = require("../util.js");
var _asserts = require("../asserts.js");
var _proj = require("../proj.js");
var _tilecoord = require("../tilecoord.js");
var _tilegrid = require("../tilegrid.js");
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Tile
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource = /*#__PURE__*/function (_Source) {
  _inherits(TileSource, _Source);
  var _super = _createSuper(TileSource);
  /**
   * @param {Options} options SourceTile source options.
   */
  function TileSource(options) {
    var _this;
    _classCallCheck(this, TileSource);
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {TileSourceOnSignature<void>}
     */
    _this.un;

    /**
     * @private
     * @type {boolean}
     */
    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */
    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
    var tileSize = [256, 256];
    if (_this.tileGrid) {
      (0, _size.toSize)(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
    }

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    _this.tileCache = new _TileCache.default(options.cacheSize || 0);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    _this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    _this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    _this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };

    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  _createClass(TileSource, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.tileCache.canExpireCache();
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (tileCache) {
        tileCache.expireCache(usedTiles);
      }
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {number} z Zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
     *     loaded tile.  If the callback returns `false`, the tile will not be
     *     considered loaded.
     * @return {boolean} The tile range is fully covered with loaded tiles.
     */
  }, {
    key: "forEachLoadedTile",
    value: function forEachLoadedTile(projection, z, tileRange, callback) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (!tileCache) {
        return false;
      }
      var covered = true;
      var tile, tileCoordKey, loaded;
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
          loaded = false;
          if (tileCache.containsKey(tileCoordKey)) {
            tile = /** @type {!import("../Tile.js").default} */
            tileCache.get(tileCoordKey);
            loaded = tile.getState() === _TileState.default.LOADED;
            if (loaded) {
              loaded = callback(tile) !== false;
            }
          }
          if (!loaded) {
            covered = false;
          }
        }
      }
      return covered;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
  }, {
    key: "getGutterForProjection",
    value: function getGutterForProjection(projection) {
      return 0;
    }

    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
  }, {
    key: "getKey",
    value: function getKey() {
      return this.key_;
    }

    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
  }, {
    key: "setKey",
    value: function setKey(key) {
      if (this.key_ !== key) {
        this.key_ = key;
        this.changed();
      }
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */
  }, {
    key: "getOpaque",
    value: function getOpaque(projection) {
      return this.opaque_;
    }

    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
  }, {
    key: "getResolutions",
    value: function getResolutions(projection) {
      var tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
      if (!tileGrid) {
        return null;
      }
      return tileGrid.getResolutions();
    }

    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../Tile.js").default} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      return (0, _util.abstract)();
    }

    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
  }, {
    key: "getTileGrid",
    value: function getTileGrid() {
      return this.tileGrid;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      if (!this.tileGrid) {
        return (0, _tilegrid.getForProjection)(projection);
      }
      return this.tileGrid;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     * @protected
     */
  }, {
    key: "getTileCacheForProjection",
    value: function getTileCacheForProjection(projection) {
      var sourceProjection = this.getProjection();
      (0, _asserts.assert)(sourceProjection === null || (0, _proj.equivalent)(sourceProjection, projection), 'A VectorTile source can only be rendered if it has a projection compatible with the view projection.');
      return this.tileCache;
    }

    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return this.tilePixelRatio_;
    }

    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
  }, {
    key: "getTilePixelSize",
    value: function getTilePixelSize(z, pixelRatio, projection) {
      var tileGrid = this.getTileGridForProjection(projection);
      var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
      var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);
      if (tilePixelRatio == 1) {
        return tileSize;
      }
      return (0, _size.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }

    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
  }, {
    key: "getTileCoordForTileUrlFunction",
    value: function getTileCoordForTileUrlFunction(tileCoord, projection) {
      projection = projection !== undefined ? projection : this.getProjection();
      var tileGrid = this.getTileGridForProjection(projection);
      if (this.getWrapX() && projection.isGlobal()) {
        tileCoord = (0, _tilegrid.wrapX)(tileGrid, tileCoord, projection);
      }
      return (0, _tilecoord.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
    }

    /**
     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
     * @api
     */
  }, {
    key: "clear",
    value: function clear() {
      this.tileCache.clear();
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.clear();
      _get(_getPrototypeOf(TileSource.prototype), "refresh", this).call(this);
    }

    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
  }, {
    key: "updateCacheSize",
    value: function updateCacheSize(tileCount, projection) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (tileCount > tileCache.highWaterMark) {
        tileCache.highWaterMark = tileCount;
      }
    }

    /**
     * Marks a tile coord as being used, without triggering a load.
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
  }, {
    key: "useTile",
    value: function useTile(z, x, y, projection) {}
  }]);
  return TileSource;
}(_Source2.default);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = exports.TileSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(TileSourceEvent, _Event);
  var _super2 = _createSuper(TileSourceEvent);
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  function TileSourceEvent(type, tile) {
    var _this2;
    _classCallCheck(this, TileSourceEvent);
    _this2 = _super2.call(this, type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    _this2.tile = tile;
    return _this2;
  }
  return _createClass(TileSourceEvent);
}(_Event2.default);
var _default = exports.default = TileSource;
},{"../events/Event.js":"node_modules/ol/events/Event.js","./Source.js":"node_modules/ol/source/Source.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","../util.js":"node_modules/ol/util.js","../asserts.js":"node_modules/ol/asserts.js","../proj.js":"node_modules/ol/proj.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/tileurlfunction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromTemplate = createFromTemplate;
exports.createFromTemplates = createFromTemplates;
exports.createFromTileUrlFunctions = createFromTileUrlFunctions;
exports.expandUrl = expandUrl;
exports.nullTileUrlFunction = nullTileUrlFunction;
var _math = require("./math.js");
var _tilecoord = require("./tilecoord.js");
/**
 * @module ol/tileurlfunction
 */

/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
        var z = tileCoord[0];
        var range = tileGrid.getFullTileRange(z);
        if (!range) {
          throw new Error('The {-y} placeholder requires a tile grid with extent');
        }
        var y = range.getHeight() - tileCoord[2] - 1;
        return y.toString();
      });
    }
  );
}

/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      var h = (0, _tilecoord.hash)(tileCoord);
      var index = (0, _math.modulo)(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
},{"./math.js":"node_modules/ol/math.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/UrlTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileEventType = _interopRequireDefault(require("./TileEventType.js"));
var _Tile = _interopRequireWildcard(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _tileurlfunction = require("../tileurlfunction.js");
var _tilecoord = require("../tilecoord.js");
var _util = require("../util.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/UrlTile
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile = /*#__PURE__*/function (_TileSource) {
  _inherits(UrlTile, _TileSource);
  var _super = _createSuper(UrlTile);
  /**
   * @param {Options} options Image tile options.
   */
  function UrlTile(options) {
    var _this;
    _classCallCheck(this, UrlTile);
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {boolean}
     */
    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    _this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      _this.tileUrlFunction = options.tileUrlFunction;
    }

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    _this.urls = null;
    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    _this.tileLoadingKeys_ = {};
    return _this;
  }

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  _createClass(UrlTile, [{
    key: "getTileLoadFunction",
    value: function getTileLoadFunction() {
      return this.tileLoadFunction;
    }

    /**
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
  }, {
    key: "getTileUrlFunction",
    value: function getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }

    /**
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
  }, {
    key: "getUrls",
    value: function getUrls() {
      return this.urls;
    }

    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
  }, {
    key: "handleTileChange",
    value: function handleTileChange(event) {
      var tile = /** @type {import("../Tile.js").default} */event.target;
      var uid = (0, _util.getUid)(tile);
      var tileState = tile.getState();
      var type;
      if (tileState == _TileState.default.LOADING) {
        this.tileLoadingKeys_[uid] = true;
        type = _TileEventType.default.TILELOADSTART;
      } else if (uid in this.tileLoadingKeys_) {
        delete this.tileLoadingKeys_[uid];
        type = tileState == _TileState.default.ERROR ? _TileEventType.default.TILELOADERROR : tileState == _TileState.default.LOADED ? _TileEventType.default.TILELOADEND : undefined;
      }
      if (type != undefined) {
        this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
      }
    }

    /**
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
  }, {
    key: "setTileLoadFunction",
    value: function setTileLoadFunction(tileLoadFunction) {
      this.tileCache.clear();
      this.tileLoadFunction = tileLoadFunction;
      this.changed();
    }

    /**
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
  }, {
    key: "setTileUrlFunction",
    value: function setTileUrlFunction(tileUrlFunction, key) {
      this.tileUrlFunction = tileUrlFunction;
      this.tileCache.pruneExceptNewestZ();
      if (typeof key !== 'undefined') {
        this.setKey(key);
      } else {
        this.changed();
      }
    }

    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
  }, {
    key: "setUrl",
    value: function setUrl(url) {
      var urls = (0, _tileurlfunction.expandUrl)(url);
      this.urls = urls;
      this.setUrls(urls);
    }

    /**
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
  }, {
    key: "setUrls",
    value: function setUrls(urls) {
      this.urls = urls;
      var key = urls.join('\n');
      if (this.generateTileUrlFunction_) {
        this.setTileUrlFunction((0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), key);
      } else {
        this.setKey(key);
      }
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
  }, {
    key: "tileUrlFunction",
    value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
      return undefined;
    }

    /**
     * Marks a tile coord as being used, without triggering a load.
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     */
  }, {
    key: "useTile",
    value: function useTile(z, x, y) {
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      if (this.tileCache.containsKey(tileCoordKey)) {
        this.tileCache.get(tileCoordKey);
      }
    }
  }]);
  return UrlTile;
}(_Tile.default);
var _default = exports.default = UrlTile;
},{"./TileEventType.js":"node_modules/ol/source/TileEventType.js","./Tile.js":"node_modules/ol/source/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/TileImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));
var _Tile = _interopRequireDefault(require("../reproj/Tile.js"));
var _TileCache = _interopRequireDefault(require("../TileCache.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _UrlTile2 = _interopRequireDefault(require("./UrlTile.js"));
var _proj = require("../proj.js");
var _tilecoord = require("../tilecoord.js");
var _tilegrid = require("../tilegrid.js");
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/TileImage
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage = /*#__PURE__*/function (_UrlTile) {
  _inherits(TileImage, _UrlTile);
  var _super = _createSuper(TileImage);
  /**
   * @param {!Options} options Image tile options.
   */
  function TileImage(options) {
    var _this;
    _classCallCheck(this, TileImage);
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== undefined ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });

    /**
     * @protected
     * @type {?string}
     */
    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    _this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile.default;

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    _this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    _this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    _this.renderReprojectionEdges_ = false;
    return _this;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  _createClass(TileImage, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      if (this.tileCache.canExpireCache()) {
        return true;
      }
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
      return false;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var usedTileCache = this.getTileCacheForProjection(projection);
      this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
      for (var id in this.tileCacheForProjection) {
        var tileCache = this.tileCacheForProjection[id];
        tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
      }
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
  }, {
    key: "getGutterForProjection",
    value: function getGutterForProjection(projection) {
      if (this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
        return 0;
      }
      return this.getGutter();
    }

    /**
     * @return {number} Gutter.
     */
  }, {
    key: "getGutter",
    value: function getGutter() {
      return 0;
    }

    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
  }, {
    key: "getKey",
    value: function getKey() {
      var key = _get(_getPrototypeOf(TileImage.prototype), "getKey", this).call(this);
      if (!this.getInterpolate()) {
        key += ':disable-interpolation';
      }
      return key;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */
  }, {
    key: "getOpaque",
    value: function getOpaque(projection) {
      if (this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
        return false;
      }
      return _get(_getPrototypeOf(TileImage.prototype), "getOpaque", this).call(this, projection);
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      var thisProj = this.getProjection();
      if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
        return this.tileGrid;
      }
      var projKey = (0, _util.getUid)(projection);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = (0, _tilegrid.getForProjection)(projection);
      }
      return this.tileGridForProjection[projKey];
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     */
  }, {
    key: "getTileCacheForProjection",
    value: function getTileCacheForProjection(projection) {
      var thisProj = this.getProjection();
      if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
        return this.tileCache;
      }
      var projKey = (0, _util.getUid)(projection);
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache.default(this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
  }, {
    key: "createTile_",
    value: function createTile_(z, x, y, pixelRatio, projection, key) {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
      var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
      tile.key = key;
      tile.addEventListener(_EventType.default.CHANGE, this.handleTileChange.bind(this));
      return tile;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      var _this2 = this;
      var sourceProjection = this.getProjection();
      if (!sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
      }
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile;
      var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);
      if (cache.containsKey(tileCoordKey)) {
        tile = cache.get(tileCoordKey);
      }
      var key = this.getKey();
      if (tile && tile.key == key) {
        return tile;
      }
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new _Tile.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
        return _this2.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }, this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.tileOptions);
      newTile.key = key;
      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!ImageTile} Tile.
     * @protected
     */
  }, {
    key: "getTileInternal",
    value: function getTileInternal(z, x, y, pixelRatio, projection) {
      var tile = null;
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      var key = this.getKey();
      if (!this.tileCache.containsKey(tileCoordKey)) {
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);
        this.tileCache.set(tileCoordKey, tile);
      } else {
        tile = this.tileCache.get(tileCoordKey);
        if (tile.key != key) {
          // The source's params changed. If the tile has an interim tile and if we
          // can use it then we use it. Otherwise we create a new tile.  In both
          // cases we attempt to assign an interim tile to the new tile.
          var interimTile = tile;
          tile = this.createTile_(z, x, y, pixelRatio, projection, key);

          //make the new tile the head of the list,
          if (interimTile.getState() == _TileState.default.IDLE) {
            //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
            tile.interimTile = interimTile.interimTile;
          } else {
            tile.interimTile = interimTile;
          }
          tile.refreshInterimChain();
          this.tileCache.replace(tileCoordKey, tile);
        }
      }
      return tile;
    }

    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
  }, {
    key: "setRenderReprojectionEdges",
    value: function setRenderReprojectionEdges(render) {
      if (this.renderReprojectionEdges_ == render) {
        return;
      }
      this.renderReprojectionEdges_ = render;
      for (var id in this.tileCacheForProjection) {
        this.tileCacheForProjection[id].clear();
      }
      this.changed();
    }

    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
  }, {
    key: "setTileGridForProjection",
    value: function setTileGridForProjection(projection, tilegrid) {
      var proj = (0, _proj.get)(projection);
      if (proj) {
        var projKey = (0, _util.getUid)(proj);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      _get(_getPrototypeOf(TileImage.prototype), "clear", this).call(this);
      for (var id in this.tileCacheForProjection) {
        this.tileCacheForProjection[id].clear();
      }
    }
  }]);
  return TileImage;
}(_UrlTile2.default);
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */imageTile.getImage().src = src;
}
var _default = exports.default = TileImage;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","./UrlTile.js":"node_modules/ol/source/UrlTile.js","../proj.js":"node_modules/ol/proj.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/BingMaps.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.quadKey = quadKey;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _extent2 = require("../extent.js");
var _tileurlfunction = require("../tileurlfunction.js");
var _tilecoord = require("../tilecoord.js");
var _tilegrid = require("../tilegrid.js");
var _proj = require("../proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/BingMaps
 */
/**
 * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}

/**
 * The attribution containing a link to the Microsoft Bing Maps Platform APIs
 * Terms Of Use.
 * @const
 * @type {string}
 */
var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" ' + 'href="https://www.microsoft.com/maps/product/terms.html" target="_blank">' + 'Terms of Use</a>';

/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.
 * @property {string} [culture='en-us'] Culture code.
 * @property {string} key Bing Maps API key. Get yours at https://www.bingmapsportal.com/.
 * @property {string} imagerySet Type of imagery.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {boolean} [placeholderTiles] Whether to show BingMaps placeholder tiles when zoomed past the maximum level provided in an area. When `false`, requests beyond
 * the maximum zoom level will return no tile. When `true`, the placeholder tile will be returned. When not set, the default behaviour of the imagery set takes place,
 * which is unique for each imagery set in BingMaps.
 */

/**
 * @typedef {Object} BingMapsImageryMetadataResponse
 * @property {number} statusCode The response status code
 * @property {string} statusDescription The response status description
 * @property {string} authenticationResultCode The authentication result code
 * @property {Array<ResourceSet>} resourceSets The array of resource sets
 */

/**
 * @typedef {Object} ResourceSet
 * @property {Array<Resource>} resources Resources.
 */

/**
 * @typedef {Object} Resource
 * @property {number} imageHeight The image height
 * @property {number} imageWidth The image width
 * @property {number} zoomMin The minimum zoom level
 * @property {number} zoomMax The maximum zoom level
 * @property {string} imageUrl The image URL
 * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation
 * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders
 */

/**
 * @typedef {Object} ImageryProvider
 * @property {Array<CoverageArea>} coverageAreas The coverage areas
 * @property {string} [attribution] The attribution
 */

/**
 * @typedef {Object} CoverageArea
 * @property {number} zoomMin The minimum zoom
 * @property {number} zoomMax The maximum zoom
 * @property {Array<number>} bbox The coverage bounding box
 */

/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 * @api
 */
var BingMaps = /*#__PURE__*/function (_TileImage) {
  _inherits(BingMaps, _TileImage);
  var _super = _createSuper(BingMaps);
  /**
   * @param {Options} options Bing Maps options.
   */
  function BingMaps(options) {
    var _this;
    _classCallCheck(this, BingMaps);
    var hidpi = options.hidpi !== undefined ? options.hidpi : false;
    _this = _super.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      interpolate: options.interpolate,
      opaque: true,
      projection: (0, _proj.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: 'loading',
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = hidpi;

    /**
     * @private
     * @type {string}
     */
    _this.culture_ = options.culture !== undefined ? options.culture : 'en-us';

    /**
     * @private
     * @type {number}
     */
    _this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;

    /**
     * @private
     * @type {string}
     */
    _this.apiKey_ = options.key;

    /**
     * @private
     * @type {string}
     */
    _this.imagerySet_ = options.imagerySet;

    /**
     * @private
     * @type {boolean|undefined}
     */
    _this.placeholderTiles_ = options.placeholderTiles;
    var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' + _this.imagerySet_ + '?uriScheme=https&include=ImageryProviders&key=' + _this.apiKey_ + '&c=' + _this.culture_;
    fetch(url).then(function (response) {
      return response.json();
    }).then(function (json) {
      return _this.handleImageryMetadataResponse(json);
    });
    return _this;
  }

  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */
  _createClass(BingMaps, [{
    key: "getApiKey",
    value: function getApiKey() {
      return this.apiKey_;
    }

    /**
     * Get the imagery set associated with this source.
     *
     * @return {string} The imagery set.
     * @api
     */
  }, {
    key: "getImagerySet",
    value: function getImagerySet() {
      return this.imagerySet_;
    }

    /**
     * @param {BingMapsImageryMetadataResponse} response Response.
     */
  }, {
    key: "handleImageryMetadataResponse",
    value: function handleImageryMetadataResponse(response) {
      var _this2 = this;
      if (response.statusCode != 200 || response.statusDescription != 'OK' || response.authenticationResultCode != 'ValidCredentials' || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
        this.setState('error');
        return;
      }
      var resource = response.resourceSets[0].resources[0];
      var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
      var sourceProjection = this.getProjection();
      var extent = (0, _tilegrid.extentFromProjection)(sourceProjection);
      var scale = this.hidpi_ ? 2 : 1;
      var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale : [resource.imageWidth / scale, resource.imageHeight / scale];
      var tileGrid = (0, _tilegrid.createXYZ)({
        extent: extent,
        minZoom: resource.zoomMin,
        maxZoom: maxZoom,
        tileSize: tileSize
      });
      this.tileGrid = tileGrid;
      var culture = this.culture_;
      var hidpi = this.hidpi_;
      var placeholderTiles = this.placeholderTiles_;
      this.tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(resource.imageUrlSubdomains.map(function (subdomain) {
        /** @type {import('../tilecoord.js').TileCoord} */
        var quadKeyTileCoord = [0, 0, 0];
        var imageUrl = resource.imageUrl.replace('{subdomain}', subdomain).replace('{culture}', culture);
        return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          function (tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
              return undefined;
            }
            (0, _tilecoord.createOrUpdate)(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
            var url = new URL(imageUrl.replace('{quadkey}', quadKey(quadKeyTileCoord)));
            var params = url.searchParams;
            if (hidpi) {
              params.set('dpi', 'd1');
              params.set('device', 'mobile');
            }
            if (placeholderTiles === true) {
              params.delete('n');
            } else if (placeholderTiles === false) {
              params.set('n', 'z');
            }
            return url.toString();
          }
        );
      }));
      if (resource.imageryProviders) {
        var transform = (0, _proj.getTransformFromProjections)((0, _proj.get)('EPSG:4326'), this.getProjection());
        this.setAttributions(function (frameState) {
          var attributions = [];
          var viewState = frameState.viewState;
          var tileGrid = _this2.getTileGrid();
          var z = tileGrid.getZForResolution(viewState.resolution, _this2.zDirection);
          var tileCoord = tileGrid.getTileCoordForCoordAndZ(viewState.center, z);
          var zoom = tileCoord[0];
          resource.imageryProviders.map(function (imageryProvider) {
            var intersecting = false;
            var coverageAreas = imageryProvider.coverageAreas;
            for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
              var coverageArea = coverageAreas[i];
              if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
                var bbox = coverageArea.bbox;
                var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
                var _extent = (0, _extent2.applyTransform)(epsg4326Extent, transform);
                if ((0, _extent2.intersects)(_extent, frameState.extent)) {
                  intersecting = true;
                  break;
                }
              }
            }
            if (intersecting) {
              attributions.push(imageryProvider.attribution);
            }
          });
          attributions.push(TOS_ATTRIBUTION);
          return attributions;
        });
      }
      this.setState('ready');
    }
  }]);
  return BingMaps;
}(_TileImage2.default);
var _default = exports.default = BingMaps;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../extent.js":"node_modules/ol/extent.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source/XYZ.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _tilegrid = require("../tilegrid.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/XYZ
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
var XYZ = /*#__PURE__*/function (_TileImage) {
  _inherits(XYZ, _TileImage);
  var _super = _createSuper(XYZ);
  /**
   * @param {Options} [options] XYZ options.
   */
  function XYZ(options) {
    var _this;
    _classCallCheck(this, XYZ);
    options = options || {};
    var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegrid.createXYZ)({
      extent: (0, _tilegrid.extentFromProjection)(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {number}
     */
    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    return _this;
  }

  /**
   * @return {number} Gutter.
   */
  _createClass(XYZ, [{
    key: "getGutter",
    value: function getGutter() {
      return this.gutter_;
    }
  }]);
  return XYZ;
}(_TileImage2.default);
var _default = exports.default = XYZ;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../tilegrid.js":"node_modules/ol/tilegrid.js"}],"node_modules/ol/source/CartoDB.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _XYZ2 = _interopRequireDefault(require("./XYZ.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/CartoDB
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [maxZoom=18] Max zoom.
 * @property {number} [minZoom] Minimum zoom.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See
 * https://carto.com/developers/maps-api/guides/anonymous-maps/
 * for more detail.
 * If using named maps, a key-value lookup with the template parameters.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [map] If using named maps, this will be the name of the template to load.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [account] Username as used to access public Carto dashboard at https://{username}.carto.com/.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @typedef {Object} CartoDBLayerInfo
 * @property {string} layergroupid The layer group ID
 * @property {{https: string}} cdn_url The CDN URL
 */
/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 * @api
 */
var CartoDB = /*#__PURE__*/function (_XYZ) {
  _inherits(CartoDB, _XYZ);
  var _super = _createSuper(CartoDB);
  /**
   * @param {Options} options CartoDB options.
   */
  function CartoDB(options) {
    var _this;
    _classCallCheck(this, CartoDB);
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,
      minZoom: options.minZoom,
      projection: options.projection,
      transition: options.transition,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });

    /**
     * @type {string}
     * @private
     */
    _this.account_ = options.account;

    /**
     * @type {string}
     * @private
     */
    _this.mapId_ = options.map || '';

    /**
     * @type {!Object}
     * @private
     */
    _this.config_ = options.config || {};

    /**
     * @type {!Object<string, CartoDBLayerInfo>}
     * @private
     */
    _this.templateCache_ = {};
    _this.initializeMap_();
    return _this;
  }

  /**
   * Returns the current config.
   * @return {!Object} The current configuration.
   * @api
   */
  _createClass(CartoDB, [{
    key: "getConfig",
    value: function getConfig() {
      return this.config_;
    }

    /**
     * Updates the carto db config.
     * @param {Object} config a key-value lookup. Values will replace current values
     *     in the config.
     * @api
     */
  }, {
    key: "updateConfig",
    value: function updateConfig(config) {
      Object.assign(this.config_, config);
      this.initializeMap_();
    }

    /**
     * Sets the CartoDB config
     * @param {Object} config In the case of anonymous maps, a CartoDB configuration
     *     object.
     * If using named maps, a key-value lookup with the template parameters.
     * @api
     */
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      this.config_ = config || {};
      this.initializeMap_();
    }

    /**
     * Issue a request to initialize the CartoDB map.
     * @private
     */
  }, {
    key: "initializeMap_",
    value: function initializeMap_() {
      var paramHash = JSON.stringify(this.config_);
      if (this.templateCache_[paramHash]) {
        this.applyTemplate_(this.templateCache_[paramHash]);
        return;
      }
      var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';
      if (this.mapId_) {
        mapUrl += '/named/' + this.mapId_;
      }
      var client = new XMLHttpRequest();
      client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));
      client.addEventListener('error', this.handleInitError_.bind(this));
      client.open('POST', mapUrl);
      client.setRequestHeader('Content-type', 'application/json');
      client.send(JSON.stringify(this.config_));
    }

    /**
     * Handle map initialization response.
     * @param {string} paramHash a hash representing the parameter set that was used
     *     for the request
     * @param {Event} event Event.
     * @private
     */
  }, {
    key: "handleInitResponse_",
    value: function handleInitResponse_(paramHash, event) {
      var client = /** @type {XMLHttpRequest} */event.target;
      // status will be 0 for file:// urls
      if (!client.status || client.status >= 200 && client.status < 300) {
        var response;
        try {
          response = /** @type {CartoDBLayerInfo} */
          JSON.parse(client.responseText);
        } catch (err) {
          this.setState('error');
          return;
        }
        this.applyTemplate_(response);
        this.templateCache_[paramHash] = response;
        this.setState('ready');
      } else {
        this.setState('error');
      }
    }

    /**
     * @private
     * @param {Event} event Event.
     */
  }, {
    key: "handleInitError_",
    value: function handleInitError_(event) {
      this.setState('error');
    }

    /**
     * Apply the new tile urls returned by carto db
     * @param {CartoDBLayerInfo} data Result of carto db call.
     * @private
     */
  }, {
    key: "applyTemplate_",
    value: function applyTemplate_(data) {
      var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ + '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';
      this.setUrl(tilesUrl);
    }
  }]);
  return CartoDB;
}(_XYZ2.default);
var _default = exports.default = CartoDB;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js"}],"node_modules/ol/source/Cluster.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Feature = _interopRequireDefault(require("../Feature.js"));
var _Point = _interopRequireDefault(require("../geom/Point.js"));
var _Vector = _interopRequireDefault(require("./Vector.js"));
var _coordinate = require("../coordinate.js");
var _asserts = require("../asserts.js");
var _extent = require("../extent.js");
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Cluster
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Distance in pixels within which features will
 * be clustered together.
 * @property {number} [minDistance=0] Minimum distance in pixels between clusters.
 * Will be capped at the configured distance.
 * By default no minimum distance is guaranteed. This config can be used to avoid
 * overlapping icons. As a tradoff, the cluster feature's position will no longer be
 * the center of all its features.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underlying source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {function(Point, Array<Feature>):Feature} [createCluster]
 * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array
 * of {@link module:ol/Feature~Feature} included in this cluster. Must return a
 * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:
 * ```js
 * function(point, features) {
 *   return new Feature({
 *     geometry: point,
 *     features: features
 *   });
 * }
 * ```
 * @property {VectorSource} [source=null] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */
/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 */
var Cluster = /*#__PURE__*/function (_VectorSource) {
  _inherits(Cluster, _VectorSource);
  var _super = _createSuper(Cluster);
  /**
   * @param {Options} options Cluster options.
   */
  function Cluster(options) {
    var _this;
    _classCallCheck(this, Cluster);
    _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    });

    /**
     * @type {number|undefined}
     * @protected
     */
    _this.resolution = undefined;

    /**
     * @type {number}
     * @protected
     */
    _this.distance = options.distance !== undefined ? options.distance : 20;

    /**
     * @type {number}
     * @protected
     */
    _this.minDistance = options.minDistance || 0;

    /**
     * @type {number}
     * @protected
     */
    _this.interpolationRatio = 0;

    /**
     * @type {Array<Feature>}
     * @protected
     */
    _this.features = [];

    /**
     * @param {Feature} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */
    _this.geometryFunction = options.geometryFunction || function (feature) {
      var geometry = /** @type {Point} */feature.getGeometry();
      (0, _asserts.assert)(!geometry || geometry.getType() === 'Point', 'The default `geometryFunction` can only handle `Point` or null geometries');
      return geometry;
    };

    /**
     * @type {function(Point, Array<Feature>):Feature}
     * @private
     */
    _this.createCustomCluster_ = options.createCluster;

    /**
     * @type {VectorSource|null}
     * @protected
     */
    _this.source = null;

    /**
     * @private
     */
    _this.boundRefresh_ = _this.refresh.bind(_assertThisInitialized(_this));
    _this.updateDistance(_this.distance, _this.minDistance);
    _this.setSource(options.source || null);
    return _this;
  }

  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  _createClass(Cluster, [{
    key: "clear",
    value: function clear(fast) {
      this.features.length = 0;
      _get(_getPrototypeOf(Cluster.prototype), "clear", this).call(this, fast);
    }

    /**
     * Get the distance in pixels between clusters.
     * @return {number} Distance.
     * @api
     */
  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }

    /**
     * Get a reference to the wrapped source.
     * @return {VectorSource|null} Source.
     * @api
     */
  }, {
    key: "getSource",
    value: function getSource() {
      return this.source;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
  }, {
    key: "loadFeatures",
    value: function loadFeatures(extent, resolution, projection) {
      this.source.loadFeatures(extent, resolution, projection);
      if (resolution !== this.resolution) {
        this.resolution = resolution;
        this.refresh();
      }
    }

    /**
     * Set the distance within which features will be clusterd together.
     * @param {number} distance The distance in pixels.
     * @api
     */
  }, {
    key: "setDistance",
    value: function setDistance(distance) {
      this.updateDistance(distance, this.minDistance);
    }

    /**
     * Set the minimum distance between clusters. Will be capped at the
     * configured distance.
     * @param {number} minDistance The minimum distance in pixels.
     * @api
     */
  }, {
    key: "setMinDistance",
    value: function setMinDistance(minDistance) {
      this.updateDistance(this.distance, minDistance);
    }

    /**
     * The configured minimum distance between clusters.
     * @return {number} The minimum distance in pixels.
     * @api
     */
  }, {
    key: "getMinDistance",
    value: function getMinDistance() {
      return this.minDistance;
    }

    /**
     * Replace the wrapped source.
     * @param {VectorSource|null} source The new source for this instance.
     * @api
     */
  }, {
    key: "setSource",
    value: function setSource(source) {
      if (this.source) {
        this.source.removeEventListener(_EventType.default.CHANGE, this.boundRefresh_);
      }
      this.source = source;
      if (source) {
        source.addEventListener(_EventType.default.CHANGE, this.boundRefresh_);
      }
      this.refresh();
    }

    /**
     * Handle the source changing.
     */
  }, {
    key: "refresh",
    value: function refresh() {
      this.clear();
      this.cluster();
      this.addFeatures(this.features);
    }

    /**
     * Update the distances and refresh the source if necessary.
     * @param {number} distance The new distance.
     * @param {number} minDistance The new minimum distance.
     */
  }, {
    key: "updateDistance",
    value: function updateDistance(distance, minDistance) {
      var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
      var changed = distance !== this.distance || this.interpolationRatio !== ratio;
      this.distance = distance;
      this.minDistance = minDistance;
      this.interpolationRatio = ratio;
      if (changed) {
        this.refresh();
      }
    }

    /**
     * @protected
     */
  }, {
    key: "cluster",
    value: function cluster() {
      if (this.resolution === undefined || !this.source) {
        return;
      }
      var extent = (0, _extent.createEmpty)();
      var mapDistance = this.distance * this.resolution;
      var features = this.source.getFeatures();

      /** @type {Object<string, true>} */
      var clustered = {};
      for (var i = 0, ii = features.length; i < ii; i++) {
        var feature = features[i];
        if (!((0, _util.getUid)(feature) in clustered)) {
          var geometry = this.geometryFunction(feature);
          if (geometry) {
            var coordinates = geometry.getCoordinates();
            (0, _extent.createOrUpdateFromCoordinate)(coordinates, extent);
            (0, _extent.buffer)(extent, mapDistance, extent);
            var neighbors = this.source.getFeaturesInExtent(extent).filter(function (neighbor) {
              var uid = (0, _util.getUid)(neighbor);
              if (uid in clustered) {
                return false;
              }
              clustered[uid] = true;
              return true;
            });
            this.features.push(this.createCluster(neighbors, extent));
          }
        }
      }
    }

    /**
     * @param {Array<Feature>} features Features
     * @param {import("../extent.js").Extent} extent The searched extent for these features.
     * @return {Feature} The cluster feature.
     * @protected
     */
  }, {
    key: "createCluster",
    value: function createCluster(features, extent) {
      var centroid = [0, 0];
      for (var i = features.length - 1; i >= 0; --i) {
        var _geometry = this.geometryFunction(features[i]);
        if (_geometry) {
          (0, _coordinate.add)(centroid, _geometry.getCoordinates());
        } else {
          features.splice(i, 1);
        }
      }
      (0, _coordinate.scale)(centroid, 1 / features.length);
      var searchCenter = (0, _extent.getCenter)(extent);
      var ratio = this.interpolationRatio;
      var geometry = new _Point.default([centroid[0] * (1 - ratio) + searchCenter[0] * ratio, centroid[1] * (1 - ratio) + searchCenter[1] * ratio]);
      if (this.createCustomCluster_) {
        return this.createCustomCluster_(geometry, features);
      }
      return new _Feature.default({
        geometry: geometry,
        features: features
      });
    }
  }]);
  return Cluster;
}(_Vector.default);
var _default = exports.default = Cluster;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Vector.js":"node_modules/ol/source/Vector.js","../coordinate.js":"node_modules/ol/coordinate.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/DataTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asArrayLike = asArrayLike;
exports.asImageLike = asImageLike;
exports.default = void 0;
exports.toArray = toArray;
var _Tile2 = _interopRequireDefault(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("./TileState.js"));
var _dom = require("./dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/DataTile
 */
/**
 * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike
 */

/**
 * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike
 */

/**
 * Data that can be used with a DataTile.
 * @typedef {ArrayLike|ImageLike} Data
 */

/**
 * @param {Data} data Tile data.
 * @return {ImageLike|null} The image-like data.
 */
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}

/**
 * @param {Data} data Tile data.
 * @return {ArrayLike|null} The array-like data.
 */
function asArrayLike(data) {
  return data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Float32Array || data instanceof DataView ? data : null;
}

/**
 * @type {CanvasRenderingContext2D|null}
 */
var sharedContext = null;

/**
 * @param {ImageLike} image The image.
 * @return {Uint8ClampedArray} The data.
 */
function toArray(image) {
  if (!sharedContext) {
    sharedContext = (0, _dom.createCanvasContext2D)(image.width, image.height, undefined, {
      willReadFrequently: true
    });
  }
  var canvas = sharedContext.canvas;
  var width = image.width;
  if (canvas.width !== width) {
    canvas.width = width;
  }
  var height = image.height;
  if (canvas.height !== height) {
    canvas.height = height;
  }
  sharedContext.clearRect(0, 0, width, height);
  sharedContext.drawImage(image, 0, 0);
  return sharedContext.getImageData(0, 0, width, height).data;
}

/**
 * @type {import('./size.js').Size}
 */
var defaultSize = [256, 256];

/**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,
 * the promise should not resolve until the image is loaded.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {import('./size.js').Size} [size=[256, 256]] Tile size.
 * @api
 */
var DataTile = /*#__PURE__*/function (_Tile) {
  _inherits(DataTile, _Tile);
  var _super = _createSuper(DataTile);
  /**
   * @param {Options} options Tile options.
   */
  function DataTile(options) {
    var _this;
    _classCallCheck(this, DataTile);
    var state = _TileState.default.IDLE;
    _this = _super.call(this, options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    });

    /**
     * @type {function(): Promise<Data>}
     * @private
     */
    _this.loader_ = options.loader;

    /**
     * @type {Data}
     * @private
     */
    _this.data_ = null;

    /**
     * @type {Error}
     * @private
     */
    _this.error_ = null;

    /**
     * @type {import('./size.js').Size|null}
     * @private
     */
    _this.size_ = options.size || null;
    return _this;
  }

  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  _createClass(DataTile, [{
    key: "getSize",
    value: function getSize() {
      if (this.size_) {
        return this.size_;
      }
      var imageData = asImageLike(this.data_);
      if (imageData) {
        return [imageData.width, imageData.height];
      }
      return defaultSize;
    }

    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */
  }, {
    key: "getData",
    value: function getData() {
      return this.data_;
    }

    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */
  }, {
    key: "getError",
    value: function getError() {
      return this.error_;
    }

    /**
     * Load not yet loaded URI.
     * @api
     */
  }, {
    key: "load",
    value: function load() {
      if (this.state !== _TileState.default.IDLE && this.state !== _TileState.default.ERROR) {
        return;
      }
      this.state = _TileState.default.LOADING;
      this.changed();
      var self = this;
      this.loader_().then(function (data) {
        self.data_ = data;
        self.state = _TileState.default.LOADED;
        self.changed();
      }).catch(function (error) {
        self.error_ = error;
        self.state = _TileState.default.ERROR;
        self.changed();
      });
    }
  }]);
  return DataTile;
}(_Tile2.default);
var _default = exports.default = DataTile;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js","./dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/reproj/DataTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _common = require("./common.js");
var _DataTile2 = _interopRequireWildcard(require("../DataTile.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));
var _reproj = require("../reproj.js");
var _math = require("../math.js");
var _dom = require("../dom.js");
var _extent = require("../extent.js");
var _events = require("../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/reproj/DataTile
 */
/**
 * @typedef {function(number, number, number, number) : import("../DataTile.js").default} TileGetter
 */
/**
 * @typedef {Object} Options
 * @property {import("../proj/Projection.js").default} sourceProj Source projection.
 * @property {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
 * @property {import("../proj/Projection.js").default} targetProj Target projection.
 * @property {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
 * @property {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
 * @property {import("../tilecoord.js").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.
 * @property {number} pixelRatio Pixel ratio.
 * @property {number} gutter Gutter of the source tiles.
 * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {number} [errorThreshold] Acceptable reprojection error (in px).
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 */
/**
 * @classdesc
 * Class encapsulating single reprojected data tile.
 * See {@link module:ol/source/DataTile~DataTileSource}.
 *
 */
var ReprojDataTile = /*#__PURE__*/function (_DataTile) {
  _inherits(ReprojDataTile, _DataTile);
  var _super = _createSuper(ReprojDataTile);
  /**
   * @param {Options} options Tile options.
   */
  function ReprojDataTile(options) {
    var _this;
    _classCallCheck(this, ReprojDataTile);
    _this = _super.call(this, {
      tileCoord: options.tileCoord,
      loader: function loader() {
        return Promise.resolve(new Uint8Array(4));
      },
      interpolate: options.interpolate,
      transition: options.transition
    });

    /**
     * @private
     * @type {number}
     */
    _this.pixelRatio_ = options.pixelRatio;

    /**
     * @private
     * @type {number}
     */
    _this.gutter_ = options.gutter;

    /**
     * @type {import("../DataTile.js").Data}
     * @private
     */
    _this.reprojData_ = null;

    /**
     * @type {Error}
     * @private
     */
    _this.reprojError_ = null;

    /**
     * @type {import('../size.js').Size}
     * @private
     */
    _this.reprojSize_ = undefined;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    _this.sourceTileGrid_ = options.sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    _this.targetTileGrid_ = options.targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    _this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;

    /**
     * @private
     * @type {!Array<DataTile>}
     */
    _this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    _this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.sourceZ_ = 0;
    var targetExtent = _this.targetTileGrid_.getTileCoordExtent(_this.wrappedTileCoord_);
    var maxTargetExtent = _this.targetTileGrid_.getExtent();
    var maxSourceExtent = _this.sourceTileGrid_.getExtent();
    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
    if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    var sourceProj = options.sourceProj;
    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }
    var targetResolution = _this.targetTileGrid_.getResolution(_this.wrappedTileCoord_[0]);
    var targetProj = options.targetProj;
    var sourceResolution = (0, _reproj.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    var errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : _common.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    _this.triangulation_ = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = _TileState.default.EMPTY;
      return _possibleConstructorReturn(_this);
    }
    _this.sourceZ_ = _this.sourceTileGrid_.getZForResolution(sourceResolution);
    var sourceExtent = _this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }
    if (!(0, _extent.getArea)(sourceExtent)) {
      _this.state = _TileState.default.EMPTY;
    } else {
      var sourceRange = _this.sourceTileGrid_.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
      var getTile = options.getTileFunction;
      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTile(_this.sourceZ_, srcX, srcY, _this.pixelRatio_);
          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }
      if (_this.sourceTiles_.length === 0) {
        _this.state = _TileState.default.EMPTY;
      }
    }
    return _this;
  }

  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   */
  _createClass(ReprojDataTile, [{
    key: "getSize",
    value: function getSize() {
      return this.reprojSize_;
    }

    /**
     * Get the data for the tile.
     * @return {import("../DataTile.js").Data} Tile data.
     */
  }, {
    key: "getData",
    value: function getData() {
      return this.reprojData_;
    }

    /**
     * Get any loading error.
     * @return {Error} Loading error.
     */
  }, {
    key: "getError",
    value: function getError() {
      return this.reprojError_;
    }

    /**
     * @private
     */
  }, {
    key: "reproject_",
    value: function reproject_() {
      var _this2 = this;
      var dataSources = [];
      this.sourceTiles_.forEach(function (tile) {
        if (!tile || tile.getState() !== _TileState.default.LOADED) {
          return;
        }
        var size = tile.getSize();
        var gutter = _this2.gutter_;
        /**
         * @type {import("../DataTile.js").ArrayLike}
         */
        var tileData;
        var arrayData = (0, _DataTile2.asArrayLike)(tile.getData());
        if (arrayData) {
          tileData = arrayData;
        } else {
          tileData = (0, _DataTile2.toArray)((0, _DataTile2.asImageLike)(tile.getData()));
        }
        var pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];
        var isFloat = tileData instanceof Float32Array;
        var pixelCount = pixelSize[0] * pixelSize[1];
        var DataType = isFloat ? Float32Array : Uint8Array;
        var tileDataR = new DataType(tileData.buffer);
        var bytesPerElement = DataType.BYTES_PER_ELEMENT;
        var bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;
        var bytesPerRow = tileDataR.byteLength / pixelSize[1];
        var bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
        var packedLength = pixelCount * bandCount;
        var packedData = tileDataR;
        if (tileDataR.length !== packedLength) {
          packedData = new DataType(packedLength);
          var dataIndex = 0;
          var rowOffset = 0;
          var colCount = pixelSize[0] * bandCount;
          for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
            for (var colIndex = 0; colIndex < colCount; ++colIndex) {
              packedData[dataIndex++] = tileDataR[rowOffset + colIndex];
            }
            rowOffset += bytesPerRow / bytesPerElement;
          }
        }
        dataSources.push({
          extent: _this2.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          data: new Uint8Array(packedData.buffer),
          dataType: DataType,
          bytesPerPixel: bytesPerPixel,
          pixelSize: pixelSize
        });
      });
      this.sourceTiles_.length = 0;
      if (dataSources.length === 0) {
        this.state = _TileState.default.ERROR;
      } else {
        var z = this.wrappedTileCoord_[0];
        var size = this.targetTileGrid_.getTileSize(z);
        var targetWidth = typeof size === 'number' ? size : size[0];
        var targetHeight = typeof size === 'number' ? size : size[1];
        var targetResolution = this.targetTileGrid_.getResolution(z);
        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        var dataR, dataU;
        var bytesPerPixel = dataSources[0].bytesPerPixel;
        var reprojs = Math.ceil(bytesPerPixel / 3);
        for (var reproj = reprojs - 1; reproj >= 0; --reproj) {
          var sources = [];
          for (var i = 0, len = dataSources.length; i < len; ++i) {
            var dataSource = dataSources[i];
            var buffer = dataSource.data;
            var pixelSize = dataSource.pixelSize;
            var width = pixelSize[0];
            var height = pixelSize[1];
            var _context = (0, _dom.createCanvasContext2D)(width, height, _reproj.canvasPool);
            var _imageData = _context.createImageData(width, height);
            var _data = _imageData.data;
            var _offset = reproj * 3;
            for (var j = 0, _len = _data.length; j < _len; j += 4) {
              _data[j] = buffer[_offset];
              _data[j + 1] = buffer[_offset + 1];
              _data[j + 2] = buffer[_offset + 2];
              _data[j + 3] = 255;
              _offset += bytesPerPixel;
            }
            _context.putImageData(_imageData, 0, 0);
            sources.push({
              extent: dataSource.extent,
              image: _context.canvas
            });
          }
          var canvas = (0, _reproj.render)(targetWidth, targetHeight, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, false, false);
          for (var _i = 0, _len2 = sources.length; _i < _len2; ++_i) {
            var _canvas = sources[_i].image;
            var _context2 = _canvas.getContext('2d');
            (0, _dom.releaseCanvas)(_context2);
            _reproj.canvasPool.push(_context2.canvas);
          }
          var context = canvas.getContext('2d');
          var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          (0, _dom.releaseCanvas)(context);
          _reproj.canvasPool.push(canvas);
          if (!dataR) {
            dataU = new Uint8Array(bytesPerPixel * imageData.width * imageData.height);
            dataR = new dataSources[0].dataType(dataU.buffer);
          }
          var data = imageData.data;
          var offset = reproj * 3;
          for (var _i2 = 0, _len3 = data.length; _i2 < _len3; _i2 += 4) {
            if (data[_i2 + 3] === 255) {
              dataU[offset] = data[_i2];
              dataU[offset + 1] = data[_i2 + 1];
              dataU[offset + 2] = data[_i2 + 2];
            } else {
              dataU[offset] = 0;
              dataU[offset + 1] = 0;
              dataU[offset + 2] = 0;
            }
            offset += bytesPerPixel;
          }
        }
        this.reprojData_ = dataR;
        this.reprojSize_ = [Math.round(targetWidth * this.pixelRatio_), Math.round(targetHeight * this.pixelRatio_)];
        this.state = _TileState.default.LOADED;
      }
      this.changed();
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      var _this3 = this;
      if (this.state !== _TileState.default.IDLE && this.state !== _TileState.default.ERROR) {
        return;
      }
      this.state = _TileState.default.LOADING;
      this.changed();
      var leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function (tile) {
        var state = tile.getState();
        if (state !== _TileState.default.IDLE && state !== _TileState.default.LOADING) {
          return;
        }
        leftToLoad++;
        var sourceListenKey = (0, _events.listen)(tile, _EventType.default.CHANGE, function () {
          var state = tile.getState();
          if (state == _TileState.default.LOADED || state == _TileState.default.ERROR || state == _TileState.default.EMPTY) {
            (0, _events.unlistenByKey)(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, _this3);
        _this3.sourcesListenerKeys_.push(sourceListenKey);
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function (tile) {
          var state = tile.getState();
          if (state == _TileState.default.IDLE) {
            tile.load();
          }
        });
      }
    }

    /**
     * @private
     */
  }, {
    key: "unlistenSources_",
    value: function unlistenSources_() {
      this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
      this.sourcesListenerKeys_ = null;
    }
  }]);
  return ReprojDataTile;
}(_DataTile2.default);
var _default = exports.default = ReprojDataTile;
},{"./common.js":"node_modules/ol/reproj/common.js","../DataTile.js":"node_modules/ol/DataTile.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../TileState.js":"node_modules/ol/TileState.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js","../reproj.js":"node_modules/ol/reproj.js","../math.js":"node_modules/ol/math.js","../dom.js":"node_modules/ol/dom.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/source/DataTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _DataTile = _interopRequireDefault(require("../DataTile.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _DataTile2 = _interopRequireDefault(require("../reproj/DataTile.js"));
var _TileCache = _interopRequireDefault(require("../TileCache.js"));
var _TileEventType = _interopRequireDefault(require("./TileEventType.js"));
var _Tile = _interopRequireWildcard(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _tilegrid = require("../tilegrid.js");
var _proj = require("../proj.js");
var _tilecoord = require("../tilecoord.js");
var _util = require("../util.js");
var _functions = require("../functions.js");
var _size = require("../size.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/DataTile
 */
/**
 * Data tile loading function.  The function is called with z, x, and y tile coordinates and
 * returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * @typedef {function(number, number, number) : (import("../DataTile.js").Data|Promise<import("../DataTile.js").Data>)} Loader
 */
/**
 * @typedef {Object} Options
 * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.
 * Returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.
 * This may be different than the rendered pixel size if a `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Tile projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("./Source.js").State} [state] The source state.
 * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.
 * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).
 * @property {number} [bandCount=4] Number of bands represented in the data.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * A source for typed array data tiles.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var DataTileSource = /*#__PURE__*/function (_TileSource) {
  _inherits(DataTileSource, _TileSource);
  var _super = _createSuper(DataTileSource);
  /**
   * @param {Options} options DataTile source options.
   */
  function DataTileSource(options) {
    var _this;
    _classCallCheck(this, DataTileSource);
    var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;
    var tileGrid = options.tileGrid;
    if (tileGrid === undefined && projection) {
      tileGrid = (0, _tilegrid.createXYZ)({
        extent: (0, _tilegrid.extentFromProjection)(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
    }
    _this = _super.call(this, {
      cacheSize: 0.1,
      // don't cache on the source
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: projection,
      tileGrid: tileGrid,
      opaque: options.opaque,
      state: options.state,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate
    });

    /**
     * @private
     * @type {number}
     */
    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;

    /**
     * @private
     * @type {import('../size.js').Size|null}
     */
    _this.tileSize_ = options.tileSize ? (0, _size.toSize)(options.tileSize) : null;

    /**
     * @private
     * @type {Array<import('../size.js').Size>|null}
     */
    _this.tileSizes_ = null;

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    _this.tileLoadingKeys_ = {};

    /**
     * @private
     */
    _this.loader_ = options.loader;
    _this.handleTileChange_ = _this.handleTileChange_.bind(_assertThisInitialized(_this));

    /**
     * @type {number}
     */
    _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined

    /**
     * @private
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    _this.tileGridForProjection_ = {};

    /**
     * @private
     * @type {!Object<string, import("../TileCache.js").default>}
     */
    _this.tileCacheForProjection_ = {};
    return _this;
  }

  /**
   * Set the source tile sizes.  The length of the array is expected to match the number of
   * levels in the tile grid.
   * @protected
   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.
   */
  _createClass(DataTileSource, [{
    key: "setTileSizes",
    value: function setTileSizes(tileSizes) {
      this.tileSizes_ = tileSizes;
    }

    /**
     * Get the source tile size at the given zoom level.  This may be different than the rendered tile
     * size.
     * @protected
     * @param {number} z Tile zoom level.
     * @return {import('../size.js').Size} The source tile size.
     */
  }, {
    key: "getTileSize",
    value: function getTileSize(z) {
      if (this.tileSizes_) {
        return this.tileSizes_[z];
      }
      if (this.tileSize_) {
        return this.tileSize_;
      }
      var tileGrid = this.getTileGrid();
      return tileGrid ? (0, _size.toSize)(tileGrid.getTileSize(z)) : [256, 256];
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
  }, {
    key: "getGutterForProjection",
    value: function getGutterForProjection(projection) {
      var thisProj = this.getProjection();
      if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
        return this.gutter_;
      }
      return 0;
    }

    /**
     * @param {Loader} loader The data loader.
     * @protected
     */
  }, {
    key: "setLoader",
    value: function setLoader(loader) {
      this.loader_ = loader;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} targetProj The output projection.
     * @param {import("../proj/Projection.js").default} sourceProj The input projection.
     * @return {!DataTile} Tile.
     */
  }, {
    key: "getReprojTile_",
    value: function getReprojTile_(z, x, y, targetProj, sourceProj) {
      var _this2 = this;
      var cache = this.getTileCacheForProjection(targetProj);
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      if (cache.containsKey(tileCoordKey)) {
        var tile = cache.get(tileCoordKey);
        if (tile && tile.key == this.getKey()) {
          return tile;
        }
      }
      var tileGrid = this.getTileGrid();
      var reprojTilePixelRatio = Math.max.apply(null, tileGrid.getResolutions().map(function (r, z) {
        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z));
        var textureSize = _this2.getTileSize(z);
        return Math.max(textureSize[0] / tileSize[0], textureSize[1] / tileSize[1]);
      }));
      var sourceTileGrid = this.getTileGridForProjection(sourceProj);
      var targetTileGrid = this.getTileGridForProjection(targetProj);
      var tileCoord = [z, x, y];
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, targetProj);
      var options = Object.assign({
        sourceProj: sourceProj,
        sourceTileGrid: sourceTileGrid,
        targetProj: targetProj,
        targetTileGrid: targetTileGrid,
        tileCoord: tileCoord,
        wrappedTileCoord: wrappedTileCoord,
        pixelRatio: reprojTilePixelRatio,
        gutter: this.getGutterForProjection(sourceProj),
        getTileFunction: function getTileFunction(z, x, y, pixelRatio) {
          return _this2.getTile(z, x, y, pixelRatio, sourceProj);
        }
      }, this.tileOptions);
      var newTile = new _DataTile2.default(options);
      newTile.key = this.getKey();
      return newTile;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!DataTile} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      var sourceProjection = this.getProjection();
      if (sourceProjection && projection && !(0, _proj.equivalent)(sourceProjection, projection)) {
        return this.getReprojTile_(z, x, y, projection, sourceProjection);
      }
      var size = this.getTileSize(z);
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      if (this.tileCache.containsKey(tileCoordKey)) {
        return this.tileCache.get(tileCoordKey);
      }
      var sourceLoader = this.loader_;
      function loader() {
        return (0, _functions.toPromise)(function () {
          return sourceLoader(z, x, y);
        });
      }
      var options = Object.assign({
        tileCoord: [z, x, y],
        loader: loader,
        size: size
      }, this.tileOptions);
      var tile = new _DataTile.default(options);
      tile.key = this.getKey();
      tile.addEventListener(_EventType.default.CHANGE, this.handleTileChange_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }

    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     */
  }, {
    key: "handleTileChange_",
    value: function handleTileChange_(event) {
      var tile = /** @type {import("../Tile.js").default} */event.target;
      var uid = (0, _util.getUid)(tile);
      var tileState = tile.getState();
      var type;
      if (tileState == _TileState.default.LOADING) {
        this.tileLoadingKeys_[uid] = true;
        type = _TileEventType.default.TILELOADSTART;
      } else if (uid in this.tileLoadingKeys_) {
        delete this.tileLoadingKeys_[uid];
        type = tileState == _TileState.default.ERROR ? _TileEventType.default.TILELOADERROR : tileState == _TileState.default.LOADED ? _TileEventType.default.TILELOADEND : undefined;
      }
      if (type) {
        this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
      }
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      var thisProj = this.getProjection();
      if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
        return this.tileGrid;
      }
      var projKey = (0, _util.getUid)(projection);
      if (!(projKey in this.tileGridForProjection_)) {
        this.tileGridForProjection_[projKey] = (0, _tilegrid.getForProjection)(projection);
      }
      return this.tileGridForProjection_[projKey];
    }

    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
  }, {
    key: "setTileGridForProjection",
    value: function setTileGridForProjection(projection, tilegrid) {
      var proj = (0, _proj.get)(projection);
      if (proj) {
        var projKey = (0, _util.getUid)(proj);
        if (!(projKey in this.tileGridForProjection_)) {
          this.tileGridForProjection_[projKey] = tilegrid;
        }
      }
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     */
  }, {
    key: "getTileCacheForProjection",
    value: function getTileCacheForProjection(projection) {
      var thisProj = this.getProjection();
      if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
        return this.tileCache;
      }
      var projKey = (0, _util.getUid)(projection);
      if (!(projKey in this.tileCacheForProjection_)) {
        this.tileCacheForProjection_[projKey] = new _TileCache.default(0.1); // don't cache
      }
      return this.tileCacheForProjection_[projKey];
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var usedTileCache = this.getTileCacheForProjection(projection);
      this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
      for (var id in this.tileCacheForProjection_) {
        var tileCache = this.tileCacheForProjection_[id];
        tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      _get(_getPrototypeOf(DataTileSource.prototype), "clear", this).call(this);
      for (var id in this.tileCacheForProjection_) {
        this.tileCacheForProjection_[id].clear();
      }
    }
  }]);
  return DataTileSource;
}(_Tile.default);
var _default = exports.default = DataTileSource;
},{"../DataTile.js":"node_modules/ol/DataTile.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../reproj/DataTile.js":"node_modules/ol/reproj/DataTile.js","../TileCache.js":"node_modules/ol/TileCache.js","./TileEventType.js":"node_modules/ol/source/TileEventType.js","./Tile.js":"node_modules/ol/source/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../proj.js":"node_modules/ol/proj.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../util.js":"node_modules/ol/util.js","../functions.js":"node_modules/ol/functions.js","../size.js":"node_modules/ol/size.js"}],"node_modules/@petamoriken/float16/browser/float16.js":[function(require,module,exports) {
/*! @petamoriken/float16 v3.8.4 | MIT License - https://github.com/petamoriken/float16 */

var float16 = (function (exports) {
  'use strict';

  const THIS_IS_NOT_AN_OBJECT = "This is not an object";
  const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = "This is not a Float16Array object";
  const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =
    "This constructor is not a subclass of Float16Array";
  const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =
    "The constructor property value is not an object";
  const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =
    "Species constructor didn't return TypedArray object";
  const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =
    "Derived constructor created TypedArray object which was too small length";
  const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =
    "Attempting to access detached ArrayBuffer";
  const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =
    "Cannot convert undefined or null to object";
  const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =
    "Cannot mix BigInt and other types, use explicit conversions";
  const ITERATOR_PROPERTY_IS_NOT_CALLABLE = "@@iterator property is not callable";
  const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =
    "Reduce of empty array with no initial value";
  const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =
    "The comparison function must be either a function or undefined";
  const OFFSET_IS_OUT_OF_BOUNDS = "Offset is out of bounds";

  function uncurryThis(target) {
    return (thisArg, ...args) => {
      return ReflectApply(target, thisArg, args);
    };
  }
  function uncurryThisGetter(target, key) {
    return uncurryThis(
      ReflectGetOwnPropertyDescriptor(
        target,
        key
      ).get
    );
  }
  const {
    apply: ReflectApply,
    construct: ReflectConstruct,
    defineProperty: ReflectDefineProperty,
    get: ReflectGet,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
    getPrototypeOf: ReflectGetPrototypeOf,
    has: ReflectHas,
    ownKeys: ReflectOwnKeys,
    set: ReflectSet,
    setPrototypeOf: ReflectSetPrototypeOf,
  } = Reflect;
  const NativeProxy = Proxy;
  const {
    EPSILON,
    MAX_SAFE_INTEGER,
    isFinite: NumberIsFinite,
    isNaN: NumberIsNaN,
  } = Number;
  const {
    iterator: SymbolIterator,
    species: SymbolSpecies,
    toStringTag: SymbolToStringTag,
    for: SymbolFor,
  } = Symbol;
  const NativeObject = Object;
  const {
    create: ObjectCreate,
    defineProperty: ObjectDefineProperty,
    freeze: ObjectFreeze,
    is: ObjectIs,
  } = NativeObject;
  const ObjectPrototype = NativeObject.prototype;
  const ObjectPrototype__lookupGetter__ =  (ObjectPrototype).__lookupGetter__
    ? uncurryThis( (ObjectPrototype).__lookupGetter__)
    : (object, key) => {
      if (object == null) {
        throw NativeTypeError(
          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT
        );
      }
      let target = NativeObject(object);
      do {
        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);
        if (descriptor !== undefined) {
          if (ObjectHasOwn(descriptor, "get")) {
            return descriptor.get;
          }
          return;
        }
      } while ((target = ReflectGetPrototypeOf(target)) !== null);
    };
  const ObjectHasOwn =  (NativeObject).hasOwn ||
    uncurryThis(ObjectPrototype.hasOwnProperty);
  const NativeArray = Array;
  const ArrayIsArray = NativeArray.isArray;
  const ArrayPrototype = NativeArray.prototype;
  const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);
  const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);
  const ArrayPrototypeToLocaleString = uncurryThis(
    ArrayPrototype.toLocaleString
  );
  const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];
  const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);
  const {
    abs: MathAbs,
    trunc: MathTrunc,
  } = Math;
  const NativeArrayBuffer = ArrayBuffer;
  const ArrayBufferIsView = NativeArrayBuffer.isView;
  const ArrayBufferPrototype = NativeArrayBuffer.prototype;
  const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);
  const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, "byteLength");
  const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : null;
  const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer
    && uncurryThisGetter(NativeSharedArrayBuffer.prototype, "byteLength");
  const TypedArray = ReflectGetPrototypeOf(Uint8Array);
  const TypedArrayFrom = TypedArray.from;
  const TypedArrayPrototype = TypedArray.prototype;
  const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];
  const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);
  const TypedArrayPrototypeValues = uncurryThis(
    TypedArrayPrototype.values
  );
  const TypedArrayPrototypeEntries = uncurryThis(
    TypedArrayPrototype.entries
  );
  const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);
  const TypedArrayPrototypeReverse = uncurryThis(
    TypedArrayPrototype.reverse
  );
  const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);
  const TypedArrayPrototypeCopyWithin = uncurryThis(
    TypedArrayPrototype.copyWithin
  );
  const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);
  const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);
  const TypedArrayPrototypeSubarray = uncurryThis(
    TypedArrayPrototype.subarray
  );
  const TypedArrayPrototypeGetBuffer = uncurryThisGetter(
    TypedArrayPrototype,
    "buffer"
  );
  const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(
    TypedArrayPrototype,
    "byteOffset"
  );
  const TypedArrayPrototypeGetLength = uncurryThisGetter(
    TypedArrayPrototype,
    "length"
  );
  const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(
    TypedArrayPrototype,
    SymbolToStringTag
  );
  const NativeUint8Array = Uint8Array;
  const NativeUint16Array = Uint16Array;
  const Uint16ArrayFrom = (...args) => {
    return ReflectApply(TypedArrayFrom, NativeUint16Array, args);
  };
  const NativeUint32Array = Uint32Array;
  const NativeFloat32Array = Float32Array;
  const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());
  const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);
  const GeneratorPrototypeNext = uncurryThis((function* () {})().next);
  const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);
  const DataViewPrototype = DataView.prototype;
  const DataViewPrototypeGetUint16 = uncurryThis(
    DataViewPrototype.getUint16
  );
  const DataViewPrototypeSetUint16 = uncurryThis(
    DataViewPrototype.setUint16
  );
  const NativeTypeError = TypeError;
  const NativeRangeError = RangeError;
  const NativeWeakSet = WeakSet;
  const WeakSetPrototype = NativeWeakSet.prototype;
  const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);
  const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);
  const NativeWeakMap = WeakMap;
  const WeakMapPrototype = NativeWeakMap.prototype;
  const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);
  const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);
  const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);

  const arrayIterators = new NativeWeakMap();
  const SafeIteratorPrototype = ObjectCreate(null, {
    next: {
      value: function next() {
        const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);
        return ArrayIteratorPrototypeNext(arrayIterator);
      },
    },
    [SymbolIterator]: {
      value: function values() {
        return this;
      },
    },
  });
  function safeIfNeeded(array) {
    if (
      array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&
      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext
    ) {
      return array;
    }
    const safe = ObjectCreate(SafeIteratorPrototype);
    WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));
    return safe;
  }
  const generators = new NativeWeakMap();
  const DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {
    next: {
      value: function next() {
        const generator = WeakMapPrototypeGet(generators, this);
        return GeneratorPrototypeNext(generator);
      },
      writable: true,
      configurable: true,
    },
  });
  for (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {
    if (key === "next") {
      continue;
    }
    ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));
  }
  function wrap(generator) {
    const dummy = ObjectCreate(DummyArrayIteratorPrototype);
    WeakMapPrototypeSet(generators, dummy, generator);
    return dummy;
  }

  function isObject(value) {
    return (
      (value !== null && typeof value === "object") ||
      typeof value === "function"
    );
  }
  function isObjectLike(value) {
    return value !== null && typeof value === "object";
  }
  function isNativeTypedArray(value) {
    return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;
  }
  function isNativeBigIntTypedArray(value) {
    const typedArrayName = TypedArrayPrototypeGetSymbolToStringTag(value);
    return (
      typedArrayName === "BigInt64Array" ||
      typedArrayName === "BigUint64Array"
    );
  }
  function isArrayBuffer(value) {
    try {
      ArrayBufferPrototypeGetByteLength( (value));
      return true;
    } catch (e) {
      return false;
    }
  }
  function isSharedArrayBuffer(value) {
    if (NativeSharedArrayBuffer === null) {
      return false;
    }
    try {
      SharedArrayBufferPrototypeGetByteLength( (value));
      return true;
    } catch (e) {
      return false;
    }
  }
  function isAnyArrayBuffer(value) {
    return isArrayBuffer(value) || isSharedArrayBuffer(value);
  }
  function isOrdinaryArray(value) {
    if (!ArrayIsArray(value)) {
      return false;
    }
    return (
      value[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&
      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext
    );
  }
  function isOrdinaryNativeTypedArray(value) {
    if (!isNativeTypedArray(value)) {
      return false;
    }
    return (
      value[SymbolIterator] === NativeTypedArrayPrototypeSymbolIterator &&
      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext
    );
  }
  function isCanonicalIntegerIndexString(value) {
    if (typeof value !== "string") {
      return false;
    }
    const number = +value;
    if (value !== number + "") {
      return false;
    }
    if (!NumberIsFinite(number)) {
      return false;
    }
    return number === MathTrunc(number);
  }

  const brand = SymbolFor("__Float16Array__");
  function hasFloat16ArrayBrand(target) {
    if (!isObjectLike(target)) {
      return false;
    }
    const prototype = ReflectGetPrototypeOf(target);
    if (!isObjectLike(prototype)) {
      return false;
    }
    const constructor = prototype.constructor;
    if (constructor === undefined) {
      return false;
    }
    if (!isObject(constructor)) {
      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
    }
    return ReflectHas(constructor, brand);
  }

  const INVERSE_OF_EPSILON = 1 / EPSILON;
  function roundTiesToEven(num) {
    return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;
  }
  const FLOAT16_MIN_VALUE = 6.103515625e-05;
  const FLOAT16_MAX_VALUE = 65504;
  const FLOAT16_EPSILON = 0.0009765625;
  const FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;
  const FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;
  function roundToFloat16(num) {
    const number = +num;
    if (!NumberIsFinite(number) || number === 0) {
      return number;
    }
    const sign = number > 0 ? 1 : -1;
    const absolute = MathAbs(number);
    if (absolute < FLOAT16_MIN_VALUE) {
      return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;
    }
    const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;
    const result = temp - (temp - absolute);
    if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {
      return sign * Infinity;
    }
    return sign * result;
  }
  const buffer = new NativeArrayBuffer(4);
  const floatView = new NativeFloat32Array(buffer);
  const uint32View = new NativeUint32Array(buffer);
  const baseTable = new NativeUint16Array(512);
  const shiftTable = new NativeUint8Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i]         = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i]         = 24;
      shiftTable[i | 0x100] = 24;
    } else if (e < -14) {
      baseTable[i]         =  0x0400 >> (-e - 14);
      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
      shiftTable[i]         = -e - 1;
      shiftTable[i | 0x100] = -e - 1;
    } else if (e <= 15) {
      baseTable[i]         =  (e + 15) << 10;
      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
      shiftTable[i]         = 13;
      shiftTable[i | 0x100] = 13;
    } else if (e < 128) {
      baseTable[i]         = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i]         = 24;
      shiftTable[i | 0x100] = 24;
    } else {
      baseTable[i]         = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i]         = 13;
      shiftTable[i | 0x100] = 13;
    }
  }
  function roundToFloat16Bits(num) {
    floatView[0] = roundToFloat16(num);
    const f = uint32View[0];
    const e = (f >> 23) & 0x1ff;
    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);
  }
  const mantissaTable = new NativeUint32Array(2048);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 0x00800000) === 0) {
      m <<= 1;
      e -= 0x00800000;
    }
    m &= ~0x00800000;
    e += 0x38800000;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
  }
  const exponentTable = new NativeUint32Array(64);
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 0x80000000 + ((i - 32) << 23);
  }
  exponentTable[63] = 0xc7800000;
  const offsetTable = new NativeUint16Array(64);
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  function convertToNumber(float16bits) {
    const i = float16bits >> 10;
    uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];
    return floatView[0];
  }

  function ToIntegerOrInfinity(target) {
    const number = +target;
    if (NumberIsNaN(number) || number === 0) {
      return 0;
    }
    return MathTrunc(number);
  }
  function ToLength(target) {
    const length = ToIntegerOrInfinity(target);
    if (length < 0) {
      return 0;
    }
    return length < MAX_SAFE_INTEGER
      ? length
      : MAX_SAFE_INTEGER;
  }
  function SpeciesConstructor(target, defaultConstructor) {
    if (!isObject(target)) {
      throw NativeTypeError(THIS_IS_NOT_AN_OBJECT);
    }
    const constructor = target.constructor;
    if (constructor === undefined) {
      return defaultConstructor;
    }
    if (!isObject(constructor)) {
      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
    }
    const species = constructor[SymbolSpecies];
    if (species == null) {
      return defaultConstructor;
    }
    return species;
  }
  function IsDetachedBuffer(buffer) {
    if (isSharedArrayBuffer(buffer)) {
      return false;
    }
    try {
      ArrayBufferPrototypeSlice(buffer, 0, 0);
      return false;
    } catch (e) {}
    return true;
  }
  function defaultCompare(x, y) {
    const isXNaN = NumberIsNaN(x);
    const isYNaN = NumberIsNaN(y);
    if (isXNaN && isYNaN) {
      return 0;
    }
    if (isXNaN) {
      return 1;
    }
    if (isYNaN) {
      return -1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    if (x === 0 && y === 0) {
      const isXPlusZero = ObjectIs(x, 0);
      const isYPlusZero = ObjectIs(y, 0);
      if (!isXPlusZero && isYPlusZero) {
        return -1;
      }
      if (isXPlusZero && !isYPlusZero) {
        return 1;
      }
    }
    return 0;
  }

  const BYTES_PER_ELEMENT = 2;
  const float16bitsArrays = new NativeWeakMap();
  function isFloat16Array(target) {
    return WeakMapPrototypeHas(float16bitsArrays, target) ||
      (!ArrayBufferIsView(target) && hasFloat16ArrayBrand(target));
  }
  function assertFloat16Array(target) {
    if (!isFloat16Array(target)) {
      throw NativeTypeError(THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);
    }
  }
  function assertSpeciesTypedArray(target, count) {
    const isTargetFloat16Array = isFloat16Array(target);
    const isTargetTypedArray = isNativeTypedArray(target);
    if (!isTargetFloat16Array && !isTargetTypedArray) {
      throw NativeTypeError(SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);
    }
    if (typeof count === "number") {
      let length;
      if (isTargetFloat16Array) {
        const float16bitsArray = getFloat16BitsArray(target);
        length = TypedArrayPrototypeGetLength(float16bitsArray);
      } else {
        length = TypedArrayPrototypeGetLength(target);
      }
      if (length < count) {
        throw NativeTypeError(
          DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH
        );
      }
    }
    if (isNativeBigIntTypedArray(target)) {
      throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
    }
  }
  function getFloat16BitsArray(float16) {
    const float16bitsArray = WeakMapPrototypeGet(float16bitsArrays, float16);
    if (float16bitsArray !== undefined) {
      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);
      if (IsDetachedBuffer(buffer)) {
        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
      }
      return float16bitsArray;
    }
    const buffer =  (float16).buffer;
    if (IsDetachedBuffer(buffer)) {
      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
    }
    const cloned = ReflectConstruct(Float16Array, [
      buffer,
       (float16).byteOffset,
       (float16).length,
    ], float16.constructor);
    return WeakMapPrototypeGet(float16bitsArrays, cloned);
  }
  function copyToArray(float16bitsArray) {
    const length = TypedArrayPrototypeGetLength(float16bitsArray);
    const array = [];
    for (let i = 0; i < length; ++i) {
      array[i] = convertToNumber(float16bitsArray[i]);
    }
    return array;
  }
  const TypedArrayPrototypeGetters = new NativeWeakSet();
  for (const key of ReflectOwnKeys(TypedArrayPrototype)) {
    if (key === SymbolToStringTag) {
      continue;
    }
    const descriptor = ReflectGetOwnPropertyDescriptor(TypedArrayPrototype, key);
    if (ObjectHasOwn(descriptor, "get") && typeof descriptor.get === "function") {
      WeakSetPrototypeAdd(TypedArrayPrototypeGetters, descriptor.get);
    }
  }
  const handler = ObjectFreeze( ({
    get(target, key, receiver) {
      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {
        return convertToNumber(ReflectGet(target, key));
      }
      if (WeakSetPrototypeHas(TypedArrayPrototypeGetters, ObjectPrototype__lookupGetter__(target, key))) {
        return ReflectGet(target, key);
      }
      return ReflectGet(target, key, receiver);
    },
    set(target, key, value, receiver) {
      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {
        return ReflectSet(target, key, roundToFloat16Bits(value));
      }
      return ReflectSet(target, key, value, receiver);
    },
    getOwnPropertyDescriptor(target, key) {
      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {
        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);
        descriptor.value = convertToNumber(descriptor.value);
        return descriptor;
      }
      return ReflectGetOwnPropertyDescriptor(target, key);
    },
    defineProperty(target, key, descriptor) {
      if (
        isCanonicalIntegerIndexString(key) &&
        ObjectHasOwn(target, key) &&
        ObjectHasOwn(descriptor, "value")
      ) {
        descriptor.value = roundToFloat16Bits(descriptor.value);
        return ReflectDefineProperty(target, key, descriptor);
      }
      return ReflectDefineProperty(target, key, descriptor);
    },
  }));
  class Float16Array {
    constructor(input, _byteOffset, _length) {
      let float16bitsArray;
      if (isFloat16Array(input)) {
        float16bitsArray = ReflectConstruct(NativeUint16Array, [getFloat16BitsArray(input)], new.target);
      } else if (isObject(input) && !isAnyArrayBuffer(input)) {
        let list;
        let length;
        if (isNativeTypedArray(input)) {
          list = input;
          length = TypedArrayPrototypeGetLength(input);
          const buffer = TypedArrayPrototypeGetBuffer(input);
          if (IsDetachedBuffer(buffer)) {
            throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
          }
          if (isNativeBigIntTypedArray(input)) {
            throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
          }
          const data = new NativeArrayBuffer(
            length * BYTES_PER_ELEMENT
          );
          float16bitsArray = ReflectConstruct(NativeUint16Array, [data], new.target);
        } else {
          const iterator = input[SymbolIterator];
          if (iterator != null && typeof iterator !== "function") {
            throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);
          }
          if (iterator != null) {
            if (isOrdinaryArray(input)) {
              list = input;
              length = input.length;
            } else {
              list = [...  (input)];
              length = list.length;
            }
          } else {
            list =  (input);
            length = ToLength(list.length);
          }
          float16bitsArray = ReflectConstruct(NativeUint16Array, [length], new.target);
        }
        for (let i = 0; i < length; ++i) {
          float16bitsArray[i] = roundToFloat16Bits(list[i]);
        }
      } else {
        float16bitsArray = ReflectConstruct(NativeUint16Array, arguments, new.target);
      }
      const proxy =  (new NativeProxy(float16bitsArray, handler));
      WeakMapPrototypeSet(float16bitsArrays, proxy, float16bitsArray);
      return proxy;
    }
    static from(src, ...opts) {
      const Constructor = this;
      if (!ReflectHas(Constructor, brand)) {
        throw NativeTypeError(
          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY
        );
      }
      if (Constructor === Float16Array) {
        if (isFloat16Array(src) && opts.length === 0) {
          const float16bitsArray = getFloat16BitsArray(src);
          const uint16 = new NativeUint16Array(
            TypedArrayPrototypeGetBuffer(float16bitsArray),
            TypedArrayPrototypeGetByteOffset(float16bitsArray),
            TypedArrayPrototypeGetLength(float16bitsArray)
          );
          return new Float16Array(
            TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16))
          );
        }
        if (opts.length === 0) {
          return new Float16Array(
            TypedArrayPrototypeGetBuffer(
              Uint16ArrayFrom(src, roundToFloat16Bits)
            )
          );
        }
        const mapFunc = opts[0];
        const thisArg = opts[1];
        return new Float16Array(
          TypedArrayPrototypeGetBuffer(
            Uint16ArrayFrom(src, function (val, ...args) {
              return roundToFloat16Bits(
                ReflectApply(mapFunc, this, [val, ...safeIfNeeded(args)])
              );
            }, thisArg)
          )
        );
      }
      let list;
      let length;
      const iterator = src[SymbolIterator];
      if (iterator != null && typeof iterator !== "function") {
        throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);
      }
      if (iterator != null) {
        if (isOrdinaryArray(src)) {
          list = src;
          length = src.length;
        } else if (isOrdinaryNativeTypedArray(src)) {
          list = src;
          length = TypedArrayPrototypeGetLength(src);
        } else {
          list = [...src];
          length = list.length;
        }
      } else {
        if (src == null) {
          throw NativeTypeError(
            CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT
          );
        }
        list = NativeObject(src);
        length = ToLength(list.length);
      }
      const array = new Constructor(length);
      if (opts.length === 0) {
        for (let i = 0; i < length; ++i) {
          array[i] =  (list[i]);
        }
      } else {
        const mapFunc = opts[0];
        const thisArg = opts[1];
        for (let i = 0; i < length; ++i) {
          array[i] = ReflectApply(mapFunc, thisArg, [list[i], i]);
        }
      }
      return array;
    }
    static of(...items) {
      const Constructor = this;
      if (!ReflectHas(Constructor, brand)) {
        throw NativeTypeError(
          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY
        );
      }
      const length = items.length;
      if (Constructor === Float16Array) {
        const proxy = new Float16Array(length);
        const float16bitsArray = getFloat16BitsArray(proxy);
        for (let i = 0; i < length; ++i) {
          float16bitsArray[i] = roundToFloat16Bits(items[i]);
        }
        return proxy;
      }
      const array = new Constructor(length);
      for (let i = 0; i < length; ++i) {
        array[i] = items[i];
      }
      return array;
    }
    keys() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return TypedArrayPrototypeKeys(float16bitsArray);
    }
    values() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return wrap((function* () {
        for (const val of TypedArrayPrototypeValues(float16bitsArray)) {
          yield convertToNumber(val);
        }
      })());
    }
    entries() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return wrap((function* () {
        for (const [i, val] of TypedArrayPrototypeEntries(float16bitsArray)) {
          yield  ([i, convertToNumber(val)]);
        }
      })());
    }
    at(index) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const relativeIndex = ToIntegerOrInfinity(index);
      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
      if (k < 0 || k >= length) {
        return;
      }
      return convertToNumber(float16bitsArray[k]);
    }
    with(index, value) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const relativeIndex = ToIntegerOrInfinity(index);
      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
      const number = +value;
      if (k < 0 || k >= length) {
        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);
      }
      const uint16 = new NativeUint16Array(
        TypedArrayPrototypeGetBuffer(float16bitsArray),
        TypedArrayPrototypeGetByteOffset(float16bitsArray),
        TypedArrayPrototypeGetLength(float16bitsArray)
      );
      const cloned = new Float16Array(
        TypedArrayPrototypeGetBuffer(
          TypedArrayPrototypeSlice(uint16)
        )
      );
      const array = getFloat16BitsArray(cloned);
      array[k] = roundToFloat16Bits(number);
      return cloned;
    }
    map(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);
      if (Constructor === Float16Array) {
        const proxy = new Float16Array(length);
        const array = getFloat16BitsArray(proxy);
        for (let i = 0; i < length; ++i) {
          const val = convertToNumber(float16bitsArray[i]);
          array[i] = roundToFloat16Bits(
            ReflectApply(callback, thisArg, [val, i, this])
          );
        }
        return proxy;
      }
      const array = new Constructor(length);
      assertSpeciesTypedArray(array, length);
      for (let i = 0; i < length; ++i) {
        const val = convertToNumber(float16bitsArray[i]);
        array[i] = ReflectApply(callback, thisArg, [val, i, this]);
      }
      return  (array);
    }
    filter(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      const kept = [];
      for (let i = 0; i < length; ++i) {
        const val = convertToNumber(float16bitsArray[i]);
        if (ReflectApply(callback, thisArg, [val, i, this])) {
          ArrayPrototypePush(kept, val);
        }
      }
      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);
      const array = new Constructor(kept);
      assertSpeciesTypedArray(array);
      return  (array);
    }
    reduce(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      if (length === 0 && opts.length === 0) {
        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
      }
      let accumulator, start;
      if (opts.length === 0) {
        accumulator = convertToNumber(float16bitsArray[0]);
        start = 1;
      } else {
        accumulator = opts[0];
        start = 0;
      }
      for (let i = start; i < length; ++i) {
        accumulator = callback(
          accumulator,
          convertToNumber(float16bitsArray[i]),
          i,
          this
        );
      }
      return accumulator;
    }
    reduceRight(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      if (length === 0 && opts.length === 0) {
        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
      }
      let accumulator, start;
      if (opts.length === 0) {
        accumulator = convertToNumber(float16bitsArray[length - 1]);
        start = length - 2;
      } else {
        accumulator = opts[0];
        start = length - 1;
      }
      for (let i = start; i >= 0; --i) {
        accumulator = callback(
          accumulator,
          convertToNumber(float16bitsArray[i]),
          i,
          this
        );
      }
      return accumulator;
    }
    forEach(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        ReflectApply(callback, thisArg, [
          convertToNumber(float16bitsArray[i]),
          i,
          this,
        ]);
      }
    }
    find(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        const value = convertToNumber(float16bitsArray[i]);
        if (ReflectApply(callback, thisArg, [value, i, this])) {
          return value;
        }
      }
    }
    findIndex(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        const value = convertToNumber(float16bitsArray[i]);
        if (ReflectApply(callback, thisArg, [value, i, this])) {
          return i;
        }
      }
      return -1;
    }
    findLast(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = length - 1; i >= 0; --i) {
        const value = convertToNumber(float16bitsArray[i]);
        if (ReflectApply(callback, thisArg, [value, i, this])) {
          return value;
        }
      }
    }
    findLastIndex(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = length - 1; i >= 0; --i) {
        const value = convertToNumber(float16bitsArray[i]);
        if (ReflectApply(callback, thisArg, [value, i, this])) {
          return i;
        }
      }
      return -1;
    }
    every(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        if (
          !ReflectApply(callback, thisArg, [
            convertToNumber(float16bitsArray[i]),
            i,
            this,
          ])
        ) {
          return false;
        }
      }
      return true;
    }
    some(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        if (
          ReflectApply(callback, thisArg, [
            convertToNumber(float16bitsArray[i]),
            i,
            this,
          ])
        ) {
          return true;
        }
      }
      return false;
    }
    set(input, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const targetOffset = ToIntegerOrInfinity(opts[0]);
      if (targetOffset < 0) {
        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);
      }
      if (input == null) {
        throw NativeTypeError(
          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT
        );
      }
      if (isNativeBigIntTypedArray(input)) {
        throw NativeTypeError(
          CANNOT_MIX_BIGINT_AND_OTHER_TYPES
        );
      }
      if (isFloat16Array(input)) {
        return TypedArrayPrototypeSet(
          getFloat16BitsArray(this),
          getFloat16BitsArray(input),
          targetOffset
        );
      }
      if (isNativeTypedArray(input)) {
        const buffer = TypedArrayPrototypeGetBuffer(input);
        if (IsDetachedBuffer(buffer)) {
          throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
        }
      }
      const targetLength = TypedArrayPrototypeGetLength(float16bitsArray);
      const src = NativeObject(input);
      const srcLength = ToLength(src.length);
      if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);
      }
      for (let i = 0; i < srcLength; ++i) {
        float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);
      }
    }
    reverse() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      TypedArrayPrototypeReverse(float16bitsArray);
      return this;
    }
    toReversed() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const uint16 = new NativeUint16Array(
        TypedArrayPrototypeGetBuffer(float16bitsArray),
        TypedArrayPrototypeGetByteOffset(float16bitsArray),
        TypedArrayPrototypeGetLength(float16bitsArray)
      );
      const cloned = new Float16Array(
        TypedArrayPrototypeGetBuffer(
          TypedArrayPrototypeSlice(uint16)
        )
      );
      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);
      TypedArrayPrototypeReverse(clonedFloat16bitsArray);
      return cloned;
    }
    fill(value, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      TypedArrayPrototypeFill(
        float16bitsArray,
        roundToFloat16Bits(value),
        ...safeIfNeeded(opts)
      );
      return this;
    }
    copyWithin(target, start, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      TypedArrayPrototypeCopyWithin(float16bitsArray, target, start, ...safeIfNeeded(opts));
      return this;
    }
    sort(compareFn) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;
      TypedArrayPrototypeSort(float16bitsArray, (x, y) => {
        return sortCompare(convertToNumber(x), convertToNumber(y));
      });
      return this;
    }
    toSorted(compareFn) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      if (compareFn !== undefined && typeof compareFn !== "function") {
        throw new NativeTypeError(THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);
      }
      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;
      const uint16 = new NativeUint16Array(
        TypedArrayPrototypeGetBuffer(float16bitsArray),
        TypedArrayPrototypeGetByteOffset(float16bitsArray),
        TypedArrayPrototypeGetLength(float16bitsArray)
      );
      const cloned = new Float16Array(
        TypedArrayPrototypeGetBuffer(
          TypedArrayPrototypeSlice(uint16)
        )
      );
      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);
      TypedArrayPrototypeSort(clonedFloat16bitsArray, (x, y) => {
        return sortCompare(convertToNumber(x), convertToNumber(y));
      });
      return cloned;
    }
    slice(start, end) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);
      if (Constructor === Float16Array) {
        const uint16 = new NativeUint16Array(
          TypedArrayPrototypeGetBuffer(float16bitsArray),
          TypedArrayPrototypeGetByteOffset(float16bitsArray),
          TypedArrayPrototypeGetLength(float16bitsArray)
        );
        return new Float16Array(
          TypedArrayPrototypeGetBuffer(
            TypedArrayPrototypeSlice(uint16, start, end)
          )
        );
      }
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      const relativeStart = ToIntegerOrInfinity(start);
      const relativeEnd = end === undefined ? length : ToIntegerOrInfinity(end);
      let k;
      if (relativeStart === -Infinity) {
        k = 0;
      } else if (relativeStart < 0) {
        k = length + relativeStart > 0 ? length + relativeStart : 0;
      } else {
        k = length < relativeStart ? length : relativeStart;
      }
      let final;
      if (relativeEnd === -Infinity) {
        final = 0;
      } else if (relativeEnd < 0) {
        final = length + relativeEnd > 0 ? length + relativeEnd : 0;
      } else {
        final = length < relativeEnd ? length : relativeEnd;
      }
      const count = final - k > 0 ? final - k : 0;
      const array = new Constructor(count);
      assertSpeciesTypedArray(array, count);
      if (count === 0) {
        return array;
      }
      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);
      if (IsDetachedBuffer(buffer)) {
        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
      }
      let n = 0;
      while (k < final) {
        array[n] = convertToNumber(float16bitsArray[k]);
        ++k;
        ++n;
      }
      return  (array);
    }
    subarray(begin, end) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);
      const uint16 = new NativeUint16Array(
        TypedArrayPrototypeGetBuffer(float16bitsArray),
        TypedArrayPrototypeGetByteOffset(float16bitsArray),
        TypedArrayPrototypeGetLength(float16bitsArray)
      );
      const uint16Subarray = TypedArrayPrototypeSubarray(uint16, begin, end);
      const array = new Constructor(
        TypedArrayPrototypeGetBuffer(uint16Subarray),
        TypedArrayPrototypeGetByteOffset(uint16Subarray),
        TypedArrayPrototypeGetLength(uint16Subarray)
      );
      assertSpeciesTypedArray(array);
      return  (array);
    }
    indexOf(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      let from = ToIntegerOrInfinity(opts[0]);
      if (from === Infinity) {
        return -1;
      }
      if (from < 0) {
        from += length;
        if (from < 0) {
          from = 0;
        }
      }
      for (let i = from; i < length; ++i) {
        if (
          ObjectHasOwn(float16bitsArray, i) &&
          convertToNumber(float16bitsArray[i]) === element
        ) {
          return i;
        }
      }
      return -1;
    }
    lastIndexOf(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;
      if (from === -Infinity) {
        return -1;
      }
      if (from >= 0) {
        from = from < length - 1 ? from : length - 1;
      } else {
        from += length;
      }
      for (let i = from; i >= 0; --i) {
        if (
          ObjectHasOwn(float16bitsArray, i) &&
          convertToNumber(float16bitsArray[i]) === element
        ) {
          return i;
        }
      }
      return -1;
    }
    includes(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = TypedArrayPrototypeGetLength(float16bitsArray);
      let from = ToIntegerOrInfinity(opts[0]);
      if (from === Infinity) {
        return false;
      }
      if (from < 0) {
        from += length;
        if (from < 0) {
          from = 0;
        }
      }
      const isNaN = NumberIsNaN(element);
      for (let i = from; i < length; ++i) {
        const value = convertToNumber(float16bitsArray[i]);
        if (isNaN && NumberIsNaN(value)) {
          return true;
        }
        if (value === element) {
          return true;
        }
      }
      return false;
    }
    join(separator) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const array = copyToArray(float16bitsArray);
      return ArrayPrototypeJoin(array, separator);
    }
    toLocaleString(...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const array = copyToArray(float16bitsArray);
      return ArrayPrototypeToLocaleString(array, ...safeIfNeeded(opts));
    }
    get [SymbolToStringTag]() {
      if (isFloat16Array(this)) {
        return  ("Float16Array");
      }
    }
  }
  ObjectDefineProperty(Float16Array, "BYTES_PER_ELEMENT", {
    value: BYTES_PER_ELEMENT,
  });
  ObjectDefineProperty(Float16Array, brand, {});
  ReflectSetPrototypeOf(Float16Array, TypedArray);
  const Float16ArrayPrototype = Float16Array.prototype;
  ObjectDefineProperty(Float16ArrayPrototype, "BYTES_PER_ELEMENT", {
    value: BYTES_PER_ELEMENT,
  });
  ObjectDefineProperty(Float16ArrayPrototype, SymbolIterator, {
    value: Float16ArrayPrototype.values,
    writable: true,
    configurable: true,
  });
  ReflectSetPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);

  function isTypedArray(target) {
    return isNativeTypedArray(target) || isFloat16Array(target);
  }

  function getFloat16(dataView, byteOffset, ...opts) {
    return convertToNumber(
      DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))
    );
  }
  function setFloat16(dataView, byteOffset, value, ...opts) {
    return DataViewPrototypeSetUint16(
      dataView,
      byteOffset,
      roundToFloat16Bits(value),
      ...safeIfNeeded(opts)
    );
  }

  function f16round(x) {
    return roundToFloat16(x);
  }

  exports.Float16Array = Float16Array;
  exports.f16round = f16round;
  exports.getFloat16 = getFloat16;
  exports.hfround = f16round;
  exports.isFloat16Array = isFloat16Array;
  exports.isTypedArray = isTypedArray;
  exports.setFloat16 = setFloat16;

  Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

  return exports;

})({});

},{}],"node_modules/xml-utils/get-attribute.js":[function(require,module,exports) {
function getAttribute(tag, attributeName, options) {
  const debug = (options && options.debug) || false;
  if (debug) console.log("[xml-utils] getting " + attributeName + " in " + tag);

  const xml = typeof tag === "object" ? tag.outer : tag;

  // only search for attributes in the opening tag
  const opening = xml.slice(0, xml.indexOf(">") + 1);

  const quotechars = ['"', "'"];
  for (let i = 0; i < quotechars.length; i++) {
    const char = quotechars[i];
    const pattern = attributeName + "\\=" + char + "([^" + char + "]*)" + char;
    if (debug) console.log("[xml-utils] pattern:", pattern);

    const re = new RegExp(pattern);
    const match = re.exec(opening);
    if (debug) console.log("[xml-utils] match:", match);
    if (match) return match[1];
  }
}

module.exports = getAttribute;
module.exports.default = getAttribute;

},{}],"node_modules/xml-utils/index-of-match.js":[function(require,module,exports) {
function indexOfMatch(xml, pattern, startIndex) {
  const re = new RegExp(pattern);
  const match = re.exec(xml.slice(startIndex));
  if (match) return startIndex + match.index;
  else return -1;
}

module.exports = indexOfMatch;
module.exports.default = indexOfMatch;

},{}],"node_modules/xml-utils/index-of-match-end.js":[function(require,module,exports) {
function indexOfMatchEnd(xml, pattern, startIndex) {
  const re = new RegExp(pattern);
  const match = re.exec(xml.slice(startIndex));
  if (match) return startIndex + match.index + match[0].length - 1;
  else return -1;
}

module.exports = indexOfMatchEnd;
module.exports.default = indexOfMatchEnd;

},{}],"node_modules/xml-utils/count-substring.js":[function(require,module,exports) {
function countSubstring(string, substring) {
  const pattern = new RegExp(substring, "g");
  const match = string.match(pattern);
  return match ? match.length : 0;
}

module.exports = countSubstring;
module.exports.default = countSubstring;

},{}],"node_modules/xml-utils/find-tag-by-name.js":[function(require,module,exports) {
const indexOfMatch = require("./index-of-match.js");
const indexOfMatchEnd = require("./index-of-match-end.js");
const countSubstring = require("./count-substring.js");

function findTagByName(xml, tagName, options) {
  const debug = (options && options.debug) || false;
  const nested = !(options && typeof options.nested === false);

  const startIndex = (options && options.startIndex) || 0;

  if (debug) console.log("[xml-utils] starting findTagByName with", tagName, " and ", options);

  const start = indexOfMatch(xml, `\<${tagName}[ \n\>\/]`, startIndex);
  if (debug) console.log("[xml-utils] start:", start);
  if (start === -1) return undefined;

  const afterStart = xml.slice(start + tagName.length);

  let relativeEnd = indexOfMatchEnd(afterStart, "^[^<]*[ /]>", 0);

  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === "/";
  if (debug) console.log("[xml-utils] selfClosing:", selfClosing);

  if (selfClosing === false) {
    // check if tag has subtags with the same name
    if (nested) {
      let startIndex = 0;
      let openings = 1;
      let closings = 0;
      while ((relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", startIndex)) !== -1) {
        const clip = afterStart.substring(startIndex, relativeEnd + 1);
        openings += countSubstring(clip, "<" + tagName + "[ \n\t>]");
        closings += countSubstring(clip, "</" + tagName + ">");
        // we can't have more openings than closings
        if (closings >= openings) break;
        startIndex = relativeEnd;
      }
    } else {
      relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", 0);
    }
  }

  const end = start + tagName.length + relativeEnd + 1;
  if (debug) console.log("[xml-utils] end:", end);
  if (end === -1) return undefined;

  const outer = xml.slice(start, end);
  // tag is like <gml:identifier codeSpace="OGP">urn:ogc:def:crs:EPSG::32617</gml:identifier>

  let inner;
  if (selfClosing) {
    inner = null;
  } else {
    inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
  }

  return { inner, outer, start, end };
}

module.exports = findTagByName;
module.exports.default = findTagByName;

},{"./index-of-match.js":"node_modules/xml-utils/index-of-match.js","./index-of-match-end.js":"node_modules/xml-utils/index-of-match-end.js","./count-substring.js":"node_modules/xml-utils/count-substring.js"}],"node_modules/xml-utils/find-tags-by-name.js":[function(require,module,exports) {
const findTagByName = require("./find-tag-by-name.js");

function findTagsByName(xml, tagName, options) {
  const tags = [];
  const debug = (options && options.debug) || false;
  const nested = options && typeof options.nested === "boolean" ? options.nested : true;
  let startIndex = (options && options.startIndex) || 0;
  let tag;
  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {
    if (nested) {
      startIndex = tag.start + 1 + tagName.length;
    } else {
      startIndex = tag.end;
    }
    tags.push(tag);
  }
  if (debug) console.log("findTagsByName found", tags.length, "tags");
  return tags;
}

module.exports = findTagsByName;
module.exports.default = findTagsByName;

},{"./find-tag-by-name.js":"node_modules/xml-utils/find-tag-by-name.js"}],"node_modules/geotiff/dist-module/globals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.photometricInterpretations = exports.geoKeys = exports.geoKeyNames = exports.fieldTypes = exports.fieldTypeNames = exports.fieldTags = exports.fieldTagTypes = exports.fieldTagNames = exports.arrayFields = exports.LercParameters = exports.LercAddCompression = exports.ExtraSamplesValues = void 0;
var fieldTagNames = exports.fieldTagNames = {
  // TIFF Baseline
  0x013B: 'Artist',
  0x0102: 'BitsPerSample',
  0x0109: 'CellLength',
  0x0108: 'CellWidth',
  0x0140: 'ColorMap',
  0x0103: 'Compression',
  0x8298: 'Copyright',
  0x0132: 'DateTime',
  0x0152: 'ExtraSamples',
  0x010A: 'FillOrder',
  0x0121: 'FreeByteCounts',
  0x0120: 'FreeOffsets',
  0x0123: 'GrayResponseCurve',
  0x0122: 'GrayResponseUnit',
  0x013C: 'HostComputer',
  0x010E: 'ImageDescription',
  0x0101: 'ImageLength',
  0x0100: 'ImageWidth',
  0x010F: 'Make',
  0x0119: 'MaxSampleValue',
  0x0118: 'MinSampleValue',
  0x0110: 'Model',
  0x00FE: 'NewSubfileType',
  0x0112: 'Orientation',
  0x0106: 'PhotometricInterpretation',
  0x011C: 'PlanarConfiguration',
  0x0128: 'ResolutionUnit',
  0x0116: 'RowsPerStrip',
  0x0115: 'SamplesPerPixel',
  0x0131: 'Software',
  0x0117: 'StripByteCounts',
  0x0111: 'StripOffsets',
  0x00FF: 'SubfileType',
  0x0107: 'Threshholding',
  0x011A: 'XResolution',
  0x011B: 'YResolution',
  // TIFF Extended
  0x0146: 'BadFaxLines',
  0x0147: 'CleanFaxData',
  0x0157: 'ClipPath',
  0x0148: 'ConsecutiveBadFaxLines',
  0x01B1: 'Decode',
  0x01B2: 'DefaultImageColor',
  0x010D: 'DocumentName',
  0x0150: 'DotRange',
  0x0141: 'HalftoneHints',
  0x015A: 'Indexed',
  0x015B: 'JPEGTables',
  0x011D: 'PageName',
  0x0129: 'PageNumber',
  0x013D: 'Predictor',
  0x013F: 'PrimaryChromaticities',
  0x0214: 'ReferenceBlackWhite',
  0x0153: 'SampleFormat',
  0x0154: 'SMinSampleValue',
  0x0155: 'SMaxSampleValue',
  0x022F: 'StripRowCounts',
  0x014A: 'SubIFDs',
  0x0124: 'T4Options',
  0x0125: 'T6Options',
  0x0145: 'TileByteCounts',
  0x0143: 'TileLength',
  0x0144: 'TileOffsets',
  0x0142: 'TileWidth',
  0x012D: 'TransferFunction',
  0x013E: 'WhitePoint',
  0x0158: 'XClipPathUnits',
  0x011E: 'XPosition',
  0x0211: 'YCbCrCoefficients',
  0x0213: 'YCbCrPositioning',
  0x0212: 'YCbCrSubSampling',
  0x0159: 'YClipPathUnits',
  0x011F: 'YPosition',
  // EXIF
  0x9202: 'ApertureValue',
  0xA001: 'ColorSpace',
  0x9004: 'DateTimeDigitized',
  0x9003: 'DateTimeOriginal',
  0x8769: 'Exif IFD',
  0x9000: 'ExifVersion',
  0x829A: 'ExposureTime',
  0xA300: 'FileSource',
  0x9209: 'Flash',
  0xA000: 'FlashpixVersion',
  0x829D: 'FNumber',
  0xA420: 'ImageUniqueID',
  0x9208: 'LightSource',
  0x927C: 'MakerNote',
  0x9201: 'ShutterSpeedValue',
  0x9286: 'UserComment',
  // IPTC
  0x83BB: 'IPTC',
  // ICC
  0x8773: 'ICC Profile',
  // XMP
  0x02BC: 'XMP',
  // GDAL
  0xA480: 'GDAL_METADATA',
  0xA481: 'GDAL_NODATA',
  // Photoshop
  0x8649: 'Photoshop',
  // GeoTiff
  0x830E: 'ModelPixelScale',
  0x8482: 'ModelTiepoint',
  0x85D8: 'ModelTransformation',
  0x87AF: 'GeoKeyDirectory',
  0x87B0: 'GeoDoubleParams',
  0x87B1: 'GeoAsciiParams',
  // LERC
  0xC5F2: 'LercParameters'
};
var fieldTags = exports.fieldTags = {};
for (var key in fieldTagNames) {
  if (fieldTagNames.hasOwnProperty(key)) {
    fieldTags[fieldTagNames[key]] = parseInt(key, 10);
  }
}
var fieldTagTypes = exports.fieldTagTypes = {
  256: 'SHORT',
  257: 'SHORT',
  258: 'SHORT',
  259: 'SHORT',
  262: 'SHORT',
  273: 'LONG',
  274: 'SHORT',
  277: 'SHORT',
  278: 'LONG',
  279: 'LONG',
  282: 'RATIONAL',
  283: 'RATIONAL',
  284: 'SHORT',
  286: 'SHORT',
  287: 'RATIONAL',
  296: 'SHORT',
  297: 'SHORT',
  305: 'ASCII',
  306: 'ASCII',
  338: 'SHORT',
  339: 'SHORT',
  513: 'LONG',
  514: 'LONG',
  1024: 'SHORT',
  1025: 'SHORT',
  2048: 'SHORT',
  2049: 'ASCII',
  3072: 'SHORT',
  3073: 'ASCII',
  33550: 'DOUBLE',
  33922: 'DOUBLE',
  34264: 'DOUBLE',
  34665: 'LONG',
  34735: 'SHORT',
  34736: 'DOUBLE',
  34737: 'ASCII',
  42113: 'ASCII'
};
var arrayFields = exports.arrayFields = [fieldTags.BitsPerSample, fieldTags.ExtraSamples, fieldTags.SampleFormat, fieldTags.StripByteCounts, fieldTags.StripOffsets, fieldTags.StripRowCounts, fieldTags.TileByteCounts, fieldTags.TileOffsets, fieldTags.SubIFDs];
var fieldTypeNames = exports.fieldTypeNames = {
  0x0001: 'BYTE',
  0x0002: 'ASCII',
  0x0003: 'SHORT',
  0x0004: 'LONG',
  0x0005: 'RATIONAL',
  0x0006: 'SBYTE',
  0x0007: 'UNDEFINED',
  0x0008: 'SSHORT',
  0x0009: 'SLONG',
  0x000A: 'SRATIONAL',
  0x000B: 'FLOAT',
  0x000C: 'DOUBLE',
  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
  0x000D: 'IFD',
  // introduced by BigTIFF
  0x0010: 'LONG8',
  0x0011: 'SLONG8',
  0x0012: 'IFD8'
};
var fieldTypes = exports.fieldTypes = {};
for (var _key in fieldTypeNames) {
  if (fieldTypeNames.hasOwnProperty(_key)) {
    fieldTypes[fieldTypeNames[_key]] = parseInt(_key, 10);
  }
}
var photometricInterpretations = exports.photometricInterpretations = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};
var ExtraSamplesValues = exports.ExtraSamplesValues = {
  Unspecified: 0,
  Assocalpha: 1,
  Unassalpha: 2
};
var LercParameters = exports.LercParameters = {
  Version: 0,
  AddCompression: 1
};
var LercAddCompression = exports.LercAddCompression = {
  None: 0,
  Deflate: 1,
  Zstandard: 2
};
var geoKeyNames = exports.geoKeyNames = {
  1024: 'GTModelTypeGeoKey',
  1025: 'GTRasterTypeGeoKey',
  1026: 'GTCitationGeoKey',
  2048: 'GeographicTypeGeoKey',
  2049: 'GeogCitationGeoKey',
  2050: 'GeogGeodeticDatumGeoKey',
  2051: 'GeogPrimeMeridianGeoKey',
  2052: 'GeogLinearUnitsGeoKey',
  2053: 'GeogLinearUnitSizeGeoKey',
  2054: 'GeogAngularUnitsGeoKey',
  2055: 'GeogAngularUnitSizeGeoKey',
  2056: 'GeogEllipsoidGeoKey',
  2057: 'GeogSemiMajorAxisGeoKey',
  2058: 'GeogSemiMinorAxisGeoKey',
  2059: 'GeogInvFlatteningGeoKey',
  2060: 'GeogAzimuthUnitsGeoKey',
  2061: 'GeogPrimeMeridianLongGeoKey',
  2062: 'GeogTOWGS84GeoKey',
  3072: 'ProjectedCSTypeGeoKey',
  3073: 'PCSCitationGeoKey',
  3074: 'ProjectionGeoKey',
  3075: 'ProjCoordTransGeoKey',
  3076: 'ProjLinearUnitsGeoKey',
  3077: 'ProjLinearUnitSizeGeoKey',
  3078: 'ProjStdParallel1GeoKey',
  3079: 'ProjStdParallel2GeoKey',
  3080: 'ProjNatOriginLongGeoKey',
  3081: 'ProjNatOriginLatGeoKey',
  3082: 'ProjFalseEastingGeoKey',
  3083: 'ProjFalseNorthingGeoKey',
  3084: 'ProjFalseOriginLongGeoKey',
  3085: 'ProjFalseOriginLatGeoKey',
  3086: 'ProjFalseOriginEastingGeoKey',
  3087: 'ProjFalseOriginNorthingGeoKey',
  3088: 'ProjCenterLongGeoKey',
  3089: 'ProjCenterLatGeoKey',
  3090: 'ProjCenterEastingGeoKey',
  3091: 'ProjCenterNorthingGeoKey',
  3092: 'ProjScaleAtNatOriginGeoKey',
  3093: 'ProjScaleAtCenterGeoKey',
  3094: 'ProjAzimuthAngleGeoKey',
  3095: 'ProjStraightVertPoleLongGeoKey',
  3096: 'ProjRectifiedGridAngleGeoKey',
  4096: 'VerticalCSTypeGeoKey',
  4097: 'VerticalCitationGeoKey',
  4098: 'VerticalDatumGeoKey',
  4099: 'VerticalUnitsGeoKey'
};
var geoKeys = exports.geoKeys = {};
for (var _key2 in geoKeyNames) {
  if (geoKeyNames.hasOwnProperty(_key2)) {
    geoKeys[geoKeyNames[_key2]] = parseInt(_key2, 10);
  }
}
},{}],"node_modules/geotiff/dist-module/rgb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromBlackIsZero = fromBlackIsZero;
exports.fromCIELab = fromCIELab;
exports.fromCMYK = fromCMYK;
exports.fromPalette = fromPalette;
exports.fromWhiteIsZero = fromWhiteIsZero;
exports.fromYCbCr = fromYCbCr;
function fromWhiteIsZero(raster, max) {
  var width = raster.width,
    height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var value;
  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = 256 - raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }
  return rgbRaster;
}
function fromBlackIsZero(raster, max) {
  var width = raster.width,
    height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var value;
  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }
  return rgbRaster;
}
function fromPalette(raster, colorMap) {
  var width = raster.width,
    height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var greenOffset = colorMap.length / 3;
  var blueOffset = colorMap.length / 3 * 2;
  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    var mapIndex = raster[i];
    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;
    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
  }
  return rgbRaster;
}
function fromCMYK(cmykRaster) {
  var width = cmykRaster.width,
    height = cmykRaster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  for (var i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {
    var c = cmykRaster[i];
    var m = cmykRaster[i + 1];
    var y = cmykRaster[i + 2];
    var k = cmykRaster[i + 3];
    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);
    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);
    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);
  }
  return rgbRaster;
}
function fromYCbCr(yCbCrRaster) {
  var width = yCbCrRaster.width,
    height = yCbCrRaster.height;
  var rgbRaster = new Uint8ClampedArray(width * height * 3);
  for (var i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {
    var y = yCbCrRaster[i];
    var cb = yCbCrRaster[i + 1];
    var cr = yCbCrRaster[i + 2];
    rgbRaster[j] = y + 1.40200 * (cr - 0x80);
    rgbRaster[j + 1] = y - 0.34414 * (cb - 0x80) - 0.71414 * (cr - 0x80);
    rgbRaster[j + 2] = y + 1.77200 * (cb - 0x80);
  }
  return rgbRaster;
}
var Xn = 0.95047;
var Yn = 1.00000;
var Zn = 1.08883;

// from https://github.com/antimatter15/rgb-lab/blob/master/color.js

function fromCIELab(cieLabRaster) {
  var width = cieLabRaster.width,
    height = cieLabRaster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  for (var i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {
    var L = cieLabRaster[i + 0];
    var a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8
    var b_ = cieLabRaster[i + 2] << 24 >> 24; // same

    var y = (L + 16) / 116;
    var x = a_ / 500 + y;
    var z = y - b_ / 200;
    var r = void 0;
    var g = void 0;
    var b = void 0;
    x = Xn * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787);
    y = Yn * (y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787);
    z = Zn * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787);
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;
    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;
    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;
  }
  return rgbRaster;
}
},{}],"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;
function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }
  return bundleURL;
}
function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
    if (matches) {
      return getBaseURL(matches[0]);
    }
  }
  return '/';
}
function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/bundle-loader.js":[function(require,module,exports) {
var getBundleURL = require('./bundle-url').getBundleURL;
function loadBundlesLazy(bundles) {
  if (!Array.isArray(bundles)) {
    bundles = [bundles];
  }
  var id = bundles[bundles.length - 1];
  try {
    return Promise.resolve(require(id));
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return new LazyPromise(function (resolve, reject) {
        loadBundles(bundles.slice(0, -1)).then(function () {
          return require(id);
        }).then(resolve, reject);
      });
    }
    throw err;
  }
}
function loadBundles(bundles) {
  return Promise.all(bundles.map(loadBundle));
}
var bundleLoaders = {};
function registerBundleLoader(type, loader) {
  bundleLoaders[type] = loader;
}
module.exports = exports = loadBundlesLazy;
exports.load = loadBundles;
exports.register = registerBundleLoader;
var bundles = {};
function loadBundle(bundle) {
  var id;
  if (Array.isArray(bundle)) {
    id = bundle[1];
    bundle = bundle[0];
  }
  if (bundles[bundle]) {
    return bundles[bundle];
  }
  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();
  var bundleLoader = bundleLoaders[type];
  if (bundleLoader) {
    return bundles[bundle] = bundleLoader(getBundleURL() + bundle).then(function (resolved) {
      if (resolved) {
        module.bundle.register(id, resolved);
      }
      return resolved;
    }).catch(function (e) {
      delete bundles[bundle];
      throw e;
    });
  }
}
function LazyPromise(executor) {
  this.executor = executor;
  this.promise = null;
}
LazyPromise.prototype.then = function (onSuccess, onError) {
  if (this.promise === null) this.promise = new Promise(this.executor);
  return this.promise.then(onSuccess, onError);
};
LazyPromise.prototype.catch = function (onError) {
  if (this.promise === null) this.promise = new Promise(this.executor);
  return this.promise.catch(onError);
};
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"node_modules/geotiff/dist-module/compression/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDecoder = addDecoder;
exports.getDecoder = getDecoder;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var registry = new Map();
function addDecoder(cases, importFn) {
  if (!Array.isArray(cases)) {
    cases = [cases]; // eslint-disable-line no-param-reassign
  }
  cases.forEach(function (c) {
    return registry.set(c, importFn);
  });
}
function getDecoder(_x) {
  return _getDecoder.apply(this, arguments);
} // Add default decoders to registry (end-user may override with other implementations)
function _getDecoder() {
  _getDecoder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileDirectory) {
    var importFn, Decoder;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          importFn = registry.get(fileDirectory.Compression);
          if (importFn) {
            _context2.next = 3;
            break;
          }
          throw new Error("Unknown compression method identifier: ".concat(fileDirectory.Compression));
        case 3:
          _context2.next = 5;
          return importFn();
        case 5:
          Decoder = _context2.sent;
          return _context2.abrupt("return", new Decoder(fileDirectory));
        case 7:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getDecoder.apply(this, arguments);
}
addDecoder([undefined, 1], function () {
  return require("_bundle_loader")(require.resolve('./raw.js')).then(function (m) {
    return m.default;
  });
});
addDecoder(5, function () {
  return require("_bundle_loader")(require.resolve('./lzw.js')).then(function (m) {
    return m.default;
  });
});
addDecoder(6, function () {
  throw new Error('old style JPEG compression is not supported.');
});
addDecoder(7, function () {
  return require("_bundle_loader")(require.resolve('./jpeg.js')).then(function (m) {
    return m.default;
  });
});
addDecoder([8, 32946], function () {
  return require("_bundle_loader")(require.resolve('./deflate.js')).then(function (m) {
    return m.default;
  });
});
addDecoder(32773, function () {
  return require("_bundle_loader")(require.resolve('./packbits.js')).then(function (m) {
    return m.default;
  });
});
addDecoder(34887, function () {
  return require("_bundle_loader")(require.resolve('./lerc.js')).then( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(m) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return m.zstd.init();
          case 2:
            return _context.abrupt("return", m);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }()).then(function (m) {
    return m.default;
  });
});
addDecoder(50001, function () {
  return require("_bundle_loader")(require.resolve('./webimage.js')).then(function (m) {
    return m.default;
  });
});
},{"_bundle_loader":"node_modules/parcel-bundler/src/builtins/bundle-loader.js","./raw.js":[["raw.030b40f5.js","node_modules/geotiff/dist-module/compression/raw.js"],"raw.030b40f5.js.map","node_modules/geotiff/dist-module/compression/raw.js"],"./lzw.js":[["lzw.892aefeb.js","node_modules/geotiff/dist-module/compression/lzw.js"],"lzw.892aefeb.js.map","node_modules/geotiff/dist-module/compression/lzw.js"],"./jpeg.js":[["jpeg.0b660512.js","node_modules/geotiff/dist-module/compression/jpeg.js"],"jpeg.0b660512.js.map","node_modules/geotiff/dist-module/compression/jpeg.js"],"./deflate.js":[["deflate.3fbe1b41.js","node_modules/geotiff/dist-module/compression/deflate.js"],"deflate.3fbe1b41.js.map","node_modules/geotiff/dist-module/compression/deflate.js"],"./packbits.js":[["packbits.6ccb4ed8.js","node_modules/geotiff/dist-module/compression/packbits.js"],"packbits.6ccb4ed8.js.map","node_modules/geotiff/dist-module/compression/packbits.js"],"./lerc.js":[["lerc.98aced57.js","node_modules/geotiff/dist-module/compression/lerc.js"],"lerc.98aced57.js.map","node_modules/geotiff/dist-module/compression/lerc.js"],"./webimage.js":[["webimage.416015e3.js","node_modules/geotiff/dist-module/compression/webimage.js"],"webimage.416015e3.js.map","node_modules/geotiff/dist-module/compression/webimage.js"]}],"node_modules/geotiff/dist-module/resample.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resample = resample;
exports.resampleBilinear = resampleBilinear;
exports.resampleBilinearInterleaved = resampleBilinearInterleaved;
exports.resampleInterleaved = resampleInterleaved;
exports.resampleNearest = resampleNearest;
exports.resampleNearestInterleaved = resampleNearestInterleaved;
/**
 * @module resample
 */

function copyNewSize(array, width, height) {
  var samplesPerPixel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);
}

/**
 * Resample the input arrays using nearest neighbor value selection.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */
function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  return valueArrays.map(function (array) {
    var newArray = copyNewSize(array, outWidth, outHeight);
    for (var y = 0; y < outHeight; ++y) {
      var cy = Math.min(Math.round(relY * y), inHeight - 1);
      for (var x = 0; x < outWidth; ++x) {
        var cx = Math.min(Math.round(relX * x), inWidth - 1);
        var value = array[cy * inWidth + cx];
        newArray[y * outWidth + x] = value;
      }
    }
    return newArray;
  });
}

// simple linear interpolation, code from:
// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support
function lerp(v0, v1, t) {
  return (1 - t) * v0 + t * v1;
}

/**
 * Resample the input arrays using bilinear interpolation.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */
function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  return valueArrays.map(function (array) {
    var newArray = copyNewSize(array, outWidth, outHeight);
    for (var y = 0; y < outHeight; ++y) {
      var rawY = relY * y;
      var yl = Math.floor(rawY);
      var yh = Math.min(Math.ceil(rawY), inHeight - 1);
      for (var x = 0; x < outWidth; ++x) {
        var rawX = relX * x;
        var tx = rawX % 1;
        var xl = Math.floor(rawX);
        var xh = Math.min(Math.ceil(rawX), inWidth - 1);
        var ll = array[yl * inWidth + xl];
        var hl = array[yl * inWidth + xh];
        var lh = array[yh * inWidth + xl];
        var hh = array[yh * inWidth + xh];
        var value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth + x] = value;
      }
    }
    return newArray;
  });
}

/**
 * Resample the input arrays using the selected resampling method.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray[]} The resampled rasters
 */
function resample(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var method = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'nearest';
  switch (method.toLowerCase()) {
    case 'nearest':
      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);
    case 'bilinear':
    case 'linear':
      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);
    default:
      throw new Error("Unsupported resampling method: '".concat(method, "'"));
  }
}

/**
 * Resample the pixel interleaved input array using nearest neighbor value selection.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */
function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  var newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (var y = 0; y < outHeight; ++y) {
    var cy = Math.min(Math.round(relY * y), inHeight - 1);
    for (var x = 0; x < outWidth; ++x) {
      var cx = Math.min(Math.round(relX * x), inWidth - 1);
      for (var i = 0; i < samples; ++i) {
        var value = valueArray[cy * inWidth * samples + cx * samples + i];
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }
  return newArray;
}

/**
 * Resample the pixel interleaved input array using bilinear interpolation.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */
function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  var newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (var y = 0; y < outHeight; ++y) {
    var rawY = relY * y;
    var yl = Math.floor(rawY);
    var yh = Math.min(Math.ceil(rawY), inHeight - 1);
    for (var x = 0; x < outWidth; ++x) {
      var rawX = relX * x;
      var tx = rawX % 1;
      var xl = Math.floor(rawX);
      var xh = Math.min(Math.ceil(rawX), inWidth - 1);
      for (var i = 0; i < samples; ++i) {
        var ll = valueArray[yl * inWidth * samples + xl * samples + i];
        var hl = valueArray[yl * inWidth * samples + xh * samples + i];
        var lh = valueArray[yh * inWidth * samples + xl * samples + i];
        var hh = valueArray[yh * inWidth * samples + xh * samples + i];
        var value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }
  return newArray;
}

/**
 * Resample the pixel interleaved input array using the selected resampling method.
 * @param {TypedArray} valueArray The input array to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                                 interleaved data
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray} The resampled rasters
 */
function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var method = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'nearest';
  switch (method.toLowerCase()) {
    case 'nearest':
      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    case 'bilinear':
    case 'linear':
      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    default:
      throw new Error("Unsupported resampling method: '".concat(method, "'"));
  }
}
},{}],"node_modules/geotiff/dist-module/geotiffimage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _float = require("@petamoriken/float16");
var _getAttribute = _interopRequireDefault(require("xml-utils/get-attribute.js"));
var _findTagsByName = _interopRequireDefault(require("xml-utils/find-tags-by-name.js"));
var _globals = require("./globals.js");
var _rgb = require("./rgb.js");
var _index = require("./compression/index.js");
var _resample = require("./resample.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /** @module geotiffimage */
/**
 * @typedef {Object} ReadRasterOptions
 * @property {Array<number>} [window=whole window] the subset to read data from in pixels.
 * @property {Array<number>} [bbox=whole image] the subset to read data from in
 *                                           geographical coordinates.
 * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.
 * @property {boolean} [interleave=false] whether the data shall be read
 *                                             in one single array or separate
 *                                             arrays.
 * @property {Pool} [pool=null] The optional decoder pool to use.
 * @property {number} [width] The desired width of the output. When the width is not the
 *                                 same as the images, resampling will be performed.
 * @property {number} [height] The desired height of the output. When the width is not the
 *                                  same as the images, resampling will be performed.
 * @property {string} [resampleMethod='nearest'] The desired resampling method.
 * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                                       to be aborted
 * @property {number|number[]} [fillValue] The value to use for parts of the image
 *                                              outside of the images extent. When multiple
 *                                              samples are requested, an array of fill values
 *                                              can be passed.
 */

/** @typedef {import("./geotiff.js").TypedArray} TypedArray */
/** @typedef {import("./geotiff.js").ReadRasterResult} ReadRasterResult */

function sum(array, start, end) {
  var s = 0;
  for (var i = start; i < end; ++i) {
    s += array[i];
  }
  return s;
}
function arrayForType(format, bitsPerSample, size) {
  switch (format) {
    case 1:
      // unsigned integer data
      if (bitsPerSample <= 8) {
        return new Uint8Array(size);
      } else if (bitsPerSample <= 16) {
        return new Uint16Array(size);
      } else if (bitsPerSample <= 32) {
        return new Uint32Array(size);
      }
      break;
    case 2:
      // twos complement signed integer data
      if (bitsPerSample === 8) {
        return new Int8Array(size);
      } else if (bitsPerSample === 16) {
        return new Int16Array(size);
      } else if (bitsPerSample === 32) {
        return new Int32Array(size);
      }
      break;
    case 3:
      // floating point data
      switch (bitsPerSample) {
        case 16:
        case 32:
          return new Float32Array(size);
        case 64:
          return new Float64Array(size);
        default:
          break;
      }
      break;
    default:
      break;
  }
  throw Error('Unsupported data format/bitsPerSample');
}
function needsNormalization(format, bitsPerSample) {
  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {
    return false;
  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {
    return false;
  }
  return true;
}
function normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
  // const inByteArray = new Uint8Array(inBuffer);
  var view = new DataView(inBuffer);
  var outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
  var samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
  var outArray = arrayForType(format, bitsPerSample, outSize);
  // let pixel = 0;

  var bitMask = parseInt('1'.repeat(bitsPerSample), 2);
  if (format === 1) {
    // unsigned integer
    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337
    var pixelBitSkip;
    // let sampleBitOffset = 0;
    if (planarConfiguration === 1) {
      pixelBitSkip = samplesPerPixel * bitsPerSample;
      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;
    } else {
      pixelBitSkip = bitsPerSample;
    }

    // Bits per line rounds up to next byte boundary.
    var bitsPerLine = tileWidth * pixelBitSkip;
    if ((bitsPerLine & 7) !== 0) {
      bitsPerLine = bitsPerLine + 7 & ~7;
    }
    for (var y = 0; y < tileHeight; ++y) {
      var lineBitOffset = y * bitsPerLine;
      for (var x = 0; x < tileWidth; ++x) {
        var pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;
        for (var i = 0; i < samplesToTransfer; ++i) {
          var bitOffset = pixelBitOffset + i * bitsPerSample;
          var outIndex = (y * tileWidth + x) * samplesToTransfer + i;
          var byteOffset = Math.floor(bitOffset / 8);
          var innerBitOffset = bitOffset % 8;
          if (innerBitOffset + bitsPerSample <= 8) {
            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 16) {
            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 24) {
            var raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;
          } else {
            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
          }

          // let outWord = 0;
          // for (let bit = 0; bit < bitsPerSample; ++bit) {
          //   if (inByteArray[bitOffset >> 3]
          //     & (0x80 >> (bitOffset & 7))) {
          //     outWord |= (1 << (bitsPerSample - 1 - bit));
          //   }
          //   ++bitOffset;
          // }

          // outArray[outIndex] = outWord;
          // outArray[pixel] = outWord;
          // pixel += 1;
        }
        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;
      }
    }
  } else if (format === 3) {// floating point
    // Float16 is handled elsewhere
    // normalize 16/24 bit floats to 32 bit floats in the array
    // console.time();
    // if (bitsPerSample === 16) {
    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {
    //     outArray[outIndex] = getFloat16(view, byte);
    //   }
    // }
    // console.timeEnd()
  }
  return outArray.buffer;
}

/**
 * GeoTIFF sub-file image.
 */
var GeoTIFFImage = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} fileDirectory The parsed file directory
   * @param {Object} geoKeys The parsed geo-keys
   * @param {DataView} dataView The DataView for the underlying file.
   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
   * @param {Boolean} cache Whether or not decoded tiles shall be cached
   * @param {import('./source/basesource').BaseSource} source The datasource to read from
   */
  function GeoTIFFImage(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {
    _classCallCheck(this, GeoTIFFImage);
    this.fileDirectory = fileDirectory;
    this.geoKeys = geoKeys;
    this.dataView = dataView;
    this.littleEndian = littleEndian;
    this.tiles = cache ? {} : null;
    this.isTiled = !fileDirectory.StripOffsets;
    var planarConfiguration = fileDirectory.PlanarConfiguration;
    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;
    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {
      throw new Error('Invalid planar configuration.');
    }
    this.source = source;
  }

  /**
   * Returns the associated parsed file directory.
   * @returns {Object} the parsed file directory
   */
  _createClass(GeoTIFFImage, [{
    key: "getFileDirectory",
    value: function getFileDirectory() {
      return this.fileDirectory;
    }

    /**
     * Returns the associated parsed geo keys.
     * @returns {Object} the parsed geo keys
     */
  }, {
    key: "getGeoKeys",
    value: function getGeoKeys() {
      return this.geoKeys;
    }

    /**
     * Returns the width of the image.
     * @returns {Number} the width of the image
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.fileDirectory.ImageWidth;
    }

    /**
     * Returns the height of the image.
     * @returns {Number} the height of the image
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.fileDirectory.ImageLength;
    }

    /**
     * Returns the number of samples per pixel.
     * @returns {Number} the number of samples per pixel
     */
  }, {
    key: "getSamplesPerPixel",
    value: function getSamplesPerPixel() {
      return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;
    }

    /**
     * Returns the width of each tile.
     * @returns {Number} the width of each tile
     */
  }, {
    key: "getTileWidth",
    value: function getTileWidth() {
      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
    }

    /**
     * Returns the height of each tile.
     * @returns {Number} the height of each tile
     */
  }, {
    key: "getTileHeight",
    value: function getTileHeight() {
      if (this.isTiled) {
        return this.fileDirectory.TileLength;
      }
      if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {
        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
      }
      return this.getHeight();
    }
  }, {
    key: "getBlockWidth",
    value: function getBlockWidth() {
      return this.getTileWidth();
    }
  }, {
    key: "getBlockHeight",
    value: function getBlockHeight(y) {
      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {
        return this.getTileHeight();
      } else {
        return this.getHeight() - y * this.getTileHeight();
      }
    }

    /**
     * Calculates the number of bytes for each pixel across all samples. Only full
     * bytes are supported, an exception is thrown when this is not the case.
     * @returns {Number} the bytes per pixel
     */
  }, {
    key: "getBytesPerPixel",
    value: function getBytesPerPixel() {
      var bytes = 0;
      for (var i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {
        bytes += this.getSampleByteSize(i);
      }
      return bytes;
    }
  }, {
    key: "getSampleByteSize",
    value: function getSampleByteSize(i) {
      if (i >= this.fileDirectory.BitsPerSample.length) {
        throw new RangeError("Sample index ".concat(i, " is out of range."));
      }
      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);
    }
  }, {
    key: "getReaderForSample",
    value: function getReaderForSample(sampleIndex) {
      var format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
      var bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];
      switch (format) {
        case 1:
          // unsigned integer data
          if (bitsPerSample <= 8) {
            return DataView.prototype.getUint8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getUint16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getUint32;
          }
          break;
        case 2:
          // twos complement signed integer data
          if (bitsPerSample <= 8) {
            return DataView.prototype.getInt8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getInt16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getInt32;
          }
          break;
        case 3:
          switch (bitsPerSample) {
            case 16:
              return function (offset, littleEndian) {
                return (0, _float.getFloat16)(this, offset, littleEndian);
              };
            case 32:
              return DataView.prototype.getFloat32;
            case 64:
              return DataView.prototype.getFloat64;
            default:
              break;
          }
          break;
        default:
          break;
      }
      throw Error('Unsupported data format/bitsPerSample');
    }
  }, {
    key: "getSampleFormat",
    value: function getSampleFormat() {
      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    }
  }, {
    key: "getBitsPerSample",
    value: function getBitsPerSample() {
      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.fileDirectory.BitsPerSample[sampleIndex];
    }
  }, {
    key: "getArrayForSample",
    value: function getArrayForSample(sampleIndex, size) {
      var format = this.getSampleFormat(sampleIndex);
      var bitsPerSample = this.getBitsPerSample(sampleIndex);
      return arrayForType(format, bitsPerSample, size);
    }

    /**
     * Returns the decoded strip or tile.
     * @param {Number} x the strip or tile x-offset
     * @param {Number} y the tile y-offset (0 for stripped images)
     * @param {Number} sample the sample to get for separated samples
     * @param {import("./geotiff").Pool|import("./geotiff").BaseDecoder} poolOrDecoder the decoder or decoder pool
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise.<ArrayBuffer>}
     */
  }, {
    key: "getTileOrStrip",
    value: (function () {
      var _getTileOrStrip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y, sample, poolOrDecoder, signal) {
        var _this = this;
        var numTilesPerRow, numTilesPerCol, index, tiles, offset, byteCount, slice, request;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
              numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
              tiles = this.tiles;
              if (this.planarConfiguration === 1) {
                index = y * numTilesPerRow + x;
              } else if (this.planarConfiguration === 2) {
                index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;
              }
              if (this.isTiled) {
                offset = this.fileDirectory.TileOffsets[index];
                byteCount = this.fileDirectory.TileByteCounts[index];
              } else {
                offset = this.fileDirectory.StripOffsets[index];
                byteCount = this.fileDirectory.StripByteCounts[index];
              }
              _context2.next = 7;
              return this.source.fetch([{
                offset: offset,
                length: byteCount
              }], signal);
            case 7:
              slice = _context2.sent[0];
              if (tiles === null || !tiles[index]) {
                // resolve each request by potentially applying array normalization
                request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  var data, sampleFormat, bitsPerSample;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return poolOrDecoder.decode(_this.fileDirectory, slice);
                      case 2:
                        data = _context.sent;
                        sampleFormat = _this.getSampleFormat();
                        bitsPerSample = _this.getBitsPerSample();
                        if (needsNormalization(sampleFormat, bitsPerSample)) {
                          data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));
                        }
                        return _context.abrupt("return", data);
                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }))();

                // set the cache
                if (tiles !== null) {
                  tiles[index] = request;
                }
              } else {
                // get from the cache
                request = tiles[index];
              }

              // cache the tile request
              _context2.t0 = x;
              _context2.t1 = y;
              _context2.t2 = sample;
              _context2.next = 14;
              return request;
            case 14:
              _context2.t3 = _context2.sent;
              return _context2.abrupt("return", {
                x: _context2.t0,
                y: _context2.t1,
                sample: _context2.t2,
                data: _context2.t3
              });
            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getTileOrStrip(_x, _x2, _x3, _x4, _x5) {
        return _getTileOrStrip.apply(this, arguments);
      }
      return getTileOrStrip;
    }()
    /**
     * Internal read function.
     * @private
     * @param {Array} imageWindow The image window in pixel coordinates
     * @param {Array} samples The selected samples (0-based indices)
     * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into
     * @param {Boolean} interleave Whether or not to write in an interleaved manner
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {number} width the width of window to be read into
     * @param {number} height the height of window to be read into
     * @param {number} resampleMethod the resampling method to be used when interpolating
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise<ReadRasterResult>}
     */
    )
  }, {
    key: "_readRaster",
    value: (function () {
      var _readRaster2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
        var _this2 = this;
        var tileWidth, tileHeight, imageWidth, imageHeight, minXTile, maxXTile, minYTile, maxYTile, windowWidth, bytesPerPixel, srcSampleOffsets, sampleReaders, i, promises, littleEndian, yTile, xTile, getPromise, _loop, sampleIndex, resampled;
        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              tileWidth = this.getTileWidth();
              tileHeight = this.getTileHeight();
              imageWidth = this.getWidth();
              imageHeight = this.getHeight();
              minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
              maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));
              minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
              maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));
              windowWidth = imageWindow[2] - imageWindow[0];
              bytesPerPixel = this.getBytesPerPixel();
              srcSampleOffsets = [];
              sampleReaders = [];
              for (i = 0; i < samples.length; ++i) {
                if (this.planarConfiguration === 1) {
                  srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);
                } else {
                  srcSampleOffsets.push(0);
                }
                sampleReaders.push(this.getReaderForSample(samples[i]));
              }
              promises = [];
              littleEndian = this.littleEndian;
              yTile = minYTile;
            case 16:
              if (!(yTile < maxYTile)) {
                _context4.next = 34;
                break;
              }
              xTile = minXTile;
            case 18:
              if (!(xTile < maxXTile)) {
                _context4.next = 31;
                break;
              }
              getPromise = void 0;
              if (this.planarConfiguration === 1) {
                getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);
              }
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var si, sample, promise;
                return _regeneratorRuntime().wrap(function _loop$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      si = sampleIndex;
                      sample = samples[sampleIndex];
                      if (_this2.planarConfiguration === 2) {
                        bytesPerPixel = _this2.getSampleByteSize(sample);
                        getPromise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);
                      }
                      promise = getPromise.then(function (tile) {
                        var buffer = tile.data;
                        var dataView = new DataView(buffer);
                        var blockHeight = _this2.getBlockHeight(tile.y);
                        var firstLine = tile.y * tileHeight;
                        var firstCol = tile.x * tileWidth;
                        var lastLine = firstLine + blockHeight;
                        var lastCol = (tile.x + 1) * tileWidth;
                        var reader = sampleReaders[si];
                        var ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);
                        var xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);
                        for (var y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {
                          for (var x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {
                            var pixelOffset = (y * tileWidth + x) * bytesPerPixel;
                            var value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);
                            var windowCoordinate = void 0;
                            if (interleave) {
                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;
                              valueArrays[windowCoordinate] = value;
                            } else {
                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];
                              valueArrays[si][windowCoordinate] = value;
                            }
                          }
                        }
                      });
                      promises.push(promise);
                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }, _loop);
              });
              sampleIndex = 0;
            case 23:
              if (!(sampleIndex < samples.length)) {
                _context4.next = 28;
                break;
              }
              return _context4.delegateYield(_loop(), "t0", 25);
            case 25:
              ++sampleIndex;
              _context4.next = 23;
              break;
            case 28:
              ++xTile;
              _context4.next = 18;
              break;
            case 31:
              ++yTile;
              _context4.next = 16;
              break;
            case 34:
              _context4.next = 36;
              return Promise.all(promises);
            case 36:
              if (!(width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height)) {
                _context4.next = 41;
                break;
              }
              if (interleave) {
                resampled = (0, _resample.resampleInterleaved)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
              } else {
                resampled = (0, _resample.resample)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
              }
              resampled.width = width;
              resampled.height = height;
              return _context4.abrupt("return", resampled);
            case 41:
              valueArrays.width = width || imageWindow[2] - imageWindow[0];
              valueArrays.height = height || imageWindow[3] - imageWindow[1];
              return _context4.abrupt("return", valueArrays);
            case 44:
            case "end":
              return _context4.stop();
          }
        }, _callee3, this);
      }));
      function _readRaster(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {
        return _readRaster2.apply(this, arguments);
      }
      return _readRaster;
    }()
    /**
     * Reads raster data from the image. This function reads all selected samples
     * into separate arrays of the correct type for that sample or into a single
     * combined array when `interleave` is set. When provided, only a subset
     * of the raster is read for each sample.
     *
     * @param {ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise
     */
    )
  }, {
    key: "readRasters",
    value: (function () {
      var _readRasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var _ref2,
          wnd,
          _ref2$samples,
          samples,
          interleave,
          _ref2$pool,
          pool,
          width,
          height,
          resampleMethod,
          fillValue,
          signal,
          imageWindow,
          imageWindowWidth,
          imageWindowHeight,
          numPixels,
          samplesPerPixel,
          i,
          _i,
          valueArrays,
          format,
          bitsPerSample,
          _i2,
          valueArray,
          poolOrDecoder,
          result,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _ref2 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, wnd = _ref2.window, _ref2$samples = _ref2.samples, samples = _ref2$samples === void 0 ? [] : _ref2$samples, interleave = _ref2.interleave, _ref2$pool = _ref2.pool, pool = _ref2$pool === void 0 ? null : _ref2$pool, width = _ref2.width, height = _ref2.height, resampleMethod = _ref2.resampleMethod, fillValue = _ref2.fillValue, signal = _ref2.signal;
              imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters
              if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {
                _context5.next = 4;
                break;
              }
              throw new Error('Invalid subsets');
            case 4:
              imageWindowWidth = imageWindow[2] - imageWindow[0];
              imageWindowHeight = imageWindow[3] - imageWindow[1];
              numPixels = imageWindowWidth * imageWindowHeight;
              samplesPerPixel = this.getSamplesPerPixel();
              if (!(!samples || !samples.length)) {
                _context5.next = 12;
                break;
              }
              for (i = 0; i < samplesPerPixel; ++i) {
                samples.push(i);
              }
              _context5.next = 19;
              break;
            case 12:
              _i = 0;
            case 13:
              if (!(_i < samples.length)) {
                _context5.next = 19;
                break;
              }
              if (!(samples[_i] >= samplesPerPixel)) {
                _context5.next = 16;
                break;
              }
              return _context5.abrupt("return", Promise.reject(new RangeError("Invalid sample index '".concat(samples[_i], "'."))));
            case 16:
              ++_i;
              _context5.next = 13;
              break;
            case 19:
              if (interleave) {
                format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
                bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
                valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);
                if (fillValue) {
                  valueArrays.fill(fillValue);
                }
              } else {
                valueArrays = [];
                for (_i2 = 0; _i2 < samples.length; ++_i2) {
                  valueArray = this.getArrayForSample(samples[_i2], numPixels);
                  if (Array.isArray(fillValue) && _i2 < fillValue.length) {
                    valueArray.fill(fillValue[_i2]);
                  } else if (fillValue && !Array.isArray(fillValue)) {
                    valueArray.fill(fillValue);
                  }
                  valueArrays.push(valueArray);
                }
              }
              _context5.t0 = pool;
              if (_context5.t0) {
                _context5.next = 25;
                break;
              }
              _context5.next = 24;
              return (0, _index.getDecoder)(this.fileDirectory);
            case 24:
              _context5.t0 = _context5.sent;
            case 25:
              poolOrDecoder = _context5.t0;
              _context5.next = 28;
              return this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);
            case 28:
              result = _context5.sent;
              return _context5.abrupt("return", result);
            case 30:
            case "end":
              return _context5.stop();
          }
        }, _callee4, this);
      }));
      function readRasters() {
        return _readRasters.apply(this, arguments);
      }
      return readRasters;
    }()
    /**
     * Reads raster data from the image as RGB. The result is always an
     * interleaved typed array.
     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
     * When no other method is applicable, the first sample is used to produce a
     * grayscale image.
     * When provided, only a subset of the raster is read for each sample.
     *
     * @param {Object} [options] optional parameters
     * @param {Array<number>} [options.window] the subset to read data from in pixels.
     * @param {boolean} [options.interleave=true] whether the data shall be read
     *                                             in one single array or separate
     *                                             arrays.
     * @param {import("./geotiff").Pool} [options.pool=null] The optional decoder pool to use.
     * @param {number} [options.width] The desired width of the output. When the width is no the
     *                                 same as the images, resampling will be performed.
     * @param {number} [options.height] The desired height of the output. When the width is no the
     *                                  same as the images, resampling will be performed.
     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.
     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
     *                                       to be aborted
     * @returns {Promise<ReadRasterResult>} the RGB array as a Promise
     */
    )
  }, {
    key: "readRGB",
    value: (function () {
      var _readRGB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _ref3,
          window,
          _ref3$interleave,
          interleave,
          _ref3$pool,
          pool,
          width,
          height,
          resampleMethod,
          _ref3$enableAlpha,
          enableAlpha,
          signal,
          imageWindow,
          pi,
          s,
          i,
          samples,
          subOptions,
          fileDirectory,
          raster,
          max,
          data,
          red,
          green,
          blue,
          _i3,
          j,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _ref3 = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {}, window = _ref3.window, _ref3$interleave = _ref3.interleave, interleave = _ref3$interleave === void 0 ? true : _ref3$interleave, _ref3$pool = _ref3.pool, pool = _ref3$pool === void 0 ? null : _ref3$pool, width = _ref3.width, height = _ref3.height, resampleMethod = _ref3.resampleMethod, _ref3$enableAlpha = _ref3.enableAlpha, enableAlpha = _ref3$enableAlpha === void 0 ? false : _ref3$enableAlpha, signal = _ref3.signal;
              imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters
              if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {
                _context6.next = 4;
                break;
              }
              throw new Error('Invalid subsets');
            case 4:
              pi = this.fileDirectory.PhotometricInterpretation;
              if (!(pi === _globals.photometricInterpretations.RGB)) {
                _context6.next = 9;
                break;
              }
              s = [0, 1, 2];
              if (!(this.fileDirectory.ExtraSamples === _globals.ExtraSamplesValues.Unspecified) && enableAlpha) {
                s = [];
                for (i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {
                  s.push(i);
                }
              }
              return _context6.abrupt("return", this.readRasters({
                window: window,
                interleave: interleave,
                samples: s,
                pool: pool,
                width: width,
                height: height,
                resampleMethod: resampleMethod,
                signal: signal
              }));
            case 9:
              _context6.t0 = pi;
              _context6.next = _context6.t0 === _globals.photometricInterpretations.WhiteIsZero ? 12 : _context6.t0 === _globals.photometricInterpretations.BlackIsZero ? 12 : _context6.t0 === _globals.photometricInterpretations.Palette ? 12 : _context6.t0 === _globals.photometricInterpretations.CMYK ? 14 : _context6.t0 === _globals.photometricInterpretations.YCbCr ? 16 : _context6.t0 === _globals.photometricInterpretations.CIELab ? 16 : 18;
              break;
            case 12:
              samples = [0];
              return _context6.abrupt("break", 19);
            case 14:
              samples = [0, 1, 2, 3];
              return _context6.abrupt("break", 19);
            case 16:
              samples = [0, 1, 2];
              return _context6.abrupt("break", 19);
            case 18:
              throw new Error('Invalid or unsupported photometric interpretation.');
            case 19:
              subOptions = {
                window: imageWindow,
                interleave: true,
                samples: samples,
                pool: pool,
                width: width,
                height: height,
                resampleMethod: resampleMethod,
                signal: signal
              };
              fileDirectory = this.fileDirectory;
              _context6.next = 23;
              return this.readRasters(subOptions);
            case 23:
              raster = _context6.sent;
              max = Math.pow(2, this.fileDirectory.BitsPerSample[0]);
              _context6.t1 = pi;
              _context6.next = _context6.t1 === _globals.photometricInterpretations.WhiteIsZero ? 28 : _context6.t1 === _globals.photometricInterpretations.BlackIsZero ? 30 : _context6.t1 === _globals.photometricInterpretations.Palette ? 32 : _context6.t1 === _globals.photometricInterpretations.CMYK ? 34 : _context6.t1 === _globals.photometricInterpretations.YCbCr ? 36 : _context6.t1 === _globals.photometricInterpretations.CIELab ? 38 : 40;
              break;
            case 28:
              data = (0, _rgb.fromWhiteIsZero)(raster, max);
              return _context6.abrupt("break", 41);
            case 30:
              data = (0, _rgb.fromBlackIsZero)(raster, max);
              return _context6.abrupt("break", 41);
            case 32:
              data = (0, _rgb.fromPalette)(raster, fileDirectory.ColorMap);
              return _context6.abrupt("break", 41);
            case 34:
              data = (0, _rgb.fromCMYK)(raster);
              return _context6.abrupt("break", 41);
            case 36:
              data = (0, _rgb.fromYCbCr)(raster);
              return _context6.abrupt("break", 41);
            case 38:
              data = (0, _rgb.fromCIELab)(raster);
              return _context6.abrupt("break", 41);
            case 40:
              throw new Error('Unsupported photometric interpretation.');
            case 41:
              // if non-interleaved data is requested, we must split the channels
              // into their respective arrays
              if (!interleave) {
                red = new Uint8Array(data.length / 3);
                green = new Uint8Array(data.length / 3);
                blue = new Uint8Array(data.length / 3);
                for (_i3 = 0, j = 0; _i3 < data.length; _i3 += 3, ++j) {
                  red[j] = data[_i3];
                  green[j] = data[_i3 + 1];
                  blue[j] = data[_i3 + 2];
                }
                data = [red, green, blue];
              }
              data.width = raster.width;
              data.height = raster.height;
              return _context6.abrupt("return", data);
            case 45:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function readRGB() {
        return _readRGB.apply(this, arguments);
      }
      return readRGB;
    }()
    /**
     * Returns an array of tiepoints.
     * @returns {Object[]}
     */
    )
  }, {
    key: "getTiePoints",
    value: function getTiePoints() {
      if (!this.fileDirectory.ModelTiepoint) {
        return [];
      }
      var tiePoints = [];
      for (var i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {
        tiePoints.push({
          i: this.fileDirectory.ModelTiepoint[i],
          j: this.fileDirectory.ModelTiepoint[i + 1],
          k: this.fileDirectory.ModelTiepoint[i + 2],
          x: this.fileDirectory.ModelTiepoint[i + 3],
          y: this.fileDirectory.ModelTiepoint[i + 4],
          z: this.fileDirectory.ModelTiepoint[i + 5]
        });
      }
      return tiePoints;
    }

    /**
     * Returns the parsed GDAL metadata items.
     *
     * If sample is passed to null, dataset-level metadata will be returned.
     * Otherwise only metadata specific to the provided sample will be returned.
     *
     * @param {number} [sample=null] The sample index.
     * @returns {Object}
     */
  }, {
    key: "getGDALMetadata",
    value: function getGDALMetadata() {
      var sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var metadata = {};
      if (!this.fileDirectory.GDAL_METADATA) {
        return null;
      }
      var string = this.fileDirectory.GDAL_METADATA;
      var items = (0, _findTagsByName.default)(string, 'Item');
      if (sample === null) {
        items = items.filter(function (item) {
          return (0, _getAttribute.default)(item, 'sample') === undefined;
        });
      } else {
        items = items.filter(function (item) {
          return Number((0, _getAttribute.default)(item, 'sample')) === sample;
        });
      }
      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        metadata[(0, _getAttribute.default)(item, 'name')] = item.inner;
      }
      return metadata;
    }

    /**
     * Returns the GDAL nodata value
     * @returns {number|null}
     */
  }, {
    key: "getGDALNoData",
    value: function getGDALNoData() {
      if (!this.fileDirectory.GDAL_NODATA) {
        return null;
      }
      var string = this.fileDirectory.GDAL_NODATA;
      return Number(string.substring(0, string.length - 1));
    }

    /**
     * Returns the image origin as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @returns {Array<number>} The origin as a vector
     */
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      var tiePoints = this.fileDirectory.ModelTiepoint;
      var modelTransformation = this.fileDirectory.ModelTransformation;
      if (tiePoints && tiePoints.length === 6) {
        return [tiePoints[3], tiePoints[4], tiePoints[5]];
      }
      if (modelTransformation) {
        return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];
      }
      throw new Error('The image does not have an affine transformation.');
    }

    /**
     * Returns the image resolution as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
     *                                             in cases when the current image does not have the
     *                                             required tags on its own.
     * @returns {Array<number>} The resolution as a vector
     */
  }, {
    key: "getResolution",
    value: function getResolution() {
      var referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modelPixelScale = this.fileDirectory.ModelPixelScale;
      var modelTransformation = this.fileDirectory.ModelTransformation;
      if (modelPixelScale) {
        return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];
      }
      if (modelTransformation) {
        return [modelTransformation[0], -modelTransformation[5], modelTransformation[10]];
      }
      if (referenceImage) {
        var _referenceImage$getRe = referenceImage.getResolution(),
          _referenceImage$getRe2 = _slicedToArray(_referenceImage$getRe, 3),
          refResX = _referenceImage$getRe2[0],
          refResY = _referenceImage$getRe2[1],
          refResZ = _referenceImage$getRe2[2];
        return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];
      }
      throw new Error('The image does not have an affine transformation.');
    }

    /**
     * Returns whether or not the pixels of the image depict an area (or point).
     * @returns {Boolean} Whether the pixels are a point
     */
  }, {
    key: "pixelIsArea",
    value: function pixelIsArea() {
      return this.geoKeys.GTRasterTypeGeoKey === 1;
    }

    /**
     * Returns the image bounding box as an array of 4 values: min-x, min-y,
     * max-x and max-y. When the image has no affine transformation, then an
     * exception is thrown.
     * @returns {Array<number>} The bounding box
     */
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox() {
      var height = this.getHeight();
      var width = this.getWidth();
      if (this.fileDirectory.ModelTransformation) {
        // eslint-disable-next-line no-unused-vars
        var _this$fileDirectory$M = _slicedToArray(this.fileDirectory.ModelTransformation, 8),
          a = _this$fileDirectory$M[0],
          b = _this$fileDirectory$M[1],
          c = _this$fileDirectory$M[2],
          d = _this$fileDirectory$M[3],
          e = _this$fileDirectory$M[4],
          f = _this$fileDirectory$M[5],
          g = _this$fileDirectory$M[6],
          h = _this$fileDirectory$M[7];
        var corners = [[0, 0], [0, height], [width, 0], [width, height]];
        var projected = corners.map(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
            I = _ref5[0],
            J = _ref5[1];
          return [d + a * I + b * J, h + e * I + f * J];
        });
        var xs = projected.map(function (pt) {
          return pt[0];
        });
        var ys = projected.map(function (pt) {
          return pt[1];
        });
        return [Math.min.apply(Math, _toConsumableArray(xs)), Math.min.apply(Math, _toConsumableArray(ys)), Math.max.apply(Math, _toConsumableArray(xs)), Math.max.apply(Math, _toConsumableArray(ys))];
      } else {
        var origin = this.getOrigin();
        var resolution = this.getResolution();
        var x1 = origin[0];
        var y1 = origin[1];
        var x2 = x1 + resolution[0] * this.getWidth();
        var y2 = y1 + resolution[1] * this.getHeight();
        return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
      }
    }
  }]);
  return GeoTIFFImage;
}();
var _default = exports.default = GeoTIFFImage;
},{"@petamoriken/float16":"node_modules/@petamoriken/float16/browser/float16.js","xml-utils/get-attribute.js":"node_modules/xml-utils/get-attribute.js","xml-utils/find-tags-by-name.js":"node_modules/xml-utils/find-tags-by-name.js","./globals.js":"node_modules/geotiff/dist-module/globals.js","./rgb.js":"node_modules/geotiff/dist-module/rgb.js","./compression/index.js":"node_modules/geotiff/dist-module/compression/index.js","./resample.js":"node_modules/geotiff/dist-module/resample.js"}],"node_modules/geotiff/dist-module/dataview64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _float = require("@petamoriken/float16");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var DataView64 = exports.default = /*#__PURE__*/function () {
  function DataView64(arrayBuffer) {
    _classCallCheck(this, DataView64);
    this._dataView = new DataView(arrayBuffer);
  }
  _createClass(DataView64, [{
    key: "buffer",
    get: function get() {
      return this._dataView.buffer;
    }
  }, {
    key: "getUint64",
    value: function getUint64(offset, littleEndian) {
      var left = this.getUint32(offset, littleEndian);
      var right = this.getUint32(offset + 4, littleEndian);
      var combined;
      if (littleEndian) {
        combined = left + Math.pow(2, 32) * right;
        if (!Number.isSafeInteger(combined)) {
          throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
        }
        return combined;
      }
      combined = Math.pow(2, 32) * left + right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
      }
      return combined;
    }

    // adapted from https://stackoverflow.com/a/55338384/8060591
  }, {
    key: "getInt64",
    value: function getInt64(offset, littleEndian) {
      var value = 0;
      var isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;
      var carrying = true;
      for (var i = 0; i < 8; i++) {
        var byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));
        if (isNegative) {
          if (carrying) {
            if (byte !== 0x00) {
              byte = ~(byte - 1) & 0xff;
              carrying = false;
            }
          } else {
            byte = ~byte & 0xff;
          }
        }
        value += byte * Math.pow(256, i);
      }
      if (isNegative) {
        value = -value;
      }
      return value;
    }
  }, {
    key: "getUint8",
    value: function getUint8(offset, littleEndian) {
      return this._dataView.getUint8(offset, littleEndian);
    }
  }, {
    key: "getInt8",
    value: function getInt8(offset, littleEndian) {
      return this._dataView.getInt8(offset, littleEndian);
    }
  }, {
    key: "getUint16",
    value: function getUint16(offset, littleEndian) {
      return this._dataView.getUint16(offset, littleEndian);
    }
  }, {
    key: "getInt16",
    value: function getInt16(offset, littleEndian) {
      return this._dataView.getInt16(offset, littleEndian);
    }
  }, {
    key: "getUint32",
    value: function getUint32(offset, littleEndian) {
      return this._dataView.getUint32(offset, littleEndian);
    }
  }, {
    key: "getInt32",
    value: function getInt32(offset, littleEndian) {
      return this._dataView.getInt32(offset, littleEndian);
    }
  }, {
    key: "getFloat16",
    value: function getFloat16(offset, littleEndian) {
      return (0, _float.getFloat16)(this._dataView, offset, littleEndian);
    }
  }, {
    key: "getFloat32",
    value: function getFloat32(offset, littleEndian) {
      return this._dataView.getFloat32(offset, littleEndian);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(offset, littleEndian) {
      return this._dataView.getFloat64(offset, littleEndian);
    }
  }]);
  return DataView64;
}();
},{"@petamoriken/float16":"node_modules/@petamoriken/float16/browser/float16.js"}],"node_modules/geotiff/dist-module/dataslice.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var DataSlice = exports.default = /*#__PURE__*/function () {
  function DataSlice(arrayBuffer, sliceOffset, littleEndian, bigTiff) {
    _classCallCheck(this, DataSlice);
    this._dataView = new DataView(arrayBuffer);
    this._sliceOffset = sliceOffset;
    this._littleEndian = littleEndian;
    this._bigTiff = bigTiff;
  }
  _createClass(DataSlice, [{
    key: "sliceOffset",
    get: function get() {
      return this._sliceOffset;
    }
  }, {
    key: "sliceTop",
    get: function get() {
      return this._sliceOffset + this.buffer.byteLength;
    }
  }, {
    key: "littleEndian",
    get: function get() {
      return this._littleEndian;
    }
  }, {
    key: "bigTiff",
    get: function get() {
      return this._bigTiff;
    }
  }, {
    key: "buffer",
    get: function get() {
      return this._dataView.buffer;
    }
  }, {
    key: "covers",
    value: function covers(offset, length) {
      return this.sliceOffset <= offset && this.sliceTop >= offset + length;
    }
  }, {
    key: "readUint8",
    value: function readUint8(offset) {
      return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt8",
    value: function readInt8(offset) {
      return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint16",
    value: function readUint16(offset) {
      return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt16",
    value: function readInt16(offset) {
      return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint32",
    value: function readUint32(offset) {
      return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt32",
    value: function readInt32(offset) {
      return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readFloat32",
    value: function readFloat32(offset) {
      return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readFloat64",
    value: function readFloat64(offset) {
      return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint64",
    value: function readUint64(offset) {
      var left = this.readUint32(offset);
      var right = this.readUint32(offset + 4);
      var combined;
      if (this._littleEndian) {
        combined = left + Math.pow(2, 32) * right;
        if (!Number.isSafeInteger(combined)) {
          throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
        }
        return combined;
      }
      combined = Math.pow(2, 32) * left + right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
      }
      return combined;
    }

    // adapted from https://stackoverflow.com/a/55338384/8060591
  }, {
    key: "readInt64",
    value: function readInt64(offset) {
      var value = 0;
      var isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) > 0;
      var carrying = true;
      for (var i = 0; i < 8; i++) {
        var byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));
        if (isNegative) {
          if (carrying) {
            if (byte !== 0x00) {
              byte = ~(byte - 1) & 0xff;
              carrying = false;
            }
          } else {
            byte = ~byte & 0xff;
          }
        }
        value += byte * Math.pow(256, i);
      }
      if (isNegative) {
        value = -value;
      }
      return value;
    }
  }, {
    key: "readOffset",
    value: function readOffset(offset) {
      if (this._bigTiff) {
        return this.readUint64(offset);
      }
      return this.readUint32(offset);
    }
  }]);
  return DataSlice;
}();
},{}],"node_modules/geotiff/dist-module/pool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = require("./compression/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;

/**
 * @module pool
 */

/**
 * Pool for workers to decode chunks of the images.
 */
var Pool = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs
   *                      available. When this parameter is `null` or 0, then the
   *                      decoding will be done in the main thread.
   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.
   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`
   * function is expected to return a `Worker` compatible with Web Workers. For code that
   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.
   *
   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:
   * ```js
   * import { addDecoder, getDecoder } from 'geotiff';
   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));
   * self.addEventListener('message', async (e) => {
   *   const { id, fileDirectory, buffer } = e.data;
   *   const decoder = await getDecoder(fileDirectory);
   *   const decoded = await decoder.decode(fileDirectory, buffer);
   *   self.postMessage({ decoded, id }, [decoded]);
   * });
   * ```
   * The way the above code is built into a worker by the `createWorker()` function
   * depends on the used bundler. For most bundlers, something like this will work:
   * ```js
   * function createWorker() {
   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));
   * }
   * ```
   */
  function Pool() {
    var _this = this;
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPoolSize;
    var createWorker = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Pool);
    this.workers = null;
    this._awaitingDecoder = null;
    this.size = size;
    this.messageId = 0;
    if (size) {
      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(function (resolve) {
        require("_bundle_loader")(require.resolve('./worker/decoder.js')).then(function (module) {
          resolve(module.create);
        });
      });
      this._awaitingDecoder.then(function (create) {
        _this._awaitingDecoder = null;
        _this.workers = [];
        for (var i = 0; i < size; i++) {
          _this.workers.push({
            worker: create(),
            idle: true
          });
        }
      });
    }
  }

  /**
   * Decode the given block of bytes with the set compression method.
   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`
   */
  _createClass(Pool, [{
    key: "decode",
    value: (function () {
      var _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileDirectory, buffer) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this._awaitingDecoder) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return this._awaitingDecoder;
            case 3:
              return _context.abrupt("return", this.size === 0 ? (0, _index.getDecoder)(fileDirectory).then(function (decoder) {
                return decoder.decode(fileDirectory, buffer);
              }) : new Promise(function (resolve) {
                var worker = _this2.workers.find(function (candidate) {
                  return candidate.idle;
                }) || _this2.workers[Math.floor(Math.random() * _this2.size)];
                worker.idle = false;
                var id = _this2.messageId++;
                var onMessage = function onMessage(e) {
                  if (e.data.id === id) {
                    worker.idle = true;
                    resolve(e.data.decoded);
                    worker.worker.removeEventListener('message', onMessage);
                  }
                };
                worker.worker.addEventListener('message', onMessage);
                worker.worker.postMessage({
                  fileDirectory: fileDirectory,
                  buffer: buffer,
                  id: id
                }, [buffer]);
              }));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function decode(_x, _x2) {
        return _decode.apply(this, arguments);
      }
      return decode;
    }())
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.workers) {
        this.workers.forEach(function (worker) {
          worker.worker.terminate();
        });
        this.workers = null;
      }
    }
  }]);
  return Pool;
}();
var _default = exports.default = Pool;
},{"./compression/index.js":"node_modules/geotiff/dist-module/compression/index.js","_bundle_loader":"node_modules/parcel-bundler/src/builtins/bundle-loader.js","./worker/decoder.js":[["decoder.9c21909f.js","node_modules/geotiff/dist-module/worker/decoder.js"],"decoder.9c21909f.js.map","node_modules/geotiff/dist-module/worker/decoder.js"]}],"node_modules/geotiff/dist-module/source/httputils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseByteRanges = parseByteRanges;
exports.parseContentRange = parseContentRange;
exports.parseContentType = parseContentType;
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var CRLFCRLF = '\r\n\r\n';

/*
 * Shim for 'Object.fromEntries'
 */
function itemsToObject(items) {
  if (typeof Object.fromEntries !== 'undefined') {
    return Object.fromEntries(items);
  }
  var obj = {};
  var _iterator = _createForOfIteratorHelper(items),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        value = _step$value[1];
      obj[key.toLowerCase()] = value;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return obj;
}

/**
 * Parse HTTP headers from a given string.
 * @param {String} text the text to parse the headers from
 * @returns {Object} the parsed headers with lowercase keys
 */
function parseHeaders(text) {
  var items = text.split('\r\n').map(function (line) {
    var kv = line.split(':').map(function (str) {
      return str.trim();
    });
    kv[0] = kv[0].toLowerCase();
    return kv;
  });
  return itemsToObject(items);
}

/**
 * Parse a 'Content-Type' header value to the content-type and parameters
 * @param {String} rawContentType the raw string to parse from
 * @returns {Object} the parsed content type with the fields: type and params
 */
function parseContentType(rawContentType) {
  var _rawContentType$split = rawContentType.split(';').map(function (s) {
      return s.trim();
    }),
    _rawContentType$split2 = _toArray(_rawContentType$split),
    type = _rawContentType$split2[0],
    rawParams = _rawContentType$split2.slice(1);
  var paramsItems = rawParams.map(function (param) {
    return param.split('=');
  });
  return {
    type: type,
    params: itemsToObject(paramsItems)
  };
}

/**
 * Parse a 'Content-Range' header value to its start, end, and total parts
 * @param {String} rawContentRange the raw string to parse from
 * @returns {Object} the parsed parts
 */
function parseContentRange(rawContentRange) {
  var start;
  var end;
  var total;
  if (rawContentRange) {
    var _rawContentRange$matc = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);
    var _rawContentRange$matc2 = _slicedToArray(_rawContentRange$matc, 4);
    start = _rawContentRange$matc2[1];
    end = _rawContentRange$matc2[2];
    total = _rawContentRange$matc2[3];
    start = parseInt(start, 10);
    end = parseInt(end, 10);
    total = parseInt(total, 10);
  }
  return {
    start: start,
    end: end,
    total: total
  };
}

/**
 * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.
 * Each item in the list has the following properties:
 * - headers: the HTTP headers
 * - data: the sliced ArrayBuffer for that specific part
 * - offset: the offset of the byterange within its originating file
 * - length: the length of the byterange
 * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split
 * @param {String} boundary the boundary string used to split the sections
 * @returns {Object[]} the parsed byteranges
 */
function parseByteRanges(responseArrayBuffer, boundary) {
  var offset = null;
  var decoder = new TextDecoder('ascii');
  var out = [];
  var startBoundary = "--".concat(boundary);
  var endBoundary = "".concat(startBoundary, "--");

  // search for the initial boundary, may be offset by some bytes
  // TODO: more efficient to check for `--` in bytes directly
  for (var i = 0; i < 10; ++i) {
    var text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));
    if (text === startBoundary) {
      offset = i;
    }
  }
  if (offset === null) {
    throw new Error('Could not find initial boundary');
  }
  while (offset < responseArrayBuffer.byteLength) {
    var _text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));

    // break if we arrived at the end
    if (_text.length === 0 || _text.startsWith(endBoundary)) {
      break;
    }

    // assert that we are actually dealing with a byterange and are at the correct offset
    if (!_text.startsWith(startBoundary)) {
      throw new Error('Part does not start with boundary');
    }

    // get a substring from where we read the headers
    var innerText = _text.substr(startBoundary.length + 2);
    if (innerText.length === 0) {
      break;
    }

    // find the double linebreak that denotes the end of the headers
    var endOfHeaders = innerText.indexOf(CRLFCRLF);

    // parse the headers to get the content range size
    var headers = parseHeaders(innerText.substr(0, endOfHeaders));
    var _parseContentRange = parseContentRange(headers['content-range']),
      start = _parseContentRange.start,
      end = _parseContentRange.end,
      total = _parseContentRange.total;

    // calculate the length of the slice and the next offset
    var startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;
    var length = parseInt(end, 10) + 1 - parseInt(start, 10);
    out.push({
      headers: headers,
      data: responseArrayBuffer.slice(startOfData, startOfData + length),
      offset: start,
      length: length,
      fileSize: total
    });
    offset = startOfData + length + 4;
  }
  return out;
}
},{}],"node_modules/geotiff/dist-module/source/basesource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseSource = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @typedef Slice
 * @property {number} offset
 * @property {number} length
 */
var BaseSource = exports.BaseSource = /*#__PURE__*/function () {
  function BaseSource() {
    _classCallCheck(this, BaseSource);
  }
  _createClass(BaseSource, [{
    key: "fetch",
    value: (
    /**
     *
     * @param {Slice[]} slices
     * @returns {ArrayBuffer[]}
     */
    function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slices) {
        var _this = this;
        var signal,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              signal = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
              return _context.abrupt("return", Promise.all(slices.map(function (slice) {
                return _this.fetchSlice(slice, signal);
              })));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function fetch(_x) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
    /**
     *
     * @param {Slice} slice
     * @returns {ArrayBuffer}
     */
    )
  }, {
    key: "fetchSlice",
    value: (function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(slice) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error("fetching of slice ".concat(slice, " not possible, not implemented"));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function fetchSlice(_x2) {
        return _fetchSlice.apply(this, arguments);
      }
      return fetchSlice;
    }()
    /**
     * Returns the filesize if already determined and null otherwise
     */
    )
  }, {
    key: "fileSize",
    get: function get() {
      return null;
    }
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }]);
  return BaseSource;
}();
},{}],"node_modules/quick-lru/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var QuickLRU = exports.default = /*#__PURE__*/function (_Map, _Symbol$iterator, _Symbol$toStringTag) {
  _inherits(QuickLRU, _Map);
  var _super = _createSuper(QuickLRU);
  function QuickLRU() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, QuickLRU);
    _this = _super.call(this);
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError('`maxSize` must be a number greater than 0');
    }
    if (typeof options.maxAge === 'number' && options.maxAge === 0) {
      throw new TypeError('`maxAge` must be a number greater than 0');
    }

    // TODO: Use private class fields when ESLint supports them.
    _this.maxSize = options.maxSize;
    _this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    _this.onEviction = options.onEviction;
    _this.cache = new Map();
    _this.oldCache = new Map();
    _this._size = 0;
    return _this;
  }

  // TODO: Use private class methods when targeting Node.js 16.
  _createClass(QuickLRU, [{
    key: "_emitEvictions",
    value: function _emitEvictions(cache) {
      if (typeof this.onEviction !== 'function') {
        return;
      }
      var _iterator = _createForOfIteratorHelper(cache),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            key = _step$value[0],
            item = _step$value[1];
          this.onEviction(key, item.value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "_deleteIfExpired",
    value: function _deleteIfExpired(key, item) {
      if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
        if (typeof this.onEviction === 'function') {
          this.onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
  }, {
    key: "_getOrDeleteIfExpired",
    value: function _getOrDeleteIfExpired(key, item) {
      var deleted = this._deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
  }, {
    key: "_getItemValue",
    value: function _getItemValue(key, item) {
      return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
  }, {
    key: "_peek",
    value: function _peek(key, cache) {
      var item = cache.get(key);
      return this._getItemValue(key, item);
    }
  }, {
    key: "_set",
    value: function _set(key, value) {
      this.cache.set(key, value);
      this._size++;
      if (this._size >= this.maxSize) {
        this._size = 0;
        this._emitEvictions(this.oldCache);
        this.oldCache = this.cache;
        this.cache = new Map();
      }
    }
  }, {
    key: "_moveToRecent",
    value: function _moveToRecent(key, item) {
      this.oldCache.delete(key);
      this._set(key, item);
    }
  }, {
    key: "_entriesAscending",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function _entriesAscending() {
      var _iterator2, _step2, item, _item, key, value, deleted, _iterator3, _step3, _item2, _item3, _key, _value, _deleted;
      return _regeneratorRuntime().wrap(function _entriesAscending$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _iterator2 = _createForOfIteratorHelper(this.oldCache);
            _context.prev = 1;
            _iterator2.s();
          case 3:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 13;
              break;
            }
            item = _step2.value;
            _item = _slicedToArray(item, 2), key = _item[0], value = _item[1];
            if (this.cache.has(key)) {
              _context.next = 11;
              break;
            }
            deleted = this._deleteIfExpired(key, value);
            if (!(deleted === false)) {
              _context.next = 11;
              break;
            }
            _context.next = 11;
            return item;
          case 11:
            _context.next = 3;
            break;
          case 13:
            _context.next = 18;
            break;
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](1);
            _iterator2.e(_context.t0);
          case 18:
            _context.prev = 18;
            _iterator2.f();
            return _context.finish(18);
          case 21:
            _iterator3 = _createForOfIteratorHelper(this.cache);
            _context.prev = 22;
            _iterator3.s();
          case 24:
            if ((_step3 = _iterator3.n()).done) {
              _context.next = 33;
              break;
            }
            _item2 = _step3.value;
            _item3 = _slicedToArray(_item2, 2), _key = _item3[0], _value = _item3[1];
            _deleted = this._deleteIfExpired(_key, _value);
            if (!(_deleted === false)) {
              _context.next = 31;
              break;
            }
            _context.next = 31;
            return _item2;
          case 31:
            _context.next = 24;
            break;
          case 33:
            _context.next = 38;
            break;
          case 35:
            _context.prev = 35;
            _context.t1 = _context["catch"](22);
            _iterator3.e(_context.t1);
          case 38:
            _context.prev = 38;
            _iterator3.f();
            return _context.finish(38);
          case 41:
          case "end":
            return _context.stop();
        }
      }, _entriesAscending, this, [[1, 15, 18, 21], [22, 35, 38, 41]]);
    })
  }, {
    key: "get",
    value: function get(key) {
      if (this.cache.has(key)) {
        var item = this.cache.get(key);
        return this._getItemValue(key, item);
      }
      if (this.oldCache.has(key)) {
        var _item4 = this.oldCache.get(key);
        if (this._deleteIfExpired(key, _item4) === false) {
          this._moveToRecent(key, _item4);
          return _item4.value;
        }
      }
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$maxAge = _ref.maxAge,
        maxAge = _ref$maxAge === void 0 ? this.maxAge : _ref$maxAge;
      var expiry = typeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : undefined;
      if (this.cache.has(key)) {
        this.cache.set(key, {
          value: value,
          expiry: expiry
        });
      } else {
        this._set(key, {
          value: value,
          expiry: expiry
        });
      }
      return this;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (this.cache.has(key)) {
        return !this._deleteIfExpired(key, this.cache.get(key));
      }
      if (this.oldCache.has(key)) {
        return !this._deleteIfExpired(key, this.oldCache.get(key));
      }
      return false;
    }
  }, {
    key: "peek",
    value: function peek(key) {
      if (this.cache.has(key)) {
        return this._peek(key, this.cache);
      }
      if (this.oldCache.has(key)) {
        return this._peek(key, this.oldCache);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var deleted = this.cache.delete(key);
      if (deleted) {
        this._size--;
      }
      return this.oldCache.delete(key) || deleted;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
  }, {
    key: "resize",
    value: function resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError('`maxSize` must be a number greater than 0');
      }
      var items = _toConsumableArray(this._entriesAscending());
      var removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.cache = new Map(items);
        this.oldCache = new Map();
        this._size = items.length;
      } else {
        if (removeCount > 0) {
          this._emitEvictions(items.slice(0, removeCount));
        }
        this.oldCache = new Map(items.slice(removeCount));
        this.cache = new Map();
        this._size = 0;
      }
      this.maxSize = newSize;
    }
  }, {
    key: "keys",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function keys() {
      var _iterator4, _step4, _step4$value, key;
      return _regeneratorRuntime().wrap(function keys$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _iterator4 = _createForOfIteratorHelper(this);
            _context2.prev = 1;
            _iterator4.s();
          case 3:
            if ((_step4 = _iterator4.n()).done) {
              _context2.next = 9;
              break;
            }
            _step4$value = _slicedToArray(_step4.value, 1), key = _step4$value[0];
            _context2.next = 7;
            return key;
          case 7:
            _context2.next = 3;
            break;
          case 9:
            _context2.next = 14;
            break;
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](1);
            _iterator4.e(_context2.t0);
          case 14:
            _context2.prev = 14;
            _iterator4.f();
            return _context2.finish(14);
          case 17:
          case "end":
            return _context2.stop();
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "values",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function values() {
      var _iterator5, _step5, _step5$value, value;
      return _regeneratorRuntime().wrap(function values$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _iterator5 = _createForOfIteratorHelper(this);
            _context3.prev = 1;
            _iterator5.s();
          case 3:
            if ((_step5 = _iterator5.n()).done) {
              _context3.next = 9;
              break;
            }
            _step5$value = _slicedToArray(_step5.value, 2), value = _step5$value[1];
            _context3.next = 7;
            return value;
          case 7:
            _context3.next = 3;
            break;
          case 9:
            _context3.next = 14;
            break;
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](1);
            _iterator5.e(_context3.t0);
          case 14:
            _context3.prev = 14;
            _iterator5.f();
            return _context3.finish(14);
          case 17:
          case "end":
            return _context3.stop();
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: _Symbol$iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      var _iterator6, _step6, item, _item5, key, value, deleted, _iterator7, _step7, _item6, _item7, _key2, _value2, _deleted2;
      return _regeneratorRuntime().wrap(function value$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _iterator6 = _createForOfIteratorHelper(this.cache);
            _context4.prev = 1;
            _iterator6.s();
          case 3:
            if ((_step6 = _iterator6.n()).done) {
              _context4.next = 12;
              break;
            }
            item = _step6.value;
            _item5 = _slicedToArray(item, 2), key = _item5[0], value = _item5[1];
            deleted = this._deleteIfExpired(key, value);
            if (!(deleted === false)) {
              _context4.next = 10;
              break;
            }
            _context4.next = 10;
            return [key, value.value];
          case 10:
            _context4.next = 3;
            break;
          case 12:
            _context4.next = 17;
            break;
          case 14:
            _context4.prev = 14;
            _context4.t0 = _context4["catch"](1);
            _iterator6.e(_context4.t0);
          case 17:
            _context4.prev = 17;
            _iterator6.f();
            return _context4.finish(17);
          case 20:
            _iterator7 = _createForOfIteratorHelper(this.oldCache);
            _context4.prev = 21;
            _iterator7.s();
          case 23:
            if ((_step7 = _iterator7.n()).done) {
              _context4.next = 33;
              break;
            }
            _item6 = _step7.value;
            _item7 = _slicedToArray(_item6, 2), _key2 = _item7[0], _value2 = _item7[1];
            if (this.cache.has(_key2)) {
              _context4.next = 31;
              break;
            }
            _deleted2 = this._deleteIfExpired(_key2, _value2);
            if (!(_deleted2 === false)) {
              _context4.next = 31;
              break;
            }
            _context4.next = 31;
            return [_key2, _value2.value];
          case 31:
            _context4.next = 23;
            break;
          case 33:
            _context4.next = 38;
            break;
          case 35:
            _context4.prev = 35;
            _context4.t1 = _context4["catch"](21);
            _iterator7.e(_context4.t1);
          case 38:
            _context4.prev = 38;
            _iterator7.f();
            return _context4.finish(38);
          case 41:
          case "end":
            return _context4.stop();
        }
      }, value, this, [[1, 14, 17, 20], [21, 35, 38, 41]]);
    })
  }, {
    key: "entriesDescending",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function entriesDescending() {
      var items, i, item, _item8, key, value, deleted, _i, _item9, _item10, _key3, _value3, _deleted3;
      return _regeneratorRuntime().wrap(function entriesDescending$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            items = _toConsumableArray(this.cache);
            i = items.length - 1;
          case 2:
            if (!(i >= 0)) {
              _context5.next = 12;
              break;
            }
            item = items[i];
            _item8 = _slicedToArray(item, 2), key = _item8[0], value = _item8[1];
            deleted = this._deleteIfExpired(key, value);
            if (!(deleted === false)) {
              _context5.next = 9;
              break;
            }
            _context5.next = 9;
            return [key, value.value];
          case 9:
            --i;
            _context5.next = 2;
            break;
          case 12:
            items = _toConsumableArray(this.oldCache);
            _i = items.length - 1;
          case 14:
            if (!(_i >= 0)) {
              _context5.next = 25;
              break;
            }
            _item9 = items[_i];
            _item10 = _slicedToArray(_item9, 2), _key3 = _item10[0], _value3 = _item10[1];
            if (this.cache.has(_key3)) {
              _context5.next = 22;
              break;
            }
            _deleted3 = this._deleteIfExpired(_key3, _value3);
            if (!(_deleted3 === false)) {
              _context5.next = 22;
              break;
            }
            _context5.next = 22;
            return [_key3, _value3.value];
          case 22:
            --_i;
            _context5.next = 14;
            break;
          case 25:
          case "end":
            return _context5.stop();
        }
      }, entriesDescending, this);
    })
  }, {
    key: "entriesAscending",
    value: /*#__PURE__*/_regeneratorRuntime().mark(function entriesAscending() {
      var _iterator8, _step8, _step8$value, key, value;
      return _regeneratorRuntime().wrap(function entriesAscending$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _iterator8 = _createForOfIteratorHelper(this._entriesAscending());
            _context6.prev = 1;
            _iterator8.s();
          case 3:
            if ((_step8 = _iterator8.n()).done) {
              _context6.next = 9;
              break;
            }
            _step8$value = _slicedToArray(_step8.value, 2), key = _step8$value[0], value = _step8$value[1];
            _context6.next = 7;
            return [key, value.value];
          case 7:
            _context6.next = 3;
            break;
          case 9:
            _context6.next = 14;
            break;
          case 11:
            _context6.prev = 11;
            _context6.t0 = _context6["catch"](1);
            _iterator8.e(_context6.t0);
          case 14:
            _context6.prev = 14;
            _iterator8.f();
            return _context6.finish(14);
          case 17:
          case "end":
            return _context6.stop();
        }
      }, entriesAscending, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "size",
    get: function get() {
      if (!this._size) {
        return this.oldCache.size;
      }
      var oldCacheSize = 0;
      var _iterator9 = _createForOfIteratorHelper(this.oldCache.keys()),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var key = _step9.value;
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
  }, {
    key: "entries",
    value: function entries() {
      return this.entriesAscending();
    }
  }, {
    key: "forEach",
    value: function forEach(callbackFunction) {
      var thisArgument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      var _iterator10 = _createForOfIteratorHelper(this.entriesAscending()),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 2),
            key = _step10$value[0],
            value = _step10$value[1];
          callbackFunction.call(thisArgument, value, key, this);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return JSON.stringify(_toConsumableArray(this.entriesAscending()));
    }
  }]);
  return QuickLRU;
}( /*#__PURE__*/_wrapNativeSuper(Map), Symbol.iterator, Symbol.toStringTag);
},{}],"node_modules/geotiff/dist-module/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomAggregateError = exports.AggregateError = exports.AbortError = void 0;
exports.assign = assign;
exports.chunk = chunk;
exports.endsWith = endsWith;
exports.forEach = forEach;
exports.invert = invert;
exports.parseContentRange = parseContentRange;
exports.range = range;
exports.times = times;
exports.toArray = toArray;
exports.toArrayRecursively = toArrayRecursively;
exports.wait = wait;
exports.zip = zip;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function assign(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function chunk(iterable, length) {
  var results = [];
  var lengthOfIterable = iterable.length;
  for (var i = 0; i < lengthOfIterable; i += length) {
    var chunked = [];
    for (var ci = i; ci < i + length; ci++) {
      chunked.push(iterable[ci]);
    }
    results.push(chunked);
  }
  return results;
}
function endsWith(string, expectedEnding) {
  if (string.length < expectedEnding.length) {
    return false;
  }
  var actualEnding = string.substr(string.length - expectedEnding.length);
  return actualEnding === expectedEnding;
}
function forEach(iterable, func) {
  var length = iterable.length;
  for (var i = 0; i < length; i++) {
    func(iterable[i], i);
  }
}
function invert(oldObj) {
  var newObj = {};
  for (var key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      var value = oldObj[key];
      newObj[value] = key;
    }
  }
  return newObj;
}
function range(n) {
  var results = [];
  for (var i = 0; i < n; i++) {
    results.push(i);
  }
  return results;
}
function times(numTimes, func) {
  var results = [];
  for (var i = 0; i < numTimes; i++) {
    results.push(func(i));
  }
  return results;
}
function toArray(iterable) {
  var results = [];
  var length = iterable.length;
  for (var i = 0; i < length; i++) {
    results.push(iterable[i]);
  }
  return results;
}
function toArrayRecursively(input) {
  if (input.length) {
    return toArray(input).map(toArrayRecursively);
  }
  return input;
}

// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js
function parseContentRange(headerValue) {
  if (!headerValue) {
    return null;
  }
  if (typeof headerValue !== 'string') {
    throw new Error('invalid argument');
  }
  var parseInt = function parseInt(number) {
    return Number.parseInt(number, 10);
  };

  // Check for presence of unit
  var matches = headerValue.match(/^(\w*) /);
  var unit = matches && matches[1];

  // check for start-end/size header format
  matches = headerValue.match(/(\d+)-(\d+)\/(\d+|\*)/);
  if (matches) {
    return {
      unit: unit,
      first: parseInt(matches[1]),
      last: parseInt(matches[2]),
      length: matches[3] === '*' ? null : parseInt(matches[3])
    };
  }

  // check for size header format
  matches = headerValue.match(/(\d+|\*)/);
  if (matches) {
    return {
      unit: unit,
      first: null,
      last: null,
      length: matches[1] === '*' ? null : parseInt(matches[1])
    };
  }
  return null;
}

/*
 * Promisified wrapper around 'setTimeout' to allow 'await'
 */
function wait(_x) {
  return _wait.apply(this, arguments);
}
function _wait() {
  _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(milliseconds) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", new Promise(function (resolve) {
            return setTimeout(resolve, milliseconds);
          }));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _wait.apply(this, arguments);
}
function zip(a, b) {
  var A = Array.isArray(a) ? a : Array.from(a);
  var B = Array.isArray(b) ? b : Array.from(b);
  return A.map(function (k, i) {
    return [k, B[i]];
  });
}

// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
var AbortError = exports.AbortError = /*#__PURE__*/function (_Error) {
  _inherits(AbortError, _Error);
  var _super = _createSuper(AbortError);
  function AbortError(params) {
    var _this;
    _classCallCheck(this, AbortError);
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    _this = _super.call(this, params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), AbortError);
    }
    _this.name = 'AbortError';
    return _this;
  }
  return _createClass(AbortError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var CustomAggregateError = exports.CustomAggregateError = /*#__PURE__*/function (_Error2) {
  _inherits(CustomAggregateError, _Error2);
  var _super2 = _createSuper(CustomAggregateError);
  function CustomAggregateError(errors, message) {
    var _this2;
    _classCallCheck(this, CustomAggregateError);
    _this2 = _super2.call(this, message);
    _this2.errors = errors;
    _this2.message = message;
    _this2.name = 'AggregateError';
    return _this2;
  }
  return _createClass(CustomAggregateError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var AggregateError = exports.AggregateError = CustomAggregateError;
},{}],"node_modules/geotiff/dist-module/source/blockedsource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockedSource = void 0;
var _quickLru = _interopRequireDefault(require("quick-lru"));
var _basesource = require("./basesource.js");
var _utils = require("../utils.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Block = /*#__PURE__*/function () {
  /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {ArrayBuffer} [data]
   */
  function Block(offset, length) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, Block);
    this.offset = offset;
    this.length = length;
    this.data = data;
  }

  /**
   * @returns {number} the top byte border
   */
  _createClass(Block, [{
    key: "top",
    get: function get() {
      return this.offset + this.length;
    }
  }]);
  return Block;
}();
var BlockGroup = /*#__PURE__*/_createClass(
/**
 *
 * @param {number} offset
 * @param {number} length
 * @param {number[]} blockIds
 */
function BlockGroup(offset, length, blockIds) {
  _classCallCheck(this, BlockGroup);
  this.offset = offset;
  this.length = length;
  this.blockIds = blockIds;
});
var BlockedSource = exports.BlockedSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(BlockedSource, _BaseSource);
  var _super = _createSuper(BlockedSource);
  /**
   *
   * @param {BaseSource} source The underlying source that shall be blocked and cached
   * @param {object} options
   * @param {number} [options.blockSize]
   * @param {number} [options.cacheSize]
   */
  function BlockedSource(source) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$blockSize = _ref.blockSize,
      blockSize = _ref$blockSize === void 0 ? 65536 : _ref$blockSize,
      _ref$cacheSize = _ref.cacheSize,
      cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize;
    _classCallCheck(this, BlockedSource);
    _this = _super.call(this);
    _this.source = source;
    _this.blockSize = blockSize;
    _this.blockCache = new _quickLru.default({
      maxSize: cacheSize,
      onEviction: function onEviction(blockId, block) {
        _this.evictedBlocks.set(blockId, block);
      }
    });

    /** @type {Map<number, Block>} */
    _this.evictedBlocks = new Map();

    // mapping blockId -> Block instance
    _this.blockRequests = new Map();

    // set of blockIds missing for the current requests
    _this.blockIdsToFetch = new Set();
    _this.abortedBlockIds = new Set();
    return _this;
  }
  _createClass(BlockedSource, [{
    key: "fileSize",
    get: function get() {
      return this.source.fileSize;
    }

    /**
     *
     * @param {import("./basesource").Slice[]} slices
     */
  }, {
    key: "fetch",
    value: (function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slices, signal) {
        var _this2 = this;
        var blockRequests, missingBlockIds, allBlockIds, _iterator, _step, _step$value, offset, length, top, fileSize, firstBlockOffset, current, _blockId2, missingRequests, _i, _missingBlockIds, blockId, abortedBlockRequests, abortedBlockIds, _iterator2, _step2, _blockId, block, blocks, failedBlocks, requiredBlocks;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              blockRequests = [];
              missingBlockIds = [];
              allBlockIds = [];
              this.evictedBlocks.clear();
              _iterator = _createForOfIteratorHelper(slices);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _step$value = _step.value, offset = _step$value.offset, length = _step$value.length;
                  top = offset + length;
                  fileSize = this.fileSize;
                  if (fileSize !== null) {
                    top = Math.min(top, fileSize);
                  }
                  firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;
                  for (current = firstBlockOffset; current < top; current += this.blockSize) {
                    _blockId2 = Math.floor(current / this.blockSize);
                    if (!this.blockCache.has(_blockId2) && !this.blockRequests.has(_blockId2)) {
                      this.blockIdsToFetch.add(_blockId2);
                      missingBlockIds.push(_blockId2);
                    }
                    if (this.blockRequests.has(_blockId2)) {
                      blockRequests.push(this.blockRequests.get(_blockId2));
                    }
                    allBlockIds.push(_blockId2);
                  }
                }

                // allow additional block requests to accumulate
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              _context.next = 8;
              return (0, _utils.wait)();
            case 8:
              this.fetchBlocks(signal);

              // Gather all of the new requests that this fetch call is contributing to `fetch`.
              missingRequests = [];
              for (_i = 0, _missingBlockIds = missingBlockIds; _i < _missingBlockIds.length; _i++) {
                blockId = _missingBlockIds[_i];
                // The requested missing block could already be in the cache
                // instead of having its request still be outstanding.
                if (this.blockRequests.has(blockId)) {
                  missingRequests.push(this.blockRequests.get(blockId));
                }
              }

              // Actually await all pending requests that are needed for this `fetch`.
              _context.next = 13;
              return Promise.allSettled(blockRequests);
            case 13:
              _context.next = 15;
              return Promise.allSettled(missingRequests);
            case 15:
              // Perform retries if a block was interrupted by a previous signal
              abortedBlockRequests = [];
              abortedBlockIds = allBlockIds.filter(function (id) {
                return _this2.abortedBlockIds.has(id) || !_this2.blockCache.has(id);
              });
              abortedBlockIds.forEach(function (id) {
                return _this2.blockIdsToFetch.add(id);
              });
              // start the retry of some blocks if required
              if (!(abortedBlockIds.length > 0 && signal && !signal.aborted)) {
                _context.next = 41;
                break;
              }
              this.fetchBlocks(null);
              _iterator2 = _createForOfIteratorHelper(abortedBlockIds);
              _context.prev = 21;
              _iterator2.s();
            case 23:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 31;
                break;
              }
              _blockId = _step2.value;
              block = this.blockRequests.get(_blockId);
              if (block) {
                _context.next = 28;
                break;
              }
              throw new Error("Block ".concat(_blockId, " is not in the block requests"));
            case 28:
              abortedBlockRequests.push(block);
            case 29:
              _context.next = 23;
              break;
            case 31:
              _context.next = 36;
              break;
            case 33:
              _context.prev = 33;
              _context.t0 = _context["catch"](21);
              _iterator2.e(_context.t0);
            case 36:
              _context.prev = 36;
              _iterator2.f();
              return _context.finish(36);
            case 39:
              _context.next = 41;
              return Promise.allSettled(abortedBlockRequests);
            case 41:
              if (!(signal && signal.aborted)) {
                _context.next = 43;
                break;
              }
              throw new _utils.AbortError('Request was aborted');
            case 43:
              blocks = allBlockIds.map(function (id) {
                return _this2.blockCache.get(id) || _this2.evictedBlocks.get(id);
              });
              failedBlocks = blocks.filter(function (i) {
                return !i;
              });
              if (!failedBlocks.length) {
                _context.next = 47;
                break;
              }
              throw new _utils.AggregateError(failedBlocks, 'Request failed');
            case 47:
              // create a final Map, with all required blocks for this request to satisfy
              requiredBlocks = new Map((0, _utils.zip)(allBlockIds, blocks)); // TODO: satisfy each slice
              return _context.abrupt("return", this.readSliceData(slices, requiredBlocks));
            case 49:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[21, 33, 36, 39]]);
      }));
      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
    /**
     *
     * @param {AbortSignal} signal
     */
    )
  }, {
    key: "fetchBlocks",
    value: function fetchBlocks(signal) {
      var _this3 = this;
      // check if we still need to
      if (this.blockIdsToFetch.size > 0) {
        var groups = this.groupBlocks(this.blockIdsToFetch);

        // start requesting slices of data
        var groupRequests = this.source.fetch(groups, signal);
        var _loop = function _loop(groupIndex) {
          var group = groups[groupIndex];
          var _iterator3 = _createForOfIteratorHelper(group.blockIds),
            _step3;
          try {
            var _loop2 = function _loop2() {
              var blockId = _step3.value;
              // make an async IIFE for each block
              _this3.blockRequests.set(blockId, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                var response, blockOffset, o, t, data, block;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;
                      _context2.next = 3;
                      return groupRequests;
                    case 3:
                      _context2.t0 = groupIndex;
                      response = _context2.sent[_context2.t0];
                      blockOffset = blockId * _this3.blockSize;
                      o = blockOffset - response.offset;
                      t = Math.min(o + _this3.blockSize, response.data.byteLength);
                      data = response.data.slice(o, t);
                      block = new Block(blockOffset, data.byteLength, data, blockId);
                      _this3.blockCache.set(blockId, block);
                      _this3.abortedBlockIds.delete(blockId);
                      _context2.next = 23;
                      break;
                    case 14:
                      _context2.prev = 14;
                      _context2.t1 = _context2["catch"](0);
                      if (!(_context2.t1.name === 'AbortError')) {
                        _context2.next = 22;
                        break;
                      }
                      // store the signal here, we need it to determine later if an
                      // error was caused by this signal
                      _context2.t1.signal = signal;
                      _this3.blockCache.delete(blockId);
                      _this3.abortedBlockIds.add(blockId);
                      _context2.next = 23;
                      break;
                    case 22:
                      throw _context2.t1;
                    case 23:
                      _context2.prev = 23;
                      _this3.blockRequests.delete(blockId);
                      return _context2.finish(23);
                    case 26:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2, null, [[0, 14, 23, 26]]);
              }))());
            };
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              _loop2();
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        };
        for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
          _loop(groupIndex);
        }
        this.blockIdsToFetch.clear();
      }
    }

    /**
     *
     * @param {Set} blockIds
     * @returns {BlockGroup[]}
     */
  }, {
    key: "groupBlocks",
    value: function groupBlocks(blockIds) {
      var sortedBlockIds = Array.from(blockIds).sort(function (a, b) {
        return a - b;
      });
      if (sortedBlockIds.length === 0) {
        return [];
      }
      var current = [];
      var lastBlockId = null;
      var groups = [];
      var _iterator4 = _createForOfIteratorHelper(sortedBlockIds),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var blockId = _step4.value;
          if (lastBlockId === null || lastBlockId + 1 === blockId) {
            current.push(blockId);
            lastBlockId = blockId;
          } else {
            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
            current = [blockId];
            lastBlockId = blockId;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
      return groups;
    }

    /**
     *
     * @param {import("./basesource").Slice[]} slices
     * @param {Map} blocks
     */
  }, {
    key: "readSliceData",
    value: function readSliceData(slices, blocks) {
      var _this4 = this;
      return slices.map(function (slice) {
        var top = slice.offset + slice.length;
        if (_this4.fileSize !== null) {
          top = Math.min(_this4.fileSize, top);
        }
        var blockIdLow = Math.floor(slice.offset / _this4.blockSize);
        var blockIdHigh = Math.floor(top / _this4.blockSize);
        var sliceData = new ArrayBuffer(slice.length);
        var sliceView = new Uint8Array(sliceData);
        for (var blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {
          var block = blocks.get(blockId);
          var delta = block.offset - slice.offset;
          var topDelta = block.top - top;
          var blockInnerOffset = 0;
          var rangeInnerOffset = 0;
          var usedBlockLength = void 0;
          if (delta < 0) {
            blockInnerOffset = -delta;
          } else if (delta > 0) {
            rangeInnerOffset = delta;
          }
          if (topDelta < 0) {
            usedBlockLength = block.length - blockInnerOffset;
          } else {
            usedBlockLength = top - block.offset - blockInnerOffset;
          }
          var blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
          sliceView.set(blockView, rangeInnerOffset);
        }
        return sliceData;
      });
    }
  }]);
  return BlockedSource;
}(_basesource.BaseSource);
},{"quick-lru":"node_modules/quick-lru/index.js","./basesource.js":"node_modules/geotiff/dist-module/source/basesource.js","../utils.js":"node_modules/geotiff/dist-module/utils.js"}],"node_modules/geotiff/dist-module/source/client/base.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseResponse = exports.BaseClient = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var BaseResponse = exports.BaseResponse = /*#__PURE__*/function () {
  function BaseResponse() {
    _classCallCheck(this, BaseResponse);
  }
  _createClass(BaseResponse, [{
    key: "ok",
    get:
    /**
     * Returns whether the response has an ok'ish status code
     */
    function get() {
      return this.status >= 200 && this.status <= 299;
    }

    /**
     * Returns the status code of the response
     */
  }, {
    key: "status",
    get: function get() {
      throw new Error('not implemented');
    }

    /**
     * Returns the value of the specified header
     * @param {string} headerName the header name
     * @returns {string} the header value
     */
  }, {
    key: "getHeader",
    value: function getHeader(headerName) {
      // eslint-disable-line no-unused-vars
      throw new Error('not implemented');
    }

    /**
     * @returns {ArrayBuffer} the response data of the request
     */
  }, {
    key: "getData",
    value: (function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              throw new Error('not implemented');
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function getData() {
        return _getData.apply(this, arguments);
      }
      return getData;
    }())
  }]);
  return BaseResponse;
}();
var BaseClient = exports.BaseClient = /*#__PURE__*/function () {
  function BaseClient(url) {
    _classCallCheck(this, BaseClient);
    this.url = url;
  }

  /**
   * Send a request with the options
   * @param {object} [options]
   */
  _createClass(BaseClient, [{
    key: "request",
    value: (function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _ref,
          headers,
          credentials,
          signal,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, credentials = _ref.credentials, signal = _ref.signal;
              throw new Error('request is not implemented');
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function request() {
        return _request.apply(this, arguments);
      }
      return request;
    }())
  }]);
  return BaseClient;
}();
},{}],"node_modules/geotiff/dist-module/source/client/fetch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchClient = void 0;
var _base = require("./base.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var FetchResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(FetchResponse, _BaseResponse);
  var _super = _createSuper(FetchResponse);
  /**
   * BaseResponse facade for fetch API Response
   * @param {Response} response
   */
  function FetchResponse(response) {
    var _this;
    _classCallCheck(this, FetchResponse);
    _this = _super.call(this);
    _this.response = response;
    return _this;
  }
  _createClass(FetchResponse, [{
    key: "status",
    get: function get() {
      return this.response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.response.headers.get(name);
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.response.arrayBuffer) {
                _context.next = 6;
                break;
              }
              _context.next = 3;
              return this.response.arrayBuffer();
            case 3:
              _context.t0 = _context.sent;
              _context.next = 9;
              break;
            case 6:
              _context.next = 8;
              return this.response.buffer();
            case 8:
              _context.t0 = _context.sent.buffer;
            case 9:
              data = _context.t0;
              return _context.abrupt("return", data);
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getData() {
        return _getData.apply(this, arguments);
      }
      return getData;
    }()
  }]);
  return FetchResponse;
}(_base.BaseResponse);
var FetchClient = exports.FetchClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(FetchClient, _BaseClient);
  var _super2 = _createSuper(FetchClient);
  function FetchClient(url, credentials) {
    var _this2;
    _classCallCheck(this, FetchClient);
    _this2 = _super2.call(this, url);
    _this2.credentials = credentials;
    return _this2;
  }
  _createClass(FetchClient, [{
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _ref,
          headers,
          credentials,
          signal,
          response,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, credentials = _ref.credentials, signal = _ref.signal;
              _context2.next = 3;
              return fetch(this.url, {
                headers: headers,
                credentials: credentials,
                signal: signal
              });
            case 3:
              response = _context2.sent;
              return _context2.abrupt("return", new FetchResponse(response));
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function request() {
        return _request.apply(this, arguments);
      }
      return request;
    }()
  }]);
  return FetchClient;
}(_base.BaseClient);
},{"./base.js":"node_modules/geotiff/dist-module/source/client/base.js"}],"node_modules/geotiff/dist-module/source/client/xhr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XHRClient = void 0;
var _base = require("./base.js");
var _utils = require("../../utils.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var XHRResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(XHRResponse, _BaseResponse);
  var _super = _createSuper(XHRResponse);
  /**
   * BaseResponse facade for XMLHttpRequest
   * @param {XMLHttpRequest} xhr
   * @param {ArrayBuffer} data
   */
  function XHRResponse(xhr, data) {
    var _this;
    _classCallCheck(this, XHRResponse);
    _this = _super.call(this);
    _this.xhr = xhr;
    _this.data = data;
    return _this;
  }
  _createClass(XHRResponse, [{
    key: "status",
    get: function get() {
      return this.xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.xhr.getResponseHeader(name);
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.data);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getData() {
        return _getData.apply(this, arguments);
      }
      return getData;
    }()
  }]);
  return XHRResponse;
}(_base.BaseResponse);
var XHRClient = exports.XHRClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(XHRClient, _BaseClient);
  var _super2 = _createSuper(XHRClient);
  function XHRClient() {
    _classCallCheck(this, XHRClient);
    return _super2.apply(this, arguments);
  }
  _createClass(XHRClient, [{
    key: "constructRequest",
    value: function constructRequest(headers, signal) {
      var _this2 = this;
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', _this2.url);
        xhr.responseType = 'arraybuffer';
        for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];
          xhr.setRequestHeader(key, value);
        }

        // hook signals
        xhr.onload = function () {
          var data = xhr.response;
          resolve(new XHRResponse(xhr, data));
        };
        xhr.onerror = reject;
        xhr.onabort = function () {
          return reject(new _utils.AbortError('Request aborted'));
        };
        xhr.send();
        if (signal) {
          if (signal.aborted) {
            xhr.abort();
          }
          signal.addEventListener('abort', function () {
            return xhr.abort();
          });
        }
      });
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _ref,
          headers,
          signal,
          response,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, signal = _ref.signal;
              _context2.next = 3;
              return this.constructRequest(headers, signal);
            case 3:
              response = _context2.sent;
              return _context2.abrupt("return", response);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function request() {
        return _request.apply(this, arguments);
      }
      return request;
    }()
  }]);
  return XHRClient;
}(_base.BaseClient);
},{"./base.js":"node_modules/geotiff/dist-module/source/client/base.js","../../utils.js":"node_modules/geotiff/dist-module/utils.js"}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/node-libs-browser/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/geotiff/dist-module/source/client/http.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpClient = void 0;
var _http = _interopRequireDefault(require("http"));
var _https = _interopRequireDefault(require("https"));
var _url = _interopRequireDefault(require("url"));
var _base = require("./base.js");
var _utils = require("../../utils.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var HttpResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(HttpResponse, _BaseResponse);
  var _super = _createSuper(HttpResponse);
  /**
   * BaseResponse facade for node HTTP/HTTPS API Response
   * @param {http.ServerResponse} response
   */
  function HttpResponse(response, dataPromise) {
    var _this;
    _classCallCheck(this, HttpResponse);
    _this = _super.call(this);
    _this.response = response;
    _this.dataPromise = dataPromise;
    return _this;
  }
  _createClass(HttpResponse, [{
    key: "status",
    get: function get() {
      return this.response.statusCode;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.response.headers[name];
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.dataPromise;
            case 2:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getData() {
        return _getData.apply(this, arguments);
      }
      return getData;
    }()
  }]);
  return HttpResponse;
}(_base.BaseResponse);
var HttpClient = exports.HttpClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(HttpClient, _BaseClient);
  var _super2 = _createSuper(HttpClient);
  function HttpClient(url) {
    var _this2;
    _classCallCheck(this, HttpClient);
    _this2 = _super2.call(this, url);
    _this2.parsedUrl = _url.default.parse(_this2.url);
    _this2.httpApi = _this2.parsedUrl.protocol === 'http:' ? _http.default : _https.default;
    return _this2;
  }
  _createClass(HttpClient, [{
    key: "constructRequest",
    value: function constructRequest(headers, signal) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        var request = _this3.httpApi.get(_objectSpread(_objectSpread({}, _this3.parsedUrl), {}, {
          headers: headers
        }), function (response) {
          var dataPromise = new Promise(function (resolveData) {
            var chunks = [];

            // collect chunks
            response.on('data', function (chunk) {
              chunks.push(chunk);
            });

            // concatenate all chunks and resolve the promise with the resulting buffer
            response.on('end', function () {
              var data = Buffer.concat(chunks).buffer;
              resolveData(data);
            });
            response.on('error', reject);
          });
          resolve(new HttpResponse(response, dataPromise));
        });
        request.on('error', reject);
        if (signal) {
          if (signal.aborted) {
            request.destroy(new _utils.AbortError('Request aborted'));
          }
          signal.addEventListener('abort', function () {
            return request.destroy(new _utils.AbortError('Request aborted'));
          });
        }
      });
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _ref,
          headers,
          signal,
          response,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, signal = _ref.signal;
              _context2.next = 3;
              return this.constructRequest(headers, signal);
            case 3:
              response = _context2.sent;
              return _context2.abrupt("return", response);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function request() {
        return _request.apply(this, arguments);
      }
      return request;
    }()
  }]);
  return HttpClient;
}(_base.BaseClient);
},{"http":"node_modules/parcel-bundler/src/builtins/_empty.js","https":"node_modules/parcel-bundler/src/builtins/_empty.js","url":"node_modules/parcel-bundler/src/builtins/_empty.js","./base.js":"node_modules/geotiff/dist-module/source/client/base.js","../../utils.js":"node_modules/geotiff/dist-module/utils.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/geotiff/dist-module/source/remote.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeCustomSource = makeCustomSource;
exports.makeFetchSource = makeFetchSource;
exports.makeHttpSource = makeHttpSource;
exports.makeRemoteSource = makeRemoteSource;
exports.makeXHRSource = makeXHRSource;
var _httputils = require("./httputils.js");
var _basesource = require("./basesource.js");
var _blockedsource = require("./blockedsource.js");
var _fetch2 = require("./client/fetch.js");
var _xhr = require("./client/xhr.js");
var _http = require("./client/http.js");
var _excluded = ["headers", "credentials", "maxRanges", "allowFullFile"],
  _excluded2 = ["headers", "maxRanges", "allowFullFile"],
  _excluded3 = ["headers", "maxRanges", "allowFullFile"],
  _excluded4 = ["headers", "maxRanges", "allowFullFile"],
  _excluded5 = ["forceXHR"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var RemoteSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(RemoteSource, _BaseSource);
  var _super = _createSuper(RemoteSource);
  /**
   *
   * @param {BaseClient} client
   * @param {object} headers
   * @param {numbers} maxRanges
   * @param {boolean} allowFullFile
   */
  function RemoteSource(client, headers, maxRanges, allowFullFile) {
    var _this;
    _classCallCheck(this, RemoteSource);
    _this = _super.call(this);
    _this.client = client;
    _this.headers = headers;
    _this.maxRanges = maxRanges;
    _this.allowFullFile = allowFullFile;
    _this._fileSize = null;
    return _this;
  }

  /**
   *
   * @param {Slice[]} slices
   */
  _createClass(RemoteSource, [{
    key: "fetch",
    value: (function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slices, signal) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.maxRanges >= slices.length)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", this.fetchSlices(slices, signal));
            case 4:
              if (this.maxRanges > 0 && slices.length > 1) {
                // TODO: split into multiple multi-range requests

                // const subSlicesRequests = [];
                // for (let i = 0; i < slices.length; i += this.maxRanges) {
                //   subSlicesRequests.push(
                //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),
                //   );
                // }
                // return (await Promise.all(subSlicesRequests)).flat();
              }
            case 5:
              return _context.abrupt("return", Promise.all(slices.map(function (slice) {
                return _this2.fetchSlice(slice, signal);
              })));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }())
  }, {
    key: "fetchSlices",
    value: function () {
      var _fetchSlices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(slices, signal) {
        var _this3 = this;
        var response, _parseContentType, type, params, byteRanges, data, _parseContentRange, start, end, total, first, others, _data;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.client.request({
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  Range: "bytes=".concat(slices.map(function (_ref) {
                    var offset = _ref.offset,
                      length = _ref.length;
                    return "".concat(offset, "-").concat(offset + length);
                  }).join(','))
                }),
                signal: signal
              });
            case 2:
              response = _context2.sent;
              if (response.ok) {
                _context2.next = 7;
                break;
              }
              throw new Error('Error fetching data.');
            case 7:
              if (!(response.status === 206)) {
                _context2.next = 32;
                break;
              }
              _parseContentType = (0, _httputils.parseContentType)(response.getHeader('content-type')), type = _parseContentType.type, params = _parseContentType.params;
              if (!(type === 'multipart/byteranges')) {
                _context2.next = 18;
                break;
              }
              _context2.t0 = _httputils.parseByteRanges;
              _context2.next = 13;
              return response.getData();
            case 13:
              _context2.t1 = _context2.sent;
              _context2.t2 = params.boundary;
              byteRanges = (0, _context2.t0)(_context2.t1, _context2.t2);
              this._fileSize = byteRanges[0].fileSize || null;
              return _context2.abrupt("return", byteRanges);
            case 18:
              _context2.next = 20;
              return response.getData();
            case 20:
              data = _context2.sent;
              _parseContentRange = (0, _httputils.parseContentRange)(response.getHeader('content-range')), start = _parseContentRange.start, end = _parseContentRange.end, total = _parseContentRange.total;
              this._fileSize = total || null;
              first = [{
                data: data,
                offset: start,
                length: end - start
              }];
              if (!(slices.length > 1)) {
                _context2.next = 29;
                break;
              }
              _context2.next = 27;
              return Promise.all(slices.slice(1).map(function (slice) {
                return _this3.fetchSlice(slice, signal);
              }));
            case 27:
              others = _context2.sent;
              return _context2.abrupt("return", first.concat(others));
            case 29:
              return _context2.abrupt("return", first);
            case 32:
              if (this.allowFullFile) {
                _context2.next = 34;
                break;
              }
              throw new Error('Server responded with full file');
            case 34:
              _context2.next = 36;
              return response.getData();
            case 36:
              _data = _context2.sent;
              this._fileSize = _data.byteLength;
              return _context2.abrupt("return", [{
                data: _data,
                offset: 0,
                length: _data.byteLength
              }]);
            case 39:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function fetchSlices(_x3, _x4) {
        return _fetchSlices.apply(this, arguments);
      }
      return fetchSlices;
    }()
  }, {
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(slice, signal) {
        var offset, length, response, data, _parseContentRange2, total, _data2;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              offset = slice.offset, length = slice.length;
              _context3.next = 3;
              return this.client.request({
                headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                  Range: "bytes=".concat(offset, "-").concat(offset + length)
                }),
                signal: signal
              });
            case 3:
              response = _context3.sent;
              if (response.ok) {
                _context3.next = 8;
                break;
              }
              throw new Error('Error fetching data.');
            case 8:
              if (!(response.status === 206)) {
                _context3.next = 17;
                break;
              }
              _context3.next = 11;
              return response.getData();
            case 11:
              data = _context3.sent;
              _parseContentRange2 = (0, _httputils.parseContentRange)(response.getHeader('content-range')), total = _parseContentRange2.total;
              this._fileSize = total || null;
              return _context3.abrupt("return", {
                data: data,
                offset: offset,
                length: length
              });
            case 17:
              if (this.allowFullFile) {
                _context3.next = 19;
                break;
              }
              throw new Error('Server responded with full file');
            case 19:
              _context3.next = 21;
              return response.getData();
            case 21:
              _data2 = _context3.sent;
              this._fileSize = _data2.byteLength;
              return _context3.abrupt("return", {
                data: _data2,
                offset: 0,
                length: _data2.byteLength
              });
            case 24:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetchSlice(_x5, _x6) {
        return _fetchSlice.apply(this, arguments);
      }
      return fetchSlice;
    }()
  }, {
    key: "fileSize",
    get: function get() {
      return this._fileSize;
    }
  }]);
  return RemoteSource;
}(_basesource.BaseSource);
function maybeWrapInBlockedSource(source, _ref2) {
  var blockSize = _ref2.blockSize,
    cacheSize = _ref2.cacheSize;
  if (blockSize === null) {
    return source;
  }
  return new _blockedsource.BlockedSource(source, {
    blockSize: blockSize,
    cacheSize: cacheSize
  });
}
function makeFetchSource(url) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref3$headers = _ref3.headers,
    headers = _ref3$headers === void 0 ? {} : _ref3$headers,
    credentials = _ref3.credentials,
    _ref3$maxRanges = _ref3.maxRanges,
    maxRanges = _ref3$maxRanges === void 0 ? 0 : _ref3$maxRanges,
    _ref3$allowFullFile = _ref3.allowFullFile,
    allowFullFile = _ref3$allowFullFile === void 0 ? false : _ref3$allowFullFile,
    blockOptions = _objectWithoutProperties(_ref3, _excluded);
  var client = new _fetch2.FetchClient(url, credentials);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeXHRSource(url) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref4$headers = _ref4.headers,
    headers = _ref4$headers === void 0 ? {} : _ref4$headers,
    _ref4$maxRanges = _ref4.maxRanges,
    maxRanges = _ref4$maxRanges === void 0 ? 0 : _ref4$maxRanges,
    _ref4$allowFullFile = _ref4.allowFullFile,
    allowFullFile = _ref4$allowFullFile === void 0 ? false : _ref4$allowFullFile,
    blockOptions = _objectWithoutProperties(_ref4, _excluded2);
  var client = new _xhr.XHRClient(url);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeHttpSource(url) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref5$headers = _ref5.headers,
    headers = _ref5$headers === void 0 ? {} : _ref5$headers,
    _ref5$maxRanges = _ref5.maxRanges,
    maxRanges = _ref5$maxRanges === void 0 ? 0 : _ref5$maxRanges,
    _ref5$allowFullFile = _ref5.allowFullFile,
    allowFullFile = _ref5$allowFullFile === void 0 ? false : _ref5$allowFullFile,
    blockOptions = _objectWithoutProperties(_ref5, _excluded3);
  var client = new _http.HttpClient(url);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeCustomSource(client) {
  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref6$headers = _ref6.headers,
    headers = _ref6$headers === void 0 ? {} : _ref6$headers,
    _ref6$maxRanges = _ref6.maxRanges,
    maxRanges = _ref6$maxRanges === void 0 ? 0 : _ref6$maxRanges,
    _ref6$allowFullFile = _ref6.allowFullFile,
    allowFullFile = _ref6$allowFullFile === void 0 ? false : _ref6$allowFullFile,
    blockOptions = _objectWithoutProperties(_ref6, _excluded4);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}

/**
 *
 * @param {string} url
 * @param {object} options
 */
function makeRemoteSource(url) {
  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref7$forceXHR = _ref7.forceXHR,
    forceXHR = _ref7$forceXHR === void 0 ? false : _ref7$forceXHR,
    clientOptions = _objectWithoutProperties(_ref7, _excluded5);
  if (typeof fetch === 'function' && !forceXHR) {
    return makeFetchSource(url, clientOptions);
  }
  if (typeof XMLHttpRequest !== 'undefined') {
    return makeXHRSource(url, clientOptions);
  }
  return makeHttpSource(url, clientOptions);
}
},{"./httputils.js":"node_modules/geotiff/dist-module/source/httputils.js","./basesource.js":"node_modules/geotiff/dist-module/source/basesource.js","./blockedsource.js":"node_modules/geotiff/dist-module/source/blockedsource.js","./client/fetch.js":"node_modules/geotiff/dist-module/source/client/fetch.js","./client/xhr.js":"node_modules/geotiff/dist-module/source/client/xhr.js","./client/http.js":"node_modules/geotiff/dist-module/source/client/http.js"}],"node_modules/geotiff/dist-module/source/arraybuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBufferSource = makeBufferSource;
var _basesource = require("./basesource.js");
var _utils = require("../utils.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var ArrayBufferSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(ArrayBufferSource, _BaseSource);
  var _super = _createSuper(ArrayBufferSource);
  function ArrayBufferSource(arrayBuffer) {
    var _this;
    _classCallCheck(this, ArrayBufferSource);
    _this = _super.call(this);
    _this.arrayBuffer = arrayBuffer;
    return _this;
  }
  _createClass(ArrayBufferSource, [{
    key: "fetchSlice",
    value: function fetchSlice(slice, signal) {
      if (signal && signal.aborted) {
        throw new _utils.AbortError('Request aborted');
      }
      return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);
    }
  }]);
  return ArrayBufferSource;
}(_basesource.BaseSource);
function makeBufferSource(arrayBuffer) {
  return new ArrayBufferSource(arrayBuffer);
}
},{"./basesource.js":"node_modules/geotiff/dist-module/source/basesource.js","../utils.js":"node_modules/geotiff/dist-module/utils.js"}],"node_modules/geotiff/dist-module/source/filereader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeFileReaderSource = makeFileReaderSource;
var _basesource = require("./basesource.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var FileReaderSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(FileReaderSource, _BaseSource);
  var _super = _createSuper(FileReaderSource);
  function FileReaderSource(file) {
    var _this;
    _classCallCheck(this, FileReaderSource);
    _this = _super.call(this);
    _this.file = file;
    return _this;
  }
  _createClass(FileReaderSource, [{
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slice, signal) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var blob = _this2.file.slice(slice.offset, slice.offset + slice.length);
                var reader = new FileReader();
                reader.onload = function (event) {
                  return resolve(event.target.result);
                };
                reader.onerror = reject;
                reader.onabort = reject;
                reader.readAsArrayBuffer(blob);
                if (signal) {
                  signal.addEventListener('abort', function () {
                    return reader.abort();
                  });
                }
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function fetchSlice(_x, _x2) {
        return _fetchSlice.apply(this, arguments);
      }
      return fetchSlice;
    }()
  }]);
  return FileReaderSource;
}(_basesource.BaseSource);
/**
 * Create a new source from a given file/blob.
 * @param {Blob} file The file or blob to read from.
 * @returns The constructed source
 */
function makeFileReaderSource(file) {
  return new FileReaderSource(file);
}
},{"./basesource.js":"node_modules/geotiff/dist-module/source/basesource.js"}],"node_modules/geotiff/dist-module/source/file.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeFileSource = makeFileSource;
var _fs = _interopRequireDefault(require("fs"));
var _basesource = require("./basesource.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function closeAsync(fd) {
  return new Promise(function (resolve, reject) {
    _fs.default.close(fd, function (err) {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}
function openAsync(path, flags) {
  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return new Promise(function (resolve, reject) {
    _fs.default.open(path, flags, mode, function (err, fd) {
      if (err) {
        reject(err);
      } else {
        resolve(fd);
      }
    });
  });
}
function readAsync() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return new Promise(function (resolve, reject) {
    _fs.default.read.apply(_fs.default, args.concat([function (err, bytesRead, buffer) {
      if (err) {
        reject(err);
      } else {
        resolve({
          bytesRead: bytesRead,
          buffer: buffer
        });
      }
    }]));
  });
}
var FileSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(FileSource, _BaseSource);
  var _super = _createSuper(FileSource);
  function FileSource(path) {
    var _this;
    _classCallCheck(this, FileSource);
    _this = _super.call(this);
    _this.path = path;
    _this.openRequest = openAsync(path, 'r');
    return _this;
  }
  _createClass(FileSource, [{
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slice) {
        var fd, _yield$readAsync, buffer;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.openRequest;
            case 2:
              fd = _context.sent;
              _context.next = 5;
              return readAsync(fd, Buffer.alloc(slice.length), 0, slice.length, slice.offset);
            case 5:
              _yield$readAsync = _context.sent;
              buffer = _yield$readAsync.buffer;
              return _context.abrupt("return", buffer.buffer);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function fetchSlice(_x) {
        return _fetchSlice.apply(this, arguments);
      }
      return fetchSlice;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var fd;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.openRequest;
            case 2:
              fd = _context2.sent;
              _context2.next = 5;
              return closeAsync(fd);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }]);
  return FileSource;
}(_basesource.BaseSource);
function makeFileSource(path) {
  return new FileSource(path);
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","./basesource.js":"node_modules/geotiff/dist-module/source/basesource.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/geotiff/dist-module/geotiffwriter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeGeotiff = writeGeotiff;
var _globals = require("./globals.js");
var _utils = require("./utils.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /*
  Some parts of this file are based on UTIF.js,
  which was released under the MIT License.
  You can view that here:
  https://github.com/photopea/UTIF.js/blob/master/LICENSE
*/
var tagName2Code = (0, _utils.invert)(_globals.fieldTagNames);
var geoKeyName2Code = (0, _utils.invert)(_globals.geoKeyNames);
var name2code = {};
(0, _utils.assign)(name2code, tagName2Code);
(0, _utils.assign)(name2code, geoKeyName2Code);
var typeName2byte = (0, _utils.invert)(_globals.fieldTypeNames);

// config variables
var numBytesInIfd = 1000;
var _binBE = {
  nextZero: function nextZero(data, o) {
    var oincr = o;
    while (data[oincr] !== 0) {
      oincr++;
    }
    return oincr;
  },
  readUshort: function readUshort(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  readShort: function readShort(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 1];
    a[1] = buff[p + 0];
    return _binBE.i16[0];
  },
  readInt: function readInt(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.i32[0];
  },
  readUint: function readUint(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.ui32[0];
  },
  readASCII: function readASCII(buff, p, l) {
    return l.map(function (i) {
      return String.fromCharCode(buff[p + i]);
    }).join('');
  },
  readFloat: function readFloat(buff, p) {
    var a = _binBE.ui8;
    (0, _utils.times)(4, function (i) {
      a[i] = buff[p + 3 - i];
    });
    return _binBE.fl32[0];
  },
  readDouble: function readDouble(buff, p) {
    var a = _binBE.ui8;
    (0, _utils.times)(8, function (i) {
      a[i] = buff[p + 7 - i];
    });
    return _binBE.fl64[0];
  },
  writeUshort: function writeUshort(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  writeUint: function writeUint(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n >> 0 & 255;
  },
  writeASCII: function writeASCII(buff, p, s) {
    (0, _utils.times)(s.length, function (i) {
      buff[p + i] = s.charCodeAt(i);
    });
  },
  ui8: new Uint8Array(8)
};
_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);
_binBE.writeDouble = function (buff, p, n) {
  _binBE.fl64[0] = n;
  (0, _utils.times)(8, function (i) {
    buff[p + i] = _binBE.ui8[7 - i];
  });
};
var _writeIFD = function _writeIFD(bin, data, _offset, ifd) {
  var offset = _offset;
  var keys = Object.keys(ifd).filter(function (key) {
    return key !== undefined && key !== null && key !== 'undefined';
  });
  bin.writeUshort(data, offset, keys.length);
  offset += 2;
  var eoff = offset + 12 * keys.length + 4;
  var _iterator = _createForOfIteratorHelper(keys),
    _step;
  try {
    var _loop = function _loop() {
      var key = _step.value;
      var tag = null;
      if (typeof key === 'number') {
        tag = key;
      } else if (typeof key === 'string') {
        tag = parseInt(key, 10);
      }
      var typeName = _globals.fieldTagTypes[tag];
      var typeNum = typeName2byte[typeName];
      if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {
        throw new Error("unknown type of tag: ".concat(tag));
      }
      var val = ifd[key];
      if (val === undefined) {
        throw new Error("failed to get value for key ".concat(key));
      }

      // ASCIIZ format with trailing 0 character
      // http://www.fileformat.info/format/tiff/corion.htm
      // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii
      if (typeName === 'ASCII' && typeof val === 'string' && (0, _utils.endsWith)(val, "\0") === false) {
        val += "\0";
      }
      var num = val.length;
      bin.writeUshort(data, offset, tag);
      offset += 2;
      bin.writeUshort(data, offset, typeNum);
      offset += 2;
      bin.writeUint(data, offset, num);
      offset += 4;
      var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;
      var toff = offset;
      if (dlen > 4) {
        bin.writeUint(data, offset, eoff);
        toff = eoff;
      }
      if (typeName === 'ASCII') {
        bin.writeASCII(data, toff, val);
      } else if (typeName === 'SHORT') {
        (0, _utils.times)(num, function (i) {
          bin.writeUshort(data, toff + 2 * i, val[i]);
        });
      } else if (typeName === 'LONG') {
        (0, _utils.times)(num, function (i) {
          bin.writeUint(data, toff + 4 * i, val[i]);
        });
      } else if (typeName === 'RATIONAL') {
        (0, _utils.times)(num, function (i) {
          bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));
          bin.writeUint(data, toff + 8 * i + 4, 10000);
        });
      } else if (typeName === 'DOUBLE') {
        (0, _utils.times)(num, function (i) {
          bin.writeDouble(data, toff + 8 * i, val[i]);
        });
      }
      if (dlen > 4) {
        dlen += dlen & 1;
        eoff += dlen;
      }
      offset += 4;
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return [offset, eoff];
};
var encodeIfds = function encodeIfds(ifds) {
  var data = new Uint8Array(numBytesInIfd);
  var offset = 4;
  var bin = _binBE;

  // set big-endian byte-order
  // https://en.wikipedia.org/wiki/TIFF#Byte_order
  data[0] = 77;
  data[1] = 77;

  // set format-version number
  // https://en.wikipedia.org/wiki/TIFF#Byte_order
  data[3] = 42;
  var ifdo = 8;
  bin.writeUint(data, offset, ifdo);
  offset += 4;
  ifds.forEach(function (ifd, i) {
    var noffs = _writeIFD(bin, data, ifdo, ifd);
    ifdo = noffs[1];
    if (i < ifds.length - 1) {
      bin.writeUint(data, noffs[0], ifdo);
    }
  });
  if (data.slice) {
    return data.slice(0, ifdo).buffer;
  }

  // node hasn't implemented slice on Uint8Array yet
  var result = new Uint8Array(ifdo);
  for (var i = 0; i < ifdo; i++) {
    result[i] = data[i];
  }
  return result.buffer;
};
var encodeImage = function encodeImage(values, width, height, metadata) {
  if (height === undefined || height === null) {
    throw new Error("you passed into encodeImage a width of type ".concat(height));
  }
  if (width === undefined || width === null) {
    throw new Error("you passed into encodeImage a width of type ".concat(width));
  }
  var ifd = {
    256: [width],
    // ImageWidth
    257: [height],
    // ImageLength
    273: [numBytesInIfd],
    // strips offset
    278: [height],
    // RowsPerStrip
    305: 'geotiff.js' // no array for ASCII(Z)
  };
  if (metadata) {
    for (var i in metadata) {
      if (metadata.hasOwnProperty(i)) {
        ifd[i] = metadata[i];
      }
    }
  }
  var prfx = new Uint8Array(encodeIfds([ifd]));
  var img = new Uint8Array(values);
  var samplesPerPixel = ifd[277];
  var data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);
  (0, _utils.times)(prfx.length, function (i) {
    data[i] = prfx[i];
  });
  (0, _utils.forEach)(img, function (value, i) {
    data[numBytesInIfd + i] = value;
  });
  return data.buffer;
};
var convertToTids = function convertToTids(input) {
  var result = {};
  for (var key in input) {
    if (key !== 'StripOffsets') {
      if (!name2code[key]) {
        console.error(key, 'not in name2code:', Object.keys(name2code));
      }
      result[name2code[key]] = input[key];
    }
  }
  return result;
};
var toArray = function toArray(input) {
  if (Array.isArray(input)) {
    return input;
  }
  return [input];
};
var metadataDefaults = [['Compression', 1],
// no compression
['PlanarConfiguration', 1], ['ExtraSamples', 0]];
function writeGeotiff(data, metadata) {
  var isFlattened = typeof data[0] === 'number';
  var height;
  var numBands;
  var width;
  var flattenedValues;
  if (isFlattened) {
    height = metadata.height || metadata.ImageLength;
    width = metadata.width || metadata.ImageWidth;
    numBands = data.length / (height * width);
    flattenedValues = data;
  } else {
    numBands = data.length;
    height = data[0].length;
    width = data[0][0].length;
    flattenedValues = [];
    (0, _utils.times)(height, function (rowIndex) {
      (0, _utils.times)(width, function (columnIndex) {
        (0, _utils.times)(numBands, function (bandIndex) {
          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);
        });
      });
    });
  }
  metadata.ImageLength = height;
  delete metadata.height;
  metadata.ImageWidth = width;
  delete metadata.width;

  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml

  if (!metadata.BitsPerSample) {
    metadata.BitsPerSample = (0, _utils.times)(numBands, function () {
      return 8;
    });
  }
  metadataDefaults.forEach(function (tag) {
    var key = tag[0];
    if (!metadata[key]) {
      var value = tag[1];
      metadata[key] = value;
    }
  });

  // The color space of the image data.
  // 1=black is zero and 2=RGB.
  if (!metadata.PhotometricInterpretation) {
    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;
  }

  // The number of components per pixel.
  if (!metadata.SamplesPerPixel) {
    metadata.SamplesPerPixel = [numBands];
  }
  if (!metadata.StripByteCounts) {
    // we are only writing one strip
    metadata.StripByteCounts = [numBands * height * width];
  }
  if (!metadata.ModelPixelScale) {
    // assumes raster takes up exactly the whole globe
    metadata.ModelPixelScale = [360 / width, 180 / height, 0];
  }
  if (!metadata.SampleFormat) {
    metadata.SampleFormat = (0, _utils.times)(numBands, function () {
      return 1;
    });
  }

  // if didn't pass in projection information, assume the popular 4326 "geographic projection"
  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {
    metadata.GeographicTypeGeoKey = 4326;
    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe
    metadata.GeogCitationGeoKey = 'WGS 84';
    metadata.GTModelTypeGeoKey = 2;
  }
  var geoKeys = Object.keys(metadata).filter(function (key) {
    return (0, _utils.endsWith)(key, 'GeoKey');
  }).sort(function (a, b) {
    return name2code[a] - name2code[b];
  });
  if (!metadata.GeoAsciiParams) {
    var geoAsciiParams = '';
    geoKeys.forEach(function (name) {
      var code = Number(name2code[name]);
      var tagType = _globals.fieldTagTypes[code];
      if (tagType === 'ASCII') {
        geoAsciiParams += "".concat(metadata[name].toString(), "\0");
      }
    });
    if (geoAsciiParams.length > 0) {
      metadata.GeoAsciiParams = geoAsciiParams;
    }
  }
  if (!metadata.GeoKeyDirectory) {
    var NumberOfKeys = geoKeys.length;
    var GeoKeyDirectory = [1, 1, 0, NumberOfKeys];
    geoKeys.forEach(function (geoKey) {
      var KeyID = Number(name2code[geoKey]);
      GeoKeyDirectory.push(KeyID);
      var Count;
      var TIFFTagLocation;
      var valueOffset;
      if (_globals.fieldTagTypes[KeyID] === 'SHORT') {
        Count = 1;
        TIFFTagLocation = 0;
        valueOffset = metadata[geoKey];
      } else if (geoKey === 'GeogCitationGeoKey') {
        Count = metadata.GeoAsciiParams.length;
        TIFFTagLocation = Number(name2code.GeoAsciiParams);
        valueOffset = 0;
      } else {
        console.log("[geotiff.js] couldn't get TIFFTagLocation for ".concat(geoKey));
      }
      GeoKeyDirectory.push(TIFFTagLocation);
      GeoKeyDirectory.push(Count);
      GeoKeyDirectory.push(valueOffset);
    });
    metadata.GeoKeyDirectory = GeoKeyDirectory;
  }

  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag
  var _iterator2 = _createForOfIteratorHelper(geoKeys),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var geoKey = _step2.value;
      if (metadata.hasOwnProperty(geoKey)) {
        delete metadata[geoKey];
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength',
  // synonym of ImageHeight
  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition', 'RowsPerStrip'].forEach(function (name) {
    if (metadata[name]) {
      metadata[name] = toArray(metadata[name]);
    }
  });
  var encodedMetadata = convertToTids(metadata);
  var outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);
  return outputImage;
}
},{"./globals.js":"node_modules/geotiff/dist-module/globals.js","./utils.js":"node_modules/geotiff/dist-module/utils.js"}],"node_modules/geotiff/dist-module/logging.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debug = debug;
exports.error = error;
exports.info = info;
exports.log = log;
exports.setLogger = setLogger;
exports.time = time;
exports.timeEnd = timeEnd;
exports.warn = warn;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * A no-op logger
 */
var DummyLogger = /*#__PURE__*/function () {
  function DummyLogger() {
    _classCallCheck(this, DummyLogger);
  }
  _createClass(DummyLogger, [{
    key: "log",
    value: function log() {}
  }, {
    key: "debug",
    value: function debug() {}
  }, {
    key: "info",
    value: function info() {}
  }, {
    key: "warn",
    value: function warn() {}
  }, {
    key: "error",
    value: function error() {}
  }, {
    key: "time",
    value: function time() {}
  }, {
    key: "timeEnd",
    value: function timeEnd() {}
  }]);
  return DummyLogger;
}();
var LOGGER = new DummyLogger();

/**
 *
 * @param {object} logger the new logger. e.g `console`
 */
function setLogger() {
  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new DummyLogger();
  LOGGER = logger;
}
function debug() {
  var _LOGGER;
  return (_LOGGER = LOGGER).debug.apply(_LOGGER, arguments);
}
function log() {
  var _LOGGER2;
  return (_LOGGER2 = LOGGER).log.apply(_LOGGER2, arguments);
}
function info() {
  var _LOGGER3;
  return (_LOGGER3 = LOGGER).info.apply(_LOGGER3, arguments);
}
function warn() {
  var _LOGGER4;
  return (_LOGGER4 = LOGGER).warn.apply(_LOGGER4, arguments);
}
function error() {
  var _LOGGER5;
  return (_LOGGER5 = LOGGER).error.apply(_LOGGER5, arguments);
}
function time() {
  var _LOGGER6;
  return (_LOGGER6 = LOGGER).time.apply(_LOGGER6, arguments);
}
function timeEnd() {
  var _LOGGER7;
  return (_LOGGER7 = LOGGER).timeEnd.apply(_LOGGER7, arguments);
}
},{}],"node_modules/geotiff/dist-module/predictor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyPredictor = applyPredictor;
function decodeRowAcc(row, stride) {
  var length = row.length - stride;
  var offset = 0;
  do {
    for (var i = stride; i > 0; i--) {
      row[offset + stride] += row[offset];
      offset++;
    }
    length -= stride;
  } while (length > 0);
}
function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  var index = 0;
  var count = row.length;
  var wc = count / bytesPerSample;
  while (count > stride) {
    for (var i = stride; i > 0; --i) {
      row[index + stride] += row[index];
      ++index;
    }
    count -= stride;
  }
  var copy = row.slice();
  for (var _i = 0; _i < wc; ++_i) {
    for (var b = 0; b < bytesPerSample; ++b) {
      row[bytesPerSample * _i + b] = copy[(bytesPerSample - b - 1) * wc + _i];
    }
  }
}
function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }
  for (var i = 0; i < bitsPerSample.length; ++i) {
    if (bitsPerSample[i] % 8 !== 0) {
      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');
    }
    if (bitsPerSample[i] !== bitsPerSample[0]) {
      throw new Error('When decoding with predictor, all samples must have the same size.');
    }
  }
  var bytesPerSample = bitsPerSample[0] / 8;
  var stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;
  for (var _i2 = 0; _i2 < height; ++_i2) {
    // Last strip will be truncated if height % stripHeight != 0
    if (_i2 * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    var row = void 0;
    if (predictor === 2) {
      // horizontal prediction
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);
          break;
        case 16:
          row = new Uint16Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);
          break;
        case 32:
          row = new Uint32Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);
          break;
        default:
          throw new Error("Predictor 2 not allowed with ".concat(bitsPerSample[0], " bits per sample."));
      }
      decodeRowAcc(row, stride, bytesPerSample);
    } else if (predictor === 3) {
      // horizontal floating point
      row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}
},{}],"node_modules/geotiff/dist-module/compression/basedecoder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _predictor = require("../predictor.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var BaseDecoder = exports.default = /*#__PURE__*/function () {
  function BaseDecoder() {
    _classCallCheck(this, BaseDecoder);
  }
  _createClass(BaseDecoder, [{
    key: "decode",
    value: function () {
      var _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileDirectory, buffer) {
        var decoded, predictor, isTiled, tileWidth, tileHeight;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.decodeBlock(buffer);
            case 2:
              decoded = _context.sent;
              predictor = fileDirectory.Predictor || 1;
              if (!(predictor !== 1)) {
                _context.next = 9;
                break;
              }
              isTiled = !fileDirectory.StripOffsets;
              tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
              tileHeight = isTiled ? fileDirectory.TileLength : fileDirectory.RowsPerStrip || fileDirectory.ImageLength;
              return _context.abrupt("return", (0, _predictor.applyPredictor)(decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample, fileDirectory.PlanarConfiguration));
            case 9:
              return _context.abrupt("return", decoded);
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function decode(_x, _x2) {
        return _decode.apply(this, arguments);
      }
      return decode;
    }()
  }]);
  return BaseDecoder;
}();
},{"../predictor.js":"node_modules/geotiff/dist-module/predictor.js"}],"node_modules/geotiff/dist-module/geotiff.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BaseClient", {
  enumerable: true,
  get: function () {
    return _base.BaseClient;
  }
});
Object.defineProperty(exports, "BaseDecoder", {
  enumerable: true,
  get: function () {
    return _basedecoder.default;
  }
});
Object.defineProperty(exports, "BaseResponse", {
  enumerable: true,
  get: function () {
    return _base.BaseResponse;
  }
});
exports.GeoTIFF = void 0;
Object.defineProperty(exports, "GeoTIFFImage", {
  enumerable: true,
  get: function () {
    return _geotiffimage.default;
  }
});
exports.MultiGeoTIFF = void 0;
Object.defineProperty(exports, "Pool", {
  enumerable: true,
  get: function () {
    return _pool.default;
  }
});
Object.defineProperty(exports, "addDecoder", {
  enumerable: true,
  get: function () {
    return _index.addDecoder;
  }
});
exports.default = void 0;
exports.fromArrayBuffer = fromArrayBuffer;
exports.fromBlob = fromBlob;
exports.fromCustomClient = fromCustomClient;
exports.fromFile = fromFile;
exports.fromUrl = fromUrl;
exports.fromUrls = fromUrls;
Object.defineProperty(exports, "getDecoder", {
  enumerable: true,
  get: function () {
    return _index.getDecoder;
  }
});
exports.rgb = exports.globals = void 0;
Object.defineProperty(exports, "setLogger", {
  enumerable: true,
  get: function () {
    return _logging.setLogger;
  }
});
exports.writeArrayBuffer = writeArrayBuffer;
var _geotiffimage = _interopRequireDefault(require("./geotiffimage.js"));
var _dataview = _interopRequireDefault(require("./dataview64.js"));
var _dataslice = _interopRequireDefault(require("./dataslice.js"));
var _pool = _interopRequireDefault(require("./pool.js"));
var _remote = require("./source/remote.js");
var _arraybuffer = require("./source/arraybuffer.js");
var _filereader = require("./source/filereader.js");
var _file = require("./source/file.js");
var _base = require("./source/client/base.js");
var _globals = _interopRequireWildcard(require("./globals.js"));
var globals = _globals;
exports.globals = _globals;
var _geotiffwriter = require("./geotiffwriter.js");
var rgb = _interopRequireWildcard(require("./rgb.js"));
exports.rgb = rgb;
var _index = require("./compression/index.js");
var _logging = require("./logging.js");
var _basedecoder = _interopRequireDefault(require("./compression/basedecoder.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /** @module geotiff */
/**
 * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}
 * TypedArray
 */

/**
 * @typedef {{ height:number, width: number }} Dimensions
 */

/**
 * The autogenerated docs are a little confusing here. The effective type is:
 *
 * `TypedArray & { height: number; width: number}`
 * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions
 */

/**
 * The autogenerated docs are a little confusing here. The effective type is:
 *
 * `TypedArray[] & { height: number; width: number}`
 * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions
 */

/**
 *  The autogenerated docs are a little confusing here. The effective type is:
 *
 * `(TypedArray | TypedArray[]) & { height: number; width: number}`
 * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult
 */

function getFieldTypeLength(fieldType) {
  switch (fieldType) {
    case _globals.fieldTypes.BYTE:
    case _globals.fieldTypes.ASCII:
    case _globals.fieldTypes.SBYTE:
    case _globals.fieldTypes.UNDEFINED:
      return 1;
    case _globals.fieldTypes.SHORT:
    case _globals.fieldTypes.SSHORT:
      return 2;
    case _globals.fieldTypes.LONG:
    case _globals.fieldTypes.SLONG:
    case _globals.fieldTypes.FLOAT:
    case _globals.fieldTypes.IFD:
      return 4;
    case _globals.fieldTypes.RATIONAL:
    case _globals.fieldTypes.SRATIONAL:
    case _globals.fieldTypes.DOUBLE:
    case _globals.fieldTypes.LONG8:
    case _globals.fieldTypes.SLONG8:
    case _globals.fieldTypes.IFD8:
      return 8;
    default:
      throw new RangeError("Invalid field type: ".concat(fieldType));
  }
}
function parseGeoKeyDirectory(fileDirectory) {
  var rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;
  if (!rawGeoKeyDirectory) {
    return null;
  }
  var geoKeyDirectory = {};
  for (var i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {
    var key = _globals.geoKeyNames[rawGeoKeyDirectory[i]];
    var location = rawGeoKeyDirectory[i + 1] ? _globals.fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;
    var count = rawGeoKeyDirectory[i + 2];
    var offset = rawGeoKeyDirectory[i + 3];
    var value = null;
    if (!location) {
      value = offset;
    } else {
      value = fileDirectory[location];
      if (typeof value === 'undefined' || value === null) {
        throw new Error("Could not get value of geoKey '".concat(key, "'."));
      } else if (typeof value === 'string') {
        value = value.substring(offset, offset + count - 1);
      } else if (value.subarray) {
        value = value.subarray(offset, offset + count);
        if (count === 1) {
          value = value[0];
        }
      }
    }
    geoKeyDirectory[key] = value;
  }
  return geoKeyDirectory;
}
function getValues(dataSlice, fieldType, count, offset) {
  var values = null;
  var readMethod = null;
  var fieldTypeLength = getFieldTypeLength(fieldType);
  switch (fieldType) {
    case _globals.fieldTypes.BYTE:
    case _globals.fieldTypes.ASCII:
    case _globals.fieldTypes.UNDEFINED:
      values = new Uint8Array(count);
      readMethod = dataSlice.readUint8;
      break;
    case _globals.fieldTypes.SBYTE:
      values = new Int8Array(count);
      readMethod = dataSlice.readInt8;
      break;
    case _globals.fieldTypes.SHORT:
      values = new Uint16Array(count);
      readMethod = dataSlice.readUint16;
      break;
    case _globals.fieldTypes.SSHORT:
      values = new Int16Array(count);
      readMethod = dataSlice.readInt16;
      break;
    case _globals.fieldTypes.LONG:
    case _globals.fieldTypes.IFD:
      values = new Uint32Array(count);
      readMethod = dataSlice.readUint32;
      break;
    case _globals.fieldTypes.SLONG:
      values = new Int32Array(count);
      readMethod = dataSlice.readInt32;
      break;
    case _globals.fieldTypes.LONG8:
    case _globals.fieldTypes.IFD8:
      values = new Array(count);
      readMethod = dataSlice.readUint64;
      break;
    case _globals.fieldTypes.SLONG8:
      values = new Array(count);
      readMethod = dataSlice.readInt64;
      break;
    case _globals.fieldTypes.RATIONAL:
      values = new Uint32Array(count * 2);
      readMethod = dataSlice.readUint32;
      break;
    case _globals.fieldTypes.SRATIONAL:
      values = new Int32Array(count * 2);
      readMethod = dataSlice.readInt32;
      break;
    case _globals.fieldTypes.FLOAT:
      values = new Float32Array(count);
      readMethod = dataSlice.readFloat32;
      break;
    case _globals.fieldTypes.DOUBLE:
      values = new Float64Array(count);
      readMethod = dataSlice.readFloat64;
      break;
    default:
      throw new RangeError("Invalid field type: ".concat(fieldType));
  }

  // normal fields
  if (!(fieldType === _globals.fieldTypes.RATIONAL || fieldType === _globals.fieldTypes.SRATIONAL)) {
    for (var i = 0; i < count; ++i) {
      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
    }
  } else {
    // RATIONAL or SRATIONAL
    for (var _i = 0; _i < count; _i += 2) {
      values[_i] = readMethod.call(dataSlice, offset + _i * fieldTypeLength);
      values[_i + 1] = readMethod.call(dataSlice, offset + (_i * fieldTypeLength + 4));
    }
  }
  if (fieldType === _globals.fieldTypes.ASCII) {
    return new TextDecoder('utf-8').decode(values);
  }
  return values;
}

/**
 * Data class to store the parsed file directory, geo key directory and
 * offset to the next IFD
 */
var ImageFileDirectory = /*#__PURE__*/_createClass(function ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {
  _classCallCheck(this, ImageFileDirectory);
  this.fileDirectory = fileDirectory;
  this.geoKeyDirectory = geoKeyDirectory;
  this.nextIFDByteOffset = nextIFDByteOffset;
});
/**
 * Error class for cases when an IFD index was requested, that does not exist
 * in the file.
 */
var GeoTIFFImageIndexError = /*#__PURE__*/function (_Error) {
  _inherits(GeoTIFFImageIndexError, _Error);
  var _super = _createSuper(GeoTIFFImageIndexError);
  function GeoTIFFImageIndexError(index) {
    var _this;
    _classCallCheck(this, GeoTIFFImageIndexError);
    _this = _super.call(this, "No image at index ".concat(index));
    _this.index = index;
    return _this;
  }
  return _createClass(GeoTIFFImageIndexError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var GeoTIFFBase = /*#__PURE__*/function () {
  function GeoTIFFBase() {
    _classCallCheck(this, GeoTIFFBase);
  }
  _createClass(GeoTIFFBase, [{
    key: "readRasters",
    value: (
    /**
     * (experimental) Reads raster data from the best fitting image. This function uses
     * the image with the lowest resolution that is still a higher resolution than the
     * requested resolution.
     * When specified, the `bbox` option is translated to the `window` option and the
     * `resX` and `resY` to `width` and `height` respectively.
     * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected
     * image is called and the result returned.
     * @see GeoTIFFImage.readRasters
     * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise
     */
    function () {
      var _readRasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var options,
          imageWindow,
          width,
          height,
          resX,
          resY,
          bbox,
          firstImage,
          usedImage,
          imageCount,
          imgBBox,
          _firstImage$getOrigin,
          _firstImage$getOrigin2,
          oX,
          oY,
          _firstImage$getResolu,
          _firstImage$getResolu2,
          rX,
          rY,
          usedBBox,
          allImages,
          i,
          image,
          _image$fileDirectory,
          subfileType,
          newSubfileType,
          _i2,
          _image,
          imgResX,
          imgResY,
          wnd,
          _firstImage$getOrigin3,
          _firstImage$getOrigin4,
          _oX,
          _oY,
          _usedImage$getResolut,
          _usedImage$getResolut2,
          imageResX,
          imageResY,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              imageWindow = options.window, width = options.width, height = options.height;
              resX = options.resX, resY = options.resY, bbox = options.bbox;
              _context.next = 5;
              return this.getImage();
            case 5:
              firstImage = _context.sent;
              usedImage = firstImage;
              _context.next = 9;
              return this.getImageCount();
            case 9:
              imageCount = _context.sent;
              imgBBox = firstImage.getBoundingBox();
              if (!(imageWindow && bbox)) {
                _context.next = 13;
                break;
              }
              throw new Error('Both "bbox" and "window" passed.');
            case 13:
              if (!(width || height)) {
                _context.next = 24;
                break;
              }
              // if we have an image window (pixel coordinates), transform it to a BBox
              // using the origin/resolution of the first image.
              if (imageWindow) {
                _firstImage$getOrigin = firstImage.getOrigin(), _firstImage$getOrigin2 = _slicedToArray(_firstImage$getOrigin, 2), oX = _firstImage$getOrigin2[0], oY = _firstImage$getOrigin2[1];
                _firstImage$getResolu = firstImage.getResolution(), _firstImage$getResolu2 = _slicedToArray(_firstImage$getResolu, 2), rX = _firstImage$getResolu2[0], rY = _firstImage$getResolu2[1];
                bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];
              }

              // if we have a bbox (or calculated one)
              usedBBox = bbox || imgBBox;
              if (!width) {
                _context.next = 20;
                break;
              }
              if (!resX) {
                _context.next = 19;
                break;
              }
              throw new Error('Both width and resX passed');
            case 19:
              resX = (usedBBox[2] - usedBBox[0]) / width;
            case 20:
              if (!height) {
                _context.next = 24;
                break;
              }
              if (!resY) {
                _context.next = 23;
                break;
              }
              throw new Error('Both width and resY passed');
            case 23:
              resY = (usedBBox[3] - usedBBox[1]) / height;
            case 24:
              if (!(resX || resY)) {
                _context.next = 48;
                break;
              }
              allImages = [];
              i = 0;
            case 27:
              if (!(i < imageCount)) {
                _context.next = 36;
                break;
              }
              _context.next = 30;
              return this.getImage(i);
            case 30:
              image = _context.sent;
              _image$fileDirectory = image.fileDirectory, subfileType = _image$fileDirectory.SubfileType, newSubfileType = _image$fileDirectory.NewSubfileType;
              if (i === 0 || subfileType === 2 || newSubfileType & 1) {
                allImages.push(image);
              }
            case 33:
              ++i;
              _context.next = 27;
              break;
            case 36:
              allImages.sort(function (a, b) {
                return a.getWidth() - b.getWidth();
              });
              _i2 = 0;
            case 38:
              if (!(_i2 < allImages.length)) {
                _context.next = 48;
                break;
              }
              _image = allImages[_i2];
              imgResX = (imgBBox[2] - imgBBox[0]) / _image.getWidth();
              imgResY = (imgBBox[3] - imgBBox[1]) / _image.getHeight();
              usedImage = _image;
              if (!(resX && resX > imgResX || resY && resY > imgResY)) {
                _context.next = 45;
                break;
              }
              return _context.abrupt("break", 48);
            case 45:
              ++_i2;
              _context.next = 38;
              break;
            case 48:
              wnd = imageWindow;
              if (bbox) {
                _firstImage$getOrigin3 = firstImage.getOrigin(), _firstImage$getOrigin4 = _slicedToArray(_firstImage$getOrigin3, 2), _oX = _firstImage$getOrigin4[0], _oY = _firstImage$getOrigin4[1];
                _usedImage$getResolut = usedImage.getResolution(firstImage), _usedImage$getResolut2 = _slicedToArray(_usedImage$getResolut, 2), imageResX = _usedImage$getResolut2[0], imageResY = _usedImage$getResolut2[1];
                wnd = [Math.round((bbox[0] - _oX) / imageResX), Math.round((bbox[1] - _oY) / imageResY), Math.round((bbox[2] - _oX) / imageResX), Math.round((bbox[3] - _oY) / imageResY)];
                wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];
              }
              return _context.abrupt("return", usedImage.readRasters(_objectSpread(_objectSpread({}, options), {}, {
                window: wnd
              })));
            case 51:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function readRasters() {
        return _readRasters.apply(this, arguments);
      }
      return readRasters;
    }())
  }]);
  return GeoTIFFBase;
}();
/**
 * @typedef {Object} GeoTIFFOptions
 * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.
 */
/**
 * The abstraction for a whole GeoTIFF file.
 * @augments GeoTIFFBase
 */
var GeoTIFF = exports.GeoTIFF = /*#__PURE__*/function (_GeoTIFFBase) {
  _inherits(GeoTIFF, _GeoTIFFBase);
  var _super2 = _createSuper(GeoTIFF);
  /**
   * @constructor
   * @param {*} source The datasource to read from.
   * @param {boolean} littleEndian Whether the image uses little endian.
   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.
   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image
   *                                to the first IFD.
   * @param {GeoTIFFOptions} [options] further options.
   */
  function GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset) {
    var _this2;
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    _classCallCheck(this, GeoTIFF);
    _this2 = _super2.call(this);
    _this2.source = source;
    _this2.littleEndian = littleEndian;
    _this2.bigTiff = bigTiff;
    _this2.firstIFDOffset = firstIFDOffset;
    _this2.cache = options.cache || false;
    _this2.ifdRequests = [];
    _this2.ghostValues = null;
    return _this2;
  }
  _createClass(GeoTIFF, [{
    key: "getSlice",
    value: function () {
      var _getSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(offset, size) {
        var fallbackSize;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              fallbackSize = this.bigTiff ? 4048 : 1024;
              _context2.t0 = _dataslice.default;
              _context2.next = 4;
              return this.source.fetch([{
                offset: offset,
                length: typeof size !== 'undefined' ? size : fallbackSize
              }]);
            case 4:
              _context2.t1 = _context2.sent[0];
              _context2.t2 = offset;
              _context2.t3 = this.littleEndian;
              _context2.t4 = this.bigTiff;
              return _context2.abrupt("return", new _context2.t0(_context2.t1, _context2.t2, _context2.t3, _context2.t4));
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getSlice(_x, _x2) {
        return _getSlice.apply(this, arguments);
      }
      return getSlice;
    }()
    /**
     * Instructs to parse an image file directory at the given file offset.
     * As there is no way to ensure that a location is indeed the start of an IFD,
     * this function must be called with caution (e.g only using the IFD offsets from
     * the headers or other IFDs).
     * @param {number} offset the offset to parse the IFD at
     * @returns {Promise<ImageFileDirectory>} the parsed IFD
     */
  }, {
    key: "parseFileDirectoryAt",
    value: (function () {
      var _parseFileDirectoryAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(offset) {
        var entrySize, offsetSize, dataSlice, numDirEntries, byteSize, fileDirectory, i, entryCount, fieldTag, fieldType, typeCount, fieldValues, value, fieldTypeLength, valueOffset, actualOffset, length, fieldDataSlice, geoKeyDirectory, nextIFDByteOffset;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              entrySize = this.bigTiff ? 20 : 12;
              offsetSize = this.bigTiff ? 8 : 2;
              _context3.next = 4;
              return this.getSlice(offset);
            case 4:
              dataSlice = _context3.sent;
              numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the
              // whole IFD fits: num of entries + n x tag length + offset to next IFD
              byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);
              if (dataSlice.covers(offset, byteSize)) {
                _context3.next = 11;
                break;
              }
              _context3.next = 10;
              return this.getSlice(offset, byteSize);
            case 10:
              dataSlice = _context3.sent;
            case 11:
              fileDirectory = {}; // loop over the IFD and create a file directory object
              i = offset + (this.bigTiff ? 8 : 2);
              entryCount = 0;
            case 14:
              if (!(entryCount < numDirEntries)) {
                _context3.next = 41;
                break;
              }
              fieldTag = dataSlice.readUint16(i);
              fieldType = dataSlice.readUint16(i + 2);
              typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);
              fieldValues = void 0;
              value = void 0;
              fieldTypeLength = getFieldTypeLength(fieldType);
              valueOffset = i + (this.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a
              // different external byte range
              if (!(fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4))) {
                _context3.next = 26;
                break;
              }
              fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);
              _context3.next = 36;
              break;
            case 26:
              // resolve the reference to the actual byte range
              actualOffset = dataSlice.readOffset(valueOffset);
              length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,
              // request a new slice of bytes to read from it
              if (!dataSlice.covers(actualOffset, length)) {
                _context3.next = 32;
                break;
              }
              fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);
              _context3.next = 36;
              break;
            case 32:
              _context3.next = 34;
              return this.getSlice(actualOffset, length);
            case 34:
              fieldDataSlice = _context3.sent;
              fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);
            case 36:
              // unpack single values from the array
              if (typeCount === 1 && _globals.arrayFields.indexOf(fieldTag) === -1 && !(fieldType === _globals.fieldTypes.RATIONAL || fieldType === _globals.fieldTypes.SRATIONAL)) {
                value = fieldValues[0];
              } else {
                value = fieldValues;
              }

              // write the tags value to the file directly
              fileDirectory[_globals.fieldTagNames[fieldTag]] = value;
            case 38:
              i += entrySize, ++entryCount;
              _context3.next = 14;
              break;
            case 41:
              geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);
              nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);
              return _context3.abrupt("return", new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset));
            case 44:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseFileDirectoryAt(_x3) {
        return _parseFileDirectoryAt.apply(this, arguments);
      }
      return parseFileDirectoryAt;
    }())
  }, {
    key: "requestIFD",
    value: function () {
      var _requestIFD = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(index) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.ifdRequests[index]) {
                _context5.next = 4;
                break;
              }
              return _context5.abrupt("return", this.ifdRequests[index]);
            case 4:
              if (!(index === 0)) {
                _context5.next = 9;
                break;
              }
              // special case for index 0
              this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);
              return _context5.abrupt("return", this.ifdRequests[index]);
            case 9:
              if (this.ifdRequests[index - 1]) {
                _context5.next = 19;
                break;
              }
              _context5.prev = 10;
              this.ifdRequests[index - 1] = this.requestIFD(index - 1);
              _context5.next = 19;
              break;
            case 14:
              _context5.prev = 14;
              _context5.t0 = _context5["catch"](10);
              if (!(_context5.t0 instanceof GeoTIFFImageIndexError)) {
                _context5.next = 18;
                break;
              }
              throw new GeoTIFFImageIndexError(index);
            case 18:
              throw _context5.t0;
            case 19:
              // if the previous IFD was loaded, we can finally fetch the one we are interested in.
              // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed
              this.ifdRequests[index] = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                var previousIfd;
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return _this3.ifdRequests[index - 1];
                    case 2:
                      previousIfd = _context4.sent;
                      if (!(previousIfd.nextIFDByteOffset === 0)) {
                        _context4.next = 5;
                        break;
                      }
                      throw new GeoTIFFImageIndexError(index);
                    case 5:
                      return _context4.abrupt("return", _this3.parseFileDirectoryAt(previousIfd.nextIFDByteOffset));
                    case 6:
                    case "end":
                      return _context4.stop();
                  }
                }, _callee4);
              }))();
              return _context5.abrupt("return", this.ifdRequests[index]);
            case 21:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[10, 14]]);
      }));
      function requestIFD(_x4) {
        return _requestIFD.apply(this, arguments);
      }
      return requestIFD;
    }()
    /**
     * Get the n-th internal subfile of an image. By default, the first is returned.
     *
     * @param {number} [index=0] the index of the image to return.
     * @returns {Promise<GeoTIFFImage>} the image at the given index
     */
  }, {
    key: "getImage",
    value: (function () {
      var _getImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var index,
          ifd,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              index = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 0;
              _context6.next = 3;
              return this.requestIFD(index);
            case 3:
              ifd = _context6.sent;
              return _context6.abrupt("return", new _geotiffimage.default(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getImage() {
        return _getImage.apply(this, arguments);
      }
      return getImage;
    }()
    /**
     * Returns the count of the internal subfiles.
     *
     * @returns {Promise<number>} the number of internal subfile images
     */
    )
  }, {
    key: "getImageCount",
    value: (function () {
      var _getImageCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var index, hasNext;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              index = 0; // loop until we run out of IFDs
              hasNext = true;
            case 2:
              if (!hasNext) {
                _context7.next = 18;
                break;
              }
              _context7.prev = 3;
              _context7.next = 6;
              return this.requestIFD(index);
            case 6:
              ++index;
              _context7.next = 16;
              break;
            case 9:
              _context7.prev = 9;
              _context7.t0 = _context7["catch"](3);
              if (!(_context7.t0 instanceof GeoTIFFImageIndexError)) {
                _context7.next = 15;
                break;
              }
              hasNext = false;
              _context7.next = 16;
              break;
            case 15:
              throw _context7.t0;
            case 16:
              _context7.next = 2;
              break;
            case 18:
              return _context7.abrupt("return", index);
            case 19:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[3, 9]]);
      }));
      function getImageCount() {
        return _getImageCount.apply(this, arguments);
      }
      return getImageCount;
    }()
    /**
     * Get the values of the COG ghost area as a parsed map.
     * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference
     * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found
     */
    )
  }, {
    key: "getGhostValues",
    value: (function () {
      var _getGhostValues = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var _this4 = this;
        var offset, detectionString, heuristicAreaSize, slice, valuesString, firstLine, metadataSize, fullString;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              offset = this.bigTiff ? 16 : 8;
              if (!this.ghostValues) {
                _context8.next = 3;
                break;
              }
              return _context8.abrupt("return", this.ghostValues);
            case 3:
              detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';
              heuristicAreaSize = detectionString.length + 100;
              _context8.next = 7;
              return this.getSlice(offset, heuristicAreaSize);
            case 7:
              slice = _context8.sent;
              if (!(detectionString === getValues(slice, _globals.fieldTypes.ASCII, detectionString.length, offset))) {
                _context8.next = 19;
                break;
              }
              valuesString = getValues(slice, _globals.fieldTypes.ASCII, heuristicAreaSize, offset);
              firstLine = valuesString.split('\n')[0];
              metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;
              if (!(metadataSize > heuristicAreaSize)) {
                _context8.next = 16;
                break;
              }
              _context8.next = 15;
              return this.getSlice(offset, metadataSize);
            case 15:
              slice = _context8.sent;
            case 16:
              fullString = getValues(slice, _globals.fieldTypes.ASCII, metadataSize, offset);
              this.ghostValues = {};
              fullString.split('\n').filter(function (line) {
                return line.length > 0;
              }).map(function (line) {
                return line.split('=');
              }).forEach(function (_ref2) {
                var _ref3 = _slicedToArray(_ref2, 2),
                  key = _ref3[0],
                  value = _ref3[1];
                _this4.ghostValues[key] = value;
              });
            case 19:
              return _context8.abrupt("return", this.ghostValues);
            case 20:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getGhostValues() {
        return _getGhostValues.apply(this, arguments);
      }
      return getGhostValues;
    }()
    /**
     * Parse a (Geo)TIFF file from the given source.
     *
     * @param {*} source The source of data to parse from.
     * @param {GeoTIFFOptions} [options] Additional options.
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     */
    )
  }, {
    key: "close",
    value:
    /**
     * Closes the underlying file buffer
     * N.B. After the GeoTIFF has been completely processed it needs
     * to be closed but only if it has been constructed from a file.
     */
    function close() {
      if (typeof this.source.close === 'function') {
        return this.source.close();
      }
      return false;
    }
  }], [{
    key: "fromSource",
    value: (function () {
      var _fromSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(source, options, signal) {
        var headerData, dataView, BOM, littleEndian, magicNumber, bigTiff, offsetByteSize, firstIFDOffset;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return source.fetch([{
                offset: 0,
                length: 1024
              }], signal);
            case 2:
              headerData = _context9.sent[0];
              dataView = new _dataview.default(headerData);
              BOM = dataView.getUint16(0, 0);
              if (!(BOM === 0x4949)) {
                _context9.next = 9;
                break;
              }
              littleEndian = true;
              _context9.next = 14;
              break;
            case 9:
              if (!(BOM === 0x4D4D)) {
                _context9.next = 13;
                break;
              }
              littleEndian = false;
              _context9.next = 14;
              break;
            case 13:
              throw new TypeError('Invalid byte order value.');
            case 14:
              magicNumber = dataView.getUint16(2, littleEndian);
              if (!(magicNumber === 42)) {
                _context9.next = 19;
                break;
              }
              bigTiff = false;
              _context9.next = 27;
              break;
            case 19:
              if (!(magicNumber === 43)) {
                _context9.next = 26;
                break;
              }
              bigTiff = true;
              offsetByteSize = dataView.getUint16(4, littleEndian);
              if (!(offsetByteSize !== 8)) {
                _context9.next = 24;
                break;
              }
              throw new Error('Unsupported offset byte-size.');
            case 24:
              _context9.next = 27;
              break;
            case 26:
              throw new TypeError('Invalid magic number.');
            case 27:
              firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);
              return _context9.abrupt("return", new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options));
            case 29:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function fromSource(_x5, _x6, _x7) {
        return _fromSource.apply(this, arguments);
      }
      return fromSource;
    }())
  }]);
  return GeoTIFF;
}(GeoTIFFBase);
var _default = exports.default = GeoTIFF;
/**
 * Wrapper for GeoTIFF files that have external overviews.
 * @augments GeoTIFFBase
 */
var MultiGeoTIFF = exports.MultiGeoTIFF = /*#__PURE__*/function (_GeoTIFFBase2) {
  _inherits(MultiGeoTIFF, _GeoTIFFBase2);
  var _super3 = _createSuper(MultiGeoTIFF);
  /**
   * Construct a new MultiGeoTIFF from a main and several overview files.
   * @param {GeoTIFF} mainFile The main GeoTIFF file.
   * @param {GeoTIFF[]} overviewFiles An array of overview files.
   */
  function MultiGeoTIFF(mainFile, overviewFiles) {
    var _this5;
    _classCallCheck(this, MultiGeoTIFF);
    _this5 = _super3.call(this);
    _this5.mainFile = mainFile;
    _this5.overviewFiles = overviewFiles;
    _this5.imageFiles = [mainFile].concat(overviewFiles);
    _this5.fileDirectoriesPerFile = null;
    _this5.fileDirectoriesPerFileParsing = null;
    _this5.imageCount = null;
    return _this5;
  }
  _createClass(MultiGeoTIFF, [{
    key: "parseFileDirectoriesPerFile",
    value: function () {
      var _parseFileDirectoriesPerFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var requests;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (file) {
                return file.parseFileDirectoryAt(file.firstIFDOffset);
              }));
              _context10.next = 3;
              return Promise.all(requests);
            case 3:
              this.fileDirectoriesPerFile = _context10.sent;
              return _context10.abrupt("return", this.fileDirectoriesPerFile);
            case 5:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function parseFileDirectoriesPerFile() {
        return _parseFileDirectoriesPerFile.apply(this, arguments);
      }
      return parseFileDirectoriesPerFile;
    }()
    /**
     * Get the n-th internal subfile of an image. By default, the first is returned.
     *
     * @param {number} [index=0] the index of the image to return.
     * @returns {Promise<GeoTIFFImage>} the image at the given index
     */
  }, {
    key: "getImage",
    value: (function () {
      var _getImage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var index,
          visited,
          relativeIndex,
          i,
          imageFile,
          ii,
          ifd,
          _args11 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              index = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 0;
              _context11.next = 3;
              return this.getImageCount();
            case 3:
              _context11.next = 5;
              return this.parseFileDirectoriesPerFile();
            case 5:
              visited = 0;
              relativeIndex = 0;
              i = 0;
            case 8:
              if (!(i < this.imageFiles.length)) {
                _context11.next = 26;
                break;
              }
              imageFile = this.imageFiles[i];
              ii = 0;
            case 11:
              if (!(ii < this.imageCounts[i])) {
                _context11.next = 22;
                break;
              }
              if (!(index === visited)) {
                _context11.next = 17;
                break;
              }
              _context11.next = 15;
              return imageFile.requestIFD(relativeIndex);
            case 15:
              ifd = _context11.sent;
              return _context11.abrupt("return", new _geotiffimage.default(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source));
            case 17:
              visited++;
              relativeIndex++;
            case 19:
              ii++;
              _context11.next = 11;
              break;
            case 22:
              relativeIndex = 0;
            case 23:
              i++;
              _context11.next = 8;
              break;
            case 26:
              throw new RangeError('Invalid image index');
            case 27:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getImage() {
        return _getImage2.apply(this, arguments);
      }
      return getImage;
    }()
    /**
     * Returns the count of the internal subfiles.
     *
     * @returns {Promise<number>} the number of internal subfile images
     */
    )
  }, {
    key: "getImageCount",
    value: (function () {
      var _getImageCount2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var requests;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              if (!(this.imageCount !== null)) {
                _context12.next = 2;
                break;
              }
              return _context12.abrupt("return", this.imageCount);
            case 2:
              requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (file) {
                return file.getImageCount();
              }));
              _context12.next = 5;
              return Promise.all(requests);
            case 5:
              this.imageCounts = _context12.sent;
              this.imageCount = this.imageCounts.reduce(function (count, ifds) {
                return count + ifds;
              }, 0);
              return _context12.abrupt("return", this.imageCount);
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function getImageCount() {
        return _getImageCount2.apply(this, arguments);
      }
      return getImageCount;
    }())
  }]);
  return MultiGeoTIFF;
}(GeoTIFFBase);
/**
 * Creates a new GeoTIFF from a remote URL.
 * @param {string} url The URL to access the image from
 * @param {object} [options] Additional options to pass to the source.
 *                           See {@link makeRemoteSource} for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */
function fromUrl(_x8) {
  return _fromUrl.apply(this, arguments);
}
/**
 * Creates a new GeoTIFF from a custom {@link BaseClient}.
 * @param {BaseClient} client The client.
 * @param {object} [options] Additional options to pass to the source.
 *                           See {@link makeRemoteSource} for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */
function _fromUrl() {
  _fromUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(url) {
    var options,
      signal,
      _args13 = arguments;
    return _regeneratorRuntime().wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
          signal = _args13.length > 2 ? _args13[2] : undefined;
          return _context13.abrupt("return", GeoTIFF.fromSource((0, _remote.makeRemoteSource)(url, options), signal));
        case 3:
        case "end":
          return _context13.stop();
      }
    }, _callee13);
  }));
  return _fromUrl.apply(this, arguments);
}
function fromCustomClient(_x9) {
  return _fromCustomClient.apply(this, arguments);
}
/**
 * Construct a new GeoTIFF from an
 * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.
 * @param {ArrayBuffer} arrayBuffer The data to read the file from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */
function _fromCustomClient() {
  _fromCustomClient = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(client) {
    var options,
      signal,
      _args14 = arguments;
    return _regeneratorRuntime().wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
          signal = _args14.length > 2 ? _args14[2] : undefined;
          return _context14.abrupt("return", GeoTIFF.fromSource((0, _remote.makeCustomSource)(client, options), signal));
        case 3:
        case "end":
          return _context14.stop();
      }
    }, _callee14);
  }));
  return _fromCustomClient.apply(this, arguments);
}
function fromArrayBuffer(_x10, _x11) {
  return _fromArrayBuffer.apply(this, arguments);
}
/**
 * Construct a GeoTIFF from a local file path. This uses the node
 * [filesystem API]{@link https://nodejs.org/api/fs.html} and is
 * not available on browsers.
 *
 * N.B. After the GeoTIFF has been completely processed it needs
 * to be closed but only if it has been constructed from a file.
 * @param {string} path The file path to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */
function _fromArrayBuffer() {
  _fromArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(arrayBuffer, signal) {
    return _regeneratorRuntime().wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          return _context15.abrupt("return", GeoTIFF.fromSource((0, _arraybuffer.makeBufferSource)(arrayBuffer), signal));
        case 1:
        case "end":
          return _context15.stop();
      }
    }, _callee15);
  }));
  return _fromArrayBuffer.apply(this, arguments);
}
function fromFile(_x12, _x13) {
  return _fromFile.apply(this, arguments);
}
/**
 * Construct a GeoTIFF from an HTML
 * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or
 * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}
 * object.
 * @param {Blob|File} blob The Blob or File object to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */
function _fromFile() {
  _fromFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(path, signal) {
    return _regeneratorRuntime().wrap(function _callee16$(_context16) {
      while (1) switch (_context16.prev = _context16.next) {
        case 0:
          return _context16.abrupt("return", GeoTIFF.fromSource((0, _file.makeFileSource)(path), signal));
        case 1:
        case "end":
          return _context16.stop();
      }
    }, _callee16);
  }));
  return _fromFile.apply(this, arguments);
}
function fromBlob(_x14, _x15) {
  return _fromBlob.apply(this, arguments);
}
/**
 * Construct a MultiGeoTIFF from the given URLs.
 * @param {string} mainUrl The URL for the main file.
 * @param {string[]} overviewUrls An array of URLs for the overview images.
 * @param {Object} [options] Additional options to pass to the source.
 *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}
 *                           for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.
 */
function _fromBlob() {
  _fromBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(blob, signal) {
    return _regeneratorRuntime().wrap(function _callee17$(_context17) {
      while (1) switch (_context17.prev = _context17.next) {
        case 0:
          return _context17.abrupt("return", GeoTIFF.fromSource((0, _filereader.makeFileReaderSource)(blob), signal));
        case 1:
        case "end":
          return _context17.stop();
      }
    }, _callee17);
  }));
  return _fromBlob.apply(this, arguments);
}
function fromUrls(_x16) {
  return _fromUrls.apply(this, arguments);
}
/**
 * Main creating function for GeoTIFF files.
 * @param {(Array)} array of pixel values
 * @returns {metadata} metadata
 */
function _fromUrls() {
  _fromUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(mainUrl) {
    var overviewUrls,
      options,
      signal,
      mainFile,
      overviewFiles,
      _args18 = arguments;
    return _regeneratorRuntime().wrap(function _callee18$(_context18) {
      while (1) switch (_context18.prev = _context18.next) {
        case 0:
          overviewUrls = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : [];
          options = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : {};
          signal = _args18.length > 3 ? _args18[3] : undefined;
          _context18.next = 5;
          return GeoTIFF.fromSource((0, _remote.makeRemoteSource)(mainUrl, options), signal);
        case 5:
          mainFile = _context18.sent;
          _context18.next = 8;
          return Promise.all(overviewUrls.map(function (url) {
            return GeoTIFF.fromSource((0, _remote.makeRemoteSource)(url, options));
          }));
        case 8:
          overviewFiles = _context18.sent;
          return _context18.abrupt("return", new MultiGeoTIFF(mainFile, overviewFiles));
        case 10:
        case "end":
          return _context18.stop();
      }
    }, _callee18);
  }));
  return _fromUrls.apply(this, arguments);
}
function writeArrayBuffer(values, metadata) {
  return (0, _geotiffwriter.writeGeotiff)(values, metadata);
}
},{"./geotiffimage.js":"node_modules/geotiff/dist-module/geotiffimage.js","./dataview64.js":"node_modules/geotiff/dist-module/dataview64.js","./dataslice.js":"node_modules/geotiff/dist-module/dataslice.js","./pool.js":"node_modules/geotiff/dist-module/pool.js","./source/remote.js":"node_modules/geotiff/dist-module/source/remote.js","./source/arraybuffer.js":"node_modules/geotiff/dist-module/source/arraybuffer.js","./source/filereader.js":"node_modules/geotiff/dist-module/source/filereader.js","./source/file.js":"node_modules/geotiff/dist-module/source/file.js","./source/client/base.js":"node_modules/geotiff/dist-module/source/client/base.js","./globals.js":"node_modules/geotiff/dist-module/globals.js","./geotiffwriter.js":"node_modules/geotiff/dist-module/geotiffwriter.js","./rgb.js":"node_modules/geotiff/dist-module/rgb.js","./compression/index.js":"node_modules/geotiff/dist-module/compression/index.js","./logging.js":"node_modules/geotiff/dist-module/logging.js","./compression/basedecoder.js":"node_modules/geotiff/dist-module/compression/basedecoder.js"}],"node_modules/ol/source/GeoTIFF.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _DataTile2 = _interopRequireDefault(require("./DataTile.js"));
var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));
var _geotiff = require("geotiff");
var _proj = require("../proj.js");
var _math = require("../math.js");
var _extent = require("../extent.js");
var _console = require("../console.js");
var _Units = require("../proj/Units.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/GeoTIFF
 */
/**
 * Determine if an image type is a mask.
 * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html
 * @param {GeoTIFFImage} image The image.
 * @return {boolean} The image is a mask.
 */
function isMask(image) {
  var fileDirectory = image.fileDirectory;
  var type = fileDirectory.NewSubfileType || 0;
  return (type & 4) === 4;
}

/**
 * @param {true|false|'auto'} preference The convertToRGB option.
 * @param {GeoTIFFImage} image The image.
 * @return {boolean} Use the `image.readRGB()` method.
 */
function readRGB(preference, image) {
  if (!preference) {
    return false;
  }
  if (preference === true) {
    return true;
  }
  if (image.getSamplesPerPixel() !== 3) {
    return false;
  }
  var interpretation = image.fileDirectory.PhotometricInterpretation;
  var interpretations = _geotiff.globals.photometricInterpretations;
  return interpretation === interpretations.CMYK || interpretation === interpretations.YCbCr || interpretation === interpretations.CIELab || interpretation === interpretations.ICCLab;
}

/**
 * @typedef {Object} SourceInfo
 * @property {string} [url] URL for the source GeoTIFF.
 * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.
 * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.
 * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
 * If neither are available, the minimum for the data type will be used.  To disable this behavior, set
 * the `normalize` option to `false` in the constructor.
 * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
 * If neither are available, the maximum for the data type will be used.  To disable this behavior, set
 * the `normalize` option to `false` in the constructor.
 * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).
 * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata
 * will include information about nodata values, so you should only need to set this property if
 * you find that it is not already extracted from the metadata.
 * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will
 * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the
 * near-infrared band, configure `bands: [4]`.
 */

/**
 * @typedef {Object} GeoKeys
 * @property {number} GTModelTypeGeoKey Model type.
 * @property {number} GTRasterTypeGeoKey Raster type.
 * @property {number} GeogAngularUnitsGeoKey Angular units.
 * @property {number} GeogInvFlatteningGeoKey Inverse flattening.
 * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.
 * @property {number} GeographicTypeGeoKey Geographic coordinate system code.
 * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.
 * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.
 */

/**
 * @typedef {import("geotiff").GeoTIFF} GeoTIFF
 */

/**
 * @typedef {import("geotiff").MultiGeoTIFF} MultiGeoTIFF
 */

/**
 * @typedef {Object} GDALMetadata
 * @property {string} STATISTICS_MINIMUM The minimum value (as a string).
 * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).
 */

var STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';
var STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';
var defaultTileSize = 256;

/**
 * @typedef {import("geotiff").GeoTIFFImage} GeoTIFFImage
 */

var workerPool;
function getWorkerPool() {
  if (!workerPool) {
    workerPool = new _geotiff.Pool();
  }
  return workerPool;
}

/**
 * Get the bounding box of an image.  If the image does not have an affine transform,
 * the pixel bounds are returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image bounding box.
 */
function getBoundingBox(image) {
  try {
    return image.getBoundingBox();
  } catch (_) {
    return [0, 0, image.getWidth(), image.getHeight()];
  }
}

/**
 * Get the origin of an image.  If the image does not have an affine transform,
 * the top-left corner of the pixel bounds is returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image origin.
 */
function getOrigin(image) {
  try {
    return image.getOrigin().slice(0, 2);
  } catch (_) {
    return [0, image.getHeight()];
  }
}

/**
 * Get the resolution of an image.  If the image does not have an affine transform,
 * the width of the image is compared with the reference image.
 * @param {GeoTIFFImage} image The image.
 * @param {GeoTIFFImage} referenceImage The reference image.
 * @return {Array<number>} The map x and y units per pixel.
 */
function getResolutions(image, referenceImage) {
  try {
    return image.getResolution(referenceImage);
  } catch (_) {
    return [referenceImage.getWidth() / image.getWidth(), referenceImage.getHeight() / image.getHeight()];
  }
}

/**
 * @param {GeoTIFFImage} image A GeoTIFF.
 * @return {import("../proj/Projection.js").default} The image projection.
 */
function getProjection(image) {
  var geoKeys = image.geoKeys;
  if (!geoKeys) {
    return null;
  }
  if (geoKeys.ProjectedCSTypeGeoKey && geoKeys.ProjectedCSTypeGeoKey !== 32767) {
    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;
    var projection = (0, _proj.get)(code);
    if (!projection) {
      var units = (0, _Units.fromCode)(geoKeys.ProjLinearUnitsGeoKey);
      if (units) {
        projection = new _proj.Projection({
          code: code,
          units: units
        });
      }
    }
    return projection;
  }
  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {
    var _code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;
    var _projection = (0, _proj.get)(_code);
    if (!_projection) {
      var _units = (0, _Units.fromCode)(geoKeys.GeogAngularUnitsGeoKey);
      if (_units) {
        _projection = new _proj.Projection({
          code: _code,
          units: _units
        });
      }
    }
    return _projection;
  }
  return null;
}

/**
 * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.
 * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
 */
function getImagesForTIFF(tiff) {
  return tiff.getImageCount().then(function (count) {
    var requests = new Array(count);
    for (var i = 0; i < count; ++i) {
      requests[i] = tiff.getImage(i);
    }
    return Promise.all(requests);
  });
}

/**
 * @param {SourceInfo} source The GeoTIFF source.
 * @param {Object} options Options for the GeoTIFF source.
 * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
 */
function getImagesForSource(source, options) {
  var request;
  if (source.blob) {
    request = (0, _geotiff.fromBlob)(source.blob);
  } else if (source.overviews) {
    request = (0, _geotiff.fromUrls)(source.url, source.overviews, options);
  } else {
    request = (0, _geotiff.fromUrl)(source.url, options);
  }
  return request.then(getImagesForTIFF);
}

/**
 * @param {number|Array<number>|Array<Array<number>>} expected Expected value.
 * @param {number|Array<number>|Array<Array<number>>} got Actual value.
 * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.
 * @param {string} message The error message.
 * @param {function(Error):void} rejector A function to be called with any error.
 */
function assertEqual(expected, got, tolerance, message, rejector) {
  if (Array.isArray(expected)) {
    var length = expected.length;
    if (!Array.isArray(got) || length != got.length) {
      var error = new Error(message);
      rejector(error);
      throw error;
    }
    for (var i = 0; i < length; ++i) {
      assertEqual(expected[i], got[i], tolerance, message, rejector);
    }
    return;
  }
  got = /** @type {number} */got;
  if (Math.abs(expected - got) > tolerance * expected) {
    throw new Error(message);
  }
}

/**
 * @param {Array} array The data array.
 * @return {number} The minimum value.
 */
function getMinForDataType(array) {
  if (array instanceof Int8Array) {
    return -128;
  }
  if (array instanceof Int16Array) {
    return -32768;
  }
  if (array instanceof Int32Array) {
    return -2147483648;
  }
  if (array instanceof Float32Array) {
    return 1.2e-38;
  }
  return 0;
}

/**
 * @param {Array} array The data array.
 * @return {number} The maximum value.
 */
function getMaxForDataType(array) {
  if (array instanceof Int8Array) {
    return 127;
  }
  if (array instanceof Uint8Array) {
    return 255;
  }
  if (array instanceof Uint8ClampedArray) {
    return 255;
  }
  if (array instanceof Int16Array) {
    return 32767;
  }
  if (array instanceof Uint16Array) {
    return 65535;
  }
  if (array instanceof Int32Array) {
    return 2147483647;
  }
  if (array instanceof Uint32Array) {
    return 4294967295;
  }
  if (array instanceof Float32Array) {
    return 3.4e38;
  }
  return 255;
}

/**
 * @typedef {Object} GeoTIFFSourceOptions
 * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.
 * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.
 * @property {string} [credentials] How credentials shall be handled. See
 * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values
 * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.
 * By default only a single range is used.
 * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is
 * requested. Only use this when you know the source image to be small enough to fit in memory.
 * @property {number} [blockSize=65536] The block size to use.
 * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.
 */

/**
 * @typedef {Object} Options
 * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.
 * Multiple sources can be combined when their resolution sets are equal after applying a scale.
 * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
 * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
 * use the {@link import("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
 * sources, one with 3 bands and {@link import("./GeoTIFF.js").SourceInfo nodata} configured, and
 * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
 * band from the first source, and 1 band from the second source.
 * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.
 * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When
 * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
 * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,
 * CIELab, and ICCLab images will automatically be converted to RGB.
 * @property {boolean} [normalize=true] By default, the source data is normalized to values between
 * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.
 * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option
 * to `false` will make it so any `min` and `max` properties on sources are ignored.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata
 * will be read for projection information.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.
 */

/**
 * @classdesc
 * A source for working with GeoTIFF data.
 * **Note for users of the full build**: The `GeoTIFF` source requires the
 * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.
 *
 * @api
 */
var GeoTIFFSource = /*#__PURE__*/function (_DataTile) {
  _inherits(GeoTIFFSource, _DataTile);
  var _super = _createSuper(GeoTIFFSource);
  /**
   * @param {Options} options Data tile options.
   */
  function GeoTIFFSource(options) {
    var _this;
    _classCallCheck(this, GeoTIFFSource);
    _this = _super.call(this, {
      state: 'loading',
      tileGrid: null,
      projection: options.projection || null,
      opaque: options.opaque,
      transition: options.transition,
      interpolate: options.interpolate !== false,
      wrapX: options.wrapX
    });

    /**
     * @type {Array<SourceInfo>}
     * @private
     */
    _this.sourceInfo_ = options.sources;
    var numSources = _this.sourceInfo_.length;

    /**
     * @type {Object}
     * @private
     */
    _this.sourceOptions_ = options.sourceOptions;

    /**
     * @type {Array<Array<GeoTIFFImage>>}
     * @private
     */
    _this.sourceImagery_ = new Array(numSources);

    /**
     * @type {Array<Array<GeoTIFFImage>>}
     * @private
     */
    _this.sourceMasks_ = new Array(numSources);

    /**
     * @type {Array<number>}
     * @private
     */
    _this.resolutionFactors_ = new Array(numSources);

    /**
     * @type {Array<number>}
     * @private
     */
    _this.samplesPerPixel_;

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    _this.nodataValues_;

    /**
     * @type {Array<Array<GDALMetadata>>}
     * @private
     */
    _this.metadata_;

    /**
     * @type {boolean}
     * @private
     */
    _this.normalize_ = options.normalize !== false;

    /**
     * @type {boolean}
     * @private
     */
    _this.addAlpha_ = false;

    /**
     * @type {Error}
     * @private
     */
    _this.error_ = null;

    /**
     * @type {true|false|'auto'}
     */
    _this.convertToRGB_ = options.convertToRGB || false;
    _this.setKey(_this.sourceInfo_.map(function (source) {
      return source.url;
    }).join(','));
    var self = _assertThisInitialized(_this);
    var requests = new Array(numSources);
    for (var i = 0; i < numSources; ++i) {
      requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);
    }
    Promise.all(requests).then(function (sources) {
      self.configure_(sources);
    }).catch(function (error) {
      (0, _console.error)(error);
      self.error_ = error;
      self.setState('error');
    });
    return _this;
  }

  /**
   * @return {Error} A source loading error. When the source state is `error`, use this function
   * to get more information about the error. To debug a faulty configuration, you may want to use
   * a listener like
   * ```js
   * geotiffSource.on('change', () => {
   *   if (geotiffSource.getState() === 'error') {
   *     console.error(geotiffSource.getError());
   *   }
   * });
   * ```
   */
  _createClass(GeoTIFFSource, [{
    key: "getError",
    value: function getError() {
      return this.error_;
    }

    /**
     * Determine the projection of the images in this GeoTIFF.
     * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey
     * of each image in turn.
     * You can override this method in a subclass to support more projections.
     *
     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     */
  }, {
    key: "determineProjection",
    value: function determineProjection(sources) {
      var firstSource = sources[0];
      for (var i = firstSource.length - 1; i >= 0; --i) {
        var image = firstSource[i];
        var projection = getProjection(image);
        if (projection) {
          this.projection = projection;
          break;
        }
      }
    }

    /**
     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
     * must have the same internal tiled structure.
     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     * @private
     */
  }, {
    key: "configure_",
    value: function configure_(sources) {
      var _this2 = this;
      var extent;
      var origin;
      var commonRenderTileSizes;
      var commonSourceTileSizes;
      var resolutions;
      var samplesPerPixel = new Array(sources.length);
      var nodataValues = new Array(sources.length);
      var metadata = new Array(sources.length);
      var minZoom = 0;
      var sourceCount = sources.length;
      var _loop = function _loop() {
        var images = [];
        var masks = [];
        sources[sourceIndex].forEach(function (item) {
          if (isMask(item)) {
            masks.push(item);
          } else {
            images.push(item);
          }
        });
        var imageCount = images.length;
        if (masks.length > 0 && masks.length !== imageCount) {
          throw new Error("Expected one mask per image found ".concat(masks.length, " masks and ").concat(imageCount, " images"));
        }
        var sourceExtent;
        var sourceOrigin;
        var sourceTileSizes = new Array(imageCount);
        var renderTileSizes = new Array(imageCount);
        var sourceResolutions = new Array(imageCount);
        nodataValues[sourceIndex] = new Array(imageCount);
        metadata[sourceIndex] = new Array(imageCount);
        for (var _imageIndex = 0; _imageIndex < imageCount; ++_imageIndex) {
          var image = images[_imageIndex];
          var nodataValue = image.getGDALNoData();
          metadata[sourceIndex][_imageIndex] = image.getGDALMetadata(0);
          nodataValues[sourceIndex][_imageIndex] = nodataValue;
          var wantedSamples = _this2.sourceInfo_[sourceIndex].bands;
          samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();
          var level = imageCount - (_imageIndex + 1);
          if (!sourceExtent) {
            sourceExtent = getBoundingBox(image);
          }
          if (!sourceOrigin) {
            sourceOrigin = getOrigin(image);
          }
          var imageResolutions = getResolutions(image, images[0]);
          sourceResolutions[level] = imageResolutions[0];
          var sourceTileSize = [image.getTileWidth(), image.getTileHeight()];

          // request larger blocks for untiled layouts
          if (sourceTileSize[0] !== sourceTileSize[1] && sourceTileSize[1] < defaultTileSize) {
            sourceTileSize[0] = defaultTileSize;
            sourceTileSize[1] = defaultTileSize;
          }
          sourceTileSizes[level] = sourceTileSize;
          var aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);
          renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];
        }
        if (!extent) {
          extent = sourceExtent;
        } else {
          (0, _extent.getIntersection)(extent, sourceExtent, extent);
        }
        if (!origin) {
          origin = sourceOrigin;
        } else {
          var message = "Origin mismatch for source ".concat(sourceIndex, ", got [").concat(sourceOrigin, "] but expected [").concat(origin, "]");
          assertEqual(origin, sourceOrigin, 0, message, _this2.viewRejector);
        }
        if (!resolutions) {
          resolutions = sourceResolutions;
          _this2.resolutionFactors_[sourceIndex] = 1;
        } else {
          if (resolutions.length - minZoom > sourceResolutions.length) {
            minZoom = resolutions.length - sourceResolutions.length;
          }
          var resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
          _this2.resolutionFactors_[sourceIndex] = resolutionFactor;
          var scaledSourceResolutions = sourceResolutions.map(function (resolution) {
            return resolution *= resolutionFactor;
          });
          var _message = "Resolution mismatch for source ".concat(sourceIndex, ", got [").concat(scaledSourceResolutions, "] but expected [").concat(resolutions, "]");
          assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, _message, _this2.viewRejector);
        }
        if (!commonRenderTileSizes) {
          commonRenderTileSizes = renderTileSizes;
        } else {
          assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, "Tile size mismatch for source ".concat(sourceIndex), _this2.viewRejector);
        }
        if (!commonSourceTileSizes) {
          commonSourceTileSizes = sourceTileSizes;
        } else {
          assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, "Tile size mismatch for source ".concat(sourceIndex), _this2.viewRejector);
        }
        _this2.sourceImagery_[sourceIndex] = images.reverse();
        _this2.sourceMasks_[sourceIndex] = masks.reverse();
      };
      for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
        _loop();
      }
      for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {
        var sourceImagery = this.sourceImagery_[i];
        while (sourceImagery.length < resolutions.length) {
          sourceImagery.unshift(undefined);
        }
      }
      if (!this.getProjection()) {
        this.determineProjection(sources);
      }
      this.samplesPerPixel_ = samplesPerPixel;
      this.nodataValues_ = nodataValues;
      this.metadata_ = metadata;

      // decide if we need to add an alpha band to handle nodata
      outer: for (var _sourceIndex = 0; _sourceIndex < sourceCount; ++_sourceIndex) {
        // option 1: source is configured with a nodata value
        if (this.sourceInfo_[_sourceIndex].nodata !== undefined) {
          this.addAlpha_ = true;
          break;
        }
        if (this.sourceMasks_[_sourceIndex].length) {
          this.addAlpha_ = true;
          break;
        }
        var values = nodataValues[_sourceIndex];

        // option 2: check image metadata for limited bands
        var bands = this.sourceInfo_[_sourceIndex].bands;
        if (bands) {
          for (var _i = 0; _i < bands.length; ++_i) {
            if (values[bands[_i] - 1] !== null) {
              this.addAlpha_ = true;
              break outer;
            }
          }
          continue;
        }

        // option 3: check image metadata for all bands
        for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {
          if (values[imageIndex] !== null) {
            this.addAlpha_ = true;
            break outer;
          }
        }
      }
      var bandCount = this.addAlpha_ ? 1 : 0;
      for (var _sourceIndex2 = 0; _sourceIndex2 < sourceCount; ++_sourceIndex2) {
        bandCount += samplesPerPixel[_sourceIndex2];
      }
      this.bandCount = bandCount;
      var tileGrid = new _TileGrid.default({
        extent: extent,
        minZoom: minZoom,
        origin: origin,
        resolutions: resolutions,
        tileSizes: commonRenderTileSizes
      });
      this.tileGrid = tileGrid;
      this.setTileSizes(commonSourceTileSizes);
      this.setLoader(this.loadTile_.bind(this));
      this.setState('ready');
      var zoom = 1;
      if (resolutions.length === 2) {
        resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];
      } else if (resolutions.length === 1) {
        resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];
      }
      this.viewResolver({
        showFullExtent: true,
        projection: this.projection,
        resolutions: resolutions,
        center: (0, _proj.toUserCoordinate)((0, _extent.getCenter)(extent), this.projection),
        extent: (0, _proj.toUserExtent)(extent, this.projection),
        zoom: zoom
      });
    }

    /**
     * @param {number} z The z tile index.
     * @param {number} x The x tile index.
     * @param {number} y The y tile index.
     * @return {Promise} The composed tile data.
     * @private
     */
  }, {
    key: "loadTile_",
    value: function loadTile_(z, x, y) {
      var _this3 = this;
      var sourceTileSize = this.getTileSize(z);
      var sourceCount = this.sourceImagery_.length;
      var requests = new Array(sourceCount * 2);
      var nodataValues = this.nodataValues_;
      var sourceInfo = this.sourceInfo_;
      var pool = getWorkerPool();
      var _loop2 = function _loop2(sourceIndex) {
        var source = sourceInfo[sourceIndex];
        var resolutionFactor = _this3.resolutionFactors_[sourceIndex];
        var pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];
        var image = _this3.sourceImagery_[sourceIndex][z];
        var samples;
        if (source.bands) {
          samples = source.bands.map(function (bandNumber) {
            return bandNumber - 1;
          });
        }

        /** @type {number|Array<number>} */
        var fillValue;
        if ('nodata' in source && source.nodata !== null) {
          fillValue = source.nodata;
        } else {
          if (!samples) {
            fillValue = nodataValues[sourceIndex];
          } else {
            fillValue = samples.map(function (sampleIndex) {
              return nodataValues[sourceIndex][sampleIndex];
            });
          }
        }
        var readOptions = {
          window: pixelBounds,
          width: sourceTileSize[0],
          height: sourceTileSize[1],
          samples: samples,
          fillValue: fillValue,
          pool: pool,
          interleave: false
        };
        if (readRGB(_this3.convertToRGB_, image)) {
          requests[sourceIndex] = image.readRGB(readOptions);
        } else {
          requests[sourceIndex] = image.readRasters(readOptions);
        }

        // requests after `sourceCount` are for mask data (if any)
        var maskIndex = sourceCount + sourceIndex;
        var mask = _this3.sourceMasks_[sourceIndex][z];
        if (!mask) {
          requests[maskIndex] = Promise.resolve(null);
          return 1; // continue
        }
        requests[maskIndex] = mask.readRasters({
          window: pixelBounds,
          width: sourceTileSize[0],
          height: sourceTileSize[1],
          samples: [0],
          pool: pool,
          interleave: false
        });
      };
      for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
        if (_loop2(sourceIndex)) continue;
      }
      return Promise.all(requests).then(this.composeTile_.bind(this, sourceTileSize)).catch(function (error) {
        (0, _console.error)(error);
        throw error;
      });
    }

    /**
     * @param {import("../size.js").Size} sourceTileSize The source tile size.
     * @param {Array} sourceSamples The source samples.
     * @return {import("../DataTile.js").Data} The composed tile data.
     * @private
     */
  }, {
    key: "composeTile_",
    value: function composeTile_(sourceTileSize, sourceSamples) {
      var metadata = this.metadata_;
      var sourceInfo = this.sourceInfo_;
      var sourceCount = this.sourceImagery_.length;
      var bandCount = this.bandCount;
      var samplesPerPixel = this.samplesPerPixel_;
      var nodataValues = this.nodataValues_;
      var normalize = this.normalize_;
      var addAlpha = this.addAlpha_;
      var pixelCount = sourceTileSize[0] * sourceTileSize[1];
      var dataLength = pixelCount * bandCount;

      /** @type {Uint8Array|Float32Array} */
      var data;
      if (normalize) {
        data = new Uint8Array(dataLength);
      } else {
        data = new Float32Array(dataLength);
      }
      var dataIndex = 0;
      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {
        var transparent = addAlpha;
        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
          var source = sourceInfo[sourceIndex];
          var min = source.min;
          var max = source.max;
          var gain = void 0,
            bias = void 0;
          if (normalize) {
            var stats = metadata[sourceIndex][0];
            if (min === undefined) {
              if (stats && STATISTICS_MINIMUM in stats) {
                min = parseFloat(stats[STATISTICS_MINIMUM]);
              } else {
                min = getMinForDataType(sourceSamples[sourceIndex][0]);
              }
            }
            if (max === undefined) {
              if (stats && STATISTICS_MAXIMUM in stats) {
                max = parseFloat(stats[STATISTICS_MAXIMUM]);
              } else {
                max = getMaxForDataType(sourceSamples[sourceIndex][0]);
              }
            }
            gain = 255 / (max - min);
            bias = -min * gain;
          }
          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {
            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];
            var value = void 0;
            if (normalize) {
              value = (0, _math.clamp)(gain * sourceValue + bias, 0, 255);
            } else {
              value = sourceValue;
            }
            if (!addAlpha) {
              data[dataIndex] = value;
            } else {
              var nodata = source.nodata;
              if (nodata === undefined) {
                var bandIndex = void 0;
                if (source.bands) {
                  bandIndex = source.bands[sampleIndex] - 1;
                } else {
                  bandIndex = sampleIndex;
                }
                nodata = nodataValues[sourceIndex][bandIndex];
              }
              var nodataIsNaN = isNaN(nodata);
              if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {
                transparent = false;
                data[dataIndex] = value;
              }
            }
            dataIndex++;
          }
          if (!transparent) {
            var maskIndex = sourceCount + sourceIndex;
            var mask = sourceSamples[maskIndex];
            if (mask && !mask[0][pixelIndex]) {
              transparent = true;
            }
          }
        }
        if (addAlpha) {
          if (!transparent) {
            data[dataIndex] = 255;
          }
          dataIndex++;
        }
      }
      return data;
    }
  }]);
  return GeoTIFFSource;
}(_DataTile2.default);
/**
 * Get a promise for view properties based on the source.  Use the result of this function
 * as the `view` option in a map constructor.
 *
 *     const source = new GeoTIFF(options);
 *
 *     const map = new Map({
 *       target: 'map',
 *       layers: [
 *         new TileLayer({
 *           source: source,
 *         }),
 *       ],
 *       view: source.getView(),
 *     });
 *
 * @function
 * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
 * @api
 *
 */
GeoTIFFSource.prototype.getView;
var _default = exports.default = GeoTIFFSource;
},{"./DataTile.js":"node_modules/ol/source/DataTile.js","../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","geotiff":"node_modules/geotiff/dist-module/geotiff.js","../proj.js":"node_modules/ol/proj.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../console.js":"node_modules/ol/console.js","../proj/Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/source/Zoomify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CustomTile = void 0;
var _common = require("../tilegrid/common.js");
var _ImageTile2 = _interopRequireDefault(require("../ImageTile.js"));
var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _dom = require("../dom.js");
var _tileurlfunction = require("../tileurlfunction.js");
var _extent = require("../extent.js");
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Zoomify
 */
/**
 * @typedef {'default' | 'truncated'} TierSizeCalculation
 */
var CustomTile = exports.CustomTile = /*#__PURE__*/function (_ImageTile) {
  _inherits(CustomTile, _ImageTile);
  var _super = _createSuper(CustomTile);
  /**
   * @param {import("../size.js").Size} tileSize Full tile size.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  function CustomTile(tileSize, tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    var _this;
    _classCallCheck(this, CustomTile);
    _this = _super.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, options);

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */
    _this.zoomifyImage_ = null;

    /**
     * @type {import("../size.js").Size}
     */
    _this.tileSize_ = tileSize;
    return _this;
  }

  /**
   * Get the image element for this tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  _createClass(CustomTile, [{
    key: "getImage",
    value: function getImage() {
      if (this.zoomifyImage_) {
        return this.zoomifyImage_;
      }
      var image = _get(_getPrototypeOf(CustomTile.prototype), "getImage", this).call(this);
      if (this.state == _TileState.default.LOADED) {
        var tileSize = this.tileSize_;
        if (image.width == tileSize[0] && image.height == tileSize[1]) {
          this.zoomifyImage_ = image;
          return image;
        }
        var context = (0, _dom.createCanvasContext2D)(tileSize[0], tileSize[1]);
        context.drawImage(image, 0, 0);
        this.zoomifyImage_ = context.canvas;
        return context.canvas;
      }
      return image;
    }
  }]);
  return CustomTile;
}(_ImageTile2.default);
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {string} url URL template or base URL of the Zoomify service.
 * A base URL is the fixed part
 * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
 * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
 * Internet Imaging Protocol (IIP) with JTL extension can be also used with
 * `{tileIndex}` and `{z}` placeholders, e.g.
 * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {TierSizeCalculation} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.
 * @property {import("../size.js").Size} size Size.
 * @property {import("../extent.js").Extent} [extent] Extent for the TileGrid that is created.
 * Default sets the TileGrid in the
 * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
 * extent to the first quadrant (the default for OpenLayers 2) set the extent
 * as `[0, 0, width, height]`.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 * @api
 */
var Zoomify = /*#__PURE__*/function (_TileImage) {
  _inherits(Zoomify, _TileImage);
  var _super2 = _createSuper(Zoomify);
  /**
   * @param {Options} options Options.
   */
  function Zoomify(options) {
    var _this2;
    _classCallCheck(this, Zoomify);
    var size = options.size;
    var tierSizeCalculation = options.tierSizeCalculation !== undefined ? options.tierSizeCalculation : 'default';
    var tilePixelRatio = options.tilePixelRatio || 1;
    var imageWidth = size[0];
    var imageHeight = size[1];
    var tierSizeInTiles = [];
    var tileSize = options.tileSize || _common.DEFAULT_TILE_SIZE;
    var tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;
    switch (tierSizeCalculation) {
      case 'default':
        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(imageWidth / tileSizeForTierSizeCalculation), Math.ceil(imageHeight / tileSizeForTierSizeCalculation)]);
          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
        }
        break;
      case 'truncated':
        var width = imageWidth;
        var height = imageHeight;
        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(width / tileSizeForTierSizeCalculation), Math.ceil(height / tileSizeForTierSizeCalculation)]);
          width >>= 1;
          height >>= 1;
        }
        break;
      default:
        throw new Error('Unknown `tierSizeCalculation` configured');
    }
    tierSizeInTiles.push([1, 1]);
    tierSizeInTiles.reverse();
    var resolutions = [tilePixelRatio];
    var tileCountUpToTier = [0];
    for (var i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
      resolutions.push(tilePixelRatio << i);
      tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
    }
    resolutions.reverse();
    var tileGrid = new _TileGrid.default({
      tileSize: tileSize,
      extent: options.extent || [0, -imageHeight, imageWidth, 0],
      resolutions: resolutions
    });
    var url = options.url;
    if (url && !url.includes('{TileGroup}') && !url.includes('{tileIndex}')) {
      url += '{TileGroup}/{z}-{x}-{y}.jpg';
    }
    var urls = (0, _tileurlfunction.expandUrl)(url);
    var tileWidth = tileSize * tilePixelRatio;

    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    function createFromTemplate(template) {
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          }
          var tileCoordZ = tileCoord[0];
          var tileCoordX = tileCoord[1];
          var tileCoordY = tileCoord[2];
          var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
          var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth | 0;
          var localContext = {
            'z': tileCoordZ,
            'x': tileCoordX,
            'y': tileCoordY,
            'tileIndex': tileIndex,
            'TileGroup': 'TileGroup' + tileGroup
          };
          return template.replace(/\{(\w+?)\}/g, function (m, p) {
            return localContext[p];
          });
        }
      );
    }
    var tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(createFromTemplate));
    var ZoomifyTileClass = CustomTile.bind(null, (0, _size.toSize)(tileSize * tilePixelRatio));
    _this2 = _super2.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      tilePixelRatio: tilePixelRatio,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: ZoomifyTileClass,
      tileGrid: tileGrid,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    });

    /**
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    _this2.zDirection = options.zDirection;

    // Server retina tile detection (non-standard):
    // Try loading the center tile for the highest resolution. If it is not
    // available, we are dealing with retina tiles, and need to adjust the
    // tile url calculation.
    var tileUrl = tileGrid.getTileCoordForCoordAndResolution((0, _extent.getCenter)(tileGrid.getExtent()), resolutions[resolutions.length - 1]);
    var testTileUrl = tileUrlFunction(tileUrl, 1, null);
    var image = new Image();
    image.addEventListener('error', function () {
      tileWidth = tileSize;
      _this2.changed();
    });
    image.src = testTileUrl;
    return _this2;
  }
  return _createClass(Zoomify);
}(_TileImage2.default);
var _default = exports.default = Zoomify;
},{"../tilegrid/common.js":"node_modules/ol/tilegrid/common.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./TileImage.js":"node_modules/ol/source/TileImage.js","../TileState.js":"node_modules/ol/TileState.js","../dom.js":"node_modules/ol/dom.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../extent.js":"node_modules/ol/extent.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/format/IIIFInfo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Versions = void 0;
var _asserts = require("../asserts.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * @module ol/format/IIIFInfo
 */
/**
 * @typedef {Object} PreferredOptions
 * @property {string} [format] Preferred image format. Will be used if the image information
 * indicates support for that format.
 * @property {string} [quality] IIIF image qualitiy.  Will be used if the image information
 * indicates support for that quality.
 */

/**
 * @typedef {Object} SupportedFeatures
 * @property {Array<string>} [supports] Supported IIIF image size and region
 * calculation features.
 * @property {Array<string>} [formats] Supported image formats.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 */

/**
 * @typedef {Object} TileInfo
 * @property {Array<number>} scaleFactors Supported resolution scaling factors.
 * @property {number} width Tile width in pixels.
 * @property {number} [height] Tile height in pixels. Same as tile width if height is
 * not given.
 */

/**
 * @typedef {Object} IiifProfile
 * @property {Array<string>} [formats] Supported image formats for the image service.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 * @property {Array<string>} [supports] Supported features.
 * @property {number} [maxArea] Maximum area (pixels) available for this image service.
 * @property {number} [maxHeight] Maximum height.
 * @property {number} [maxWidth] Maximum width.
 */

/**
 * @typedef {Object<string,string|number|Array<number|string|IiifProfile|Object<string, number>|TileInfo>>}
 *    ImageInformationResponse
 */

/**
 * Enum representing the major IIIF Image API versions
 * @enum {string}
 */
var Versions = exports.Versions = {
  VERSION1: 'version1',
  VERSION2: 'version2',
  VERSION3: 'version3'
};

/**
 * Supported image formats, qualities and supported region / size calculation features
 * for different image API versions and compliance levels
 * @const
 * @type {Object<string, Object<string, SupportedFeatures>>}
 */
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  'level0': {
    supports: [],
    formats: [],
    qualities: ['native']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['native']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['native', 'color', 'grey', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByDistortedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'regionSquare', 'sizeByW', 'sizeByH', 'sizeByWh'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionSquare', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default']
  }
};
IIIF_PROFILE_VALUES['none'] = {
  'none': {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  // Version 1.0 and 1.1 do not require a profile.
  if (levelProfile === undefined) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]['level0'];
  }
  return {
    url: iiifInfo.imageInfo['@id'] === undefined ? undefined : iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    supports: levelProfile.supports,
    formats: [].concat(_toConsumableArray(levelProfile.formats), [iiifInfo.imageInfo.formats === undefined ? [] : iiifInfo.imageInfo.formats]),
    qualities: [].concat(_toConsumableArray(levelProfile.qualities), [iiifInfo.imageInfo.qualities === undefined ? [] : iiifInfo.imageInfo.qualities]),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== undefined ? iiifInfo.imageInfo.tile_height !== undefined ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != undefined ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : undefined
  };
}
function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
    additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1,
    profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [],
    profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [],
    profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height === undefined ? tile.width : tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: [].concat(_toConsumableArray(levelProfile.supports), _toConsumableArray(profileSupports)),
    formats: [].concat(_toConsumableArray(levelProfile.formats), _toConsumableArray(profileFormats)),
    qualities: [].concat(_toConsumableArray(levelProfile.qualities), _toConsumableArray(profileQualities))
  };
}
function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
    formats = iiifInfo.imageInfo.extraFormats === undefined ? levelProfile.formats : [].concat(_toConsumableArray(levelProfile.formats), _toConsumableArray(iiifInfo.imageInfo.extraFormats)),
    preferredFormat = iiifInfo.imageInfo.preferredFormats !== undefined && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function (format) {
      return ['jpg', 'png', 'gif'].includes(format);
    }).reduce(function (acc, format) {
      return acc === undefined && formats.includes(format) ? format : acc;
    }, undefined) : undefined;
  return {
    url: iiifInfo.imageInfo['id'],
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === undefined ? levelProfile.supports : [].concat(_toConsumableArray(levelProfile.supports), _toConsumableArray(iiifInfo.imageInfo.extraFeatures)),
    formats: formats,
    qualities: iiifInfo.imageInfo.extraQualities === undefined ? levelProfile.qualities : [].concat(_toConsumableArray(levelProfile.qualities), _toConsumableArray(iiifInfo.imageInfo.extraQualities)),
    preferredFormat: preferredFormat
  };
}
var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;

/**
 * @classdesc
 * Format for transforming IIIF Image API image information responses into
 * IIIF tile source ready options
 *
 * @api
 */
var IIIFInfo = /*#__PURE__*/function () {
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   */
  function IIIFInfo(imageInfo) {
    _classCallCheck(this, IIIFInfo);
    this.setImageInfo(imageInfo);
  }

  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   * @api
   */
  _createClass(IIIFInfo, [{
    key: "setImageInfo",
    value: function setImageInfo(imageInfo) {
      if (typeof imageInfo == 'string') {
        this.imageInfo = JSON.parse(imageInfo);
      } else {
        this.imageInfo = imageInfo;
      }
    }

    /**
     * @return {Versions|undefined} Major IIIF version.
     * @api
     */
  }, {
    key: "getImageApiVersion",
    value: function getImageApiVersion() {
      if (this.imageInfo === undefined) {
        return undefined;
      }
      var context = this.imageInfo['@context'] || 'ol-no-context';
      if (typeof context == 'string') {
        context = [context];
      }
      for (var i = 0; i < context.length; i++) {
        switch (context[i]) {
          case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
          case 'http://iiif.io/api/image/1/context.json':
            return Versions.VERSION1;
          case 'http://iiif.io/api/image/2/context.json':
            return Versions.VERSION2;
          case 'http://iiif.io/api/image/3/context.json':
            return Versions.VERSION3;
          case 'ol-no-context':
            // Image API 1.0 has no '@context'
            if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
              return Versions.VERSION1;
            }
            break;
          default:
        }
      }
      (0, _asserts.assert)(false, 'Cannot determine IIIF Image API version from provided image information JSON');
    }

    /**
     * @param {Versions} version Optional IIIF image API version
     * @return {string|undefined} Compliance level as it appears in the IIIF image information
     * response.
     */
  }, {
    key: "getComplianceLevelEntryFromProfile",
    value: function getComplianceLevelEntryFromProfile(version) {
      if (this.imageInfo === undefined || this.imageInfo.profile === undefined) {
        return undefined;
      }
      if (version === undefined) {
        version = this.getImageApiVersion();
      }
      switch (version) {
        case Versions.VERSION1:
          if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
            return this.imageInfo.profile;
          }
          break;
        case Versions.VERSION3:
          if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
            return this.imageInfo.profile;
          }
          break;
        case Versions.VERSION2:
          if (typeof this.imageInfo.profile === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
            return this.imageInfo.profile;
          }
          if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
            return this.imageInfo.profile[0];
          }
          break;
        default:
      }
      return undefined;
    }

    /**
     * @param {Versions} version Optional IIIF image API version
     * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
     */
  }, {
    key: "getComplianceLevelFromProfile",
    value: function getComplianceLevelFromProfile(version) {
      var complianceLevel = this.getComplianceLevelEntryFromProfile(version);
      if (complianceLevel === undefined) {
        return undefined;
      }
      var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
      return Array.isArray(level) ? level[0].replace('.json', '') : undefined;
    }

    /**
     * @return {SupportedFeatures|undefined} Image formats, qualities and region / size calculation
     * methods that are supported by the IIIF service.
     */
  }, {
    key: "getComplianceLevelSupportedFeatures",
    value: function getComplianceLevelSupportedFeatures() {
      if (this.imageInfo === undefined) {
        return undefined;
      }
      var version = this.getImageApiVersion();
      var level = this.getComplianceLevelFromProfile(version);
      if (level === undefined) {
        return IIIF_PROFILE_VALUES['none']['none'];
      }
      return IIIF_PROFILE_VALUES[version][level];
    }

    /**
     * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.
     * @return {import("../source/IIIF.js").Options|undefined} IIIF tile source ready constructor options.
     * @api
     */
  }, {
    key: "getTileSourceOptions",
    value: function getTileSourceOptions(preferredOptions) {
      var options = preferredOptions || {},
        version = this.getImageApiVersion();
      if (version === undefined) {
        return undefined;
      }
      var imageOptions = version === undefined ? undefined : versionFunctions[version](this);
      if (imageOptions === undefined) {
        return undefined;
      }
      return {
        url: imageOptions.url,
        version: version,
        size: [this.imageInfo.width, this.imageInfo.height],
        sizes: imageOptions.sizes,
        format: options.format !== undefined && imageOptions.formats.includes(options.format) ? options.format : imageOptions.preferredFormat !== undefined ? imageOptions.preferredFormat : 'jpg',
        supports: imageOptions.supports,
        quality: options.quality && imageOptions.qualities.includes(options.quality) ? options.quality : imageOptions.qualities.includes('native') ? 'native' : 'default',
        resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function (a, b) {
          return b - a;
        }) : undefined,
        tileSize: imageOptions.tileSize
      };
    }
  }]);
  return IIIFInfo;
}();
var _default = exports.default = IIIFInfo;
},{"../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/source/IIIF.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _Zoomify = require("./Zoomify.js");
var _common = require("../tilegrid/common.js");
var _IIIFInfo = require("../format/IIIFInfo.js");
var _asserts = require("../asserts.js");
var _extent = require("../extent.js");
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/IIIF
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Size of the cache.
 * @property {null|string} [crossOrigin] The value for the crossOrigin option of the request.
 * @property {import("../extent.js").Extent} [extent=[0, -height, width, 0]] The extent.
 * @property {string} [format='jpg'] Requested image format.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {string} [quality] Requested IIIF image quality. Default is 'native'
 * for version 1, 'default' for versions 2 and 3.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'
 * @property {import("../size.js").Size} size Size of the image [width, height].
 * @property {Array<import("../size.js").Size>} [sizes] Supported scaled image sizes.
 * Content of the IIIF info.json 'sizes' property, but as array of Size objects.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation
 * features.
 * @property {number} [tilePixelRatio] Tile pixel ratio.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Same tile size is used for all zoom levels. If tile size is a number,
 * a square tile is assumed. If the IIIF image service supports arbitrary
 * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct
 * are supported), the default tilesize is 256.
 * @property {number} [transition] Transition.
 * @property {string} [url] Base URL of the IIIF Image service.
 * This should be the same as the IIIF Image ID.
 * @property {import("../format/IIIFInfo.js").Versions} [version=Versions.VERSION2] Service's IIIF Image API version.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

function formatPercentage(percentage) {
  return percentage.toLocaleString('en', {
    maximumFractionDigits: 10
  });
}

/**
 * @classdesc
 * Layer source for IIIF Image API services.
 * @api
 */
var IIIF = /*#__PURE__*/function (_TileImage) {
  _inherits(IIIF, _TileImage);
  var _super = _createSuper(IIIF);
  /**
   * @param {Options} [options] Tile source options. Use {@link import("../format/IIIFInfo.js").IIIFInfo}
   * to parse Image API service information responses into constructor options.
   * @api
   */
  function IIIF(options) {
    var _this;
    _classCallCheck(this, IIIF);
    /**
     * @type {Partial<Options>}
     */
    var partialOptions = options || {};
    var baseUrl = partialOptions.url || '';
    baseUrl = baseUrl + (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === '' ? '' : '/');
    var version = partialOptions.version || _IIIFInfo.Versions.VERSION2;
    var sizes = partialOptions.sizes || [];
    var size = partialOptions.size;
    (0, _asserts.assert)(size != undefined && Array.isArray(size) && size.length == 2 && !isNaN(size[0]) && size[0] > 0 && !isNaN(size[1]) && size[1] > 0, 'Missing or invalid `size`');
    var width = size[0];
    var height = size[1];
    var tileSize = partialOptions.tileSize;
    var tilePixelRatio = partialOptions.tilePixelRatio || 1;
    var format = partialOptions.format || 'jpg';
    var quality = partialOptions.quality || (partialOptions.version == _IIIFInfo.Versions.VERSION1 ? 'native' : 'default');
    var resolutions = partialOptions.resolutions || [];
    var supports = partialOptions.supports || [];
    var extent = partialOptions.extent || [0, -height, width, 0];
    var supportsListedSizes = sizes != undefined && Array.isArray(sizes) && sizes.length > 0;
    var supportsListedTiles = tileSize !== undefined && (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0 || Array.isArray(tileSize) && tileSize.length > 0);
    var supportsArbitraryTiling = supports != undefined && Array.isArray(supports) && (supports.includes('regionByPx') || supports.includes('regionByPct')) && (supports.includes('sizeByWh') || supports.includes('sizeByH') || supports.includes('sizeByW') || supports.includes('sizeByPct'));
    var tileWidth, tileHeight, maxZoom;
    resolutions.sort(function (a, b) {
      return b - a;
    });
    if (supportsListedTiles || supportsArbitraryTiling) {
      if (tileSize != undefined) {
        if (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0) {
          tileWidth = tileSize;
          tileHeight = tileSize;
        } else if (Array.isArray(tileSize) && tileSize.length > 0) {
          if (tileSize.length == 1 || tileSize[1] == undefined && Number.isInteger(tileSize[0])) {
            tileWidth = tileSize[0];
            tileHeight = tileSize[0];
          }
          if (tileSize.length == 2) {
            if (Number.isInteger(tileSize[0]) && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[0];
              tileHeight = tileSize[1];
            } else if (tileSize[0] == undefined && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[1];
              tileHeight = tileSize[1];
            }
          }
        }
      }
      if (tileWidth === undefined || tileHeight === undefined) {
        tileWidth = _common.DEFAULT_TILE_SIZE;
        tileHeight = _common.DEFAULT_TILE_SIZE;
      }
      if (resolutions.length == 0) {
        maxZoom = Math.max(Math.ceil(Math.log(width / tileWidth) / Math.LN2), Math.ceil(Math.log(height / tileHeight) / Math.LN2));
        for (var i = maxZoom; i >= 0; i--) {
          resolutions.push(Math.pow(2, i));
        }
      } else {
        var maxScaleFactor = Math.max.apply(Math, _toConsumableArray(resolutions));
        // TODO maxScaleFactor might not be a power to 2
        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);
      }
    } else {
      // No tile support.
      tileWidth = width;
      tileHeight = height;
      resolutions = [];
      if (supportsListedSizes) {
        /*
         * 'sizes' provided. Use full region in different resolutions. Every
         * resolution has only one tile.
         */
        sizes.sort(function (a, b) {
          return a[0] - b[0];
        });
        maxZoom = -1;
        var ignoredSizesIndex = [];
        for (var _i = 0; _i < sizes.length; _i++) {
          var resolution = width / sizes[_i][0];
          if (resolutions.length > 0 && resolutions[resolutions.length - 1] == resolution) {
            ignoredSizesIndex.push(_i);
            continue;
          }
          resolutions.push(resolution);
          maxZoom++;
        }
        if (ignoredSizesIndex.length > 0) {
          for (var _i2 = 0; _i2 < ignoredSizesIndex.length; _i2++) {
            sizes.splice(ignoredSizesIndex[_i2] - _i2, 1);
          }
        }
      } else {
        // No useful image information at all. Try pseudo tile with full image.
        resolutions.push(1);
        sizes.push([width, height]);
        maxZoom = 0;
      }
    }
    var tileGrid = new _TileGrid.default({
      tileSize: [tileWidth, tileHeight],
      extent: extent,
      origin: (0, _extent.getTopLeft)(extent),
      resolutions: resolutions
    });
    var tileUrlFunction = function tileUrlFunction(tileCoord, pixelRatio, projection) {
      var regionParam, sizeParam;
      var zoom = tileCoord[0];
      if (zoom > maxZoom) {
        return;
      }
      var tileX = tileCoord[1],
        tileY = tileCoord[2],
        scale = resolutions[zoom];
      if (tileX === undefined || tileY === undefined || scale === undefined || tileX < 0 || Math.ceil(width / scale / tileWidth) <= tileX || tileY < 0 || Math.ceil(height / scale / tileHeight) <= tileY) {
        return;
      }
      if (supportsArbitraryTiling || supportsListedTiles) {
        var regionX = tileX * tileWidth * scale,
          regionY = tileY * tileHeight * scale;
        var regionW = tileWidth * scale,
          regionH = tileHeight * scale,
          sizeW = tileWidth,
          sizeH = tileHeight;
        if (regionX + regionW > width) {
          regionW = width - regionX;
        }
        if (regionY + regionH > height) {
          regionH = height - regionY;
        }
        if (regionX + tileWidth * scale > width) {
          sizeW = Math.floor((width - regionX + scale - 1) / scale);
        }
        if (regionY + tileHeight * scale > height) {
          sizeH = Math.floor((height - regionY + scale - 1) / scale);
        }
        if (regionX == 0 && regionW == width && regionY == 0 && regionH == height) {
          // canonical full image region parameter is 'full', not 'x,y,w,h'
          regionParam = 'full';
        } else if (!supportsArbitraryTiling || supports.includes('regionByPx')) {
          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;
        } else if (supports.includes('regionByPct')) {
          var pctX = formatPercentage(regionX / width * 100),
            pctY = formatPercentage(regionY / height * 100),
            pctW = formatPercentage(regionW / width * 100),
            pctH = formatPercentage(regionH / height * 100);
          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;
        }
        if (version == _IIIFInfo.Versions.VERSION3 && (!supportsArbitraryTiling || supports.includes('sizeByWh'))) {
          sizeParam = sizeW + ',' + sizeH;
        } else if (!supportsArbitraryTiling || supports.includes('sizeByW')) {
          sizeParam = sizeW + ',';
        } else if (supports.includes('sizeByH')) {
          sizeParam = ',' + sizeH;
        } else if (supports.includes('sizeByWh')) {
          sizeParam = sizeW + ',' + sizeH;
        } else if (supports.includes('sizeByPct')) {
          sizeParam = 'pct:' + formatPercentage(100 / scale);
        }
      } else {
        regionParam = 'full';
        if (supportsListedSizes) {
          var regionWidth = sizes[zoom][0],
            regionHeight = sizes[zoom][1];
          if (version == _IIIFInfo.Versions.VERSION3) {
            if (regionWidth == width && regionHeight == height) {
              sizeParam = 'max';
            } else {
              sizeParam = regionWidth + ',' + regionHeight;
            }
          } else {
            if (regionWidth == width) {
              sizeParam = 'full';
            } else {
              sizeParam = regionWidth + ',';
            }
          }
        } else {
          sizeParam = version == _IIIFInfo.Versions.VERSION3 ? 'max' : 'full';
        }
      }
      return baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format;
    };
    var IiifTileClass = _Zoomify.CustomTile.bind(null, (0, _size.toSize)(tileSize || 256).map(function (size) {
      return size * tilePixelRatio;
    }));
    _this = _super.call(this, {
      attributions: partialOptions.attributions,
      attributionsCollapsible: partialOptions.attributionsCollapsible,
      cacheSize: partialOptions.cacheSize,
      crossOrigin: partialOptions.crossOrigin,
      interpolate: partialOptions.interpolate,
      projection: partialOptions.projection,
      reprojectionErrorThreshold: partialOptions.reprojectionErrorThreshold,
      state: partialOptions.state,
      tileClass: IiifTileClass,
      tileGrid: tileGrid,
      tilePixelRatio: partialOptions.tilePixelRatio,
      tileUrlFunction: tileUrlFunction,
      transition: partialOptions.transition
    });

    /**
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    _this.zDirection = partialOptions.zDirection;
    return _this;
  }
  return _createClass(IIIF);
}(_TileImage2.default);
var _default = exports.default = IIIF;
},{"../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./TileImage.js":"node_modules/ol/source/TileImage.js","./Zoomify.js":"node_modules/ol/source/Zoomify.js","../tilegrid/common.js":"node_modules/ol/tilegrid/common.js","../format/IIIFInfo.js":"node_modules/ol/format/IIIFInfo.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/resolution.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromResolutionLike = fromResolutionLike;
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * @module ol/resolution
 */

/**
 * @typedef {number|Array<number>} ResolutionLike
 */

/**
 * @param {ResolutionLike} resolution Resolution.
 * @return {number} Resolution.
 */
function fromResolutionLike(resolution) {
  if (Array.isArray(resolution)) {
    return Math.min.apply(Math, _toConsumableArray(resolution));
  }
  return resolution;
}
},{}],"node_modules/ol/reproj/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _common = require("./common.js");
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _Image = _interopRequireDefault(require("../Image.js"));
var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));
var _reproj = require("../reproj.js");
var _resolution = require("../resolution.js");
var _extent = require("../extent.js");
var _events = require("../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/reproj/Image
 */
/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../Image.js").default} FunctionType
 */
/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
var ReprojImage = /*#__PURE__*/function (_ImageWrapper) {
  _inherits(ReprojImage, _ImageWrapper);
  var _super = _createSuper(ReprojImage);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
    var _this;
    _classCallCheck(this, ReprojImage);
    var maxSourceExtent = sourceProj.getExtent();
    if (maxSourceExtent && sourceProj.canWrapX()) {
      maxSourceExtent = maxSourceExtent.slice();
      maxSourceExtent[0] = -Infinity;
      maxSourceExtent[2] = Infinity;
    }
    var maxTargetExtent = targetProj.getExtent();
    if (maxTargetExtent && targetProj.canWrapX()) {
      maxTargetExtent = maxTargetExtent.slice();
      maxTargetExtent[0] = -Infinity;
      maxTargetExtent[2] = Infinity;
    }
    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
    var targetCenter = (0, _extent.getCenter)(limitedTargetExtent);
    var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);
    var errorThresholdInPixels = _common.ERROR_THRESHOLD;
    var triangulation = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = (0, _extent.isEmpty)(sourceExtent) ? null : getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = sourceImage ? _ImageState.default.IDLE : _ImageState.default.EMPTY;
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state);

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    _this.targetProj_ = targetProj;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    _this.triangulation_ = triangulation;

    /**
     * @private
     * @type {number}
     */
    _this.targetResolution_ = targetResolution;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.targetExtent_ = targetExtent;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    _this.sourceImage_ = sourceImage;

    /**
     * @private
     * @type {number}
     */
    _this.sourcePixelRatio_ = sourcePixelRatio;

    /**
     * @private
     * @type {boolean}
     */
    _this.interpolate_ = interpolate;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    _this.canvas_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    _this.sourceListenerKey_ = null;
    return _this;
  }

  /**
   * Clean up.
   */
  _createClass(ReprojImage, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.state == _ImageState.default.LOADING) {
        this.unlistenSource_();
      }
      _get(_getPrototypeOf(ReprojImage.prototype), "disposeInternal", this).call(this);
    }

    /**
     * @return {HTMLCanvasElement} Image.
     */
  }, {
    key: "getImage",
    value: function getImage() {
      return this.canvas_;
    }

    /**
     * @return {import("../proj/Projection.js").default} Projection.
     */
  }, {
    key: "getProjection",
    value: function getProjection() {
      return this.targetProj_;
    }

    /**
     * @private
     */
  }, {
    key: "reproject_",
    value: function reproject_() {
      var sourceState = this.sourceImage_.getState();
      if (sourceState == _ImageState.default.LOADED) {
        var width = (0, _extent.getWidth)(this.targetExtent_) / this.targetResolution_;
        var height = (0, _extent.getHeight)(this.targetExtent_) / this.targetResolution_;
        this.canvas_ = (0, _reproj.render)(width, height, this.sourcePixelRatio_, (0, _resolution.fromResolutionLike)(this.sourceImage_.getResolution()), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }], 0, undefined, this.interpolate_, true);
      }
      this.state = sourceState;
      this.changed();
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      if (this.state == _ImageState.default.IDLE) {
        this.state = _ImageState.default.LOADING;
        this.changed();
        var sourceState = this.sourceImage_.getState();
        if (sourceState == _ImageState.default.LOADED || sourceState == _ImageState.default.ERROR) {
          this.reproject_();
        } else {
          this.sourceListenerKey_ = (0, _events.listen)(this.sourceImage_, _EventType.default.CHANGE, function (e) {
            var sourceState = this.sourceImage_.getState();
            if (sourceState == _ImageState.default.LOADED || sourceState == _ImageState.default.ERROR) {
              this.unlistenSource_();
              this.reproject_();
            }
          }, this);
          this.sourceImage_.load();
        }
      }
    }

    /**
     * @private
     */
  }, {
    key: "unlistenSource_",
    value: function unlistenSource_() {
      (0, _events.unlistenByKey)( /** @type {!import("../events.js").EventsKey} */this.sourceListenerKey_);
      this.sourceListenerKey_ = null;
    }
  }]);
  return ReprojImage;
}(_Image.default);
var _default = exports.default = ReprojImage;
},{"./common.js":"node_modules/ol/reproj/common.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../Image.js":"node_modules/ol/Image.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js","../reproj.js":"node_modules/ol/reproj.js","../resolution.js":"node_modules/ol/resolution.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/source/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_WMS_VERSION = exports.DECIMALS = void 0;
/**
 * @module ol/source/common
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_WMS_VERSION = exports.DEFAULT_WMS_VERSION = '1.3.0';

/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
var DECIMALS = exports.DECIMALS = 4;
},{}],"node_modules/ol/source/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ImageSourceEventType = exports.ImageSourceEvent = void 0;
exports.defaultImageLoadFunction = defaultImageLoadFunction;
exports.getRequestExtent = getRequestExtent;
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageState = _interopRequireDefault(require("../ImageState.js"));
var _Image = _interopRequireDefault(require("../Image.js"));
var _Image2 = _interopRequireDefault(require("../reproj/Image.js"));
var _Source2 = _interopRequireDefault(require("./Source.js"));
var _common = require("./common.js");
var _math = require("../math.js");
var _extent = require("../extent.js");
var _proj = require("../proj.js");
var _resolution = require("../resolution.js");
var _array = require("../array.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Image
 */
/**
 * @enum {string}
 */
var ImageSourceEventType = exports.ImageSourceEventType = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'
};

/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */
var ImageSourceEvent = exports.ImageSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(ImageSourceEvent, _Event);
  var _super = _createSuper(ImageSourceEvent);
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  function ImageSourceEvent(type, image) {
    var _this;
    _classCallCheck(this, ImageSourceEvent);
    _this = _super.call(this, type);

    /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */
    _this.image = image;
    return _this;
  }
  return _createClass(ImageSourceEvent);
}(_Event2.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../Image.js").Loader} [loader] Loader. Can either be a custom loader, or one of the
 * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},
 * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},
 * {@link module:ol/source/static.createLoader static}).
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./Source.js").State} [state] State.
 */
/**
 * @classdesc
 * Base class for sources providing a single image.
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageSource = /*#__PURE__*/function (_Source) {
  _inherits(ImageSource, _Source);
  var _super2 = _createSuper(ImageSource);
  /**
   * @param {Options} options Single image source options.
   */
  function ImageSource(options) {
    var _this2;
    _classCallCheck(this, ImageSource);
    _this2 = _super2.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state,
      interpolate: options.interpolate !== undefined ? options.interpolate : true
    });

    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {ImageSourceOnSignature<void>}
     */
    _this2.un;

    /**
     * @protected
     * @type {import("../Image.js").Loader}
     */
    _this2.loader = options.loader || null;

    /**
     * @private
     * @type {Array<number>|null}
     */
    _this2.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;

    /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */
    _this2.reprojectedImage_ = null;

    /**
     * @private
     * @type {number}
     */
    _this2.reprojectedRevision_ = 0;

    /**
     * @protected
     * @type {import("../Image.js").default}
     */
    _this2.image = null;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this2.wantedExtent_;

    /**
     * @private
     * @type {number}
     */
    _this2.wantedResolution_;

    /**
     * @private
     * @type {boolean}
     */
    _this2.static_ = options.loader ? options.loader.length === 0 : false;

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    _this2.wantedProjection_ = null;
    return _this2;
  }

  /**
   * @return {Array<number>|null} Resolutions.
   */
  _createClass(ImageSource, [{
    key: "getResolutions",
    value: function getResolutions() {
      return this.resolutions_;
    }

    /**
     * @param {Array<number>|null} resolutions Resolutions.
     */
  }, {
    key: "setResolutions",
    value: function setResolutions(resolutions) {
      this.resolutions_ = resolutions;
    }

    /**
     * @protected
     * @param {number} resolution Resolution.
     * @return {number} Resolution.
     */
  }, {
    key: "findNearestResolution",
    value: function findNearestResolution(resolution) {
      var resolutions = this.getResolutions();
      if (resolutions) {
        var idx = (0, _array.linearFindNearest)(resolutions, resolution, 0);
        resolution = resolutions[idx];
      }
      return resolution;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
  }, {
    key: "getImage",
    value: function getImage(extent, resolution, pixelRatio, projection) {
      var _this3 = this;
      var sourceProjection = this.getProjection();
      if (!sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
        if (sourceProjection) {
          projection = sourceProjection;
        }
        return this.getImageInternal(extent, resolution, pixelRatio, projection);
      }
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && (0, _proj.equivalent)(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && (0, _extent.equals)(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }
      this.reprojectedImage_ = new _Image2.default(sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
        return _this3.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
      }, this.getInterpolate());
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }

    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     * @protected
     */
  }, {
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      if (this.loader) {
        var requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);
        var requestResolution = this.findNearestResolution(resolution);
        if (this.image && (this.static_ || this.wantedProjection_ === projection && (this.wantedExtent_ && (0, _extent.containsExtent)(this.wantedExtent_, requestExtent) || (0, _extent.containsExtent)(this.image.getExtent(), requestExtent)) && (this.wantedResolution_ && (0, _resolution.fromResolutionLike)(this.wantedResolution_) === requestResolution || (0, _resolution.fromResolutionLike)(this.image.getResolution()) === requestResolution))) {
          return this.image;
        }
        this.wantedProjection_ = projection;
        this.wantedExtent_ = requestExtent;
        this.wantedResolution_ = requestResolution;
        this.image = new _Image.default(requestExtent, requestResolution, pixelRatio, this.loader);
        this.image.addEventListener(_EventType.default.CHANGE, this.handleImageChange.bind(this));
      }
      return this.image;
    }

    /**
     * Handle image change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
  }, {
    key: "handleImageChange",
    value: function handleImageChange(event) {
      var image = /** @type {import("../Image.js").default} */event.target;
      var type;
      switch (image.getState()) {
        case _ImageState.default.LOADING:
          this.loading = true;
          type = ImageSourceEventType.IMAGELOADSTART;
          break;
        case _ImageState.default.LOADED:
          this.loading = false;
          type = ImageSourceEventType.IMAGELOADEND;
          break;
        case _ImageState.default.ERROR:
          this.loading = false;
          type = ImageSourceEventType.IMAGELOADERROR;
          break;
        default:
          return;
      }
      if (this.hasListener(type)) {
        this.dispatchEvent(new ImageSourceEvent(type, image));
      }
    }
  }]);
  return ImageSource;
}(_Source2.default);
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */
function defaultImageLoadFunction(image, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */image.getImage().src = src;
}

/**
 * Adjusts the extent so it aligns with pixel boundaries.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} resolution Reolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} ratio Ratio between request size and view size.
 * @return {import("../extent.js").Extent} Request extent.
 */
function getRequestExtent(extent, resolution, pixelRatio, ratio) {
  var imageResolution = resolution / pixelRatio;
  var center = (0, _extent.getCenter)(extent);
  var viewWidth = (0, _math.ceil)((0, _extent.getWidth)(extent) / imageResolution, _common.DECIMALS);
  var viewHeight = (0, _math.ceil)((0, _extent.getHeight)(extent) / imageResolution, _common.DECIMALS);
  var marginWidth = (0, _math.ceil)((ratio - 1) * viewWidth / 2, _common.DECIMALS);
  var requestWidth = viewWidth + 2 * marginWidth;
  var marginHeight = (0, _math.ceil)((ratio - 1) * viewHeight / 2, _common.DECIMALS);
  var requestHeight = viewHeight + 2 * marginHeight;
  return (0, _extent.getForViewAndSize)(center, imageResolution, 0, [requestWidth, requestHeight]);
}
var _default = exports.default = ImageSource;
},{"../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../Image.js":"node_modules/ol/Image.js","../reproj/Image.js":"node_modules/ol/reproj/Image.js","./Source.js":"node_modules/ol/source/Source.js","./common.js":"node_modules/ol/source/common.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../resolution.js":"node_modules/ol/resolution.js","../array.js":"node_modules/ol/array.js"}],"node_modules/ol/uri.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.appendParams = appendParams;
/**
 * @module ol/uri
 */

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  /** @type {Array<string>} */
  var keyParams = [];
  // Skip any null or undefined parameter values
  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&');
  // remove any trailing ? or &
  uri = uri.replace(/[?&]$/, '');
  // append ? or & depending on whether uri has existing parameters
  uri += uri.includes('?') ? '&' : '?';
  return uri + qs;
}
},{}],"node_modules/ol/source/arcgisRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoader = createLoader;
exports.getRequestUrl = getRequestUrl;
var _common = require("./common.js");
var _uri = require("../uri.js");
var _Image = require("../Image.js");
var _extent = require("../extent.js");
var _proj = require("../proj.js");
var _Image2 = require("./Image.js");
var _math = require("../math.js");
/**
 * @module ol/source/arcgisRest
 */

/**
 * @param {string} baseUrl Base URL for the ArcGIS Rest service.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("../proj/Projection.js").default} projection Projection.
 * @param {Object} params Params.
 * @return {string} Request URL.
 */
function getRequestUrl(baseUrl, extent, resolution, pixelRatio, projection, params) {
  // ArcGIS Server only wants the numeric portion of the projection ID.
  // (if there is no numeric portion the entire projection code must
  // form a valid ArcGIS SpatialReference definition).
  var srid = projection.getCode().split(/:(?=\d+$)/).pop();
  var imageResolution = resolution / pixelRatio;
  var imageSize = [(0, _math.round)((0, _extent.getWidth)(extent) / imageResolution, _common.DECIMALS), (0, _math.round)((0, _extent.getHeight)(extent) / imageResolution, _common.DECIMALS)];
  params['SIZE'] = imageSize[0] + ',' + imageSize[1];
  params['BBOX'] = extent.join(',');
  params['BBOXSR'] = srid;
  params['IMAGESR'] = srid;
  params['DPI'] = Math.round(params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio);
  var modifiedUrl = baseUrl.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');
  if (modifiedUrl == baseUrl) {
    throw new Error('`options.featureTypes` should be an Array');
  }
  return (0, _uri.appendParams)(modifiedUrl, params);
}

/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */

/**
 * Creates a loader for ArcGIS Rest images.
 * @param {LoaderOptions} options Image ArcGIS Rest Options.
 * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.
 * @api
 */
function createLoader(options) {
  var load = options.load ? options.load : _Image.decode;
  var projection = (0, _proj.get)(options.projection || 'EPSG:3857');

  /** @type {import('../Image.js').ImageObjectPromiseLoader} */
  return function (extent, resolution, pixelRatio) {
    pixelRatio = options.hidpi ? pixelRatio : 1;
    var params = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    Object.assign(params, options.params);
    extent = (0, _Image2.getRequestExtent)(extent, resolution, pixelRatio, options.ratio);
    var src = getRequestUrl(options.url, extent, resolution, pixelRatio, projection, params);
    var image = new Image();
    if (options.crossOrigin !== null) {
      image.crossOrigin = options.crossOrigin;
    }
    return load(image, src).then(function (image) {
      // Update resolution, because the server may return a smaller size than requested
      var resolution = (0, _extent.getWidth)(extent) / image.width * pixelRatio;
      return {
        image: image,
        extent: extent,
        resolution: resolution,
        pixelRatio: pixelRatio
      };
    });
  };
}
},{"./common.js":"node_modules/ol/source/common.js","../uri.js":"node_modules/ol/uri.js","../Image.js":"node_modules/ol/Image.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","./Image.js":"node_modules/ol/source/Image.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/source/ImageArcGISRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Image = _interopRequireWildcard(require("./Image.js"));
var _arcgisRest = require("./arcgisRest.js");
var _Image2 = require("../Image.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/ImageArcGISRest
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given
 * a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for
 * these resolutions only.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 */
/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link module:ol/source/TileArcGISRest~TileArcGISRest} data source.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageArcGISRest = /*#__PURE__*/function (_ImageSource) {
  _inherits(ImageArcGISRest, _ImageSource);
  var _super = _createSuper(ImageArcGISRest);
  /**
   * @param {Options} [options] Image ArcGIS Rest Options.
   */
  function ImageArcGISRest(options) {
    var _this;
    _classCallCheck(this, ImageArcGISRest);
    options = options ? options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {string|undefined}
     */
    _this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;

    /**
     * @private
     * @type {!Object}
     */
    _this.params_ = options.params || {};

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    _this.image_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    _this.imageSize_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    _this.renderedRevision_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    _this.loaderProjection_ = null;
    return _this;
  }

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  _createClass(ImageArcGISRest, [{
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
  }, {
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      var _this2 = this;
      if (this.url_ === undefined) {
        return null;
      }
      if (!this.loader || this.loaderProjection_ !== projection) {
        // Lazily create loader to pick up the view projection and to allow `params` updates
        this.loaderProjection_ = projection;
        this.loader = (0, _arcgisRest.createLoader)({
          crossOrigin: this.crossOrigin_,
          params: this.params_,
          projection: projection,
          hidpi: this.hidpi_,
          url: this.url_,
          ratio: this.ratio_,
          load: function load(image, src) {
            _this2.image.setImage(image);
            _this2.imageLoadFunction_(_this2.image, src);
            return (0, _Image2.decode)(image);
          }
        });
      }
      return _get(_getPrototypeOf(ImageArcGISRest.prototype), "getImageInternal", this).call(this, extent, resolution, pixelRatio, projection);
    }

    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
  }, {
    key: "getImageLoadFunction",
    value: function getImageLoadFunction() {
      return this.imageLoadFunction_;
    }

    /**
     * Return the URL used for this ArcGIS source.
     * @return {string|undefined} URL.
     * @api
     */
  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.url_;
    }

    /**
     * Set the image load function of the source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
  }, {
    key: "setImageLoadFunction",
    value: function setImageLoadFunction(imageLoadFunction) {
      this.image_ = null;
      this.imageLoadFunction_ = imageLoadFunction;
      this.changed();
    }

    /**
     * Set the URL to use for requests.
     * @param {string|undefined} url URL.
     * @api
     */
  }, {
    key: "setUrl",
    value: function setUrl(url) {
      if (url != this.url_) {
        this.url_ = url;
        this.image_ = null;
        this.changed();
      }
    }

    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.image_ = null;
      this.changed();
    }
  }]);
  return ImageArcGISRest;
}(_Image.default);
var _default = exports.default = ImageArcGISRest;
},{"./Image.js":"node_modules/ol/source/Image.js","./arcgisRest.js":"node_modules/ol/source/arcgisRest.js","../Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/ImageCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ImageState = _interopRequireDefault(require("./ImageState.js"));
var _Image = _interopRequireDefault(require("./Image.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/ImageCanvas
 */
/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */
var ImageCanvas = /*#__PURE__*/function (_ImageWrapper) {
  _inherits(ImageCanvas, _ImageWrapper);
  var _super = _createSuper(ImageCanvas);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  function ImageCanvas(extent, resolution, pixelRatio, canvas, loader) {
    var _this;
    _classCallCheck(this, ImageCanvas);
    var state = loader !== undefined ? _ImageState.default.IDLE : _ImageState.default.LOADED;
    _this = _super.call(this, extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    _this.loader_ = loader !== undefined ? loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    _this.canvas_ = canvas;

    /**
     * @private
     * @type {?Error}
     */
    _this.error_ = null;
    return _this;
  }

  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  _createClass(ImageCanvas, [{
    key: "getError",
    value: function getError() {
      return this.error_;
    }

    /**
     * Handle async drawing complete.
     * @param {Error} [err] Any error during drawing.
     * @private
     */
  }, {
    key: "handleLoad_",
    value: function handleLoad_(err) {
      if (err) {
        this.error_ = err;
        this.state = _ImageState.default.ERROR;
      } else {
        this.state = _ImageState.default.LOADED;
      }
      this.changed();
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      if (this.state == _ImageState.default.IDLE) {
        this.state = _ImageState.default.LOADING;
        this.changed();
        this.loader_(this.handleLoad_.bind(this));
      }
    }

    /**
     * @return {HTMLCanvasElement} Canvas element.
     */
  }, {
    key: "getImage",
    value: function getImage() {
      return this.canvas_;
    }
  }]);
  return ImageCanvas;
}(_Image.default);
var _default = exports.default = ImageCanvas;
},{"./ImageState.js":"node_modules/ol/ImageState.js","./Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/source/ImageCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ImageCanvas = _interopRequireDefault(require("../ImageCanvas.js"));
var _Image = _interopRequireDefault(require("./Image.js"));
var _extent = require("../extent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/ImageCanvas
 */
/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,
 * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.
 *
 * @typedef {function(this:import("../ImageCanvas.js").default, import("../extent.js").Extent, number,
 *     number, import("../size.js").Size, import("../proj/Projection.js").default): HTMLCanvasElement} FunctionType
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: {@link import("../extent.js").Extent} the
 * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,
 * {@link import("../size.js").Size} the image size, and {@link import("../proj/Projection.js").default} the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {import("./Source.js").State} [state] Source state.
 */
/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */
var ImageCanvasSource = /*#__PURE__*/function (_ImageSource) {
  _inherits(ImageCanvasSource, _ImageSource);
  var _super = _createSuper(ImageCanvasSource);
  /**
   * @param {Options} [options] ImageCanvas options.
   */
  function ImageCanvasSource(options) {
    var _this;
    _classCallCheck(this, ImageCanvasSource);
    options = options ? options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    });

    /**
     * @private
     * @type {FunctionType}
     */
    _this.canvasFunction_ = options.canvasFunction;

    /**
     * @private
     * @type {import("../ImageCanvas.js").default}
     */
    _this.canvas_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.renderedRevision_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */
  _createClass(ImageCanvasSource, [{
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      resolution = this.findNearestResolution(resolution);
      var canvas = this.canvas_;
      if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && (0, _extent.containsExtent)(canvas.getExtent(), extent)) {
        return canvas;
      }
      extent = extent.slice();
      (0, _extent.scaleFromCenter)(extent, this.ratio_);
      var width = (0, _extent.getWidth)(extent) / resolution;
      var height = (0, _extent.getHeight)(extent) / resolution;
      var size = [width * pixelRatio, height * pixelRatio];
      var canvasElement = this.canvasFunction_.call(this, extent, resolution, pixelRatio, size, projection);
      if (canvasElement) {
        canvas = new _ImageCanvas.default(extent, resolution, pixelRatio, canvasElement);
      }
      this.canvas_ = canvas;
      this.renderedRevision_ = this.getRevision();
      return canvas;
    }
  }]);
  return ImageCanvasSource;
}(_Image.default);
var _default = exports.default = ImageCanvasSource;
},{"../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","./Image.js":"node_modules/ol/source/Image.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/mapguide.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoader = createLoader;
var _uri = require("../uri.js");
var _Image = require("../Image.js");
var _extent = require("../extent.js");
var _Image2 = require("./Image.js");
/**
 * @module ol/source/mapguide
 */

/**
 * @typedef {Object} LoaderOptions
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Object} [params] Additional query parameters.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */

/**
 * @param {import("../extent.js").Extent} extent The map extents.
 * @param {import("../size.js").Size} size The viewport size.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} dpi The display resolution.
 * @return {number} The computed map scale.
 */
function getScale(extent, size, metersPerUnit, dpi) {
  var mcsW = (0, _extent.getWidth)(extent);
  var mcsH = (0, _extent.getHeight)(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;
  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp); // width limited
  }
  return mcsH * metersPerUnit / (devH * mpp); // height limited
}

/**
 * @param {string} baseUrl The mapagent url.
 * @param {Object<string, string|number>} params Request parameters.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {import("../size.js").Size} size Size.
 * @param {boolean} useOverlay If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} displayDpi The display resolution.
 * @return {string} The mapagent map image request URL.
 */
function getUrl(baseUrl, params, extent, size, useOverlay, metersPerUnit, displayDpi) {
  var scale = getScale(extent, size, metersPerUnit, displayDpi);
  var center = (0, _extent.getCenter)(extent);
  var baseParams = {
    'OPERATION': useOverlay ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',
    'VERSION': '2.0.0',
    'LOCALE': 'en',
    'CLIENTAGENT': 'ol/source/ImageMapGuide source',
    'CLIP': '1',
    'SETDISPLAYDPI': displayDpi,
    'SETDISPLAYWIDTH': Math.round(size[0]),
    'SETDISPLAYHEIGHT': Math.round(size[1]),
    'SETVIEWSCALE': scale,
    'SETVIEWCENTERX': center[0],
    'SETVIEWCENTERY': center[1]
  };
  Object.assign(baseParams, params);
  return (0, _uri.appendParams)(baseUrl, baseParams);
}

/**
 * Creates a loader for MapGuide images.
 * @param {LoaderOptions} options Image ArcGIS Rest Options.
 * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.
 * @api
 */
function createLoader(options) {
  var load = options.load || _Image.decode;

  /** @type {import('../Image.js').ImageObjectPromiseLoader} */
  return function (extent, resolution, pixelRatio) {
    var image = new Image();
    if (options.crossOrigin !== null) {
      image.crossOrigin = options.crossOrigin;
    }
    extent = (0, _Image2.getRequestExtent)(extent, resolution, pixelRatio, options.ratio);
    var width = (0, _extent.getWidth)(extent) / resolution;
    var height = (0, _extent.getHeight)(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];
    var src = getUrl(options.url, options.params, extent, size, options.useOverlay, options.metersPerUnit || 1, options.displayDpi || 96);
    return load(image, src).then(function (image) {
      return {
        image: image,
        extent: extent,
        pixelRatio: pixelRatio
      };
    });
  };
}
},{"../uri.js":"node_modules/ol/uri.js","../Image.js":"node_modules/ol/Image.js","../extent.js":"node_modules/ol/extent.js","./Image.js":"node_modules/ol/source/Image.js"}],"node_modules/ol/source/ImageMapGuide.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Image = _interopRequireWildcard(require("./Image.js"));
var _mapguide = require("./mapguide.js");
var _Image2 = require("../Image.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/ImageMapGuide
 */
/**
 * @typedef {Object} Options
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object} [params] Additional parameters.
 */
/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageMapGuide = /*#__PURE__*/function (_ImageSource) {
  _inherits(ImageMapGuide, _ImageSource);
  var _super = _createSuper(ImageMapGuide);
  /**
   * @param {Options} options ImageMapGuide options.
   */
  function ImageMapGuide(options) {
    var _this;
    _classCallCheck(this, ImageMapGuide);
    _this = _super.call(this, {
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {number}
     */
    _this.displayDpi_ = options.displayDpi !== undefined ? options.displayDpi : 96;

    /**
     * @private
     * @type {!Object}
     */
    _this.params_ = options.params || {};

    /**
     * @private
     * @type {string|undefined}
     */
    _this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {number}
     */
    _this.metersPerUnit_ = options.metersPerUnit !== undefined ? options.metersPerUnit : 1;

    /**
     * @private
     * @type {number}
     */
    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1;

    /**
     * @private
     * @type {boolean}
     */
    _this.useOverlay_ = options.useOverlay !== undefined ? options.useOverlay : false;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    _this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.renderedRevision_ = 0;

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    _this.loaderProjection_ = null;
    return _this;
  }

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  _createClass(ImageMapGuide, [{
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
  }, {
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      var _this2 = this;
      if (this.url_ === undefined) {
        return null;
      }
      if (!this.loader || this.loaderProjection_ !== projection) {
        // Lazily create loader to pick up the view projection and to allow `params` updates
        this.loaderProjection_ = projection;
        this.loader = (0, _mapguide.createLoader)({
          crossOrigin: this.crossOrigin_,
          params: this.params_,
          hidpi: this.hidpi_,
          metersPerUnit: this.metersPerUnit_,
          url: this.url_,
          useOverlay: this.useOverlay_,
          ratio: this.ratio_,
          load: function load(image, src) {
            _this2.image.setImage(image);
            _this2.imageLoadFunction_(_this2.image, src);
            return (0, _Image2.decode)(image);
          }
        });
      }
      return _get(_getPrototypeOf(ImageMapGuide.prototype), "getImageInternal", this).call(this, extent, resolution, pixelRatio, projection);
    }

    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
  }, {
    key: "getImageLoadFunction",
    value: function getImageLoadFunction() {
      return this.imageLoadFunction_;
    }

    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.changed();
    }

    /**
     * Set the image load function of the MapGuide source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
  }, {
    key: "setImageLoadFunction",
    value: function setImageLoadFunction(imageLoadFunction) {
      this.image_ = null;
      this.imageLoadFunction_ = imageLoadFunction;
      this.changed();
    }
  }]);
  return ImageMapGuide;
}(_Image.default);
var _default = exports.default = ImageMapGuide;
},{"./Image.js":"node_modules/ol/source/Image.js","./mapguide.js":"node_modules/ol/source/mapguide.js","../Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/source/static.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoader = createLoader;
var _Image = require("../Image.js");
var _extent = require("../extent.js");
/**
 * @module ol/source/static
 */

/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image. When using this loader with an
 * `ol/source/Image`, the same extent must be set as `extent` of the `ol/layer/Image`.
 * @property {string} url Image URL.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */

/**
 * Creates a loader for static images.
 * @param {LoaderOptions} options Loader options.
 * @return {import("../Image.js").ImageObjectPromiseLoader} Loader.
 * @api
 */
function createLoader(options) {
  var load = options.load || _Image.decode;
  var extent = options.imageExtent;
  var image = new Image();
  if (options.crossOrigin !== null) {
    image.crossOrigin = options.crossOrigin;
  }
  return function () {
    return load(image, options.url).then(function (image) {
      var resolutionX = (0, _extent.getWidth)(extent) / image.width;
      var resolutionY = (0, _extent.getHeight)(extent) / image.height;
      var resolution = resolutionX !== resolutionY ? [resolutionX, resolutionY] : resolutionY;
      return {
        image: image,
        extent: extent,
        resolution: resolution,
        pixelRatio: 1
      };
    });
  };
}
},{"../Image.js":"node_modules/ol/Image.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/ImageStatic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Image = _interopRequireWildcard(require("./Image.js"));
var _Image2 = _interopRequireWildcard(require("../Image.js"));
var _static = require("./static.js");
var _proj = require("../proj.js");
var _extent = require("../extent.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/ImageStatic
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} imageExtent Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {string} url Image URL.
 */
/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */
var Static = /*#__PURE__*/function (_ImageSource) {
  _inherits(Static, _ImageSource);
  var _super = _createSuper(Static);
  /**
   * @param {Options} options ImageStatic options.
   */
  function Static(options) {
    var _this;
    _classCallCheck(this, Static);
    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    var /** @type {import("../Image.js").LoadFunction} */imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: (0, _proj.get)(options.projection)
    });

    /**
     * @private
     * @type {string}
     */
    _this.url_ = options.url;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.imageExtent_ = options.imageExtent;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    _this.image = null;
    _this.image = new _Image2.default(_this.imageExtent_, undefined, 1, (0, _static.createLoader)({
      url: options.url,
      imageExtent: options.imageExtent,
      crossOrigin: crossOrigin,
      load: function load(image, src) {
        _this.image.setImage(image);
        imageLoadFunction(_this.image, src);
        return (0, _Image2.decode)(image);
      }
    }));
    _this.image.addEventListener(_EventType.default.CHANGE, _this.handleImageChange.bind(_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  _createClass(Static, [{
    key: "getImageExtent",
    value: function getImageExtent() {
      return this.imageExtent_;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
  }, {
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      if ((0, _extent.intersects)(extent, this.image.getExtent())) {
        return this.image;
      }
      return null;
    }

    /**
     * Return the URL used for this image source.
     * @return {string} URL.
     * @api
     */
  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.url_;
    }
  }]);
  return Static;
}(_Image.default);
var _default = exports.default = Static;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Image.js":"node_modules/ol/source/Image.js","../Image.js":"node_modules/ol/Image.js","./static.js":"node_modules/ol/source/static.js","../proj.js":"node_modules/ol/proj.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/wms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_VERSION = void 0;
exports.createLoader = createLoader;
exports.getFeatureInfoUrl = getFeatureInfoUrl;
exports.getImageSrc = getImageSrc;
exports.getLegendUrl = getLegendUrl;
exports.getRequestParams = getRequestParams;
exports.getRequestUrl = getRequestUrl;
var _common = require("./common.js");
var _uri = require("../uri.js");
var _string = require("../string.js");
var _Image = require("../Image.js");
var _math = require("../math.js");
var _extent = require("../extent.js");
var _proj = require("../proj.js");
var _Image2 = require("./Image.js");
/**
 * @module ol/source/wms
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_VERSION = exports.DEFAULT_VERSION = '1.3.0';

/**
 * @const
 * @type {import("../size.js").Size}
 */
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];

/**
 * @api
 * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType
 * Set the server type to use implementation-specific parameters beyond the WMS specification.
 *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
 *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)
 *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)
 *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)
 */

/**
 * @param {string} baseUrl Base URL.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {import("../size.js").Size} size Size.
 * @param {import("../proj/Projection.js").default} projection Projection.
 * @param {Object} params WMS params. Will be modified in place.
 * @return {string} Request URL.
 */
function getRequestUrl(baseUrl, extent, size, projection, params) {
  params['WIDTH'] = size[0];
  params['HEIGHT'] = size[1];
  var axisOrientation = projection.getAxisOrientation();
  var bbox;
  var v13 = (0, _string.compareVersions)(params['VERSION'], '1.3') >= 0;
  params[v13 ? 'CRS' : 'SRS'] = projection.getCode();
  if (v13 && axisOrientation.substr(0, 2) == 'ne') {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }
  params['BBOX'] = bbox.join(',');
  return (0, _uri.appendParams)( /** @type {string} */baseUrl, params);
}

/**
 * @param {import("../extent").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio pixel ratio.
 * @param {import("../proj.js").Projection} projection Projection.
 * @param {string} url WMS service url.
 * @param {Object} params WMS params.
 * @param {import("./wms.js").ServerType} serverType The type of the remote WMS server.
 * @return {string} Image src.
 */
function getImageSrc(extent, resolution, pixelRatio, projection, url, params, serverType) {
  params = Object.assign({
    REQUEST: 'GetMap'
  }, params);
  var imageResolution = resolution / pixelRatio;
  var imageSize = [(0, _math.round)((0, _extent.getWidth)(extent) / imageResolution, _common.DECIMALS), (0, _math.round)((0, _extent.getHeight)(extent) / imageResolution, _common.DECIMALS)];
  if (pixelRatio != 1) {
    switch (serverType) {
      case 'geoserver':
        var dpi = 90 * pixelRatio + 0.5 | 0;
        if ('FORMAT_OPTIONS' in params) {
          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
        } else {
          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
        }
        break;
      case 'mapserver':
        params['MAP_RESOLUTION'] = 90 * pixelRatio;
        break;
      case 'carmentaserver':
      case 'qgis':
        params['DPI'] = 90 * pixelRatio;
        break;
      default:
        throw new Error('Unknown `serverType` configured');
    }
  }
  var src = getRequestUrl(url, extent, imageSize, projection, params);
  return src;
}

/**
 * @param {Object} params WMS params.
 * @param {string} request WMS `REQUEST`.
 * @return {Object} WMS params with required properties set.
 */
function getRequestParams(params, request) {
  return Object.assign({
    'REQUEST': request,
    'SERVICE': 'WMS',
    'VERSION': DEFAULT_VERSION,
    'FORMAT': 'image/png',
    'STYLES': '',
    'TRANSPARENT': true
  }, params);
}

/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {Object<string,*>} [params] WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set
 * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {string} url WMS service URL.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */

/**
 * Creates a loader for WMS images.
 * @param {LoaderOptions} options Loader options.
 * @return {import("../Image.js").ImageObjectPromiseLoader} Loader.
 * @api
 */
function createLoader(options) {
  var hidpi = options.hidpi === undefined ? true : options.hidpi;
  var projection = (0, _proj.get)(options.projection || 'EPSG:3857');
  var ratio = options.ratio || 1.5;
  var load = options.load || _Image.decode;

  /**
   * @type {import("../Image.js").Loader}
   */
  return function (extent, resolution, pixelRatio) {
    extent = (0, _Image2.getRequestExtent)(extent, resolution, pixelRatio, ratio);
    if (pixelRatio != 1 && (!hidpi || options.serverType === undefined)) {
      pixelRatio = 1;
    }
    var src = getImageSrc(extent, resolution, pixelRatio, projection, options.url, getRequestParams(options.params, 'GetMap'), options.serverType);
    var image = new Image();
    if (options.crossOrigin !== null) {
      image.crossOrigin = options.crossOrigin;
    }
    return load(image, src).then(function (image) {
      return {
        image: image,
        extent: extent,
        pixelRatio: pixelRatio
      };
    });
  };
}

/**
 * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the
 * GetFeatureInfo URL cannot be constructed.
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to
 * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to
 * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`
 * parameter will be used.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @return {string|undefined} GetFeatureInfo URL.
 * @api
 */
function getFeatureInfoUrl(options, coordinate, resolution) {
  if (options.url === undefined) {
    return undefined;
  }
  var projectionObj = (0, _proj.get)(options.projection || 'EPSG:3857');
  var extent = (0, _extent.getForViewAndSize)(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
  var baseParams = {
    'QUERY_LAYERS': options.params['LAYERS'],
    'INFO_FORMAT': 'application/json'
  };
  Object.assign(baseParams, getRequestParams(options.params, 'GetFeatureInfo'), options.params);
  var x = (0, _math.floor)((coordinate[0] - extent[0]) / resolution, _common.DECIMALS);
  var y = (0, _math.floor)((extent[3] - coordinate[1]) / resolution, _common.DECIMALS);
  var v13 = (0, _string.compareVersions)(baseParams['VERSION'], '1.3') >= 0;
  baseParams[v13 ? 'I' : 'X'] = x;
  baseParams[v13 ? 'J' : 'Y'] = y;
  return getRequestUrl(options.url, extent, GETFEATUREINFO_IMAGE_SIZE, projectionObj, baseParams);
}

/**
 * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly
 * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL
 * cannot be constructed.
 *
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.
 * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and
 * included in URL.
 * @return {string|undefined} GetLegendGraphic URL.
 * @api
 */
function getLegendUrl(options, resolution) {
  if (options.url === undefined) {
    return undefined;
  }
  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': DEFAULT_VERSION,
    'REQUEST': 'GetLegendGraphic',
    'FORMAT': 'image/png'
  };
  if (options.params === undefined || options.params['LAYER'] === undefined) {
    var layers = options.params.LAYERS;
    var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
    if (!isSingleLayer) {
      return undefined;
    }
    baseParams['LAYER'] = layers;
  }
  if (resolution !== undefined) {
    var mpu = (0, _proj.get)(options.projection || 'EPSG:3857').getMetersPerUnit() || 1;
    var pixelSize = 0.00028;
    baseParams['SCALE'] = resolution * mpu / pixelSize;
  }
  Object.assign(baseParams, options.params);
  return (0, _uri.appendParams)(options.url, baseParams);
}
},{"./common.js":"node_modules/ol/source/common.js","../uri.js":"node_modules/ol/uri.js","../string.js":"node_modules/ol/string.js","../Image.js":"node_modules/ol/Image.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","./Image.js":"node_modules/ol/source/Image.js"}],"node_modules/ol/source/ImageWMS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Image = _interopRequireWildcard(require("./Image.js"));
var _reproj = require("../reproj.js");
var _wms = require("./wms.js");
var _Image2 = require("../Image.js");
var _proj = require("../proj.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/ImageWMS
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {string} [url] WMS service URL.
 */
/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageWMS = /*#__PURE__*/function (_ImageSource) {
  _inherits(ImageWMS, _ImageSource);
  var _super = _createSuper(ImageWMS);
  /**
   * @param {Options} [options] ImageWMS options.
   */
  function ImageWMS(options) {
    var _this;
    _classCallCheck(this, ImageWMS);
    options = options ? options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {string|undefined}
     */
    _this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;

    /**
     * @private
     * @type {!Object}
     */
    _this.params_ = options.params;

    /**
     * @private
     * @type {import("./wms.js").ServerType}
     */
    _this.serverType_ = options.serverType;

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {number}
     */
    _this.renderedRevision_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    _this.loaderProjection_ = null;
    return _this;
  }

  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  _createClass(ImageWMS, [{
    key: "getFeatureInfoUrl",
    value: function getFeatureInfoUrl(coordinate, resolution, projection, params) {
      var projectionObj = (0, _proj.get)(projection);
      var sourceProjectionObj = this.getProjection();
      if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
        resolution = (0, _reproj.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, resolution);
        coordinate = (0, _proj.transform)(coordinate, projectionObj, sourceProjectionObj);
      }
      var options = {
        url: this.url_,
        params: _objectSpread(_objectSpread({}, this.params_), params),
        projection: sourceProjectionObj || projectionObj
      };
      return (0, _wms.getFeatureInfoUrl)(options, coordinate, resolution);
    }

    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
  }, {
    key: "getLegendUrl",
    value: function getLegendUrl(resolution, params) {
      return (0, _wms.getLegendUrl)({
        url: this.url_,
        params: _objectSpread(_objectSpread({}, this.params_), params)
      }, resolution);
    }

    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
  }, {
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
  }, {
    key: "getImageInternal",
    value: function getImageInternal(extent, resolution, pixelRatio, projection) {
      var _this2 = this;
      if (this.url_ === undefined) {
        return null;
      }
      if (!this.loader || this.loaderProjection_ !== projection) {
        // Lazily create loader to pick up the view projection and to allow `params` updates
        this.loaderProjection_ = projection;
        this.loader = (0, _wms.createLoader)({
          crossOrigin: this.crossOrigin_,
          params: this.params_,
          projection: projection,
          serverType: this.serverType_,
          hidpi: this.hidpi_,
          url: this.url_,
          ratio: this.ratio_,
          load: function load(image, src) {
            _this2.image.setImage(image);
            _this2.imageLoadFunction_(_this2.image, src);
            return (0, _Image2.decode)(image);
          }
        });
      }
      return _get(_getPrototypeOf(ImageWMS.prototype), "getImageInternal", this).call(this, extent, resolution, pixelRatio, projection);
    }

    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
  }, {
    key: "getImageLoadFunction",
    value: function getImageLoadFunction() {
      return this.imageLoadFunction_;
    }

    /**
     * Return the URL used for this WMS source.
     * @return {string|undefined} URL.
     * @api
     */
  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.url_;
    }

    /**
     * Set the image load function of the source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
  }, {
    key: "setImageLoadFunction",
    value: function setImageLoadFunction(imageLoadFunction) {
      this.imageLoadFunction_ = imageLoadFunction;
      this.changed();
    }

    /**
     * Set the URL to use for requests.
     * @param {string|undefined} url URL.
     * @api
     */
  }, {
    key: "setUrl",
    value: function setUrl(url) {
      if (url != this.url_) {
        this.url_ = url;
        this.loader = null;
        this.changed();
      }
    }

    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.changed();
    }
  }, {
    key: "changed",
    value: function changed() {
      this.image = null;
      _get(_getPrototypeOf(ImageWMS.prototype), "changed", this).call(this);
    }
  }]);
  return ImageWMS;
}(_Image.default);
var _default = exports.default = ImageWMS;
},{"./Image.js":"node_modules/ol/source/Image.js","../reproj.js":"node_modules/ol/reproj.js","./wms.js":"node_modules/ol/source/wms.js","../Image.js":"node_modules/ol/Image.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/net.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResponseError = exports.ClientError = void 0;
exports.getJSON = getJSON;
exports.jsonp = jsonp;
exports.overrideXHR = overrideXHR;
exports.resolveUrl = resolveUrl;
exports.restoreXHR = restoreXHR;
var _util = require("./util.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/net
 */
/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {Function} [errback] Callback on error.
 * @param {string} [callbackParam] Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */
function jsonp(url, callback, errback, callbackParam) {
  var script = document.createElement('script');
  var key = 'olc_' + (0, _util.getUid)(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.includes('?') ? '&' : '?') + (callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function () {
    cleanup();
    if (errback) {
      errback();
    }
  }, 10000);
  window[key] = function (data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.head.appendChild(script);
}
var ResponseError = exports.ResponseError = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);
  var _super = _createSuper(ResponseError);
  /**
   * @param {XMLHttpRequest} response The XHR object.
   */
  function ResponseError(response) {
    var _this;
    _classCallCheck(this, ResponseError);
    var message = 'Unexpected response status: ' + response.status;
    _this = _super.call(this, message);

    /**
     * @type {string}
     */
    _this.name = 'ResponseError';

    /**
     * @type {XMLHttpRequest}
     */
    _this.response = response;
    return _this;
  }
  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var ClientError = exports.ClientError = /*#__PURE__*/function (_Error2) {
  _inherits(ClientError, _Error2);
  var _super2 = _createSuper(ClientError);
  /**
   * @param {XMLHttpRequest} client The XHR object.
   */
  function ClientError(client) {
    var _this2;
    _classCallCheck(this, ClientError);
    _this2 = _super2.call(this, 'Failed to issue request');

    /**
     * @type {string}
     */
    _this2.name = 'ClientError';

    /**
     * @type {XMLHttpRequest}
     */
    _this2.client = client;
    return _this2;
  }
  return _createClass(ClientError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param {string} url The URL.
 * @return {Promise<Object>} A promise that resolves to the JSON response.
 */
function getJSON(url) {
  return new Promise(function (resolve, reject) {
    /**
     * @param {ProgressEvent<XMLHttpRequest>} event The load event.
     */
    function onLoad(event) {
      var client = event.target;
      // status will be 0 for file:// urls
      if (!client.status || client.status >= 200 && client.status < 300) {
        var data;
        try {
          data = JSON.parse(client.responseText);
        } catch (err) {
          var message = 'Error parsing response text as JSON: ' + err.message;
          reject(new Error(message));
          return;
        }
        resolve(data);
        return;
      }
      reject(new ResponseError(client));
    }

    /**
     * @param {ProgressEvent<XMLHttpRequest>} event The error event.
     */
    function onError(event) {
      reject(new ClientError(event.target));
    }
    var client = new XMLHttpRequest();
    client.addEventListener('load', onLoad);
    client.addEventListener('error', onError);
    client.open('GET', url);
    client.setRequestHeader('Accept', 'application/json');
    client.send();
  });
}

/**
 * @param {string} base The base URL.
 * @param {string} url The potentially relative URL.
 * @return {string} The full URL.
 */
function resolveUrl(base, url) {
  if (url.includes('://')) {
    return url;
  }
  return new URL(url, base).href;
}
var originalXHR;
function overrideXHR(xhr) {
  if (typeof XMLHttpRequest !== 'undefined') {
    originalXHR = XMLHttpRequest;
  }
  global.XMLHttpRequest = xhr;
}
function restoreXHR() {
  global.XMLHttpRequest = originalXHR;
}
},{"./util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/ogcTileUtil.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapTileUrlTemplate = getMapTileUrlTemplate;
exports.getTileSetInfo = getTileSetInfo;
exports.getVectorTileUrlTemplate = getVectorTileUrlTemplate;
var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));
var _net = require("../net.js");
var _proj = require("../proj.js");
var _extent = require("../extent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/source/ogcTileUtil
 */

/**
 * See https://ogcapi.ogc.org/tiles/.
 */

/**
 * @typedef {'map' | 'vector'} TileType
 */

/**
 * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin
 */

/**
 * @typedef {Object} TileSet
 * @property {TileType} dataType Type of data represented in the tileset.
 * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.
 * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.
 * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.
 * @property {Array<Link>} links Tileset links.
 */

/**
 * @typedef {Object} Link
 * @property {string} rel The link rel attribute.
 * @property {string} href The link URL.
 * @property {string} type The link type.
 */

/**
 * @typedef {Object} TileMatrixSetLimit
 * @property {string} tileMatrix The tile matrix id.
 * @property {number} minTileRow The minimum tile row.
 * @property {number} maxTileRow The maximum tile row.
 * @property {number} minTileCol The minimum tile column.
 * @property {number} maxTileCol The maximum tile column.
 */

/**
 * @typedef {Object} TileMatrixSet
 * @property {string} id The tile matrix set identifier.
 * @property {string} crs The coordinate reference system.
 * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.
 */

/**
 * @typedef {Object} TileMatrix
 * @property {string} id The tile matrix identifier.
 * @property {number} cellSize The pixel resolution (map units per pixel).
 * @property {Array<number>} pointOfOrigin The map location of the matrix origin.
 * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').
 * @property {number} matrixWidth The number of columns.
 * @property {number} matrixHeight The number of rows.
 * @property {number} tileWidth The pixel width of a tile.
 * @property {number} tileHeight The pixel height of a tile.
 */

/**
 * @type {Object<string, boolean>}
 */
var knownMapMediaTypes = {
  'image/png': true,
  'image/jpeg': true,
  'image/gif': true,
  'image/webp': true
};

/**
 * @type {Object<string, boolean>}
 */
var knownVectorMediaTypes = {
  'application/vnd.mapbox-vector-tile': true,
  'application/geo+json': true
};

/**
 * @typedef {Object} TileSetInfo
 * @property {string} urlTemplate The tile URL template.
 * @property {import("../tilegrid/TileGrid.js").default} grid The tile grid.
 * @property {import("../Tile.js").UrlFunction} urlFunction The tile URL function.
 */

/**
 * @typedef {Object} SourceInfo
 * @property {string} url The tile set URL.
 * @property {string} mediaType The preferred tile media type.
 * @property {Array<string>} [supportedMediaTypes] The supported media types.
 * @property {import("../proj/Projection.js").default} projection The source projection.
 * @property {Object} [context] Optional context for constructing the URL.
 */

/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @return {string} The tile URL template.
 */
function getMapTileUrlTemplate(links, mediaType) {
  var tileUrlTemplate;
  var fallbackUrlTemplate;
  for (var i = 0; i < links.length; ++i) {
    var link = links[i];
    if (link.rel === 'item') {
      if (link.type === mediaType) {
        tileUrlTemplate = link.href;
        break;
      }
      if (knownMapMediaTypes[link.type]) {
        fallbackUrlTemplate = link.href;
      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {
        fallbackUrlTemplate = link.href;
      }
    }
  }
  if (!tileUrlTemplate) {
    if (fallbackUrlTemplate) {
      tileUrlTemplate = fallbackUrlTemplate;
    } else {
      throw new Error('Could not find "item" link');
    }
  }
  return tileUrlTemplate;
}

/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.
 * @return {string} The tile URL template.
 */
function getVectorTileUrlTemplate(links, mediaType, supportedMediaTypes) {
  var tileUrlTemplate;
  var fallbackUrlTemplate;

  /**
   * Lookup of URL by media type.
   * @type {Object<string, string>}
   */
  var hrefLookup = {};
  for (var i = 0; i < links.length; ++i) {
    var link = links[i];
    hrefLookup[link.type] = link.href;
    if (link.rel === 'item') {
      if (link.type === mediaType) {
        tileUrlTemplate = link.href;
        break;
      }
      if (knownVectorMediaTypes[link.type]) {
        fallbackUrlTemplate = link.href;
      }
    }
  }
  if (!tileUrlTemplate && supportedMediaTypes) {
    for (var _i = 0; _i < supportedMediaTypes.length; ++_i) {
      var supportedMediaType = supportedMediaTypes[_i];
      if (hrefLookup[supportedMediaType]) {
        tileUrlTemplate = hrefLookup[supportedMediaType];
        break;
      }
    }
  }
  if (!tileUrlTemplate) {
    if (fallbackUrlTemplate) {
      tileUrlTemplate = fallbackUrlTemplate;
    } else {
      throw new Error('Could not find "item" link');
    }
  }
  return tileUrlTemplate;
}

/**
 * @param {SourceInfo} sourceInfo The source info.
 * @param {TileMatrixSet} tileMatrixSet Tile matrix set.
 * @param {string} tileUrlTemplate Tile URL template.
 * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.
 * @return {TileSetInfo} Tile set info.
 */
function parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits) {
  var projection = sourceInfo.projection;
  if (!projection) {
    projection = (0, _proj.get)(tileMatrixSet.crs);
    if (!projection) {
      throw new Error("Unsupported CRS: ".concat(tileMatrixSet.crs));
    }
  }
  var backwards = projection.getAxisOrientation().substr(0, 2) !== 'en';
  var matrices = tileMatrixSet.tileMatrices;

  /**
   * @type {Object<string, TileMatrix>}
   */
  var matrixLookup = {};
  for (var i = 0; i < matrices.length; ++i) {
    var matrix = matrices[i];
    matrixLookup[matrix.id] = matrix;
  }

  /**
   * @type {Object<string, TileMatrixSetLimit>}
   */
  var limitLookup = {};

  /**
   * @type {Array<string>}
   */
  var matrixIds = [];
  if (tileMatrixSetLimits) {
    for (var _i2 = 0; _i2 < tileMatrixSetLimits.length; ++_i2) {
      var limit = tileMatrixSetLimits[_i2];
      var id = limit.tileMatrix;
      matrixIds.push(id);
      limitLookup[id] = limit;
    }
  } else {
    for (var _i3 = 0; _i3 < matrices.length; ++_i3) {
      var _id = matrices[_i3].id;
      matrixIds.push(_id);
    }
  }
  var length = matrixIds.length;
  var origins = new Array(length);
  var resolutions = new Array(length);
  var sizes = new Array(length);
  var tileSizes = new Array(length);
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  for (var _i4 = 0; _i4 < length; ++_i4) {
    var _id2 = matrixIds[_i4];
    var _matrix = matrixLookup[_id2];
    var origin = _matrix.pointOfOrigin;
    if (backwards) {
      origins[_i4] = [origin[1], origin[0]];
    } else {
      origins[_i4] = origin;
    }
    resolutions[_i4] = _matrix.cellSize;
    sizes[_i4] = [_matrix.matrixWidth, _matrix.matrixHeight];
    tileSizes[_i4] = [_matrix.tileWidth, _matrix.tileHeight];
    var _limit = limitLookup[_id2];
    if (_limit) {
      var tileMapWidth = _matrix.cellSize * _matrix.tileWidth;
      var minX = origins[_i4][0] + _limit.minTileCol * tileMapWidth;
      var maxX = origins[_i4][0] + (_limit.maxTileCol + 1) * tileMapWidth;
      var tileMapHeight = _matrix.cellSize * _matrix.tileHeight;
      var upsideDown = _matrix.cornerOfOrigin === 'bottomLeft';
      var minY = void 0;
      var maxY = void 0;
      if (upsideDown) {
        minY = origins[_i4][1] + _limit.minTileRow * tileMapHeight;
        maxY = origins[_i4][1] + (_limit.maxTileRow + 1) * tileMapHeight;
      } else {
        minY = origins[_i4][1] - (_limit.maxTileRow + 1) * tileMapHeight;
        maxY = origins[_i4][1] - _limit.minTileRow * tileMapHeight;
      }
      (0, _extent.getIntersection)(extent, [minX, minY, maxX, maxY], extent);
    }
  }
  var tileGrid = new _TileGrid.default({
    origins: origins,
    resolutions: resolutions,
    sizes: sizes,
    tileSizes: tileSizes,
    extent: tileMatrixSetLimits ? extent : undefined
  });
  var context = sourceInfo.context;
  var base = sourceInfo.url;

  /** @type {import('../Tile.js').UrlFunction} */
  function tileUrlFunction(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return undefined;
    }
    var id = matrixIds[tileCoord[0]];
    var matrix = matrixLookup[id];
    var upsideDown = matrix.cornerOfOrigin === 'bottomLeft';
    var localContext = {
      tileMatrix: id,
      tileCol: tileCoord[1],
      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2]
    };
    if (tileMatrixSetLimits) {
      var _limit2 = limitLookup[matrix.id];
      if (localContext.tileCol < _limit2.minTileCol || localContext.tileCol > _limit2.maxTileCol || localContext.tileRow < _limit2.minTileRow || localContext.tileRow > _limit2.maxTileRow) {
        return undefined;
      }
    }
    Object.assign(localContext, context);
    var url = tileUrlTemplate.replace(/\{(\w+?)\}/g, function (m, p) {
      return localContext[p];
    });
    return (0, _net.resolveUrl)(base, url);
  }
  return {
    grid: tileGrid,
    urlTemplate: tileUrlTemplate,
    urlFunction: tileUrlFunction
  };
}

/**
 * @param {SourceInfo} sourceInfo The source info.
 * @param {TileSet} tileSet Tile set.
 * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.
 */
function parseTileSetMetadata(sourceInfo, tileSet) {
  var tileMatrixSetLimits = tileSet.tileMatrixSetLimits;
  /** @type {string} */
  var tileUrlTemplate;
  if (tileSet.dataType === 'map') {
    tileUrlTemplate = getMapTileUrlTemplate(tileSet.links, sourceInfo.mediaType);
  } else if (tileSet.dataType === 'vector') {
    tileUrlTemplate = getVectorTileUrlTemplate(tileSet.links, sourceInfo.mediaType, sourceInfo.supportedMediaTypes);
  } else {
    throw new Error('Expected tileset data type to be "map" or "vector"');
  }
  if (tileSet.tileMatrixSet) {
    return parseTileMatrixSet(sourceInfo, tileSet.tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);
  }
  var tileMatrixSetLink = tileSet.links.find(function (link) {
    return link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme';
  });
  if (!tileMatrixSetLink) {
    throw new Error('Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet');
  }
  var tileMatrixSetDefinition = tileMatrixSetLink.href;
  var url = (0, _net.resolveUrl)(sourceInfo.url, tileMatrixSetDefinition);
  return (0, _net.getJSON)(url).then(function (tileMatrixSet) {
    return parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);
  });
}

/**
 * @param {SourceInfo} sourceInfo Source info.
 * @return {Promise<TileSetInfo>} Tile set info.
 */
function getTileSetInfo(sourceInfo) {
  return (0, _net.getJSON)(sourceInfo.url).then(function (tileSet) {
    return parseTileSetMetadata(sourceInfo, tileSet);
  });
}
},{"../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","../net.js":"node_modules/ol/net.js","../proj.js":"node_modules/ol/proj.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/OGCMapTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _ogcTileUtil = require("./ogcTileUtil.js");
var _console = require("../console.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/OGCMapTile
 */
/**
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Map Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {string} [mediaType] The content type for the tiles (e.g. "image/png").  If not provided,
 * the source will try to find a link with rel="item" that uses a supported image type.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. By default, the projection
 * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying
 * a projection to the constructor.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(tile, src) {
 *   tile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */
/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "map" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes.
 * @api
 */
var OGCMapTile = /*#__PURE__*/function (_TileImage) {
  _inherits(OGCMapTile, _TileImage);
  var _super = _createSuper(OGCMapTile);
  /**
   * @param {Options} options OGC map tile options.
   */
  function OGCMapTile(options) {
    var _this;
    _classCallCheck(this, OGCMapTile);
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: 'loading',
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });
    var sourceInfo = {
      url: options.url,
      projection: _this.getProjection(),
      mediaType: options.mediaType,
      context: options.context || null
    };
    (0, _ogcTileUtil.getTileSetInfo)(sourceInfo).then(_this.handleTileSetInfo_.bind(_assertThisInitialized(_this))).catch(_this.handleError_.bind(_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */
  _createClass(OGCMapTile, [{
    key: "handleTileSetInfo_",
    value: function handleTileSetInfo_(tileSetInfo) {
      this.tileGrid = tileSetInfo.grid;
      this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);
      this.setState('ready');
    }

    /**
     * @private
     * @param {Error} error The error.
     */
  }, {
    key: "handleError_",
    value: function handleError_(error) {
      (0, _console.error)(error);
      this.setState('error');
    }
  }]);
  return OGCMapTile;
}(_TileImage2.default);
var _default = exports.default = OGCMapTile;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","./ogcTileUtil.js":"node_modules/ol/source/ogcTileUtil.js","../console.js":"node_modules/ol/console.js"}],"node_modules/ol/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Tile2 = _interopRequireDefault(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("./TileState.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/VectorTile
 */
var VectorTile = /*#__PURE__*/function (_Tile) {
  _inherits(VectorTile, _Tile);
  var _super = _createSuper(VectorTile);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  function VectorTile(tileCoord, state, src, format, tileLoadFunction, options) {
    var _this;
    _classCallCheck(this, VectorTile);
    _this = _super.call(this, tileCoord, state, options);

    /**
     * Extent of this tile; set by the source.
     * @type {import("./extent.js").Extent}
     */
    _this.extent = null;

    /**
     * @private
     * @type {import("./format/Feature.js").default}
     */
    _this.format_ = format;

    /**
     * @private
     * @type {Array<import("./Feature.js").FeatureLike>}
     */
    _this.features_ = null;

    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */
    _this.loader_;

    /**
     * Feature projection of this tile; set by the source.
     * @type {import("./proj/Projection.js").default}
     */
    _this.projection = null;

    /**
     * Resolution of this tile; set by the source.
     * @type {number}
     */
    _this.resolution;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    _this.tileLoadFunction_ = tileLoadFunction;

    /**
     * @private
     * @type {string}
     */
    _this.url_ = src;
    _this.key = src;
    return _this;
  }

  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */
  _createClass(VectorTile, [{
    key: "getFormat",
    value: function getFormat() {
      return this.format_;
    }

    /**
     * Get the features for this tile. Geometries will be in the view projection.
     * @return {Array<import("./Feature.js").FeatureLike>} Features.
     * @api
     */
  }, {
    key: "getFeatures",
    value: function getFeatures() {
      return this.features_;
    }

    /**
     * Load not yet loaded URI.
     */
  }, {
    key: "load",
    value: function load() {
      if (this.state == _TileState.default.IDLE) {
        this.setState(_TileState.default.LOADING);
        this.tileLoadFunction_(this, this.url_);
        if (this.loader_) {
          this.loader_(this.extent, this.resolution, this.projection);
        }
      }
    }

    /**
     * Handler for successful tile load.
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data projection.
     */
  }, {
    key: "onLoad",
    value: function onLoad(features, dataProjection) {
      this.setFeatures(features);
    }

    /**
     * Handler for tile load errors.
     */
  }, {
    key: "onError",
    value: function onError() {
      this.setState(_TileState.default.ERROR);
    }

    /**
     * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
     * Sets the features for the tile.
     * @param {Array<import("./Feature.js").FeatureLike>} features Features.
     * @api
     */
  }, {
    key: "setFeatures",
    value: function setFeatures(features) {
      this.features_ = features;
      this.setState(_TileState.default.LOADED);
    }

    /**
     * Set the feature loader for reading this tile's features.
     * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
     * @api
     */
  }, {
    key: "setLoader",
    value: function setLoader(loader) {
      this.loader_ = loader;
    }
  }]);
  return VectorTile;
}(_Tile2.default);
var _default = exports.default = VectorTile;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js"}],"node_modules/ol/VectorRenderTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Tile2 = _interopRequireDefault(require("./Tile.js"));
var _dom = require("./dom.js");
var _util = require("./util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/VectorRenderTile
 */
/**
 * @typedef {Object} ReplayState
 * @property {boolean} dirty Dirty.
 * @property {null|import("./render.js").OrderFunction} renderedRenderOrder RenderedRenderOrder.
 * @property {number} renderedTileRevision RenderedTileRevision.
 * @property {number} renderedResolution RenderedResolution.
 * @property {number} renderedRevision RenderedRevision.
 * @property {number} renderedTileResolution RenderedTileResolution.
 * @property {number} renderedTileZ RenderedTileZ.
 */

/**
 * @type {Array<HTMLCanvasElement>}
 */
var canvasPool = [];
var VectorRenderTile = /*#__PURE__*/function (_Tile) {
  _inherits(VectorRenderTile, _Tile);
  var _super = _createSuper(VectorRenderTile);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  function VectorRenderTile(tileCoord, state, urlTileCoord, getSourceTiles) {
    var _this;
    _classCallCheck(this, VectorRenderTile);
    _this = _super.call(this, tileCoord, state, {
      transition: 0
    });

    /**
     * @private
     * @type {!Object<string, CanvasRenderingContext2D>}
     */
    _this.context_ = {};

    /**
     * Executor groups by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */
    _this.executorGroups = {};

    /**
     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */
    _this.declutterExecutorGroups = {};

    /**
     * Number of loading source tiles. Read/written by the source.
     * @type {number}
     */
    _this.loadingSourceTiles = 0;

    /**
     * @type {Object<number, ImageData>}
     */
    _this.hitDetectionImageData = {};

    /**
     * @private
     * @type {!Object<string, ReplayState>}
     */
    _this.replayState_ = {};

    /**
     * @type {Array<import("./VectorTile.js").default>}
     */
    _this.sourceTiles = [];

    /**
     * @type {Object<string, boolean>}
     */
    _this.errorTileKeys = {};

    /**
     * @type {number}
     */
    _this.wantedResolution;

    /**
     * @type {!function():Array<import("./VectorTile.js").default>}
     */
    _this.getSourceTiles = getSourceTiles.bind(undefined, _assertThisInitialized(_this));

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    _this.wrappedTileCoord = urlTileCoord;
    return _this;
  }

  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  _createClass(VectorRenderTile, [{
    key: "getContext",
    value: function getContext(layer) {
      var key = (0, _util.getUid)(layer);
      if (!(key in this.context_)) {
        this.context_[key] = (0, _dom.createCanvasContext2D)(1, 1, canvasPool);
      }
      return this.context_[key];
    }

    /**
     * @param {import("./layer/Layer.js").default} layer Layer.
     * @return {boolean} Tile has a rendering context for the given layer.
     */
  }, {
    key: "hasContext",
    value: function hasContext(layer) {
      return (0, _util.getUid)(layer) in this.context_;
    }

    /**
     * Get the Canvas for this tile.
     * @param {import("./layer/Layer.js").default} layer Layer.
     * @return {HTMLCanvasElement} Canvas.
     */
  }, {
    key: "getImage",
    value: function getImage(layer) {
      return this.hasContext(layer) ? this.getContext(layer).canvas : null;
    }

    /**
     * @param {import("./layer/Layer.js").default} layer Layer.
     * @return {ReplayState} The replay state.
     */
  }, {
    key: "getReplayState",
    value: function getReplayState(layer) {
      var key = (0, _util.getUid)(layer);
      if (!(key in this.replayState_)) {
        this.replayState_[key] = {
          dirty: false,
          renderedRenderOrder: null,
          renderedResolution: NaN,
          renderedRevision: -1,
          renderedTileResolution: NaN,
          renderedTileRevision: -1,
          renderedTileZ: -1
        };
      }
      return this.replayState_[key];
    }

    /**
     * Load the tile.
     */
  }, {
    key: "load",
    value: function load() {
      this.getSourceTiles();
    }

    /**
     * Remove from the cache due to expiry
     */
  }, {
    key: "release",
    value: function release() {
      for (var key in this.context_) {
        var context = this.context_[key];
        (0, _dom.releaseCanvas)(context);
        canvasPool.push(context.canvas);
        delete this.context_[key];
      }
      _get(_getPrototypeOf(VectorRenderTile.prototype), "release", this).call(this);
    }
  }]);
  return VectorRenderTile;
}(_Tile2.default);
var _default = exports.default = VectorRenderTile;
},{"./Tile.js":"node_modules/ol/Tile.js","./dom.js":"node_modules/ol/dom.js","./util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.defaultLoadFunction = defaultLoadFunction;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _VectorTile = _interopRequireDefault(require("../VectorTile.js"));
var _TileCache = _interopRequireDefault(require("../TileCache.js"));
var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _UrlTile2 = _interopRequireDefault(require("./UrlTile.js"));
var _VectorRenderTile = _interopRequireDefault(require("../VectorRenderTile.js"));
var _common = require("../tilegrid/common.js");
var _extent = require("../extent.js");
var _tilegrid = require("../tilegrid.js");
var _tilecoord = require("../tilecoord.js");
var _obj = require("../obj.js");
var _featureloader = require("../featureloader.js");
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/VectorTile
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {import("../format/Feature.js").default} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile~VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this for pbf tiles:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function(extent, resolution, projection) {
 *     fetch(url).then(function(response) {
 *       response.arrayBuffer().then(function(data) {
 *         const format = tile.getFormat() // ol/format/MVT configured as source format
 *         const features = format.readFeatures(data, {
 *           extent: extent,
 *           featureProjection: projection
 *         });
 *         tile.setFeatures(features);
 *       });
 *     });
 *   });
 * }
 * ```
 * If you do not need extent, resolution and projection to get the features for a tile (e.g.
 * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
 * to call `setFeatures()` on the tile:
 * ```js
 * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
 * async function tileLoadFunction(tile, url) {
 *   const response = await fetch(url);
 *   const data = await response.json();
 *   tile.setFeatures(format.readFeatures(data));
 * }
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var VectorTile = /*#__PURE__*/function (_UrlTile) {
  _inherits(VectorTile, _UrlTile);
  var _super = _createSuper(VectorTile);
  /**
   * @param {!Options} options Vector tile options.
   */
  function VectorTile(options) {
    var _this;
    _classCallCheck(this, VectorTile);
    var projection = options.projection || 'EPSG:3857';
    var extent = options.extent || (0, _tilegrid.extentFromProjection)(projection);
    var tileGrid = options.tileGrid || (0, _tilegrid.createXYZ)({
      extent: extent,
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      interpolate: true,
      opaque: false,
      projection: projection,
      state: options.state,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === undefined ? true : options.wrapX,
      transition: options.transition,
      zDirection: options.zDirection === undefined ? 1 : options.zDirection
    });

    /**
     * @private
     * @type {import("../format/Feature.js").default|null}
     */
    _this.format_ = options.format ? options.format : null;

    /**
     * @private
     * @type {TileCache}
     */
    _this.sourceTileCache = new _TileCache.default(_this.tileCache.highWaterMark);

    /**
     * @private
     * @type {boolean}
     */
    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */
    _this.tileClass = options.tileClass ? options.tileClass : _VectorTile.default;

    /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    _this.tileGrids_ = {};
    return _this;
  }

  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  _createClass(VectorTile, [{
    key: "getFeaturesInExtent",
    value: function getFeaturesInExtent(extent) {
      var features = [];
      var tileCache = this.tileCache;
      if (tileCache.getCount() === 0) {
        return features;
      }
      var z = (0, _tilecoord.fromKey)(tileCache.peekFirstKey())[0];
      var tileGrid = this.tileGrid;
      tileCache.forEach(function (tile) {
        if (tile.tileCoord[0] !== z || tile.getState() !== _TileState.default.LOADED) {
          return;
        }
        var sourceTiles = tile.getSourceTiles();
        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
          var sourceTile = sourceTiles[i];
          var tileCoord = sourceTile.tileCoord;
          if ((0, _extent.intersects)(extent, tileGrid.getTileCoordExtent(tileCoord))) {
            var tileFeatures = sourceTile.getFeatures();
            if (tileFeatures) {
              for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
                var candidate = tileFeatures[j];
                var geometry = candidate.getGeometry();
                if ((0, _extent.intersects)(extent, geometry.getExtent())) {
                  features.push(candidate);
                }
              }
            }
          }
        }
      });
      return features;
    }

    /**
     * @return {boolean} The source can have overlapping geometries.
     */
  }, {
    key: "getOverlaps",
    value: function getOverlaps() {
      return this.overlaps_;
    }

    /**
     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
     * @api
     */
  }, {
    key: "clear",
    value: function clear() {
      this.tileCache.clear();
      this.sourceTileCache.clear();
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var tileCache = this.getTileCacheForProjection(projection);
      var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {
        var cacheKey = (0, _tilecoord.getCacheKeyForTileKey)(key);
        var tile = tileCache.peek(cacheKey);
        if (tile) {
          var sourceTiles = tile.sourceTiles;
          for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
            acc[sourceTiles[i].getKey()] = true;
          }
        }
        return acc;
      }, {});
      _get(_getPrototypeOf(VectorTile.prototype), "expireCache", this).call(this, projection, usedTiles);
      this.sourceTileCache.expireCache(usedSourceTiles);
    }

    /**
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection").default} projection Projection.
     * @param {VectorRenderTile} tile Vector image tile.
     * @return {Array<import("../VectorTile").default>} Tile keys.
     */
  }, {
    key: "getSourceTiles",
    value: function getSourceTiles(pixelRatio, projection, tile) {
      var _this2 = this;
      if (tile.getState() === _TileState.default.IDLE) {
        tile.setState(_TileState.default.LOADING);
        var urlTileCoord = tile.wrappedTileCoord;
        var tileGrid = this.getTileGridForProjection(projection);
        var extent = tileGrid.getTileCoordExtent(urlTileCoord);
        var z = urlTileCoord[0];
        var resolution = tileGrid.getResolution(z);
        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
        (0, _extent.buffer)(extent, -resolution, extent);
        var sourceTileGrid = this.tileGrid;
        var sourceExtent = sourceTileGrid.getExtent();
        if (sourceExtent) {
          (0, _extent.getIntersection)(extent, sourceExtent, extent);
        }
        var sourceZ = sourceTileGrid.getZForResolution(resolution, this.zDirection);
        sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
          var tileUrl = _this2.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
          var sourceTile = _this2.sourceTileCache.containsKey(tileUrl) ? _this2.sourceTileCache.get(tileUrl) : new _this2.tileClass(sourceTileCoord, tileUrl ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl, _this2.format_, _this2.tileLoadFunction);
          tile.sourceTiles.push(sourceTile);
          var sourceTileState = sourceTile.getState();
          if (sourceTileState < _TileState.default.LOADED) {
            var listenChange = function listenChange(event) {
              _this2.handleTileChange(event);
              var state = sourceTile.getState();
              if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {
                var sourceTileKey = sourceTile.getKey();
                if (sourceTileKey in tile.errorTileKeys) {
                  if (sourceTile.getState() === _TileState.default.LOADED) {
                    delete tile.errorTileKeys[sourceTileKey];
                  }
                } else {
                  tile.loadingSourceTiles--;
                }
                if (state === _TileState.default.ERROR) {
                  tile.errorTileKeys[sourceTileKey] = true;
                } else {
                  sourceTile.removeEventListener(_EventType.default.CHANGE, listenChange);
                }
                if (tile.loadingSourceTiles === 0) {
                  tile.setState((0, _obj.isEmpty)(tile.errorTileKeys) ? _TileState.default.LOADED : _TileState.default.ERROR);
                }
              }
            };
            sourceTile.addEventListener(_EventType.default.CHANGE, listenChange);
            tile.loadingSourceTiles++;
          }
          if (sourceTileState === _TileState.default.IDLE) {
            sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
            sourceTile.projection = projection;
            sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);
            _this2.sourceTileCache.set(tileUrl, sourceTile);
            sourceTile.load();
          }
        });
        if (!tile.loadingSourceTiles) {
          tile.setState(tile.sourceTiles.some(function (sourceTile) {
            return sourceTile.getState() === _TileState.default.ERROR;
          }) ? _TileState.default.ERROR : _TileState.default.LOADED);
        }
      }
      return tile.sourceTiles;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!VectorRenderTile} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      var _this3 = this;
      var coordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      var key = this.getKey();
      var tile;
      if (this.tileCache.containsKey(coordKey)) {
        tile = this.tileCache.get(coordKey);
        if (tile.key === key) {
          return tile;
        }
      }
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var sourceExtent = this.getTileGrid().getExtent();
      var tileGrid = this.getTileGridForProjection(projection);
      if (urlTileCoord && sourceExtent) {
        var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);
        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
        (0, _extent.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);
        if (!(0, _extent.intersects)(sourceExtent, tileExtent)) {
          urlTileCoord = null;
        }
      }
      var empty = true;
      if (urlTileCoord !== null) {
        var sourceTileGrid = this.tileGrid;
        var resolution = tileGrid.getResolution(z);
        var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
        var extent = tileGrid.getTileCoordExtent(urlTileCoord);
        (0, _extent.buffer)(extent, -resolution, extent);
        sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
          empty = empty && !_this3.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
        });
      }
      var newTile = new _VectorRenderTile.default(tileCoord, empty ? _TileState.default.EMPTY : _TileState.default.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
      newTile.key = key;
      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        this.tileCache.replace(coordKey, newTile);
      } else {
        this.tileCache.set(coordKey, newTile);
      }
      return newTile;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      var code = projection.getCode();
      var tileGrid = this.tileGrids_[code];
      if (!tileGrid) {
        // A tile grid that matches the tile size of the source tile grid is more
        // likely to have 1:1 relationships between source tiles and rendered tiles.
        var sourceTileGrid = this.tileGrid;
        var resolutions = sourceTileGrid.getResolutions().slice();
        var origins = resolutions.map(function (resolution, z) {
          return sourceTileGrid.getOrigin(z);
        });
        var tileSizes = resolutions.map(function (resolution, z) {
          return sourceTileGrid.getTileSize(z);
        });
        var length = _common.DEFAULT_MAX_ZOOM + 1;
        for (var z = resolutions.length; z < length; ++z) {
          resolutions.push(resolutions[z - 1] / 2);
          origins.push(origins[z - 1]);
          tileSizes.push(tileSizes[z - 1]);
        }
        tileGrid = new _TileGrid.default({
          extent: sourceTileGrid.getExtent(),
          origins: origins,
          resolutions: resolutions,
          tileSizes: tileSizes
        });
        this.tileGrids_[code] = tileGrid;
      }
      return tileGrid;
    }

    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return pixelRatio;
    }

    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
  }, {
    key: "getTilePixelSize",
    value: function getTilePixelSize(z, pixelRatio, projection) {
      var tileGrid = this.getTileGridForProjection(projection);
      var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);
      return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
    }

    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
  }, {
    key: "updateCacheSize",
    value: function updateCacheSize(tileCount, projection) {
      _get(_getPrototypeOf(VectorTile.prototype), "updateCacheSize", this).call(this, tileCount * 2, projection);
      this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
    }
  }]);
  return VectorTile;
}(_UrlTile2.default);
var _default = exports.default = VectorTile;
/**
 * Sets the loader for a tile.
 * @param {import("../VectorTile.js").default} tile Vector tile.
 * @param {string} url URL.
 */
function defaultLoadFunction(tile, url) {
  tile.setLoader(
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  function (extent, resolution, projection) {
    (0, _featureloader.loadFeaturesXhr)(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
  });
}
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../VectorTile.js":"node_modules/ol/VectorTile.js","../TileCache.js":"node_modules/ol/TileCache.js","../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","../TileState.js":"node_modules/ol/TileState.js","./UrlTile.js":"node_modules/ol/source/UrlTile.js","../VectorRenderTile.js":"node_modules/ol/VectorRenderTile.js","../tilegrid/common.js":"node_modules/ol/tilegrid/common.js","../extent.js":"node_modules/ol/extent.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../obj.js":"node_modules/ol/obj.js","../featureloader.js":"node_modules/ol/featureloader.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/source/OGCVectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _VectorTile = _interopRequireDefault(require("./VectorTile.js"));
var _ogcTileUtil = require("./ogcTileUtil.js");
var _console = require("../console.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/OGCVectorTile
 */
/**
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Vector Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {import("../format/Feature.js").default} format Feature parser for tiles.
 * @property {string} [mediaType] The content type for the tiles (e.g. "application/vnd.mapbox-vector-tile").  If not provided,
 * the source will try to find a link with rel="item" that uses a vector type supported by the configured format.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile~VectorTile}.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "vector" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes.
 *
 * Vector tile sets may come in a variety of formats (e.g. GeoJSON, MVT).  The `format` option is used to determine
 * which of the advertised media types is used.  If you need to force the use of a particular media type, you can
 * provide the `mediaType` option.
 * @api
 */
var OGCVectorTile = /*#__PURE__*/function (_VectorTileSource) {
  _inherits(OGCVectorTile, _VectorTileSource);
  var _super = _createSuper(OGCVectorTile);
  /**
   * @param {Options} options OGC vector tile options.
   */
  function OGCVectorTile(options) {
    var _this;
    _classCallCheck(this, OGCVectorTile);
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      format: options.format,
      overlaps: options.overlaps,
      projection: options.projection,
      tileClass: options.tileClass,
      transition: options.transition,
      wrapX: options.wrapX,
      zDirection: options.zDirection,
      state: 'loading'
    });
    var sourceInfo = {
      url: options.url,
      projection: _this.getProjection(),
      mediaType: options.mediaType,
      supportedMediaTypes: options.format.supportedMediaTypes,
      context: options.context || null
    };
    (0, _ogcTileUtil.getTileSetInfo)(sourceInfo).then(_this.handleTileSetInfo_.bind(_assertThisInitialized(_this))).catch(_this.handleError_.bind(_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */
  _createClass(OGCVectorTile, [{
    key: "handleTileSetInfo_",
    value: function handleTileSetInfo_(tileSetInfo) {
      this.tileGrid = tileSetInfo.grid;
      this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);
      this.setState('ready');
    }

    /**
     * @private
     * @param {Error} error The error.
     */
  }, {
    key: "handleError_",
    value: function handleError_(error) {
      (0, _console.error)(error);
      this.setState('error');
    }
  }]);
  return OGCVectorTile;
}(_VectorTile.default);
var _default = exports.default = OGCVectorTile;
},{"./VectorTile.js":"node_modules/ol/source/VectorTile.js","./ogcTileUtil.js":"node_modules/ol/source/ogcTileUtil.js","../console.js":"node_modules/ol/console.js"}],"node_modules/ol/source/OSM.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ATTRIBUTION = void 0;
var _XYZ2 = _interopRequireDefault(require("./XYZ.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/OSM
 */
/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = exports.ATTRIBUTION = '&#169; ' + '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' + 'contributors.';

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = /*#__PURE__*/function (_XYZ) {
  _inherits(OSM, _XYZ);
  var _super = _createSuper(OSM);
  /**
   * @param {Options} [options] Open Street Map options.
   */
  function OSM(options) {
    _classCallCheck(this, OSM);
    options = options || {};
    var attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
    var url = options.url !== undefined ? options.url : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    return _super.call(this, {
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      opaque: options.opaque !== undefined ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
  return _createClass(OSM);
}(_XYZ2.default);
var _default = exports.default = OSM;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js"}],"node_modules/ol/layer/BaseImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer2 = _interopRequireDefault(require("./Layer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/BaseImage
 */
/**
 * @template {import("../source/Image.js").default} ImageSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {ImageSourceType} [source] Source for this layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<ImageSourceType, RendererType>}
 * @api
 */
var BaseImageLayer = /*#__PURE__*/function (_Layer) {
  _inherits(BaseImageLayer, _Layer);
  var _super = _createSuper(BaseImageLayer);
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  function BaseImageLayer(options) {
    _classCallCheck(this, BaseImageLayer);
    options = options ? options : {};
    return _super.call(this, options);
  }
  return _createClass(BaseImageLayer);
}(_Layer2.default);
var _default = exports.default = BaseImageLayer;
},{"./Layer.js":"node_modules/ol/layer/Layer.js"}],"node_modules/ol/renderer/canvas/ImageLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer = _interopRequireDefault(require("./Layer.js"));
var _ImageState = _interopRequireDefault(require("../../ImageState.js"));
var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));
var _transform = require("../../transform.js");
var _extent = require("../../extent.js");
var _proj = require("../../proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/ImageLayer
 */
/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
  _inherits(CanvasImageLayerRenderer, _CanvasLayerRenderer);
  var _super = _createSuper(CanvasImageLayerRenderer);
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  function CanvasImageLayerRenderer(imageLayer) {
    var _this;
    _classCallCheck(this, CanvasImageLayerRenderer);
    _this = _super.call(this, imageLayer);

    /**
     * @protected
     * @type {?import("../../Image.js").default}
     */
    _this.image_ = null;
    return _this;
  }

  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  _createClass(CanvasImageLayerRenderer, [{
    key: "getImage",
    value: function getImage() {
      return !this.image_ ? null : this.image_.getImage();
    }

    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var viewResolution = viewState.resolution;
      var imageSource = this.getLayer().getSource();
      var hints = frameState.viewHints;
      var renderedExtent = frameState.extent;
      if (layerState.extent !== undefined) {
        renderedExtent = (0, _extent.getIntersection)(renderedExtent, (0, _proj.fromUserExtent)(layerState.extent, viewState.projection));
      }
      if (!hints[_ViewHint.default.ANIMATING] && !hints[_ViewHint.default.INTERACTING] && !(0, _extent.isEmpty)(renderedExtent)) {
        if (imageSource) {
          var projection = viewState.projection;
          var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
          if (image) {
            if (this.loadImage(image)) {
              this.image_ = image;
            } else if (image.getState() === _ImageState.default.EMPTY) {
              this.image_ = null;
            }
          }
        } else {
          this.image_ = null;
        }
      }
      return !!this.image_;
    }

    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      var frameState = this.frameState;
      if (!frameState) {
        return null;
      }
      var layer = this.getLayer();
      var coordinate = (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      var layerExtent = layer.getExtent();
      if (layerExtent) {
        if (!(0, _extent.containsCoordinate)(layerExtent, coordinate)) {
          return null;
        }
      }
      var imageExtent = this.image_.getExtent();
      var img = this.image_.getImage();
      var imageMapWidth = (0, _extent.getWidth)(imageExtent);
      var col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));
      if (col < 0 || col >= img.width) {
        return null;
      }
      var imageMapHeight = (0, _extent.getHeight)(imageExtent);
      var row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));
      if (row < 0 || row >= img.height) {
        return null;
      }
      return this.getImageData(img, col, row);
    }

    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      var image = this.image_;
      var imageExtent = image.getExtent();
      var imageResolution = image.getResolution();
      var _ref = Array.isArray(imageResolution) ? imageResolution : [imageResolution, imageResolution],
        _ref2 = _slicedToArray(_ref, 2),
        imageResolutionX = _ref2[0],
        imageResolutionY = _ref2[1];
      var imagePixelRatio = image.getPixelRatio();
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var viewCenter = viewState.center;
      var viewResolution = viewState.resolution;
      var scaleX = pixelRatio * imageResolutionX / (viewResolution * imagePixelRatio);
      var scaleY = pixelRatio * imageResolutionY / (viewResolution * imagePixelRatio);
      var extent = frameState.extent;
      var resolution = viewState.resolution;
      var rotation = viewState.rotation;
      // desired dimensions of the canvas in pixels
      var width = Math.round((0, _extent.getWidth)(extent) / resolution * pixelRatio);
      var height = Math.round((0, _extent.getHeight)(extent) / resolution * pixelRatio);

      // set forward and inverse pixel transforms
      (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
      (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
      var canvasTransform = (0, _transform.toString)(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      var context = this.context;
      var canvas = context.canvas;
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }

      // clipped rendering if layer extent is set
      var clipped = false;
      var render = true;
      if (layerState.extent) {
        var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, viewState.projection);
        render = (0, _extent.intersects)(layerExtent, frameState.extent);
        clipped = render && !(0, _extent.containsExtent)(layerExtent, frameState.extent);
        if (clipped) {
          this.clipUnrotated(context, frameState, layerExtent);
        }
      }
      var img = image.getImage();
      var transform = (0, _transform.compose)(this.tempTransform, width / 2, height / 2, scaleX, scaleY, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolutionX, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolutionY);
      this.renderedResolution = imageResolutionY * pixelRatio / imagePixelRatio;
      var dw = img.width * transform[0];
      var dh = img.height * transform[3];
      if (!this.getLayer().getSource().getInterpolate()) {
        context.imageSmoothingEnabled = false;
      }
      this.preRender(context, frameState);
      if (render && dw >= 0.5 && dh >= 0.5) {
        var dx = transform[4];
        var dy = transform[5];
        var opacity = layerState.opacity;
        var previousAlpha;
        if (opacity !== 1) {
          previousAlpha = context.globalAlpha;
          context.globalAlpha = opacity;
        }
        context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);
        if (opacity !== 1) {
          context.globalAlpha = previousAlpha;
        }
      }
      this.postRender(context, frameState);
      if (clipped) {
        context.restore();
      }
      context.imageSmoothingEnabled = true;
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
      return this.container;
    }
  }]);
  return CanvasImageLayerRenderer;
}(_Layer.default);
var _default = exports.default = CanvasImageLayerRenderer;
},{"./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../ImageState.js":"node_modules/ol/ImageState.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/layer/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseImage = _interopRequireDefault(require("./BaseImage.js"));
var _ImageLayer = _interopRequireDefault(require("../renderer/canvas/ImageLayer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Image
 */
/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}
 * @api
 */
var ImageLayer = /*#__PURE__*/function (_BaseImageLayer) {
  _inherits(ImageLayer, _BaseImageLayer);
  var _super = _createSuper(ImageLayer);
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  function ImageLayer(options) {
    _classCallCheck(this, ImageLayer);
    return _super.call(this, options);
  }
  _createClass(ImageLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new _ImageLayer.default(this);
    }

    /**
     * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
     * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
     * source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      return _get(_getPrototypeOf(ImageLayer.prototype), "getData", this).call(this, pixel);
    }
  }]);
  return ImageLayer;
}(_BaseImage.default);
var _default = exports.default = ImageLayer;
},{"./BaseImage.js":"node_modules/ol/layer/BaseImage.js","../renderer/canvas/ImageLayer.js":"node_modules/ol/renderer/canvas/ImageLayer.js"}],"node_modules/ol/layer/TileProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/layer/TileProperty
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};
},{}],"node_modules/ol/layer/BaseTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer2 = _interopRequireDefault(require("./Layer.js"));
var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/BaseTile
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */
/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
var BaseTileLayer = /*#__PURE__*/function (_Layer) {
  _inherits(BaseTileLayer, _Layer);
  var _super = _createSuper(BaseTileLayer);
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  function BaseTileLayer(options) {
    var _this;
    _classCallCheck(this, BaseTileLayer);
    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions);

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {BaseTileLayerOnSignature<void>}
     */
    _this.un;
    _this.setPreload(options.preload !== undefined ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
    return _this;
  }

  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  _createClass(BaseTileLayer, [{
    key: "getPreload",
    value: function getPreload() {
      return /** @type {number} */this.get(_TileProperty.default.PRELOAD);
    }

    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
  }, {
    key: "setPreload",
    value: function setPreload(preload) {
      this.set(_TileProperty.default.PRELOAD, preload);
    }

    /**
     * Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
  }, {
    key: "getUseInterimTilesOnError",
    value: function getUseInterimTilesOnError() {
      return /** @type {boolean} */(
        this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
      );
    }

    /**
     * Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
  }, {
    key: "setUseInterimTilesOnError",
    value: function setUseInterimTilesOnError(useInterimTilesOnError) {
      this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }

    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      return _get(_getPrototypeOf(BaseTileLayer.prototype), "getData", this).call(this, pixel);
    }
  }]);
  return BaseTileLayer;
}(_Layer2.default);
var _default = exports.default = BaseTileLayer;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js"}],"node_modules/ol/renderer/canvas/TileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer = _interopRequireDefault(require("./Layer.js"));
var _ImageTile = _interopRequireDefault(require("../../ImageTile.js"));
var _Tile = _interopRequireDefault(require("../../reproj/Tile.js"));
var _TileRange = _interopRequireDefault(require("../../TileRange.js"));
var _TileState = _interopRequireDefault(require("../../TileState.js"));
var _transform = require("../../transform.js");
var _array = require("../../array.js");
var _extent = require("../../extent.js");
var _proj = require("../../proj.js");
var _util = require("../../util.js");
var _size = require("../../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/TileLayer
 */
/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
var CanvasTileLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
  _inherits(CanvasTileLayerRenderer, _CanvasLayerRenderer);
  var _super = _createSuper(CanvasTileLayerRenderer);
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  function CanvasTileLayerRenderer(tileLayer) {
    var _this;
    _classCallCheck(this, CanvasTileLayerRenderer);
    _this = _super.call(this, tileLayer);

    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */
    _this.extentChanged = true;

    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */
    _this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    _this.renderedPixelRatio;

    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */
    _this.renderedProjection = null;

    /**
     * @protected
     * @type {number}
     */
    _this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    _this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    _this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    _this.tmpExtent = (0, _extent.createEmpty)();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    _this.tmpTileRange_ = new _TileRange.default(0, 0, 0, 0);
    return _this;
  }

  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  _createClass(CanvasTileLayerRenderer, [{
    key: "isDrawableTile",
    value: function isDrawableTile(tile) {
      var tileLayer = this.getLayer();
      var tileState = tile.getState();
      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
      return tileState == _TileState.default.LOADED || tileState == _TileState.default.EMPTY || tileState == _TileState.default.ERROR && !useInterimTilesOnError;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {!import("../../Tile.js").default} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, frameState) {
      var pixelRatio = frameState.pixelRatio;
      var projection = frameState.viewState.projection;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getSource();
      var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
      if (tile.getState() == _TileState.default.ERROR) {
        if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
          // Preloaded tiles for lower resolutions might have finished loading.
          this.newTiles_ = true;
        }
      }
      if (!this.isDrawableTile(tile)) {
        tile = tile.getInterimTile();
      }
      return tile;
    }

    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      var frameState = this.frameState;
      if (!frameState) {
        return null;
      }
      var layer = this.getLayer();
      var coordinate = (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      var layerExtent = layer.getExtent();
      if (layerExtent) {
        if (!(0, _extent.containsCoordinate)(layerExtent, coordinate)) {
          return null;
        }
      }
      var pixelRatio = frameState.pixelRatio;
      var projection = frameState.viewState.projection;
      var viewState = frameState.viewState;
      var source = layer.getRenderSource();
      var tileGrid = source.getTileGridForProjection(viewState.projection);
      var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
      for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
        var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
        var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);
        if (!(tile instanceof _ImageTile.default || tile instanceof _Tile.default) || tile instanceof _Tile.default && tile.getState() === _TileState.default.EMPTY) {
          return null;
        }
        if (tile.getState() !== _TileState.default.LOADED) {
          continue;
        }
        var tileOrigin = tileGrid.getOrigin(z);
        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z));
        var tileResolution = tileGrid.getResolution(z);
        var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
        var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
        var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
        return this.getImageData(tile.getImage(), col + gutter, row + gutter);
      }
      return null;
    }

    /**
     * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */
  }, {
    key: "loadedTileCallback",
    value: function loadedTileCallback(tiles, zoom, tile) {
      if (this.isDrawableTile(tile)) {
        return _get(_getPrototypeOf(CanvasTileLayerRenderer.prototype), "loadedTileCallback", this).call(this, tiles, zoom, tile);
      }
      return false;
    }

    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      return !!this.getLayer().getSource();
    }

    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      var viewResolution = viewState.resolution;
      var viewCenter = viewState.center;
      var rotation = viewState.rotation;
      var pixelRatio = frameState.pixelRatio;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getSource();
      var sourceRevision = tileSource.getRevision();
      var tileGrid = tileSource.getTileGridForProjection(projection);
      var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
      var tileResolution = tileGrid.getResolution(z);
      var extent = frameState.extent;
      var resolution = frameState.viewState.resolution;
      var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
      // desired dimensions of the canvas in pixels
      var width = Math.round((0, _extent.getWidth)(extent) / resolution * pixelRatio);
      var height = Math.round((0, _extent.getHeight)(extent) / resolution * pixelRatio);
      var layerExtent = layerState.extent && (0, _proj.fromUserExtent)(layerState.extent, projection);
      if (layerExtent) {
        extent = (0, _extent.getIntersection)(extent, (0, _proj.fromUserExtent)(layerState.extent, projection));
      }
      var dx = tileResolution * width / 2 / tilePixelRatio;
      var dy = tileResolution * height / 2 / tilePixelRatio;
      var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);

      /**
       * @type {Object<number, Object<string, import("../../Tile.js").default>>}
       */
      var tilesToDrawByZ = {};
      tilesToDrawByZ[z] = {};
      var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
      var tmpExtent = this.tmpExtent;
      var tmpTileRange = this.tmpTileRange_;
      this.newTiles_ = false;
      var viewport = rotation ? (0, _extent.getRotatedViewport)(viewState.center, resolution, rotation, frameState.size) : undefined;
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          var tile = this.getTile(z, x, y, frameState);
          if (this.isDrawableTile(tile)) {
            var uid = (0, _util.getUid)(this);
            if (tile.getState() == _TileState.default.LOADED) {
              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
              var inTransition = tile.inTransition(uid);
              if (inTransition && layerState.opacity !== 1) {
                // Skipping transition when layer is not fully opaque avoids visual artifacts.
                tile.endTransition(uid);
                inTransition = false;
              }
              if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {
                this.newTiles_ = true;
              }
            }
            if (tile.getAlpha(uid, frameState.time) === 1) {
              // don't look for alt tiles if alpha is 1
              continue;
            }
          }
          var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
          var covered = false;
          if (childTileRange) {
            covered = findLoadedTiles(z + 1, childTileRange);
          }
          if (!covered) {
            tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
          }
        }
      }
      var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;

      // set forward and inverse pixel transforms
      (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
      var canvasTransform = (0, _transform.toString)(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      var context = this.context;
      var canvas = context.canvas;
      (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);

      // set scale transform for calculating tile positions on the canvas
      (0, _transform.compose)(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }
      if (layerExtent) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
      if (!tileSource.getInterpolate()) {
        context.imageSmoothingEnabled = false;
      }
      this.preRender(context, frameState);
      this.renderedTiles.length = 0;
      /** @type {Array<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(_array.ascending);
      var clips, clipZs, currentClip;
      if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
        zs = zs.reverse();
      } else {
        clips = [];
        clipZs = [];
      }
      for (var i = zs.length - 1; i >= 0; --i) {
        var currentZ = zs[i];
        var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        var currentResolution = tileGrid.getResolution(currentZ);
        var currentScale = currentResolution / tileResolution;
        var _dx = currentTilePixelSize[0] * currentScale * canvasScale;
        var _dy = currentTilePixelSize[1] * currentScale * canvasScale;
        var originTileCoord = tileGrid.getTileCoordForCoordAndZ((0, _extent.getTopLeft)(canvasExtent), currentZ);
        var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
        var origin = (0, _transform.apply)(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
        var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
        var tilesToDraw = tilesToDrawByZ[currentZ];
        for (var tileCoordKey in tilesToDraw) {
          var _tile = /** @type {import("../../ImageTile.js").default} */
          tilesToDraw[tileCoordKey];
          var tileCoord = _tile.tileCoord;

          // Calculate integer positions and sizes so that tiles align
          var xIndex = originTileCoord[1] - tileCoord[1];
          var nextX = Math.round(origin[0] - (xIndex - 1) * _dx);
          var yIndex = originTileCoord[2] - tileCoord[2];
          var nextY = Math.round(origin[1] - (yIndex - 1) * _dy);
          var _x = Math.round(origin[0] - xIndex * _dx);
          var _y = Math.round(origin[1] - yIndex * _dy);
          var w = nextX - _x;
          var h = nextY - _y;
          var transition = z === currentZ;
          var _inTransition = transition && _tile.getAlpha((0, _util.getUid)(this), frameState.time) !== 1;
          var contextSaved = false;
          if (!_inTransition) {
            if (clips) {
              // Clip mask for regions in this tile that already filled by a higher z tile
              currentClip = [_x, _y, _x + w, _y, _x + w, _y + h, _x, _y + h];
              for (var _i = 0, ii = clips.length; _i < ii; ++_i) {
                if (z !== currentZ && currentZ < clipZs[_i]) {
                  var clip = clips[_i];
                  if ((0, _extent.intersects)([_x, _y, _x + w, _y + h], [clip[0], clip[3], clip[4], clip[7]])) {
                    if (!contextSaved) {
                      context.save();
                      contextSaved = true;
                    }
                    context.beginPath();
                    // counter-clockwise (outer ring) for current tile
                    context.moveTo(currentClip[0], currentClip[1]);
                    context.lineTo(currentClip[2], currentClip[3]);
                    context.lineTo(currentClip[4], currentClip[5]);
                    context.lineTo(currentClip[6], currentClip[7]);
                    // clockwise (inner ring) for higher z tile
                    context.moveTo(clip[6], clip[7]);
                    context.lineTo(clip[4], clip[5]);
                    context.lineTo(clip[2], clip[3]);
                    context.lineTo(clip[0], clip[1]);
                    context.clip();
                  }
                }
              }
              clips.push(currentClip);
              clipZs.push(currentZ);
            } else {
              context.clearRect(_x, _y, w, h);
            }
          }
          this.drawTileImage(_tile, frameState, _x, _y, w, h, tileGutter, transition);
          if (clips && !_inTransition) {
            if (contextSaved) {
              context.restore();
            }
            this.renderedTiles.unshift(_tile);
          } else {
            this.renderedTiles.push(_tile);
          }
          this.updateUsedTiles(frameState.usedTiles, tileSource, _tile);
        }
      }
      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution;
      this.extentChanged = !this.renderedExtent_ || !(0, _extent.equals)(this.renderedExtent_, canvasExtent);
      this.renderedExtent_ = canvasExtent;
      this.renderedPixelRatio = pixelRatio;
      this.renderedProjection = projection;
      this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
      this.scheduleExpireCache(frameState, tileSource);
      this.postRender(context, frameState);
      if (layerState.extent) {
        context.restore();
      }
      context.imageSmoothingEnabled = true;
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
      return this.container;
    }

    /**
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     */
  }, {
    key: "drawTileImage",
    value: function drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
      var image = this.getTileImage(tile);
      if (!image) {
        return;
      }
      var uid = (0, _util.getUid)(this);
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
      var alphaChanged = alpha !== this.context.globalAlpha;
      if (alphaChanged) {
        this.context.save();
        this.context.globalAlpha = alpha;
      }
      this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
      if (alphaChanged) {
        this.context.restore();
      }
      if (alpha !== layerState.opacity) {
        frameState.animate = true;
      } else if (transition) {
        tile.endTransition(uid);
      }
    }

    /**
     * @return {HTMLCanvasElement} Image
     */
  }, {
    key: "getImage",
    value: function getImage() {
      var context = this.context;
      return context ? context.canvas : null;
    }

    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
  }, {
    key: "getTileImage",
    value: function getTileImage(tile) {
      return tile.getImage();
    }

    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @protected
     */
  }, {
    key: "scheduleExpireCache",
    value: function scheduleExpireCache(frameState, tileSource) {
      if (tileSource.canExpireCache()) {
        /**
         * @param {import("../../source/Tile.js").default} tileSource Tile source.
         * @param {import("../../Map.js").default} map Map.
         * @param {import("../../Map.js").FrameState} frameState Frame state.
         */
        var postRenderFunction = function (tileSource, map, frameState) {
          var tileSourceKey = (0, _util.getUid)(tileSource);
          if (tileSourceKey in frameState.usedTiles) {
            tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
          }
        }.bind(null, tileSource);
        frameState.postRenderFunctions.push( /** @type {import("../../Map.js").PostRenderFunction} */
        postRenderFunction);
      }
    }

    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
  }, {
    key: "updateUsedTiles",
    value: function updateUsedTiles(usedTiles, tileSource, tile) {
      // FIXME should we use tilesToDrawByZ instead?
      var tileSourceKey = (0, _util.getUid)(tileSource);
      if (!(tileSourceKey in usedTiles)) {
        usedTiles[tileSourceKey] = {};
      }
      usedTiles[tileSourceKey][tile.getKey()] = true;
    }

    /**
     * Manage tile pyramid.
     * This function performs a number of functions related to the tiles at the
     * current zoom and lower zoom levels:
     * - registers idle tiles in frameState.wantedTiles so that they are not
     *   discarded by the tile queue
     * - enqueues missing tiles
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {number} currentZ Current Z.
     * @param {number} preload Load low resolution tiles up to `preload` levels.
     * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
     * @protected
     */
  }, {
    key: "manageTilePyramid",
    value: function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
      var tileSourceKey = (0, _util.getUid)(tileSource);
      if (!(tileSourceKey in frameState.wantedTiles)) {
        frameState.wantedTiles[tileSourceKey] = {};
      }
      var wantedTiles = frameState.wantedTiles[tileSourceKey];
      var tileQueue = frameState.tileQueue;
      var minZoom = tileGrid.getMinZoom();
      var rotation = frameState.viewState.rotation;
      var viewport = rotation ? (0, _extent.getRotatedViewport)(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;
      var tileCount = 0;
      var tile, tileRange, tileResolution, x, y, z;
      for (z = minZoom; z <= currentZ; ++z) {
        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
        tileResolution = tileGrid.getResolution(z);
        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
            if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
              continue;
            }
            if (currentZ - z <= preload) {
              ++tileCount;
              tile = tileSource.getTile(z, x, y, pixelRatio, projection);
              if (tile.getState() == _TileState.default.IDLE) {
                wantedTiles[tile.getKey()] = true;
                if (!tileQueue.isKeyQueued(tile.getKey())) {
                  tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
                }
              }
              if (tileCallback !== undefined) {
                tileCallback(tile);
              }
            } else {
              tileSource.useTile(z, x, y, projection);
            }
          }
        }
      }
      tileSource.updateCacheSize(tileCount, projection);
    }
  }]);
  return CanvasTileLayerRenderer;
}(_Layer.default);
var _default = exports.default = CanvasTileLayerRenderer;
},{"./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../ImageTile.js":"node_modules/ol/ImageTile.js","../../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","../../TileRange.js":"node_modules/ol/TileRange.js","../../TileState.js":"node_modules/ol/TileState.js","../../transform.js":"node_modules/ol/transform.js","../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js","../../proj.js":"node_modules/ol/proj.js","../../util.js":"node_modules/ol/util.js","../../size.js":"node_modules/ol/size.js"}],"node_modules/ol/layer/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseTile = _interopRequireDefault(require("./BaseTile.js"));
var _TileLayer = _interopRequireDefault(require("../renderer/canvas/TileLayer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Tile
 */
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
var TileLayer = /*#__PURE__*/function (_BaseTileLayer) {
  _inherits(TileLayer, _BaseTileLayer);
  var _super = _createSuper(TileLayer);
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  function TileLayer(options) {
    _classCallCheck(this, TileLayer);
    return _super.call(this, options);
  }
  _createClass(TileLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new _TileLayer.default(this);
    }
  }]);
  return TileLayer;
}(_BaseTile.default);
var _default = exports.default = TileLayer;
},{"./BaseTile.js":"node_modules/ol/layer/BaseTile.js","../renderer/canvas/TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js"}],"node_modules/ol/structs/PriorityQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DROP = void 0;
var _asserts = require("../asserts.js");
var _obj = require("../obj.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/structs/PriorityQueue
 */
/**
 * @type {number}
 */
var DROP = exports.DROP = Infinity;

/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue = /*#__PURE__*/function () {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  function PriorityQueue(priorityFunction, keyFunction) {
    _classCallCheck(this, PriorityQueue);
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;

    /**
     * @type {function(T): string}
     * @private
     */
    this.keyFunction_ = keyFunction;

    /**
     * @type {Array<T>}
     * @private
     */
    this.elements_ = [];

    /**
     * @type {Array<number>}
     * @private
     */
    this.priorities_ = [];

    /**
     * @type {!Object<string, boolean>}
     * @private
     */
    this.queuedElements_ = {};
  }

  /**
   * FIXME empty description for jsdoc
   */
  _createClass(PriorityQueue, [{
    key: "clear",
    value: function clear() {
      this.elements_.length = 0;
      this.priorities_.length = 0;
      (0, _obj.clear)(this.queuedElements_);
    }

    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
  }, {
    key: "dequeue",
    value: function dequeue() {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[0];
      if (elements.length == 1) {
        elements.length = 0;
        priorities.length = 0;
      } else {
        elements[0] = /** @type {T} */elements.pop();
        priorities[0] = /** @type {number} */priorities.pop();
        this.siftUp_(0);
      }
      var elementKey = this.keyFunction_(element);
      delete this.queuedElements_[elementKey];
      return element;
    }

    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
  }, {
    key: "enqueue",
    value: function enqueue(element) {
      (0, _asserts.assert)(!(this.keyFunction_(element) in this.queuedElements_), 'Tried to enqueue an `element` that was already added to the queue');
      var priority = this.priorityFunction_(element);
      if (priority != DROP) {
        this.elements_.push(element);
        this.priorities_.push(priority);
        this.queuedElements_[this.keyFunction_(element)] = true;
        this.siftDown_(0, this.elements_.length - 1);
        return true;
      }
      return false;
    }

    /**
     * @return {number} Count.
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.elements_.length;
    }

    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
  }, {
    key: "getLeftChildIndex_",
    value: function getLeftChildIndex_(index) {
      return index * 2 + 1;
    }

    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
  }, {
    key: "getRightChildIndex_",
    value: function getRightChildIndex_(index) {
      return index * 2 + 2;
    }

    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
  }, {
    key: "getParentIndex_",
    value: function getParentIndex_(index) {
      return index - 1 >> 1;
    }

    /**
     * Make this a heap. O(N).
     * @private
     */
  }, {
    key: "heapify_",
    value: function heapify_() {
      var i;
      for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
        this.siftUp_(i);
      }
    }

    /**
     * @return {boolean} Is empty.
     */
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.elements_.length === 0;
    }

    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
  }, {
    key: "isKeyQueued",
    value: function isKeyQueued(key) {
      return key in this.queuedElements_;
    }

    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
  }, {
    key: "isQueued",
    value: function isQueued(element) {
      return this.isKeyQueued(this.keyFunction_(element));
    }

    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
  }, {
    key: "siftUp_",
    value: function siftUp_(index) {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var count = elements.length;
      var element = elements[index];
      var priority = priorities[index];
      var startIndex = index;
      while (index < count >> 1) {
        var lIndex = this.getLeftChildIndex_(index);
        var rIndex = this.getRightChildIndex_(index);
        var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
        elements[index] = elements[smallerChildIndex];
        priorities[index] = priorities[smallerChildIndex];
        index = smallerChildIndex;
      }
      elements[index] = element;
      priorities[index] = priority;
      this.siftDown_(startIndex, index);
    }

    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
  }, {
    key: "siftDown_",
    value: function siftDown_(startIndex, index) {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[index];
      var priority = priorities[index];
      while (index > startIndex) {
        var parentIndex = this.getParentIndex_(index);
        if (priorities[parentIndex] > priority) {
          elements[index] = elements[parentIndex];
          priorities[index] = priorities[parentIndex];
          index = parentIndex;
        } else {
          break;
        }
      }
      elements[index] = element;
      priorities[index] = priority;
    }

    /**
     * FIXME empty description for jsdoc
     */
  }, {
    key: "reprioritize",
    value: function reprioritize() {
      var priorityFunction = this.priorityFunction_;
      var elements = this.elements_;
      var priorities = this.priorities_;
      var index = 0;
      var n = elements.length;
      var element, i, priority;
      for (i = 0; i < n; ++i) {
        element = elements[i];
        priority = priorityFunction(element);
        if (priority == DROP) {
          delete this.queuedElements_[this.keyFunction_(element)];
        } else {
          priorities[index] = priority;
          elements[index++] = element;
        }
      }
      elements.length = index;
      priorities.length = index;
      this.heapify_();
    }
  }]);
  return PriorityQueue;
}();
var _default = exports.default = PriorityQueue;
},{"../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/TileQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getTilePriority = getTilePriority;
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _PriorityQueue2 = _interopRequireWildcard(require("./structs/PriorityQueue.js"));
var _TileState = _interopRequireDefault(require("./TileState.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/TileQueue
 */
/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */
var TileQueue = /*#__PURE__*/function (_PriorityQueue) {
  _inherits(TileQueue, _PriorityQueue);
  var _super = _createSuper(TileQueue);
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  function TileQueue(tilePriorityFunction, tileChangeCallback) {
    var _this;
    _classCallCheck(this, TileQueue);
    _this = _super.call(this,
    /**
     * @param {Array} element Element.
     * @return {number} Priority.
     */
    function (element) {
      return tilePriorityFunction.apply(null, element);
    },
    /**
     * @param {Array} element Element.
     * @return {string} Key.
     */
    function (element) {
      return /** @type {import("./Tile.js").default} */element[0].getKey();
    });

    /** @private */
    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_assertThisInitialized(_this));

    /**
     * @private
     * @type {function(): ?}
     */
    _this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    _this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    _this.tilesLoadingKeys_ = {};
    return _this;
  }

  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  _createClass(TileQueue, [{
    key: "enqueue",
    value: function enqueue(element) {
      var added = _get(_getPrototypeOf(TileQueue.prototype), "enqueue", this).call(this, element);
      if (added) {
        var tile = element[0];
        tile.addEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
      }
      return added;
    }

    /**
     * @return {number} Number of tiles loading.
     */
  }, {
    key: "getTilesLoading",
    value: function getTilesLoading() {
      return this.tilesLoading_;
    }

    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
  }, {
    key: "handleTileChange",
    value: function handleTileChange(event) {
      var tile = /** @type {import("./Tile.js").default} */event.target;
      var state = tile.getState();
      if (state === _TileState.default.LOADED || state === _TileState.default.ERROR || state === _TileState.default.EMPTY) {
        if (state !== _TileState.default.ERROR) {
          tile.removeEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
        }
        var tileKey = tile.getKey();
        if (tileKey in this.tilesLoadingKeys_) {
          delete this.tilesLoadingKeys_[tileKey];
          --this.tilesLoading_;
        }
        this.tileChangeCallback_();
      }
    }

    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
  }, {
    key: "loadMoreTiles",
    value: function loadMoreTiles(maxTotalLoading, maxNewLoads) {
      var newLoads = 0;
      var state, tile, tileKey;
      while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
        tile = /** @type {import("./Tile.js").default} */this.dequeue()[0];
        tileKey = tile.getKey();
        state = tile.getState();
        if (state === _TileState.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
          this.tilesLoadingKeys_[tileKey] = true;
          ++this.tilesLoading_;
          ++newLoads;
          tile.load();
        }
      }
    }
  }]);
  return TileQueue;
}(_PriorityQueue2.default);
var _default = exports.default = TileQueue;
/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _PriorityQueue2.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _PriorityQueue2.DROP;
  }
  // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.
  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
},{"./events/EventType.js":"node_modules/ol/events/EventType.js","./structs/PriorityQueue.js":"node_modules/ol/structs/PriorityQueue.js","./TileState.js":"node_modules/ol/TileState.js"}],"node_modules/ol/source/Raster.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RasterSourceEvent = exports.Processor = void 0;
exports.newImageData = newImageData;
var _Disposable2 = _interopRequireDefault(require("../Disposable.js"));
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageCanvas = _interopRequireDefault(require("../ImageCanvas.js"));
var _Image = _interopRequireDefault(require("../layer/Image.js"));
var _Image2 = _interopRequireDefault(require("./Image.js"));
var _Source = _interopRequireDefault(require("./Source.js"));
var _Tile = _interopRequireDefault(require("../layer/Tile.js"));
var _TileQueue = _interopRequireDefault(require("../TileQueue.js"));
var _Tile2 = _interopRequireDefault(require("./Tile.js"));
var _dom = require("../dom.js");
var _transform = require("../transform.js");
var _extent = require("../extent.js");
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/Raster
 */
var hasImageData = true;
try {
  new ImageData(10, 10);
} catch (_) {
  hasImageData = false;
}

/** @type {CanvasRenderingContext2D} */
var context;

/**
 * @param {Uint8ClampedArray} data Image data.
 * @param {number} width Number of columns.
 * @param {number} height Number of rows.
 * @return {ImageData} Image data.
 */
function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  }
  if (!context) {
    context = document.createElement('canvas').getContext('2d');
  }
  var imageData = context.createImageData(width, height);
  imageData.data.set(data);
  return imageData;
}

/**
 * @typedef {Object} MinionData
 * @property {Array<ArrayBuffer>} buffers Array of buffers.
 * @property {Object} meta Operation metadata.
 * @property {boolean} imageOps The operation is an image operation.
 * @property {number} width The width of the image.
 * @property {number} height The height of the image.
 */

/* istanbul ignore next */
/**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(MinionData):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */
function createMinion(operation) {
  var workerHasImageData = true;
  try {
    new ImageData(10, 10);
  } catch (_) {
    workerHasImageData = false;
  }
  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    }
    return {
      data: data,
      width: width,
      height: height
    };
  }
  return function (data) {
    // bracket notation for minification support
    var buffers = data['buffers'];
    var meta = data['meta'];
    var imageOps = data['imageOps'];
    var width = data['width'];
    var height = data['height'];
    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;
    if (imageOps) {
      var images = new Array(numBuffers);
      for (var b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
      }
      var _output = operation(images, meta).data;
      return _output.buffer;
    }
    var output = new Uint8ClampedArray(numBytes);
    var arrays = new Array(numBuffers);
    var pixels = new Array(numBuffers);
    for (var _b = 0; _b < numBuffers; ++_b) {
      arrays[_b] = new Uint8ClampedArray(buffers[_b]);
      pixels[_b] = [0, 0, 0, 0];
    }
    for (var i = 0; i < numBytes; i += 4) {
      for (var j = 0; j < numBuffers; ++j) {
        var array = arrays[j];
        pixels[j][0] = array[i];
        pixels[j][1] = array[i + 1];
        pixels[j][2] = array[i + 2];
        pixels[j][3] = array[i + 3];
      }
      var pixel = operation(pixels, meta);
      output[i] = pixel[0];
      output[i + 1] = pixel[1];
      output[i + 2] = pixel[2];
      output[i + 3] = pixel[3];
    }
    return output.buffer;
  };
}

/**
 * Create a worker for running operations.
 * @param {ProcessorOptions} config Processor options.
 * @param {function(MessageEvent): void} onMessage Called with a message event.
 * @return {Worker} The worker.
 */
function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function (name) {
    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';
  });
  var lines = lib.concat(['const __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener("message", function(event) {', '  const buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);
  var worker = new Worker(typeof Blob === 'undefined' ? 'data:text/javascript;base64,' + Buffer.from(lines.join('\n'), 'binary').toString('base64') : URL.createObjectURL(new Blob(lines, {
    type: 'text/javascript'
  })));
  worker.addEventListener('message', onMessage);
  return worker;
}

/**
 * @typedef {Object} FauxMessageEvent
 * @property {Object} data Message data.
 */

/**
 * Create a faux worker for running operations.
 * @param {ProcessorOptions} config Configuration.
 * @param {function(FauxMessageEvent): void} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */
function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  var terminated = false;
  return {
    postMessage: function postMessage(data) {
      setTimeout(function () {
        if (terminated) {
          return;
        }
        onMessage({
          data: {
            buffer: minion(data),
            meta: data['meta']
          }
        });
      }, 0);
    },
    terminate: function terminate() {
      terminated = true;
    }
  };
}

/**
 * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback
 */

/**
 * @typedef {Object} Job
 * @property {Object} meta Job metadata.
 * @property {Array<ImageData>} inputs Array of input data.
 * @property {JobCallback} callback Called when the job is complete.
 */

/**
 * @typedef {Object} ProcessorOptions
 * @property {number} threads Number of workers to spawn.
 * @property {Operation} operation The operation.
 * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} queue The number of queued jobs to allow.
 * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.
 */

/**
 * @classdesc
 * A processor runs pixel or image operations in workers.
 */
var Processor = exports.Processor = /*#__PURE__*/function (_Disposable) {
  _inherits(Processor, _Disposable);
  var _super = _createSuper(Processor);
  /**
   * @param {ProcessorOptions} config Configuration.
   */
  function Processor(config) {
    var _this;
    _classCallCheck(this, Processor);
    _this = _super.call(this);
    _this._imageOps = !!config.imageOps;
    var threads;
    if (config.threads === 0) {
      threads = 0;
    } else if (_this._imageOps) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }

    /**
     * @type {Array<Worker>}
     */
    var workers = new Array(threads);
    if (threads) {
      for (var i = 0; i < threads; ++i) {
        workers[i] = createWorker(config, _this._onWorkerMessage.bind(_assertThisInitialized(_this), i));
      }
    } else {
      workers[0] = createFauxWorker(config, _this._onWorkerMessage.bind(_assertThisInitialized(_this), 0));
    }
    _this._workers = workers;

    /**
     * @type {Array<Job>}
     * @private
     */
    _this._queue = [];
    _this._maxQueueLength = config.queue || Infinity;
    _this._running = 0;

    /**
     * @type {Object<number, any>}
     * @private
     */
    _this._dataLookup = {};

    /**
     * @type {Job}
     * @private
     */
    _this._job = null;
    return _this;
  }

  /**
   * Run operation on input data.
   * @param {Array<ImageData>} inputs Array of image data.
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */
  _createClass(Processor, [{
    key: "process",
    value: function process(inputs, meta, callback) {
      this._enqueue({
        inputs: inputs,
        meta: meta,
        callback: callback
      });
      this._dispatch();
    }

    /**
     * Add a job to the queue.
     * @param {Job} job The job.
     */
  }, {
    key: "_enqueue",
    value: function _enqueue(job) {
      this._queue.push(job);
      while (this._queue.length > this._maxQueueLength) {
        this._queue.shift().callback(null, null);
      }
    }

    /**
     * Dispatch a job.
     */
  }, {
    key: "_dispatch",
    value: function _dispatch() {
      if (this._running || this._queue.length === 0) {
        return;
      }
      var job = this._queue.shift();
      this._job = job;
      var width = job.inputs[0].width;
      var height = job.inputs[0].height;
      var buffers = job.inputs.map(function (input) {
        return input.data.buffer;
      });
      var threads = this._workers.length;
      this._running = threads;
      if (threads === 1) {
        this._workers[0].postMessage({
          buffers: buffers,
          meta: job.meta,
          imageOps: this._imageOps,
          width: width,
          height: height
        }, buffers);
        return;
      }
      var length = job.inputs[0].data.length;
      var segmentLength = 4 * Math.ceil(length / 4 / threads);
      for (var i = 0; i < threads; ++i) {
        var offset = i * segmentLength;
        var slices = [];
        for (var j = 0, jj = buffers.length; j < jj; ++j) {
          slices.push(buffers[j].slice(offset, offset + segmentLength));
        }
        this._workers[i].postMessage({
          buffers: slices,
          meta: job.meta,
          imageOps: this._imageOps,
          width: width,
          height: height
        }, slices);
      }
    }

    /**
     * Handle messages from the worker.
     * @param {number} index The worker index.
     * @param {MessageEvent} event The message event.
     */
  }, {
    key: "_onWorkerMessage",
    value: function _onWorkerMessage(index, event) {
      if (this.disposed) {
        return;
      }
      this._dataLookup[index] = event.data;
      --this._running;
      if (this._running === 0) {
        this._resolveJob();
      }
    }

    /**
     * Resolve a job.  If there are no more worker threads, the processor callback
     * will be called.
     */
  }, {
    key: "_resolveJob",
    value: function _resolveJob() {
      var job = this._job;
      var threads = this._workers.length;
      var data, meta;
      if (threads === 1) {
        data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);
        meta = this._dataLookup[0]['meta'];
      } else {
        var length = job.inputs[0].data.length;
        data = new Uint8ClampedArray(length);
        meta = new Array(threads);
        var segmentLength = 4 * Math.ceil(length / 4 / threads);
        for (var i = 0; i < threads; ++i) {
          var buffer = this._dataLookup[i]['buffer'];
          var offset = i * segmentLength;
          data.set(new Uint8ClampedArray(buffer), offset);
          meta[i] = this._dataLookup[i]['meta'];
        }
      }
      this._job = null;
      this._dataLookup = {};
      job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);
      this._dispatch();
    }

    /**
     * Terminate all workers associated with the processor.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      for (var i = 0; i < this._workers.length; ++i) {
        this._workers[i].terminate();
      }
      this._workers.length = 0;
    }
  }]);
  return Processor;
}(_Disposable2.default);
/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)
 * and should return a single
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
 * The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 *
 * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):
 *     (Array<number>|ImageData)} Operation
 */
/**
 * @enum {string}
 */
var RasterEventType = {
  /**
   * Triggered before operations are run.  Listeners will receive an event object with
   * a `data` property that can be used to make data available to operations.
   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: 'beforeoperations',
  /**
   * Triggered after operations are run.  Listeners will receive an event object with
   * a `data` property.  If more than one thread is used, `data` will be an array of
   * objects.  If a single thread is used, `data` will be a single object.
   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: 'afteroperations'
};

/**
 * @typedef {'pixel' | 'image'} RasterOperationType
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 */

/**
 * @typedef {import("./Image.js").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this
 * type.
 */
var RasterSourceEvent = exports.RasterSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(RasterSourceEvent, _Event);
  var _super2 = _createSuper(RasterSourceEvent);
  /**
   * @param {string} type Type.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
   * this will be an array of objects if more than one thread is used.
   */
  function RasterSourceEvent(type, frameState, data) {
    var _this2;
    _classCallCheck(this, RasterSourceEvent);
    _this2 = _super2.call(this, type);

    /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    _this2.extent = frameState.extent;

    /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */
    _this2.resolution = frameState.viewState.resolution / frameState.pixelRatio;

    /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */
    _this2.data = data;
    return _this2;
  }
  return _createClass(RasterSourceEvent);
}(_Event2.default);
/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers.  For vector data, use an VectorImage layer.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only
 * be run at the given resolutions.  By default, the resolutions of the first source with resolutions
 * specified will be used, if any. Set to `null` to use any view resolution instead.
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./Image.js").ImageSourceEventTypes, import("./Image.js").ImageSourceEvent, Return> &
 *   import("../Observable").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature
 */
/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:ol/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires module:ol/source/Raster.RasterSourceEvent
 * @api
 */
var RasterSource = /*#__PURE__*/function (_ImageSource) {
  _inherits(RasterSource, _ImageSource);
  var _super3 = _createSuper(RasterSource);
  /**
   * @param {Options} options Options.
   */
  function RasterSource(options) {
    var _this3;
    _classCallCheck(this, RasterSource);
    _this3 = _super3.call(this, {
      projection: null
    });

    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */
    _this3.on;

    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */
    _this3.once;

    /***
     * @type {RasterSourceOnSignature<void>}
     */
    _this3.un;

    /**
     * @private
     * @type {Processor}
     */
    _this3.processor_ = null;

    /**
     * @private
     * @type {RasterOperationType}
     */
    _this3.operationType_ = options.operationType !== undefined ? options.operationType : 'pixel';

    /**
     * @private
     * @type {number}
     */
    _this3.threads_ = options.threads !== undefined ? options.threads : 1;

    /**
     * @private
     * @type {Array<import("../layer/Layer.js").default>}
     */
    _this3.layers_ = createLayers(options.sources);
    var changed = _this3.changed.bind(_assertThisInitialized(_this3));
    for (var i = 0, ii = _this3.layers_.length; i < ii; ++i) {
      _this3.layers_[i].addEventListener(_EventType.default.CHANGE, changed);
    }

    /** @type {boolean} */
    _this3.useResolutions_ = options.resolutions !== null;

    /**
     * @private
     * @type {import("../TileQueue.js").default}
     */
    _this3.tileQueue_ = new _TileQueue.default(function () {
      return 1;
    }, _this3.processSources_.bind(_assertThisInitialized(_this3)));

    /**
     * The most recently requested frame state.
     * @type {import("../Map.js").FrameState}
     * @private
     */
    _this3.requestedFrameState_;

    /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */
    _this3.renderedImageCanvas_ = null;

    /**
     * The most recently rendered revision.
     * @type {number}
     */
    _this3.renderedRevision_;

    /**
     * @private
     * @type {import("../Map.js").FrameState}
     */
    _this3.frameState_ = {
      animate: false,
      coordinateToPixelTransform: (0, _transform.create)(),
      declutterTree: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(_this3.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: (0, _transform.create)(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: _this3.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: ( /** @type {import("../View.js").State} */{
        rotation: 0
      }),
      viewHints: [],
      wantedTiles: {},
      mapId: (0, _util.getUid)(_assertThisInitialized(_this3)),
      renderTargets: {}
    };
    _this3.setAttributions(function (frameState) {
      var attributions = [];
      for (var index = 0, iMax = options.sources.length; index < iMax; ++index) {
        var sourceOrLayer = options.sources[index];
        var source = sourceOrLayer instanceof _Source.default ? sourceOrLayer : sourceOrLayer.getSource();
        if (!source) {
          continue;
        }
        var attributionGetter = source.getAttributions();
        if (typeof attributionGetter === 'function') {
          var sourceAttribution = attributionGetter(frameState);
          attributions.push.apply(attributions, sourceAttribution);
        }
      }
      return attributions.length !== 0 ? attributions : null;
    });
    if (options.operation !== undefined) {
      _this3.setOperation(options.operation, options.lib);
    }
    return _this3;
  }

  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object} [lib] Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  _createClass(RasterSource, [{
    key: "setOperation",
    value: function setOperation(operation, lib) {
      if (this.processor_) {
        this.processor_.dispose();
      }
      this.processor_ = new Processor({
        operation: operation,
        imageOps: this.operationType_ === 'image',
        queue: 1,
        lib: lib,
        threads: this.threads_
      });
      this.changed();
    }

    /**
     * Update the stored frame state.
     * @param {import("../extent.js").Extent} extent The view extent (in map units).
     * @param {number} resolution The view resolution.
     * @param {import("../proj/Projection.js").default} projection The view projection.
     * @return {import("../Map.js").FrameState} The updated frame state.
     * @private
     */
  }, {
    key: "updateFrameState_",
    value: function updateFrameState_(extent, resolution, projection) {
      var frameState = /** @type {import("../Map.js").FrameState} */
      Object.assign({}, this.frameState_);
      frameState.viewState = /** @type {import("../View.js").State} */
      Object.assign({}, frameState.viewState);
      var center = (0, _extent.getCenter)(extent);
      frameState.size[0] = Math.ceil((0, _extent.getWidth)(extent) / resolution);
      frameState.size[1] = Math.ceil((0, _extent.getHeight)(extent) / resolution);
      frameState.extent = [center[0] - frameState.size[0] * resolution / 2, center[1] - frameState.size[1] * resolution / 2, center[0] + frameState.size[0] * resolution / 2, center[1] + frameState.size[1] * resolution / 2];
      frameState.time = Date.now();
      var viewState = frameState.viewState;
      viewState.center = center;
      viewState.projection = projection;
      viewState.resolution = resolution;
      return frameState;
    }

    /**
     * Determine if all sources are ready.
     * @return {boolean} All sources are ready.
     * @private
     */
  }, {
    key: "allSourcesReady_",
    value: function allSourcesReady_() {
      var ready = true;
      var source;
      for (var i = 0, ii = this.layers_.length; i < ii; ++i) {
        source = this.layers_[i].getSource();
        if (!source || source.getState() !== 'ready') {
          ready = false;
          break;
        }
      }
      return ready;
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageCanvas.js").default} Single image.
     */
  }, {
    key: "getImage",
    value: function getImage(extent, resolution, pixelRatio, projection) {
      if (!this.allSourcesReady_()) {
        return null;
      }
      this.tileQueue_.loadMoreTiles(16, 16);
      resolution = this.findNearestResolution(resolution);
      var frameState = this.updateFrameState_(extent, resolution, projection);
      this.requestedFrameState_ = frameState;

      // check if we can't reuse the existing ol/ImageCanvas
      if (this.renderedImageCanvas_) {
        var renderedResolution = this.renderedImageCanvas_.getResolution();
        var renderedExtent = this.renderedImageCanvas_.getExtent();
        if (resolution !== renderedResolution || !(0, _extent.equals)(frameState.extent, renderedExtent)) {
          this.renderedImageCanvas_ = null;
        }
      }
      if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
        this.processSources_();
      }
      if (frameState.animate) {
        requestAnimationFrame(this.changed.bind(this));
      }
      return this.renderedImageCanvas_;
    }

    /**
     * Start processing source data.
     * @private
     */
  }, {
    key: "processSources_",
    value: function processSources_() {
      var frameState = this.requestedFrameState_;
      var len = this.layers_.length;
      var imageDatas = new Array(len);
      for (var i = 0; i < len; ++i) {
        frameState.layerIndex = i;
        frameState.renderTargets = {};
        var imageData = getImageData(this.layers_[i], frameState);
        if (imageData) {
          imageDatas[i] = imageData;
        } else {
          return;
        }
      }
      var data = {};
      this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
      this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
    }

    /**
     * Called when pixel processing is complete.
     * @param {import("../Map.js").FrameState} frameState The frame state.
     * @param {Error} err Any error during processing.
     * @param {ImageData} output The output image data.
     * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
     * @private
     */
  }, {
    key: "onWorkerComplete_",
    value: function onWorkerComplete_(frameState, err, output, data) {
      if (err || !output) {
        return;
      }

      // do nothing if extent or resolution changed
      var extent = frameState.extent;
      var resolution = frameState.viewState.resolution;
      if (resolution !== this.requestedFrameState_.viewState.resolution || !(0, _extent.equals)(extent, this.requestedFrameState_.extent)) {
        return;
      }
      var context;
      if (this.renderedImageCanvas_) {
        context = this.renderedImageCanvas_.getImage().getContext('2d');
      } else {
        var width = Math.round((0, _extent.getWidth)(extent) / resolution);
        var height = Math.round((0, _extent.getHeight)(extent) / resolution);
        context = (0, _dom.createCanvasContext2D)(width, height);
        this.renderedImageCanvas_ = new _ImageCanvas.default(extent, resolution, 1, context.canvas);
      }
      context.putImageData(output, 0, 0);
      if (frameState.animate) {
        requestAnimationFrame(this.changed.bind(this));
      } else {
        this.changed();
      }
      this.renderedRevision_ = this.getRevision();
      this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));
    }

    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
  }, {
    key: "getResolutions",
    value: function getResolutions(projection) {
      if (!this.useResolutions_) {
        return null;
      }
      var resolutions = _get(_getPrototypeOf(RasterSource.prototype), "getResolutions", this).call(this);
      if (!resolutions) {
        for (var i = 0, ii = this.layers_.length; i < ii; ++i) {
          var source = this.layers_[i].getSource();
          resolutions = source.getResolutions(projection);
          if (resolutions) {
            break;
          }
        }
      }
      return resolutions;
    }
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.processor_) {
        this.processor_.dispose();
      }
      _get(_getPrototypeOf(RasterSource.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return RasterSource;
}(_Image2.default);
/**
 * Clean up and unregister the worker.
 * @function
 * @api
 */
RasterSource.prototype.dispose;

/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */
var sharedContext = null;

/**
 * Get image data from a layer.
 * @param {import("../layer/Layer.js").default} layer Layer to render.
 * @param {import("../Map.js").FrameState} frameState The frame state.
 * @return {ImageData} The image data.
 */
function getImageData(layer, frameState) {
  var renderer = layer.getRenderer();
  if (!renderer) {
    throw new Error('Unsupported layer type: ' + layer);
  }
  if (!renderer.prepareFrame(frameState)) {
    return null;
  }
  var width = frameState.size[0];
  var height = frameState.size[1];
  if (width === 0 || height === 0) {
    return null;
  }
  var container = renderer.renderFrame(frameState, null);
  var element;
  if (container instanceof HTMLCanvasElement) {
    element = container;
  } else {
    if (container) {
      element = container.firstElementChild;
    }
    if (!(element instanceof HTMLCanvasElement)) {
      throw new Error('Unsupported rendered element: ' + element);
    }
    if (element.width === width && element.height === height) {
      var _context = element.getContext('2d');
      return _context.getImageData(0, 0, width, height);
    }
  }
  if (!sharedContext) {
    sharedContext = (0, _dom.createCanvasContext2D)(width, height, undefined, {
      willReadFrequently: true
    });
  } else {
    var canvas = sharedContext.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = (0, _dom.createCanvasContext2D)(width, height, undefined, {
        willReadFrequently: true
      });
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }
  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}

/**
 * Get a list of layer states from a list of layers.
 * @param {Array<import("../layer/Layer.js").default>} layers Layers.
 * @return {Array<import("../layer/Layer.js").State>} The layer states.
 */
function getLayerStatesArray(layers) {
  return layers.map(function (layer) {
    return layer.getLayerState();
  });
}

/**
 * Create layers for all sources.
 * @param {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources The sources.
 * @return {Array<import("../layer/Layer.js").default>} Array of layers.
 */
function createLayers(sources) {
  var len = sources.length;
  var layers = new Array(len);
  for (var i = 0; i < len; ++i) {
    layers[i] = createLayer(sources[i]);
  }
  return layers;
}

/**
 * Create a layer for the provided source.
 * @param {import("./Source.js").default|import("../layer/Layer.js").default} layerOrSource The layer or source.
 * @return {import("../layer/Layer.js").default} The layer.
 */
function createLayer(layerOrSource) {
  // @type {import("../layer/Layer.js").default}
  var layer;
  if (layerOrSource instanceof _Source.default) {
    if (layerOrSource instanceof _Tile2.default) {
      layer = new _Tile.default({
        source: layerOrSource
      });
    } else if (layerOrSource instanceof _Image2.default) {
      layer = new _Image.default({
        source: layerOrSource
      });
    }
  } else {
    layer = layerOrSource;
  }
  return layer;
}
var _default = exports.default = RasterSource;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","../layer/Image.js":"node_modules/ol/layer/Image.js","./Image.js":"node_modules/ol/source/Image.js","./Source.js":"node_modules/ol/source/Source.js","../layer/Tile.js":"node_modules/ol/layer/Tile.js","../TileQueue.js":"node_modules/ol/TileQueue.js","./Tile.js":"node_modules/ol/source/Tile.js","../dom.js":"node_modules/ol/dom.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/ol/source/StadiaMaps.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _XYZ2 = _interopRequireDefault(require("./XYZ.js"));
var _OSM = require("./OSM.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/StadiaMaps
 */
/**
 * @const
 * @type string
 */
var STADIA_ATTRIBUTION = '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>';

/**
 * @const
 * @type string
 */
var OMT_ATTRIBUTION = '&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>';

/**
 * @const
 * @type string
 */
var STAMEN_ATTRIBUTION = '&copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a>';

/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */
var LayerConfig = {
  'stamen_terrain': {
    extension: 'png',
    opaque: true
  },
  'stamen_terrain_background': {
    extension: 'png',
    opaque: true
  },
  'stamen_terrain_labels': {
    extension: 'png',
    opaque: false
  },
  'stamen_terrain_lines': {
    extension: 'png',
    opaque: false
  },
  'stamen_toner_background': {
    extension: 'png',
    opaque: true
  },
  'stamen_toner': {
    extension: 'png',
    opaque: true
  },
  'stamen_toner_labels': {
    extension: 'png',
    opaque: false
  },
  'stamen_toner_lines': {
    extension: 'png',
    opaque: false
  },
  'stamen_toner_lite': {
    extension: 'png',
    opaque: true
  },
  'stamen_watercolor': {
    extension: 'jpg',
    opaque: true
  },
  'alidade_smooth': {
    extension: 'png',
    opaque: true
  },
  'alidade_smooth_dark': {
    extension: 'png',
    opaque: true
  },
  'outdoors': {
    extension: 'png',
    opaque: true
  },
  'osm_bright': {
    extension: 'png',
    opaque: true
  }
};

/**
 * @type {Object<string, {minZoom: number, maxZoom: number, retina: boolean}>}
 */
var ProviderConfig = {
  'stamen_terrain': {
    minZoom: 0,
    maxZoom: 18,
    retina: true
  },
  'stamen_toner': {
    minZoom: 0,
    maxZoom: 20,
    retina: true
  },
  'stamen_watercolor': {
    minZoom: 1,
    maxZoom: 18,
    retina: false
  }
};

/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {string} layer Layer name. Valid values: `alidade_smooth`, `alidade_smooth_dark`, `outdoors`, `stamen_terrain`, `stamen_terrain_background`, `stamen_terrain_labels`, `stamen_terrain_lines`, `stamen_toner_background`, `stamen_toner`, `stamen_toner_labels`, `stamen_toner_lines`, `stamen_toner_lite`, `stamen_watercolor`, and `osm_bright`.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {string} [apiKey] Stadia Maps API key. Not required for localhost or most public web deployments. See https://docs.stadiamaps.com/authentication/ for details.
 * @property {boolean} [retina] Use retina tiles (if available; not available for Stamen Watercolor).
 */

/**
 * @classdesc
 * Layer source for the Stadia Maps tile server.
 * @api
 */
var StadiaMaps = /*#__PURE__*/function (_XYZ) {
  _inherits(StadiaMaps, _XYZ);
  var _super = _createSuper(StadiaMaps);
  /**
   * @param {Options} options StadiaMaps options.
   */
  function StadiaMaps(options) {
    _classCallCheck(this, StadiaMaps);
    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider] || {
      'minZoom': 0,
      'maxZoom': 20,
      'retina': true
    };
    var layerConfig = LayerConfig[options.layer];
    var query = options.apiKey ? '?api_key=' + options.apiKey : '';
    var retina = providerConfig.retina && options.retina ? '@2x' : '';
    var url = options.url !== undefined ? options.url : 'https://tiles.stadiamaps.com/tiles/' + options.layer + '/{z}/{x}/{y}' + retina + '.' + layerConfig.extension + query;
    var attributions = [STADIA_ATTRIBUTION, OMT_ATTRIBUTION, _OSM.ATTRIBUTION];
    if (options.layer.startsWith('stamen_')) {
      attributions.splice(1, 0, STAMEN_ATTRIBUTION);
    }
    return _super.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom !== undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      tilePixelRatio: retina ? 2 : 1,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
  return _createClass(StadiaMaps);
}(_XYZ2.default);
var _default = exports.default = StadiaMaps;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js","./OSM.js":"node_modules/ol/source/OSM.js"}],"node_modules/ol/source/TileArcGISRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _extent = require("../extent.js");
var _arcgisRest = require("./arcgisRest.js");
var _math = require("../math.js");
var _size = require("../size.js");
var _tilecoord = require("../tilecoord.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/TileArcGISRest
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be
 * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
 * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
 * and `IMAGESR` will be set dynamically. Set `LAYERS` to
 * override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.
 * The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The
 * url should include /MapServer or /ImageServer.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity
 * transition, pass `transition: 0`.
 * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
 * Service supports multiple urls for export requests.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link module:ol/source/XYZ~XYZ} data source.
 * @api
 */
var TileArcGISRest = /*#__PURE__*/function (_TileImage) {
  _inherits(TileArcGISRest, _TileImage);
  var _super = _createSuper(TileArcGISRest);
  /**
   * @param {Options} [options] Tile ArcGIS Rest options.
   */
  function TileArcGISRest(options) {
    var _this;
    _classCallCheck(this, TileArcGISRest);
    options = options ? options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {!Object}
     */
    _this.params_ = options.params || {};

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.tmpExtent_ = (0, _extent.createEmpty)();
    _this.setKey(_this.getKeyForParams_());
    return _this;
  }

  /**
   * @private
   * @return {string} The key for the current params.
   */
  _createClass(TileArcGISRest, [{
    key: "getKeyForParams_",
    value: function getKeyForParams_() {
      var i = 0;
      var res = [];
      for (var key in this.params_) {
        res[i++] = key + '-' + this.params_[key];
      }
      return res.join('/');
    }

    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
  }, {
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../size.js").Size} tileSize Tile size.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */
  }, {
    key: "getRequestUrl_",
    value: function getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
      var urls = this.urls;
      if (!urls) {
        return undefined;
      }
      var url;
      if (urls.length == 1) {
        url = urls[0];
      } else {
        var index = (0, _math.modulo)((0, _tilecoord.hash)(tileCoord), urls.length);
        url = urls[index];
      }
      return (0, _arcgisRest.getRequestUrl)(url, tileExtent, (this.tileGrid || this.getTileGridForProjection(projection)).getResolution(tileCoord[0]), pixelRatio, projection, params);
    }

    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return this.hidpi_ ? pixelRatio : 1;
    }

    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.setKey(this.getKeyForParams_());
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
     * @param {number} pixelRatio The pixel ratio
     * @param {import("../proj/Projection.js").default} projection The projection
     * @return {string|undefined} The tile URL
     * @override
     */
  }, {
    key: "tileUrlFunction",
    value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
      var tileGrid = this.getTileGrid();
      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projection);
      }
      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return undefined;
      }
      if (pixelRatio != 1 && !this.hidpi_) {
        pixelRatio = 1;
      }
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
      if (pixelRatio != 1) {
        tileSize = (0, _size.scale)(tileSize, pixelRatio, this.tmpSize);
      }

      // Apply default params and override with user specified values.
      var baseParams = {
        'F': 'image',
        'FORMAT': 'PNG32',
        'TRANSPARENT': true
      };
      Object.assign(baseParams, this.params_);
      return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
    }
  }]);
  return TileArcGISRest;
}(_TileImage2.default);
var _default = exports.default = TileArcGISRest;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../extent.js":"node_modules/ol/extent.js","./arcgisRest.js":"node_modules/ol/source/arcgisRest.js","../math.js":"node_modules/ol/math.js","../size.js":"node_modules/ol/size.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/TileDebug.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _XYZ2 = _interopRequireDefault(require("./XYZ.js"));
var _dom = require("../dom.js");
var _size = require("../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/TileDebug
 */
/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Optional projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Set to `1` when debugging `VectorTile` sources with a default configuration.
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {string} [template='z:{z} x:{x} y:{y}'] Template for labeling the tiles.
 * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 */
/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 * @api
 */
var TileDebug = /*#__PURE__*/function (_XYZ) {
  _inherits(TileDebug, _XYZ);
  var _super = _createSuper(TileDebug);
  /**
   * @param {Options} [options] Debug tile options.
   */
  function TileDebug(options) {
    var _this;
    _classCallCheck(this, TileDebug);
    /**
     * @type {Options}
     */
    options = options || {};
    return _this = _super.call(this, {
      opaque: false,
      projection: options.projection,
      tileGrid: options.tileGrid,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      zDirection: options.zDirection,
      url: options.template || 'z:{z} x:{x} y:{y}',
      tileLoadFunction: function tileLoadFunction(tile, text) {
        var z = tile.getTileCoord()[0];
        var tileSize = (0, _size.toSize)(_this.tileGrid.getTileSize(z));
        var context = (0, _dom.createCanvasContext2D)(tileSize[0], tileSize[1]);
        context.strokeStyle = 'grey';
        context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
        context.fillStyle = 'grey';
        context.strokeStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.font = '24px sans-serif';
        context.lineWidth = 4;
        context.strokeText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
        context.fillText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);

        /** @type {import("../ImageTile.js").default} */
        tile.setImage(context.canvas);
      }
    });
  }
  return _createClass(TileDebug);
}(_XYZ2.default);
var _default = exports.default = TileDebug;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js","../dom.js":"node_modules/ol/dom.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/source/TileJSON.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _extent = require("../extent.js");
var _tileurlfunction = require("../tileurlfunction.js");
var _tilegrid = require("../tilegrid.js");
var _proj = require("../proj.js");
var _net = require("../net.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/TileJSON
 */ // FIXME check order of async callbacks
/**
 * See https://mapbox.com/developers/api/.
 */
/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */
var TileJSON = /*#__PURE__*/function (_TileImage) {
  _inherits(TileJSON, _TileImage);
  var _super = _createSuper(TileJSON);
  /**
   * @param {Options} options TileJSON options.
   */
  function TileJSON(options) {
    var _this;
    _classCallCheck(this, TileJSON);
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: (0, _proj.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: 'loading',
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });

    /**
     * @type {Config}
     * @private
     */
    _this.tileJSON_ = null;

    /**
     * @type {number|import("../size.js").Size}
     * @private
     */
    _this.tileSize_ = options.tileSize;
    if (options.url) {
      if (options.jsonp) {
        (0, _net.jsonp)(options.url, _this.handleTileJSONResponse.bind(_assertThisInitialized(_this)), _this.handleTileJSONError.bind(_assertThisInitialized(_this)));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this.onXHRLoad_.bind(_assertThisInitialized(_this)));
        client.addEventListener('error', _this.onXHRError_.bind(_assertThisInitialized(_this)));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      throw new Error('Either `url` or `tileJSON` options must be provided');
    }
    return _this;
  }

  /**
   * @private
   * @param {Event} event The load event.
   */
  _createClass(TileJSON, [{
    key: "onXHRLoad_",
    value: function onXHRLoad_(event) {
      var client = /** @type {XMLHttpRequest} */event.target;
      // status will be 0 for file:// urls
      if (!client.status || client.status >= 200 && client.status < 300) {
        var response;
        try {
          response = /** @type {Config} */JSON.parse(client.responseText);
        } catch (err) {
          this.handleTileJSONError();
          return;
        }
        this.handleTileJSONResponse(response);
      } else {
        this.handleTileJSONError();
      }
    }

    /**
     * @private
     * @param {Event} event The error event.
     */
  }, {
    key: "onXHRError_",
    value: function onXHRError_(event) {
      this.handleTileJSONError();
    }

    /**
     * @return {Config} The tilejson object.
     * @api
     */
  }, {
    key: "getTileJSON",
    value: function getTileJSON() {
      return this.tileJSON_;
    }

    /**
     * @protected
     * @param {Config} tileJSON Tile JSON.
     */
  }, {
    key: "handleTileJSONResponse",
    value: function handleTileJSONResponse(tileJSON) {
      var epsg4326Projection = (0, _proj.get)('EPSG:4326');
      var sourceProjection = this.getProjection();
      var extent;
      if (tileJSON['bounds'] !== undefined) {
        var transform = (0, _proj.getTransformFromProjections)(epsg4326Projection, sourceProjection);
        extent = (0, _extent.applyTransform)(tileJSON['bounds'], transform);
      }
      var gridExtent = (0, _tilegrid.extentFromProjection)(sourceProjection);
      var minZoom = tileJSON['minzoom'] || 0;
      var maxZoom = tileJSON['maxzoom'] || 22;
      var tileGrid = (0, _tilegrid.createXYZ)({
        extent: gridExtent,
        maxZoom: maxZoom,
        minZoom: minZoom,
        tileSize: this.tileSize_
      });
      this.tileGrid = tileGrid;
      this.tileUrlFunction = (0, _tileurlfunction.createFromTemplates)(tileJSON['tiles'], tileGrid);
      if (tileJSON['attribution'] && !this.getAttributions()) {
        var attributionExtent = extent !== undefined ? extent : gridExtent;
        this.setAttributions(function (frameState) {
          if ((0, _extent.intersects)(attributionExtent, frameState.extent)) {
            return [tileJSON['attribution']];
          }
          return null;
        });
      }
      this.tileJSON_ = tileJSON;
      this.setState('ready');
    }

    /**
     * @protected
     */
  }, {
    key: "handleTileJSONError",
    value: function handleTileJSONError() {
      this.setState('error');
    }
  }]);
  return TileJSON;
}(_TileImage2.default);
var _default = exports.default = TileJSON;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../extent.js":"node_modules/ol/extent.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../proj.js":"node_modules/ol/proj.js","../net.js":"node_modules/ol/net.js"}],"node_modules/ol/source/TileWMS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _wms = require("./wms.js");
var _uri = require("../uri.js");
var _extent = require("../extent.js");
var _reproj = require("../reproj.js");
var _string = require("../string.js");
var _proj = require("../proj.js");
var _math = require("../math.js");
var _tilecoord = require("../tilecoord.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/TileWMS
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See https://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */
var TileWMS = /*#__PURE__*/function (_TileImage) {
  _inherits(TileWMS, _TileImage);
  var _super = _createSuper(TileWMS);
  /**
   * @param {Options} [options] Tile WMS options.
   */
  function TileWMS(options) {
    var _this;
    _classCallCheck(this, TileWMS);
    options = options ? options : ( /** @type {Options} */{});
    var params = Object.assign({}, options.params);
    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {number}
     */
    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;

    /**
     * @private
     * @type {!Object}
     */
    _this.params_ = params;

    /**
     * @private
     * @type {boolean}
     */
    _this.v13_ = true;

    /**
     * @private
     * @type {import("./wms.js").ServerType}
     */
    _this.serverType_ = options.serverType;

    /**
     * @private
     * @type {boolean}
     */
    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.tmpExtent_ = (0, _extent.createEmpty)();
    _this.updateV13_();
    _this.setKey(_this.getKeyForParams_());
    return _this;
  }

  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  _createClass(TileWMS, [{
    key: "getFeatureInfoUrl",
    value: function getFeatureInfoUrl(coordinate, resolution, projection, params) {
      var projectionObj = (0, _proj.get)(projection);
      var sourceProjectionObj = this.getProjection() || projectionObj;
      var tileGrid = this.getTileGrid();
      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(sourceProjectionObj);
      }
      var sourceProjCoord = (0, _proj.transform)(coordinate, projectionObj, sourceProjectionObj);
      var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, resolution);
      var z = tileGrid.getZForResolution(sourceResolution, this.zDirection);
      var tileResolution = tileGrid.getResolution(z);
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(sourceProjCoord, z);
      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return undefined;
      }
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var gutter = this.gutter_;
      if (gutter !== 0) {
        tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
      }
      var baseParams = {
        'QUERY_LAYERS': this.params_['LAYERS']
      };
      Object.assign(baseParams, (0, _wms.getRequestParams)(this.params_, 'GetFeatureInfo'), params);
      var x = Math.floor((sourceProjCoord[0] - tileExtent[0]) / tileResolution);
      var y = Math.floor((tileExtent[3] - sourceProjCoord[1]) / tileResolution);
      baseParams[this.v13_ ? 'I' : 'X'] = x;
      baseParams[this.v13_ ? 'J' : 'Y'] = y;
      return this.getRequestUrl_(tileCoord, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
    }

    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
  }, {
    key: "getLegendUrl",
    value: function getLegendUrl(resolution, params) {
      if (this.urls[0] === undefined) {
        return undefined;
      }
      var baseParams = {
        'SERVICE': 'WMS',
        'VERSION': _wms.DEFAULT_VERSION,
        'REQUEST': 'GetLegendGraphic',
        'FORMAT': 'image/png'
      };
      if (params === undefined || params['LAYER'] === undefined) {
        var layers = this.params_.LAYERS;
        var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
        if (!isSingleLayer) {
          return undefined;
        }
        baseParams['LAYER'] = layers;
      }
      if (resolution !== undefined) {
        var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
        var pixelSize = 0.00028;
        baseParams['SCALE'] = resolution * mpu / pixelSize;
      }
      Object.assign(baseParams, params);
      return (0, _uri.appendParams)( /** @type {string} */this.urls[0], baseParams);
    }

    /**
     * @return {number} Gutter.
     */
  }, {
    key: "getGutter",
    value: function getGutter() {
      return this.gutter_;
    }

    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
  }, {
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */
  }, {
    key: "getRequestUrl_",
    value: function getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, params) {
      var urls = this.urls;
      if (!urls) {
        return undefined;
      }
      var url;
      if (urls.length == 1) {
        url = urls[0];
      } else {
        var index = (0, _math.modulo)((0, _tilecoord.hash)(tileCoord), urls.length);
        url = urls[index];
      }
      return (0, _wms.getImageSrc)(tileExtent, (this.tileGrid || this.getTileGridForProjection(projection)).getResolution(tileCoord[0]), pixelRatio, projection, url, params, this.serverType_);
    }

    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
    }

    /**
     * @private
     * @return {string} The key for the current params.
     */
  }, {
    key: "getKeyForParams_",
    value: function getKeyForParams_() {
      var i = 0;
      var res = [];
      for (var key in this.params_) {
        res[i++] = key + '-' + this.params_[key];
      }
      return res.join('/');
    }

    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.updateV13_();
      this.setKey(this.getKeyForParams_());
    }

    /**
     * @private
     */
  }, {
    key: "updateV13_",
    value: function updateV13_() {
      var version = this.params_['VERSION'] || _wms.DEFAULT_VERSION;
      this.v13_ = (0, _string.compareVersions)(version, '1.3') >= 0;
    }

    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
     * @param {number} pixelRatio The pixel ratio
     * @param {import("../proj/Projection.js").default} projection The projection
     * @return {string|undefined} The tile URL
     * @override
     */
  }, {
    key: "tileUrlFunction",
    value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
      var tileGrid = this.getTileGrid();
      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projection);
      }
      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return undefined;
      }
      if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
        pixelRatio = 1;
      }
      var tileResolution = tileGrid.getResolution(tileCoord[0]);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var gutter = this.gutter_;
      if (gutter !== 0) {
        tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
      }
      var baseParams = Object.assign({}, (0, _wms.getRequestParams)(this.params_, 'GetMap'));
      return this.getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, baseParams);
    }
  }]);
  return TileWMS;
}(_TileImage2.default);
var _default = exports.default = TileWMS;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","./wms.js":"node_modules/ol/source/wms.js","../uri.js":"node_modules/ol/uri.js","../extent.js":"node_modules/ol/extent.js","../reproj.js":"node_modules/ol/reproj.js","../string.js":"node_modules/ol/string.js","../proj.js":"node_modules/ol/proj.js","../math.js":"node_modules/ol/math.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/UTFGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CustomTile = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Tile2 = _interopRequireDefault(require("../Tile.js"));
var _Tile3 = _interopRequireDefault(require("./Tile.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _extent = require("../extent.js");
var _tileurlfunction = require("../tileurlfunction.js");
var _tilegrid = require("../tilegrid.js");
var _tilecoord = require("../tilecoord.js");
var _proj = require("../proj.js");
var _events = require("../events.js");
var _net = require("../net.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/UTFGrid
 */
/**
 * @typedef {Object} UTFGridJSON
 * @property {Array<string>} grid The grid.
 * @property {Array<string>} keys The keys.
 * @property {Object<string, Object>} [data] Optional data.
 */
var CustomTile = exports.CustomTile = /*#__PURE__*/function (_Tile) {
  _inherits(CustomTile, _Tile);
  var _super = _createSuper(CustomTile);
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {import("../extent.js").Extent} extent Extent of the tile.
   * @param {boolean} preemptive Load the tile when visible (before it's needed).
   * @param {boolean} jsonp Load the tile as a script.
   */
  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {
    var _this;
    _classCallCheck(this, CustomTile);
    _this = _super.call(this, tileCoord, state);

    /**
     * @private
     * @type {string}
     */
    _this.src_ = src;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    _this.extent_ = extent;

    /**
     * @private
     * @type {boolean}
     */
    _this.preemptive_ = preemptive;

    /**
     * @private
     * @type {Array<string>}
     */
    _this.grid_ = null;

    /**
     * @private
     * @type {Array<string>}
     */
    _this.keys_ = null;

    /**
     * @private
     * @type {Object<string, Object>|undefined}
     */
    _this.data_ = null;

    /**
     * @private
     * @type {boolean}
     */
    _this.jsonp_ = jsonp;
    return _this;
  }

  /**
   * Get the image element for this tile.
   * @return {HTMLImageElement} Image.
   */
  _createClass(CustomTile, [{
    key: "getImage",
    value: function getImage() {
      return null;
    }

    /**
     * Synchronously returns data at given coordinate (if available).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {*} The data.
     */
  }, {
    key: "getData",
    value: function getData(coordinate) {
      if (!this.grid_ || !this.keys_) {
        return null;
      }
      var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
      var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
      var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];
      if (typeof row !== 'string') {
        return null;
      }
      var code = row.charCodeAt(Math.floor(xRelative * row.length));
      if (code >= 93) {
        code--;
      }
      if (code >= 35) {
        code--;
      }
      code -= 32;
      var data = null;
      if (code in this.keys_) {
        var id = this.keys_[code];
        if (this.data_ && id in this.data_) {
          data = this.data_[id];
        } else {
          data = id;
        }
      }
      return data;
    }

    /**
     * Calls the callback (synchronously by default) with the available data
     * for given coordinate (or `null` if not yet loaded).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(*): void} callback Callback.
     * @param {boolean} [request] If `true` the callback is always async.
     *                               The tile data is requested if not yet loaded.
     */
  }, {
    key: "forDataAtCoordinate",
    value: function forDataAtCoordinate(coordinate, callback, request) {
      var _this2 = this;
      if (this.state == _TileState.default.EMPTY && request === true) {
        this.state = _TileState.default.IDLE;
        (0, _events.listenOnce)(this, _EventType.default.CHANGE, function (e) {
          callback(this.getData(coordinate));
        }, this);
        this.loadInternal_();
      } else {
        if (request === true) {
          setTimeout(function () {
            callback(_this2.getData(coordinate));
          }, 0);
        } else {
          callback(this.getData(coordinate));
        }
      }
    }

    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
  }, {
    key: "getKey",
    value: function getKey() {
      return this.src_;
    }

    /**
     * @private
     */
  }, {
    key: "handleError_",
    value: function handleError_() {
      this.state = _TileState.default.ERROR;
      this.changed();
    }

    /**
     * @param {!UTFGridJSON} json UTFGrid data.
     * @private
     */
  }, {
    key: "handleLoad_",
    value: function handleLoad_(json) {
      this.grid_ = json['grid'];
      this.keys_ = json['keys'];
      this.data_ = json['data'];
      this.state = _TileState.default.LOADED;
      this.changed();
    }

    /**
     * @private
     */
  }, {
    key: "loadInternal_",
    value: function loadInternal_() {
      if (this.state == _TileState.default.IDLE) {
        this.state = _TileState.default.LOADING;
        if (this.jsonp_) {
          (0, _net.jsonp)(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
        } else {
          var client = new XMLHttpRequest();
          client.addEventListener('load', this.onXHRLoad_.bind(this));
          client.addEventListener('error', this.onXHRError_.bind(this));
          client.open('GET', this.src_);
          client.send();
        }
      }
    }

    /**
     * @private
     * @param {Event} event The load event.
     */
  }, {
    key: "onXHRLoad_",
    value: function onXHRLoad_(event) {
      var client = /** @type {XMLHttpRequest} */event.target;
      // status will be 0 for file:// urls
      if (!client.status || client.status >= 200 && client.status < 300) {
        var response;
        try {
          response = /** @type {!UTFGridJSON} */
          JSON.parse(client.responseText);
        } catch (err) {
          this.handleError_();
          return;
        }
        this.handleLoad_(response);
      } else {
        this.handleError_();
      }
    }

    /**
     * @private
     * @param {Event} event The error event.
     */
  }, {
    key: "onXHRError_",
    value: function onXHRError_(event) {
      this.handleError_();
    }

    /**
     */
  }, {
    key: "load",
    value: function load() {
      if (this.preemptive_) {
        this.loadInternal_();
      } else {
        this.setState(_TileState.default.EMPTY);
      }
    }
  }]);
  return CustomTile;
}(_Tile2.default);
/**
 * @typedef {Object} Options
 * @property {boolean} [preemptive=true]
 * If `true` the UTFGrid source loads the tiles based on their "visibility".
 * This improves the speed of response, but increases traffic.
 * Note that if set to `false` (lazy loading), you need to pass `true` as
 * `request` to the `forDataAtCoordinateAndResolution` method otherwise no
 * data will ever be loaded.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {import("./TileJSON.js").Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {string} [url] TileJSON endpoint that provides the configuration for this source.
 * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * @api
 */
var UTFGrid = /*#__PURE__*/function (_TileSource) {
  _inherits(UTFGrid, _TileSource);
  var _super2 = _createSuper(UTFGrid);
  /**
   * @param {Options} options Source options.
   */
  function UTFGrid(options) {
    var _this3;
    _classCallCheck(this, UTFGrid);
    _this3 = _super2.call(this, {
      projection: (0, _proj.get)('EPSG:3857'),
      state: 'loading',
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {boolean}
     */
    _this3.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;

    /**
     * @private
     * @type {!import("../Tile.js").UrlFunction}
     */
    _this3.tileUrlFunction_ = _tileurlfunction.nullTileUrlFunction;

    /**
     * @private
     * @type {string|undefined}
     */
    _this3.template_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    _this3.jsonp_ = options.jsonp || false;
    if (options.url) {
      if (_this3.jsonp_) {
        (0, _net.jsonp)(options.url, _this3.handleTileJSONResponse.bind(_assertThisInitialized(_this3)), _this3.handleTileJSONError.bind(_assertThisInitialized(_this3)));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this3.onXHRLoad_.bind(_assertThisInitialized(_this3)));
        client.addEventListener('error', _this3.onXHRError_.bind(_assertThisInitialized(_this3)));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this3.handleTileJSONResponse(options.tileJSON);
    } else {
      throw new Error('Either `url` or `tileJSON` options must be provided');
    }
    return _this3;
  }

  /**
   * @private
   * @param {Event} event The load event.
   */
  _createClass(UTFGrid, [{
    key: "onXHRLoad_",
    value: function onXHRLoad_(event) {
      var client = /** @type {XMLHttpRequest} */event.target;
      // status will be 0 for file:// urls
      if (!client.status || client.status >= 200 && client.status < 300) {
        var response;
        try {
          response = /** @type {import("./TileJSON.js").Config} */
          JSON.parse(client.responseText);
        } catch (err) {
          this.handleTileJSONError();
          return;
        }
        this.handleTileJSONResponse(response);
      } else {
        this.handleTileJSONError();
      }
    }

    /**
     * @private
     * @param {Event} event The error event.
     */
  }, {
    key: "onXHRError_",
    value: function onXHRError_(event) {
      this.handleTileJSONError();
    }

    /**
     * Return the template from TileJSON.
     * @return {string|undefined} The template from TileJSON.
     * @api
     */
  }, {
    key: "getTemplate",
    value: function getTemplate() {
      return this.template_;
    }

    /**
     * Calls the callback (synchronously by default) with the available data
     * for given coordinate and resolution (or `null` if not yet loaded or
     * in case of an error).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {function(*): void} callback Callback.
     * @param {boolean} [request] If `true` the callback is always async.
     *                               The tile data is requested if not yet loaded.
     * @api
     */
  }, {
    key: "forDataAtCoordinateAndResolution",
    value: function forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {
      if (this.tileGrid) {
        var z = this.tileGrid.getZForResolution(resolution, this.zDirection);
        var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);
        var tile = /** @type {!CustomTile} */
        this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
        tile.forDataAtCoordinate(coordinate, callback, request);
      } else {
        if (request === true) {
          setTimeout(function () {
            callback(null);
          }, 0);
        } else {
          callback(null);
        }
      }
    }

    /**
     * @protected
     */
  }, {
    key: "handleTileJSONError",
    value: function handleTileJSONError() {
      this.setState('error');
    }

    /**
     * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
     * @protected
     * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
     */
  }, {
    key: "handleTileJSONResponse",
    value: function handleTileJSONResponse(tileJSON) {
      var epsg4326Projection = (0, _proj.get)('EPSG:4326');
      var sourceProjection = this.getProjection();
      var extent;
      if (tileJSON['bounds'] !== undefined) {
        var transform = (0, _proj.getTransformFromProjections)(epsg4326Projection, sourceProjection);
        extent = (0, _extent.applyTransform)(tileJSON['bounds'], transform);
      }
      var gridExtent = (0, _tilegrid.extentFromProjection)(sourceProjection);
      var minZoom = tileJSON['minzoom'] || 0;
      var maxZoom = tileJSON['maxzoom'] || 22;
      var tileGrid = (0, _tilegrid.createXYZ)({
        extent: gridExtent,
        maxZoom: maxZoom,
        minZoom: minZoom
      });
      this.tileGrid = tileGrid;
      this.template_ = tileJSON['template'];
      var grids = tileJSON['grids'];
      if (!grids) {
        this.setState('error');
        return;
      }
      this.tileUrlFunction_ = (0, _tileurlfunction.createFromTemplates)(grids, tileGrid);
      if (tileJSON['attribution'] !== undefined) {
        var attributionExtent = extent !== undefined ? extent : gridExtent;
        this.setAttributions(function (frameState) {
          if ((0, _extent.intersects)(attributionExtent, frameState.extent)) {
            return [tileJSON['attribution']];
          }
          return null;
        });
      }
      this.setState('ready');
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!CustomTile} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      if (this.tileCache.containsKey(tileCoordKey)) {
        return this.tileCache.get(tileCoordKey);
      }
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
      var tile = new CustomTile(tileCoord, tileUrl !== undefined ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }

    /**
     * Marks a tile coord as being used, without triggering a load.
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     */
  }, {
    key: "useTile",
    value: function useTile(z, x, y) {
      var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      if (this.tileCache.containsKey(tileCoordKey)) {
        this.tileCache.get(tileCoordKey);
      }
    }
  }]);
  return UTFGrid;
}(_Tile3.default);
var _default = exports.default = UTFGrid;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../Tile.js":"node_modules/ol/Tile.js","./Tile.js":"node_modules/ol/source/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../extent.js":"node_modules/ol/extent.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../proj.js":"node_modules/ol/proj.js","../events.js":"node_modules/ol/events.js","../net.js":"node_modules/ol/net.js"}],"node_modules/ol/source/WMTS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.optionsFromCapabilities = optionsFromCapabilities;
var _TileImage2 = _interopRequireDefault(require("./TileImage.js"));
var _uri = require("../uri.js");
var _extent = require("../extent.js");
var _WMTS = require("../tilegrid/WMTS.js");
var _tileurlfunction = require("../tileurlfunction.js");
var _proj = require("../proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/source/WMTS
 */
/**
 * Request encoding. One of 'KVP', 'REST'.
 * @typedef {'KVP' | 'REST'} RequestEncoding
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {RequestEncoding} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */
var WMTS = /*#__PURE__*/function (_TileImage) {
  _inherits(WMTS, _TileImage);
  var _super = _createSuper(WMTS);
  /**
   * @param {Options} options WMTS options.
   */
  function WMTS(options) {
    var _this;
    _classCallCheck(this, WMTS);
    // TODO: add support for TileMatrixLimits

    var requestEncoding = options.requestEncoding !== undefined ? options.requestEncoding : 'KVP';

    // FIXME: should we create a default tileGrid?
    // we could issue a getCapabilities xhr to retrieve missing configuration
    var tileGrid = options.tileGrid;
    var urls = options.urls;
    if (urls === undefined && options.url !== undefined) {
      urls = (0, _tileurlfunction.expandUrl)(options.url);
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls: urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    });

    /**
     * @private
     * @type {string}
     */
    _this.version_ = options.version !== undefined ? options.version : '1.0.0';

    /**
     * @private
     * @type {string}
     */
    _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';

    /**
     * @private
     * @type {!Object}
     */
    _this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};

    /**
     * @private
     * @type {string}
     */
    _this.layer_ = options.layer;

    /**
     * @private
     * @type {string}
     */
    _this.matrixSet_ = options.matrixSet;

    /**
     * @private
     * @type {string}
     */
    _this.style_ = options.style;

    // FIXME: should we guess this requestEncoding from options.url(s)
    //        structure? that would mean KVP only if a template is not provided.

    /**
     * @private
     * @type {RequestEncoding}
     */
    _this.requestEncoding_ = requestEncoding;
    _this.setKey(_this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      _this.tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(_this.createFromWMTSTemplate.bind(_assertThisInitialized(_this))));
    }
    return _this;
  }

  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  _createClass(WMTS, [{
    key: "setUrls",
    value: function setUrls(urls) {
      this.urls = urls;
      var key = urls.join('\n');
      this.setTileUrlFunction((0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(this.createFromWMTSTemplate.bind(this))), key);
    }

    /**
     * Get the dimensions, i.e. those passed to the constructor through the
     * "dimensions" option, and possibly updated using the updateDimensions
     * method.
     * @return {!Object} Dimensions.
     * @api
     */
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return this.dimensions_;
    }

    /**
     * Return the image format of the WMTS source.
     * @return {string} Format.
     * @api
     */
  }, {
    key: "getFormat",
    value: function getFormat() {
      return this.format_;
    }

    /**
     * Return the layer of the WMTS source.
     * @return {string} Layer.
     * @api
     */
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this.layer_;
    }

    /**
     * Return the matrix set of the WMTS source.
     * @return {string} MatrixSet.
     * @api
     */
  }, {
    key: "getMatrixSet",
    value: function getMatrixSet() {
      return this.matrixSet_;
    }

    /**
     * Return the request encoding, either "KVP" or "REST".
     * @return {RequestEncoding} Request encoding.
     * @api
     */
  }, {
    key: "getRequestEncoding",
    value: function getRequestEncoding() {
      return this.requestEncoding_;
    }

    /**
     * Return the style of the WMTS source.
     * @return {string} Style.
     * @api
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style_;
    }

    /**
     * Return the version of the WMTS source.
     * @return {string} Version.
     * @api
     */
  }, {
    key: "getVersion",
    value: function getVersion() {
      return this.version_;
    }

    /**
     * @private
     * @return {string} The key for the current dimensions.
     */
  }, {
    key: "getKeyForDimensions_",
    value: function getKeyForDimensions_() {
      var res = this.urls ? this.urls.slice(0) : [];
      for (var key in this.dimensions_) {
        res.push(key + '-' + this.dimensions_[key]);
      }
      return res.join('/');
    }

    /**
     * Update the dimensions.
     * @param {Object} dimensions Dimensions.
     * @api
     */
  }, {
    key: "updateDimensions",
    value: function updateDimensions(dimensions) {
      Object.assign(this.dimensions_, dimensions);
      this.setKey(this.getKeyForDimensions_());
    }

    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
  }, {
    key: "createFromWMTSTemplate",
    value: function createFromWMTSTemplate(template) {
      var requestEncoding = this.requestEncoding_;

      // context property names are lower case to allow for a case insensitive
      // replacement as some services use different naming conventions
      var context = {
        'layer': this.layer_,
        'style': this.style_,
        'tilematrixset': this.matrixSet_
      };
      if (requestEncoding == 'KVP') {
        Object.assign(context, {
          'Service': 'WMTS',
          'Request': 'GetTile',
          'Version': this.version_,
          'Format': this.format_
        });
      }

      // TODO: we may want to create our own appendParams function so that params
      // order conforms to wmts spec guidance, and so that we can avoid to escape
      // special template params

      template = requestEncoding == 'KVP' ? (0, _uri.appendParams)(template, context) : template.replace(/\{(\w+?)\}/g, function (m, p) {
        return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
      });
      var tileGrid = /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid;
      var dimensions = this.dimensions_;
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          }
          var localContext = {
            'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
            'TileCol': tileCoord[1],
            'TileRow': tileCoord[2]
          };
          Object.assign(localContext, dimensions);
          var url = template;
          if (requestEncoding == 'KVP') {
            url = (0, _uri.appendParams)(url, localContext);
          } else {
            url = url.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext[p];
            });
          }
          return url;
        }
      );
    }
  }]);
  return WMTS;
}(_TileImage2.default);
var _default = exports.default = WMTS;
/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {!Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {Options|null} WMTS source options object or `null` if the layer was not found.
 * @api
 */
function optionsFromCapabilities(wmtsCap, config) {
  var layers = wmtsCap['Contents']['Layer'];
  var l = layers.find(function (elt) {
    return elt['Identifier'] == config['layer'];
  });
  if (!l) {
    return null;
  }
  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var idx;
  if (l['TileMatrixSetLink'].length > 1) {
    if ('projection' in config) {
      idx = l['TileMatrixSetLink'].findIndex(function (elt) {
        var tileMatrixSet = tileMatrixSets.find(function (el) {
          return el['Identifier'] == elt['TileMatrixSet'];
        });
        var supportedCRS = tileMatrixSet['SupportedCRS'];
        var proj1 = (0, _proj.get)(supportedCRS);
        var proj2 = (0, _proj.get)(config['projection']);
        if (proj1 && proj2) {
          return (0, _proj.equivalent)(proj1, proj2);
        }
        return supportedCRS == config['projection'];
      });
    } else {
      idx = l['TileMatrixSetLink'].findIndex(function (elt) {
        return elt['TileMatrixSet'] == config['matrixSet'];
      });
    }
  } else {
    idx = 0;
  }
  if (idx < 0) {
    idx = 0;
  }
  var matrixSet = /** @type {string} */
  l['TileMatrixSetLink'][idx]['TileMatrixSet'];
  var matrixLimits = /** @type {Array<Object>} */
  l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];
  var format = /** @type {string} */l['Format'][0];
  if ('format' in config) {
    format = config['format'];
  }
  idx = l['Style'].findIndex(function (elt) {
    if ('style' in config) {
      return elt['Title'] == config['style'];
    }
    return elt['isDefault'];
  });
  if (idx < 0) {
    idx = 0;
  }
  var style = /** @type {string} */l['Style'][idx]['Identifier'];
  var dimensions = {};
  if ('Dimension' in l) {
    l['Dimension'].forEach(function (elt, index, array) {
      var key = elt['Identifier'];
      var value = elt['Default'];
      if (value === undefined) {
        value = elt['Value'][0];
      }
      dimensions[key] = value;
    });
  }
  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var matrixSetObj = matrixSets.find(function (elt) {
    return elt['Identifier'] == matrixSet;
  });
  var projection;
  var code = matrixSetObj['SupportedCRS'];
  if (code) {
    projection = (0, _proj.get)(code);
  }
  if ('projection' in config) {
    var projConfig = (0, _proj.get)(config['projection']);
    if (projConfig) {
      if (!projection || (0, _proj.equivalent)(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }
  var wrapX = false;
  var switchXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  var matrix = matrixSetObj.TileMatrix[0];

  // create default matrixLimit
  var selectedMatrixLimit = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: matrix.MatrixWidth - 1,
    MaxTileRow: matrix.MatrixHeight - 1
  };

  //in case of matrix limits, use matrix limits to calculate extent
  if (matrixLimits) {
    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
    var m = matrixSetObj.TileMatrix.find(function (tileMatrixValue) {
      return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;
    });
    if (m) {
      matrix = m;
    }
  }
  var resolution = matrix.ScaleDenominator * 0.00028 / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size
  var origin = switchXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;
  var tileSpanX = matrix.TileWidth * resolution;
  var tileSpanY = matrix.TileHeight * resolution;
  var matrixSetExtent = matrixSetObj['BoundingBox'];
  if (matrixSetExtent && switchXY) {
    matrixSetExtent = [matrixSetExtent[1], matrixSetExtent[0], matrixSetExtent[3], matrixSetExtent[2]];
  }
  var extent = [origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,
  // add one to get proper bottom/right coordinate
  origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow), origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol), origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow];
  if (matrixSetExtent !== undefined && !(0, _extent.containsExtent)(matrixSetExtent, extent)) {
    var wgs84BoundingBox = l['WGS84BoundingBox'];
    var wgs84ProjectionExtent = (0, _proj.get)('EPSG:4326').getExtent();
    extent = matrixSetExtent;
    if (wgs84BoundingBox) {
      wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];
    } else {
      var wgs84MatrixSetExtent = (0, _proj.transformExtent)(matrixSetExtent, matrixSetObj['SupportedCRS'], 'EPSG:4326');
      // Ignore slight deviation from the correct x limits
      wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];
    }
  }
  var tileGrid = (0, _WMTS.createFromCapabilitiesMatrixSet)(matrixSetObj, extent, matrixLimits);

  /** @type {!Array<string>} */
  var urls = [];
  var requestEncoding = config['requestEncoding'];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';
  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];
    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]['Constraint']) {
        var constraint = gets[i]['Constraint'].find(function (element) {
          return element['name'] == 'GetEncoding';
        });
        var encodings = constraint['AllowedValues']['Value'];
        if (requestEncoding === '') {
          // requestEncoding not provided, use the first encoding from the list
          requestEncoding = encodings[0];
        }
        if (requestEncoding === 'KVP') {
          if (encodings.includes('KVP')) {
            urls.push( /** @type {string} */gets[i]['href']);
          }
        } else {
          break;
        }
      } else if (gets[i]['href']) {
        requestEncoding = 'KVP';
        urls.push( /** @type {string} */gets[i]['href']);
      }
    }
  }
  if (urls.length === 0) {
    requestEncoding = 'REST';
    l['ResourceURL'].forEach(function (element) {
      if (element['resourceType'] === 'tile') {
        format = element['format'];
        urls.push( /** @type {string} */element['template']);
      }
    });
  }
  return {
    urls: urls,
    layer: config['layer'],
    matrixSet: matrixSet,
    format: format,
    projection: projection,
    requestEncoding: requestEncoding,
    tileGrid: tileGrid,
    style: style,
    dimensions: dimensions,
    wrapX: wrapX,
    crossOrigin: config['crossOrigin']
  };
}
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../uri.js":"node_modules/ol/uri.js","../extent.js":"node_modules/ol/extent.js","../tilegrid/WMTS.js":"node_modules/ol/tilegrid/WMTS.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BingMaps", {
  enumerable: true,
  get: function () {
    return _BingMaps.default;
  }
});
Object.defineProperty(exports, "CartoDB", {
  enumerable: true,
  get: function () {
    return _CartoDB.default;
  }
});
Object.defineProperty(exports, "Cluster", {
  enumerable: true,
  get: function () {
    return _Cluster.default;
  }
});
Object.defineProperty(exports, "DataTile", {
  enumerable: true,
  get: function () {
    return _DataTile.default;
  }
});
Object.defineProperty(exports, "GeoTIFF", {
  enumerable: true,
  get: function () {
    return _GeoTIFF.default;
  }
});
Object.defineProperty(exports, "IIIF", {
  enumerable: true,
  get: function () {
    return _IIIF.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "ImageArcGISRest", {
  enumerable: true,
  get: function () {
    return _ImageArcGISRest.default;
  }
});
Object.defineProperty(exports, "ImageCanvas", {
  enumerable: true,
  get: function () {
    return _ImageCanvas.default;
  }
});
Object.defineProperty(exports, "ImageMapGuide", {
  enumerable: true,
  get: function () {
    return _ImageMapGuide.default;
  }
});
Object.defineProperty(exports, "ImageStatic", {
  enumerable: true,
  get: function () {
    return _ImageStatic.default;
  }
});
Object.defineProperty(exports, "ImageWMS", {
  enumerable: true,
  get: function () {
    return _ImageWMS.default;
  }
});
Object.defineProperty(exports, "OGCMapTile", {
  enumerable: true,
  get: function () {
    return _OGCMapTile.default;
  }
});
Object.defineProperty(exports, "OGCVectorTile", {
  enumerable: true,
  get: function () {
    return _OGCVectorTile.default;
  }
});
Object.defineProperty(exports, "OSM", {
  enumerable: true,
  get: function () {
    return _OSM.default;
  }
});
Object.defineProperty(exports, "Raster", {
  enumerable: true,
  get: function () {
    return _Raster.default;
  }
});
Object.defineProperty(exports, "Source", {
  enumerable: true,
  get: function () {
    return _Source.default;
  }
});
Object.defineProperty(exports, "StadiaMaps", {
  enumerable: true,
  get: function () {
    return _StadiaMaps.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "TileArcGISRest", {
  enumerable: true,
  get: function () {
    return _TileArcGISRest.default;
  }
});
Object.defineProperty(exports, "TileDebug", {
  enumerable: true,
  get: function () {
    return _TileDebug.default;
  }
});
Object.defineProperty(exports, "TileImage", {
  enumerable: true,
  get: function () {
    return _TileImage.default;
  }
});
Object.defineProperty(exports, "TileJSON", {
  enumerable: true,
  get: function () {
    return _TileJSON.default;
  }
});
Object.defineProperty(exports, "TileWMS", {
  enumerable: true,
  get: function () {
    return _TileWMS.default;
  }
});
Object.defineProperty(exports, "UTFGrid", {
  enumerable: true,
  get: function () {
    return _UTFGrid.default;
  }
});
Object.defineProperty(exports, "UrlTile", {
  enumerable: true,
  get: function () {
    return _UrlTile.default;
  }
});
Object.defineProperty(exports, "Vector", {
  enumerable: true,
  get: function () {
    return _Vector.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});
Object.defineProperty(exports, "WMTS", {
  enumerable: true,
  get: function () {
    return _WMTS.default;
  }
});
Object.defineProperty(exports, "XYZ", {
  enumerable: true,
  get: function () {
    return _XYZ.default;
  }
});
Object.defineProperty(exports, "Zoomify", {
  enumerable: true,
  get: function () {
    return _Zoomify.default;
  }
});
Object.defineProperty(exports, "createArcGISRestLoader", {
  enumerable: true,
  get: function () {
    return _arcgisRest.createLoader;
  }
});
Object.defineProperty(exports, "createMapGuideLoader", {
  enumerable: true,
  get: function () {
    return _mapguide.createLoader;
  }
});
Object.defineProperty(exports, "createStaticLoader", {
  enumerable: true,
  get: function () {
    return _static.createLoader;
  }
});
Object.defineProperty(exports, "createWMSLoader", {
  enumerable: true,
  get: function () {
    return _wms.createLoader;
  }
});
exports.sourcesFromTileGrid = sourcesFromTileGrid;
var _LRUCache = _interopRequireDefault(require("./structs/LRUCache.js"));
var _extent = require("./extent.js");
var _BingMaps = _interopRequireDefault(require("./source/BingMaps.js"));
var _CartoDB = _interopRequireDefault(require("./source/CartoDB.js"));
var _Cluster = _interopRequireDefault(require("./source/Cluster.js"));
var _DataTile = _interopRequireDefault(require("./source/DataTile.js"));
var _GeoTIFF = _interopRequireDefault(require("./source/GeoTIFF.js"));
var _IIIF = _interopRequireDefault(require("./source/IIIF.js"));
var _Image = _interopRequireDefault(require("./source/Image.js"));
var _ImageArcGISRest = _interopRequireDefault(require("./source/ImageArcGISRest.js"));
var _ImageCanvas = _interopRequireDefault(require("./source/ImageCanvas.js"));
var _ImageMapGuide = _interopRequireDefault(require("./source/ImageMapGuide.js"));
var _ImageStatic = _interopRequireDefault(require("./source/ImageStatic.js"));
var _ImageWMS = _interopRequireDefault(require("./source/ImageWMS.js"));
var _OGCMapTile = _interopRequireDefault(require("./source/OGCMapTile.js"));
var _OGCVectorTile = _interopRequireDefault(require("./source/OGCVectorTile.js"));
var _OSM = _interopRequireDefault(require("./source/OSM.js"));
var _Raster = _interopRequireDefault(require("./source/Raster.js"));
var _Source = _interopRequireDefault(require("./source/Source.js"));
var _StadiaMaps = _interopRequireDefault(require("./source/StadiaMaps.js"));
var _Tile = _interopRequireDefault(require("./source/Tile.js"));
var _TileArcGISRest = _interopRequireDefault(require("./source/TileArcGISRest.js"));
var _TileDebug = _interopRequireDefault(require("./source/TileDebug.js"));
var _TileImage = _interopRequireDefault(require("./source/TileImage.js"));
var _TileJSON = _interopRequireDefault(require("./source/TileJSON.js"));
var _TileWMS = _interopRequireDefault(require("./source/TileWMS.js"));
var _UrlTile = _interopRequireDefault(require("./source/UrlTile.js"));
var _UTFGrid = _interopRequireDefault(require("./source/UTFGrid.js"));
var _Vector = _interopRequireDefault(require("./source/Vector.js"));
var _VectorTile = _interopRequireDefault(require("./source/VectorTile.js"));
var _WMTS = _interopRequireDefault(require("./source/WMTS.js"));
var _XYZ = _interopRequireDefault(require("./source/XYZ.js"));
var _Zoomify = _interopRequireDefault(require("./source/Zoomify.js"));
var _wms = require("./source/wms.js");
var _arcgisRest = require("./source/arcgisRest.js");
var _static = require("./source/static.js");
var _mapguide = require("./source/mapguide.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/source
 */

/**
 * Creates a sources function from a tile grid. This function can be used as value for the
 * `sources` property of the {@link module:ol/layer/Layer~Layer} subclasses that support it.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @param {function(import("./tilecoord.js").TileCoord): import("./source/Source.js").default} factory Source factory.
 * This function takes a {@link module:ol/tilecoord~TileCoord} as argument and is expected to return a
 * {@link module:ol/source/Source~Source}. **Note**: The returned sources should have a tile grid with
 * a limited set of resolutions, matching the resolution range of a single zoom level of the pyramid
 * `tileGrid` that `sourcesFromTileGrid` was called with.
 * @return {function(import("./extent.js").Extent, number): Array<import("./source/Source.js").default>} Sources function.
 * @api
 */
function sourcesFromTileGrid(tileGrid, factory) {
  var sourceCache = new _LRUCache.default(32);
  var tileGridExtent = tileGrid.getExtent();
  return function (extent, resolution) {
    sourceCache.expireCache();
    if (tileGridExtent) {
      extent = (0, _extent.getIntersection)(tileGridExtent, extent);
    }
    var z = tileGrid.getZForResolution(resolution);
    var wantedSources = [];
    tileGrid.forEachTileCoord(extent, z, function (tileCoord) {
      var key = tileCoord.toString();
      if (!sourceCache.containsKey(key)) {
        var source = factory(tileCoord);
        sourceCache.set(key, source);
      }
      wantedSources.push(sourceCache.get(key));
    });
    return wantedSources;
  };
}
},{"./structs/LRUCache.js":"node_modules/ol/structs/LRUCache.js","./extent.js":"node_modules/ol/extent.js","./source/BingMaps.js":"node_modules/ol/source/BingMaps.js","./source/CartoDB.js":"node_modules/ol/source/CartoDB.js","./source/Cluster.js":"node_modules/ol/source/Cluster.js","./source/DataTile.js":"node_modules/ol/source/DataTile.js","./source/GeoTIFF.js":"node_modules/ol/source/GeoTIFF.js","./source/IIIF.js":"node_modules/ol/source/IIIF.js","./source/Image.js":"node_modules/ol/source/Image.js","./source/ImageArcGISRest.js":"node_modules/ol/source/ImageArcGISRest.js","./source/ImageCanvas.js":"node_modules/ol/source/ImageCanvas.js","./source/ImageMapGuide.js":"node_modules/ol/source/ImageMapGuide.js","./source/ImageStatic.js":"node_modules/ol/source/ImageStatic.js","./source/ImageWMS.js":"node_modules/ol/source/ImageWMS.js","./source/OGCMapTile.js":"node_modules/ol/source/OGCMapTile.js","./source/OGCVectorTile.js":"node_modules/ol/source/OGCVectorTile.js","./source/OSM.js":"node_modules/ol/source/OSM.js","./source/Raster.js":"node_modules/ol/source/Raster.js","./source/Source.js":"node_modules/ol/source/Source.js","./source/StadiaMaps.js":"node_modules/ol/source/StadiaMaps.js","./source/Tile.js":"node_modules/ol/source/Tile.js","./source/TileArcGISRest.js":"node_modules/ol/source/TileArcGISRest.js","./source/TileDebug.js":"node_modules/ol/source/TileDebug.js","./source/TileImage.js":"node_modules/ol/source/TileImage.js","./source/TileJSON.js":"node_modules/ol/source/TileJSON.js","./source/TileWMS.js":"node_modules/ol/source/TileWMS.js","./source/UrlTile.js":"node_modules/ol/source/UrlTile.js","./source/UTFGrid.js":"node_modules/ol/source/UTFGrid.js","./source/Vector.js":"node_modules/ol/source/Vector.js","./source/VectorTile.js":"node_modules/ol/source/VectorTile.js","./source/WMTS.js":"node_modules/ol/source/WMTS.js","./source/XYZ.js":"node_modules/ol/source/XYZ.js","./source/Zoomify.js":"node_modules/ol/source/Zoomify.js","./source/wms.js":"node_modules/ol/source/wms.js","./source/arcgisRest.js":"node_modules/ol/source/arcgisRest.js","./source/static.js":"node_modules/ol/source/static.js","./source/mapguide.js":"node_modules/ol/source/mapguide.js"}],"node_modules/ol/render.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRenderPixel = getRenderPixel;
exports.getVectorContext = getVectorContext;
exports.toContext = toContext;
var _Immediate = _interopRequireDefault(require("./render/canvas/Immediate.js"));
var _has = require("./has.js");
var _transform = require("./transform.js");
var _vector = require("./renderer/vector.js");
var _proj = require("./proj.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/render
 */

/**
 * @typedef {Object} State
 * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.
 * @property {import("./Feature.js").FeatureLike} feature Feature.
 * @property {import("./geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} pixelRatio Pixel ratio used by the layer renderer.
 * @property {number} resolution Resolution that the render batch was created and optimized for.
 * This is not the view's resolution that is being rendered.
 * @property {number} rotation Rotation of the rendered layer in radians.
 */

/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module:ol/Feature~Feature} or
 * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.
 *
 * @typedef {function(import("./Feature.js").FeatureLike, import("./Feature.js").FeatureLike):number} OrderFunction
 */

/**
 * @typedef {Object} ToContextOptions
 * @property {import("./size.js").Size} [size] Desired size of the canvas in css
 * pixels. When provided, both canvas and css size will be set according to the
 * `pixelRatio`. If not provided, the current canvas and css sizes will not be
 * altered.
 * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas
 * pixel to css pixel ratio) for the canvas.
 */

/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 *
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * import {toContext} from 'ol/render.js';
 * import Fill from 'ol/style/Fill.js';
 * import Polygon from 'ol/geom/Polygon.js';
 *
 * const canvas = document.createElement('canvas');
 * const render = toContext(
 *     canvas.getContext('2d'),
 *     {size: [100, 100]}
 * );
 * render.setFillStrokeStyle(new Fill({ color: blue }));
 * render.drawPolygon(
 *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]])
 * );
 * ```
 *
 * @param {CanvasRenderingContext2D} context Canvas context.
 * @param {ToContextOptions} [options] Options.
 * @return {CanvasImmediateRenderer} Canvas Immediate.
 * @api
 */
function toContext(context, options) {
  var canvas = context.canvas;
  options = options ? options : {};
  var pixelRatio = options.pixelRatio || _has.DEVICE_PIXEL_RATIO;
  var size = options.size;
  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
  }
  var extent = [0, 0, canvas.width, canvas.height];
  var transform = (0, _transform.scale)((0, _transform.create)(), pixelRatio, pixelRatio);
  return new _Immediate.default(context, pixelRatio, extent, transform, 0);
}

/**
 * Gets a vector context for drawing to the event's canvas.
 * @param {import("./render/Event.js").default} event Render event.
 * @return {CanvasImmediateRenderer} Vector context.
 * @api
 */
function getVectorContext(event) {
  if (!(event.context instanceof CanvasRenderingContext2D)) {
    throw new Error('Only works for render events from Canvas 2D layers');
  }

  // canvas may be at a different pixel ratio than frameState.pixelRatio
  var a = event.inversePixelTransform[0];
  var b = event.inversePixelTransform[1];
  var canvasPixelRatio = Math.sqrt(a * a + b * b);
  var frameState = event.frameState;
  var transform = (0, _transform.multiply)(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  var squaredTolerance = (0, _vector.getSquaredTolerance)(frameState.viewState.resolution, canvasPixelRatio);
  var userTransform;
  var userProjection = (0, _proj.getUserProjection)();
  if (userProjection) {
    userTransform = (0, _proj.getTransformFromProjections)(userProjection, frameState.viewState.projection);
  }
  return new _Immediate.default(event.context, canvasPixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);
}

/**
 * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.
 * @param {import("./render/Event.js").default} event Render event.
 * @param {import("./pixel.js").Pixel} pixel CSS pixel relative to the top-left
 * corner of the map viewport.
 * @return {import("./pixel.js").Pixel} Pixel on the event's canvas context.
 * @api
 */
function getRenderPixel(event, pixel) {
  return (0, _transform.apply)(event.inversePixelTransform, pixel.slice(0));
}
},{"./render/canvas/Immediate.js":"node_modules/ol/render/canvas/Immediate.js","./has.js":"node_modules/ol/has.js","./transform.js":"node_modules/ol/transform.js","./renderer/vector.js":"node_modules/ol/renderer/vector.js","./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/geom/flat/geodesic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.greatCircleArc = greatCircleArc;
exports.meridian = meridian;
exports.parallel = parallel;
var _proj = require("../../proj.js");
var _math = require("../../math.js");
/**
 * @module ol/geom/flat/geodesic
 */

/**
 * @param {function(number): import("../../coordinate.js").Coordinate} interpolate Interpolate function.
 * @param {import("../../proj.js").TransformFunction} transform Transform from longitude/latitude to
 *     projected coordinates.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
function line(interpolate, transform, squaredTolerance) {
  // FIXME reduce garbage generation
  // FIXME optimize stack operations

  /** @type {Array<number>} */
  var flatCoordinates = [];
  var geoA = interpolate(0);
  var geoB = interpolate(1);
  var a = transform(geoA);
  var b = transform(geoB);

  /** @type {Array<import("../../coordinate.js").Coordinate>} */
  var geoStack = [geoB, geoA];
  /** @type {Array<import("../../coordinate.js").Coordinate>} */
  var stack = [b, a];
  /** @type {Array<number>} */
  var fractionStack = [1, 0];

  /** @type {!Object<string, boolean>} */
  var fractions = {};
  var maxIterations = 1e5;
  var geoM, m, fracA, fracB, fracM, key;
  while (--maxIterations > 0 && fractionStack.length > 0) {
    // Pop the a coordinate off the stack
    fracA = fractionStack.pop();
    geoA = geoStack.pop();
    a = stack.pop();
    // Add the a coordinate if it has not been added yet
    key = fracA.toString();
    if (!(key in fractions)) {
      flatCoordinates.push(a[0], a[1]);
      fractions[key] = true;
    }
    // Pop the b coordinate off the stack
    fracB = fractionStack.pop();
    geoB = geoStack.pop();
    b = stack.pop();
    // Find the m point between the a and b coordinates
    fracM = (fracA + fracB) / 2;
    geoM = interpolate(fracM);
    m = transform(geoM);
    if ((0, _math.squaredSegmentDistance)(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {
      // If the m point is sufficiently close to the straight line, then we
      // discard it.  Just use the b coordinate and move on to the next line
      // segment.
      flatCoordinates.push(b[0], b[1]);
      key = fracB.toString();
      fractions[key] = true;
    } else {
      // Otherwise, we need to subdivide the current line segment.  Split it
      // into two and push the two line segments onto the stack.
      fractionStack.push(fracB, fracM, fracM, fracA);
      stack.push(b, m, m, a);
      geoStack.push(geoB, geoM, geoM, geoA);
    }
  }
  return flatCoordinates;
}

/**
 * Generate a great-circle arcs between two lat/lon points.
 * @param {number} lon1 Longitude 1 in degrees.
 * @param {number} lat1 Latitude 1 in degrees.
 * @param {number} lon2 Longitude 2 in degrees.
 * @param {number} lat2 Latitude 2 in degrees.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {
  var geoProjection = (0, _proj.get)('EPSG:4326');
  var cosLat1 = Math.cos((0, _math.toRadians)(lat1));
  var sinLat1 = Math.sin((0, _math.toRadians)(lat1));
  var cosLat2 = Math.cos((0, _math.toRadians)(lat2));
  var sinLat2 = Math.sin((0, _math.toRadians)(lat2));
  var cosDeltaLon = Math.cos((0, _math.toRadians)(lon2 - lon1));
  var sinDeltaLon = Math.sin((0, _math.toRadians)(lon2 - lon1));
  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    if (1 <= d) {
      return [lon2, lat2];
    }
    var D = frac * Math.acos(d);
    var cosD = Math.cos(D);
    var sinD = Math.sin(D);
    var y = sinDeltaLon * cosLat2;
    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;
    var theta = Math.atan2(y, x);
    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));
    var lon = (0, _math.toRadians)(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));
    return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
  }, (0, _proj.getTransform)(geoProjection, projection), squaredTolerance);
}

/**
 * Generate a meridian (line at constant longitude).
 * @param {number} lon Longitude.
 * @param {number} lat1 Latitude 1.
 * @param {number} lat2 Latitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
function meridian(lon, lat1, lat2, projection, squaredTolerance) {
  var epsg4326Projection = (0, _proj.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon, lat1 + (lat2 - lat1) * frac];
  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);
}

/**
 * Generate a parallel (line at constant latitude).
 * @param {number} lat Latitude.
 * @param {number} lon1 Longitude 1.
 * @param {number} lon2 Longitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
function parallel(lat, lon1, lon2, projection, squaredTolerance) {
  var epsg4326Projection = (0, _proj.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon1 + (lon2 - lon1) * frac, lat];
  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);
}
},{"../../proj.js":"node_modules/ol/proj.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/layer/Graticule.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Collection = _interopRequireDefault(require("../Collection.js"));
var _EventType = _interopRequireDefault(require("../render/EventType.js"));
var _Feature = _interopRequireDefault(require("../Feature.js"));
var _Fill = _interopRequireDefault(require("../style/Fill.js"));
var _LineString = _interopRequireDefault(require("../geom/LineString.js"));
var _Point = _interopRequireDefault(require("../geom/Point.js"));
var _Stroke = _interopRequireDefault(require("../style/Stroke.js"));
var _Style = _interopRequireDefault(require("../style/Style.js"));
var _Text = _interopRequireDefault(require("../style/Text.js"));
var _Vector = _interopRequireDefault(require("./Vector.js"));
var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));
var _extent = require("../extent.js");
var _math = require("../math.js");
var _coordinate = require("../coordinate.js");
var _proj = require("../proj.js");
var _render = require("../render.js");
var _geodesic = require("../geom/flat/geodesic.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Graticule
 */
/**
 * @type {Stroke}
 * @private
 * @const
 */
var DEFAULT_STROKE_STYLE = new _Stroke.default({
  color: 'rgba(0,0,0,0.2)'
});

/**
 * @type {Array<number>}
 * @private
 */
var INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 30 / 60, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600];

/**
 * @typedef {Object} GraticuleLabelDataType
 * @property {Point} geom Geometry.
 * @property {string} text Text.
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [maxLines=100] The maximum number of meridians and
 * parallels from the center of the map. The default value of 100 means that at
 * most 200 meridians and 200 parallels will be displayed. The default value is
 * appropriate for conformal projections like Spherical Mercator. If you
 * increase the value, more lines will be drawn and the drawing performance will
 * decrease.
 * @property {Stroke} [strokeStyle] The
 * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:
 * ```js
 * new Stroke({
 *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black
 * });
 * ```
 * @property {number} [targetSize=100] The target size of the graticule cells,
 * in pixels.
 * @property {boolean} [showLabels=false] Render a label with the respective
 * latitude/longitude for each graticule line.
 * @property {function(number):string} [lonLabelFormatter] Label formatter for
 * longitudes. This function is called with the longitude as argument, and
 * should return a formatted string representing the longitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {function(number):string} [latLabelFormatter] Label formatter for
 * latitudes. This function is called with the latitude as argument, and
 * should return a formatted string representing the latitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {number} [lonLabelPosition=0] Longitude label position in fractions
 * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the
 * top.
 * @property {number} [latLabelPosition=1] Latitude label position in fractions
 * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the
 * right.
 * @property {Text} [lonLabelStyle] Longitude label text
 * style. If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textBaseline: 'bottom',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: new Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textBaseline` configuration will not work well for
 * `lonLabelPosition` configurations that position labels close to the top of
 * the viewport.
 * @property {Text} [latLabelStyle] Latitude label text style.
 * If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textAlign: 'end',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textAlign` configuration will not work well for
 * `latLabelPosition` configurations that position labels close to the left of
 * the viewport.
 * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]
 * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:
 * ```js
 * [30, 10]
 * ```
 * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).
 * Note that the view projection must define both extent and worldExtent.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @extends {VectorLayer<import("../source/Vector.js").default>}
 * @api
 */
var Graticule = /*#__PURE__*/function (_VectorLayer) {
  _inherits(Graticule, _VectorLayer);
  var _super = _createSuper(Graticule);
  /**
   * @param {Options} [options] Options.
   */
  function Graticule(options) {
    var _this;
    _classCallCheck(this, Graticule);
    options = options ? options : {};
    var baseOptions = Object.assign({
      updateWhileAnimating: true,
      updateWhileInteracting: true,
      renderBuffer: 0
    }, options);
    delete baseOptions.maxLines;
    delete baseOptions.strokeStyle;
    delete baseOptions.targetSize;
    delete baseOptions.showLabels;
    delete baseOptions.lonLabelFormatter;
    delete baseOptions.latLabelFormatter;
    delete baseOptions.lonLabelPosition;
    delete baseOptions.latLabelPosition;
    delete baseOptions.lonLabelStyle;
    delete baseOptions.latLabelStyle;
    delete baseOptions.intervals;
    _this = _super.call(this, baseOptions);

    /**
     * @type {import("../proj/Projection.js").default}
     */
    _this.projection_ = null;

    /**
     * @type {number}
     * @private
     */
    _this.maxLat_ = Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.maxLon_ = Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.minLat_ = -Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.minLon_ = -Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.maxX_ = Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.maxY_ = Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.minX_ = -Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.minY_ = -Infinity;

    /**
     * @type {number}
     * @private
     */
    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;

    /**
     * @type {number}
     * @private
     */
    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;

    /**
     * @type {Array<LineString>}
     * @private
     */
    _this.meridians_ = [];

    /**
     * @type {Array<LineString>}
     * @private
     */
    _this.parallels_ = [];

    /**
     * @type {Stroke}
     * @private
     */
    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;

    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */
    _this.fromLonLatTransform_ = undefined;

    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */
    _this.toLonLatTransform_ = undefined;

    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this.projectionCenterLonLat_ = null;

    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this.bottomLeft_ = null;

    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this.bottomRight_ = null;

    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this.topLeft_ = null;

    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    _this.topRight_ = null;

    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */
    _this.meridiansLabels_ = null;

    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */
    _this.parallelsLabels_ = null;
    if (options.showLabels) {
      /**
       * @type {null|function(number):string}
       * @private
       */
      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_assertThisInitialized(_this), 'EW') : options.lonLabelFormatter;

      /**
       * @type {function(number):string}
       * @private
       */
      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_assertThisInitialized(_this), 'NS') : options.latLabelFormatter;

      /**
       * Longitude label position in fractions (0..1) of view extent. 0 means
       * bottom, 1 means top.
       * @type {number}
       * @private
       */
      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;

      /**
       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1
       * means right.
       * @type {number}
       * @private
       */
      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;

      /**
       * @type {Style}
       * @private
       */
      _this.lonLabelStyleBase_ = new _Style.default({
        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new _Text.default({
          font: '12px Calibri,sans-serif',
          textBaseline: 'bottom',
          fill: new _Fill.default({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _Stroke.default({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });

      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */
      _this.lonLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        _this.lonLabelStyleBase_.getText().setText(label);
        return _this.lonLabelStyleBase_;
      };

      /**
       * @type {Style}
       * @private
       */
      _this.latLabelStyleBase_ = new _Style.default({
        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new _Text.default({
          font: '12px Calibri,sans-serif',
          textAlign: 'right',
          fill: new _Fill.default({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _Stroke.default({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });

      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */
      _this.latLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        _this.latLabelStyleBase_.getText().setText(label);
        return _this.latLabelStyleBase_;
      };
      _this.meridiansLabels_ = [];
      _this.parallelsLabels_ = [];
      _this.addEventListener(_EventType.default.POSTRENDER, _this.drawLabels_.bind(_assertThisInitialized(_this)));
    }

    /**
     * @type {Array<number>}
     * @private
     */
    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS;

    // use a source with a custom loader for lines & text
    _this.setSource(new _Vector2.default({
      loader: _this.loaderFunction.bind(_assertThisInitialized(_this)),
      strategy: _this.strategyFunction.bind(_assertThisInitialized(_this)),
      features: new _Collection.default(),
      overlaps: false,
      useSpatialIndex: false,
      wrapX: options.wrapX
    }));

    /**
     * feature pool to use when updating graticule
     * @type {Array<Feature>}
     * @private
     */
    _this.featurePool_ = [];

    /**
     * @type {Style}
     * @private
     */
    _this.lineStyle_ = new _Style.default({
      stroke: _this.strokeStyle_
    });

    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */
    _this.loadedExtent_ = null;

    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */
    _this.renderedExtent_ = null;

    /**
     * @type {?number}
     * @private
     */
    _this.renderedResolution_ = null;
    _this.setRenderOrder(null);
    return _this;
  }

  /**
   * Strategy function for loading features based on the view's extent and
   * resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("../extent.js").Extent>} Extents.
   */
  _createClass(Graticule, [{
    key: "strategyFunction",
    value: function strategyFunction(extent, resolution) {
      // extents may be passed in different worlds, to avoid endless loop we use only one
      var realWorldExtent = extent.slice();
      if (this.projection_ && this.getSource().getWrapX()) {
        (0, _extent.wrapX)(realWorldExtent, this.projection_);
      }
      if (this.loadedExtent_) {
        if ((0, _extent.approximatelyEquals)(this.loadedExtent_, realWorldExtent, resolution)) {
          // make sure result is exactly equal to previous extent
          realWorldExtent = this.loadedExtent_.slice();
        } else {
          // we should not keep track of loaded extents
          this.getSource().removeLoadedExtent(this.loadedExtent_);
        }
      }
      return [realWorldExtent];
    }

    /**
     * Update geometries in the source based on current view
     * @param {import("../extent").Extent} extent Extent
     * @param {number} resolution Resolution
     * @param {import("../proj/Projection.js").default} projection Projection
     */
  }, {
    key: "loaderFunction",
    value: function loaderFunction(extent, resolution, projection) {
      this.loadedExtent_ = extent;
      var source = this.getSource();

      // only consider the intersection between our own extent & the requested one
      var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];
      var renderExtent = (0, _extent.getIntersection)(layerExtent, extent);
      if (this.renderedExtent_ && (0, _extent.equals)(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {
        return;
      }
      this.renderedExtent_ = renderExtent;
      this.renderedResolution_ = resolution;

      // bail out if nothing to render
      if ((0, _extent.isEmpty)(renderExtent)) {
        return;
      }

      // update projection info
      var center = (0, _extent.getCenter)(renderExtent);
      var squaredTolerance = resolution * resolution / 4;
      var updateProjectionInfo = !this.projection_ || !(0, _proj.equivalent)(this.projection_, projection);
      if (updateProjectionInfo) {
        this.updateProjectionInfo_(projection);
      }
      this.createGraticule_(renderExtent, center, resolution, squaredTolerance);

      // first make sure we have enough features in the pool
      var featureCount = this.meridians_.length + this.parallels_.length;
      if (this.meridiansLabels_) {
        featureCount += this.meridians_.length;
      }
      if (this.parallelsLabels_) {
        featureCount += this.parallels_.length;
      }
      var feature;
      while (featureCount > this.featurePool_.length) {
        feature = new _Feature.default();
        this.featurePool_.push(feature);
      }
      var featuresColl = source.getFeaturesCollection();
      featuresColl.clear();
      var poolIndex = 0;

      // add features for the lines & labels
      var i, l;
      for (i = 0, l = this.meridians_.length; i < l; ++i) {
        feature = this.featurePool_[poolIndex++];
        feature.setGeometry(this.meridians_[i]);
        feature.setStyle(this.lineStyle_);
        featuresColl.push(feature);
      }
      for (i = 0, l = this.parallels_.length; i < l; ++i) {
        feature = this.featurePool_[poolIndex++];
        feature.setGeometry(this.parallels_[i]);
        feature.setStyle(this.lineStyle_);
        featuresColl.push(feature);
      }
    }

    /**
     * @param {number} lon Longitude.
     * @param {number} minLat Minimal latitude.
     * @param {number} maxLat Maximal latitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {number} Index.
     * @private
     */
  }, {
    key: "addMeridian_",
    value: function addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {
      var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);
      if ((0, _extent.intersects)(lineString.getExtent(), extent)) {
        if (this.meridiansLabels_) {
          var text = this.lonLabelFormatter_(lon);
          if (index in this.meridiansLabels_) {
            this.meridiansLabels_[index].text = text;
          } else {
            this.meridiansLabels_[index] = {
              geom: new _Point.default([]),
              text: text
            };
          }
        }
        this.meridians_[index++] = lineString;
      }
      return index;
    }

    /**
     * @param {number} lat Latitude.
     * @param {number} minLon Minimal longitude.
     * @param {number} maxLon Maximal longitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {number} Index.
     * @private
     */
  }, {
    key: "addParallel_",
    value: function addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {
      var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);
      if ((0, _extent.intersects)(lineString.getExtent(), extent)) {
        if (this.parallelsLabels_) {
          var text = this.latLabelFormatter_(lat);
          if (index in this.parallelsLabels_) {
            this.parallelsLabels_[index].text = text;
          } else {
            this.parallelsLabels_[index] = {
              geom: new _Point.default([]),
              text: text
            };
          }
        }
        this.parallels_[index++] = lineString;
      }
      return index;
    }

    /**
     * @param {import("../render/Event.js").default} event Render event.
     * @private
     */
  }, {
    key: "drawLabels_",
    value: function drawLabels_(event) {
      var rotation = event.frameState.viewState.rotation;
      var resolution = event.frameState.viewState.resolution;
      var size = event.frameState.size;
      var extent = event.frameState.extent;
      var rotationCenter = (0, _extent.getCenter)(extent);
      var rotationExtent = extent;
      if (rotation) {
        var unrotatedWidth = size[0] * resolution;
        var unrotatedHeight = size[1] * resolution;
        rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];
      }
      var startWorld = 0;
      var endWorld = 0;
      var labelsAtStart = this.latLabelPosition_ < 0.5;
      var projectionExtent = this.projection_.getExtent();
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
        startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);
        endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);
        var inverted = Math.abs(rotation) > Math.PI / 2;
        labelsAtStart = labelsAtStart !== inverted;
      }
      var vectorContext = (0, _render.getVectorContext)(event);
      for (var world = startWorld; world <= endWorld; ++world) {
        var poolIndex = this.meridians_.length + this.parallels_.length;
        var feature = void 0,
          index = void 0,
          l = void 0,
          textPoint = void 0;
        if (this.meridiansLabels_) {
          for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {
            var lineString = this.meridians_[index];
            if (!rotation && world === 0) {
              textPoint = this.getMeridianPoint_(lineString, extent, index);
            } else {
              var clone = lineString.clone();
              clone.translate(world * worldWidth, 0);
              clone.rotate(-rotation, rotationCenter);
              textPoint = this.getMeridianPoint_(clone, rotationExtent, index);
              textPoint.rotate(rotation, rotationCenter);
            }
            feature = this.featurePool_[poolIndex++];
            feature.setGeometry(textPoint);
            feature.set('graticule_label', this.meridiansLabels_[index].text);
            vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));
          }
        }
        if (this.parallelsLabels_) {
          if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {
            for (index = 0, l = this.parallels_.length; index < l; ++index) {
              var _lineString = this.parallels_[index];
              if (!rotation && world === 0) {
                textPoint = this.getParallelPoint_(_lineString, extent, index);
              } else {
                var _clone = _lineString.clone();
                _clone.translate(world * worldWidth, 0);
                _clone.rotate(-rotation, rotationCenter);
                textPoint = this.getParallelPoint_(_clone, rotationExtent, index);
                textPoint.rotate(rotation, rotationCenter);
              }
              feature = this.featurePool_[poolIndex++];
              feature.setGeometry(textPoint);
              feature.set('graticule_label', this.parallelsLabels_[index].text);
              vectorContext.drawFeature(feature, this.latLabelStyle_(feature));
            }
          }
        }
      }
    }

    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} squaredTolerance Squared tolerance.
     * @private
     */
  }, {
    key: "createGraticule_",
    value: function createGraticule_(extent, center, resolution, squaredTolerance) {
      var interval = this.getInterval_(resolution);
      if (interval == -1) {
        this.meridians_.length = 0;
        this.parallels_.length = 0;
        if (this.meridiansLabels_) {
          this.meridiansLabels_.length = 0;
        }
        if (this.parallelsLabels_) {
          this.parallelsLabels_.length = 0;
        }
        return;
      }
      var wrapX = false;
      var projectionExtent = this.projection_.getExtent();
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
        if ((0, _extent.getWidth)(extent) >= worldWidth) {
          extent[0] = projectionExtent[0];
          extent[2] = projectionExtent[2];
        } else {
          wrapX = true;
        }
      }

      // Constrain the center to fit into the extent available to the graticule

      var validCenterP = [(0, _math.clamp)(center[0], this.minX_, this.maxX_), (0, _math.clamp)(center[1], this.minY_, this.maxY_)];

      // Transform the center to lon lat
      // Some projections may have a void area at the poles
      // so replace any NaN latitudes with the min or max value closest to a pole

      var centerLonLat = this.toLonLatTransform_(validCenterP);
      if (isNaN(centerLonLat[1])) {
        centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
      }
      var centerLon = (0, _math.clamp)(centerLonLat[0], this.minLon_, this.maxLon_);
      var centerLat = (0, _math.clamp)(centerLonLat[1], this.minLat_, this.maxLat_);
      var maxLines = this.maxLines_;
      var cnt, idx, lat, lon;

      // Limit the extent to fit into the extent available to the graticule

      var validExtentP = extent;
      if (!wrapX) {
        validExtentP = [(0, _math.clamp)(extent[0], this.minX_, this.maxX_), (0, _math.clamp)(extent[1], this.minY_, this.maxY_), (0, _math.clamp)(extent[2], this.minX_, this.maxX_), (0, _math.clamp)(extent[3], this.minY_, this.maxY_)];
      }

      // Transform the extent to get the lon lat ranges for the edges of the extent

      var validExtent = (0, _extent.applyTransform)(validExtentP, this.toLonLatTransform_, undefined, 8);
      var maxLat = validExtent[3];
      var maxLon = validExtent[2];
      var minLat = validExtent[1];
      var minLon = validExtent[0];
      if (!wrapX) {
        // Check if extremities of the world extent lie inside the extent
        // (for example the pole in a polar projection)
        // and extend the extent as appropriate

        if ((0, _extent.containsCoordinate)(validExtentP, this.bottomLeft_)) {
          minLon = this.minLon_;
          minLat = this.minLat_;
        }
        if ((0, _extent.containsCoordinate)(validExtentP, this.bottomRight_)) {
          maxLon = this.maxLon_;
          minLat = this.minLat_;
        }
        if ((0, _extent.containsCoordinate)(validExtentP, this.topLeft_)) {
          minLon = this.minLon_;
          maxLat = this.maxLat_;
        }
        if ((0, _extent.containsCoordinate)(validExtentP, this.topRight_)) {
          maxLon = this.maxLon_;
          maxLat = this.maxLat_;
        }

        // The transformed center may also extend the lon lat ranges used for rendering

        maxLat = (0, _math.clamp)(maxLat, centerLat, this.maxLat_);
        maxLon = (0, _math.clamp)(maxLon, centerLon, this.maxLon_);
        minLat = (0, _math.clamp)(minLat, this.minLat_, centerLat);
        minLon = (0, _math.clamp)(minLon, this.minLon_, centerLon);
      }

      // Create meridians

      centerLon = Math.floor(centerLon / interval) * interval;
      lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);
      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
      cnt = 0;
      if (wrapX) {
        while ((lon -= interval) >= minLon && cnt++ < maxLines) {
          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
        }
      } else {
        while (lon != this.minLon_ && cnt++ < maxLines) {
          lon = Math.max(lon - interval, this.minLon_);
          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
        }
      }
      lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);
      cnt = 0;
      if (wrapX) {
        while ((lon += interval) <= maxLon && cnt++ < maxLines) {
          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
        }
      } else {
        while (lon != this.maxLon_ && cnt++ < maxLines) {
          lon = Math.min(lon + interval, this.maxLon_);
          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
        }
      }
      this.meridians_.length = idx;
      if (this.meridiansLabels_) {
        this.meridiansLabels_.length = idx;
      }

      // Create parallels

      centerLat = Math.floor(centerLat / interval) * interval;
      lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);
      cnt = 0;
      while (lat != this.minLat_ && cnt++ < maxLines) {
        lat = Math.max(lat - interval, this.minLat_);
        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
      }
      lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);
      cnt = 0;
      while (lat != this.maxLat_ && cnt++ < maxLines) {
        lat = Math.min(lat + interval, this.maxLat_);
        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
      }
      this.parallels_.length = idx;
      if (this.parallelsLabels_) {
        this.parallelsLabels_.length = idx;
      }
    }

    /**
     * @param {number} resolution Resolution.
     * @return {number} The interval in degrees.
     * @private
     */
  }, {
    key: "getInterval_",
    value: function getInterval_(resolution) {
      var centerLon = this.projectionCenterLonLat_[0];
      var centerLat = this.projectionCenterLonLat_[1];
      var interval = -1;
      var target = Math.pow(this.targetSize_ * resolution, 2);
      /** @type {Array<number>} **/
      var p1 = [];
      /** @type {Array<number>} **/
      var p2 = [];
      for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {
        var delta = (0, _math.clamp)(this.intervals_[i] / 2, 0, 90);
        // Don't attempt to transform latitudes beyond the poles!
        var clampedLat = (0, _math.clamp)(centerLat, -90 + delta, 90 - delta);
        p1[0] = centerLon - delta;
        p1[1] = clampedLat - delta;
        p2[0] = centerLon + delta;
        p2[1] = clampedLat + delta;
        this.fromLonLatTransform_(p1, p1);
        this.fromLonLatTransform_(p2, p2);
        var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
        if (dist <= target) {
          break;
        }
        interval = this.intervals_[i];
      }
      return interval;
    }

    /**
     * @param {number} lon Longitude.
     * @param {number} minLat Minimal latitude.
     * @param {number} maxLat Maximal latitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} The meridian line string.
     * @param {number} index Index.
     * @private
     */
  }, {
    key: "getMeridian_",
    value: function getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {
      var flatCoordinates = (0, _geodesic.meridian)(lon, minLat, maxLat, this.projection_, squaredTolerance);
      var lineString = this.meridians_[index];
      if (!lineString) {
        lineString = new _LineString.default(flatCoordinates, 'XY');
        this.meridians_[index] = lineString;
      } else {
        lineString.setFlatCoordinates('XY', flatCoordinates);
        lineString.changed();
      }
      return lineString;
    }

    /**
     * @param {LineString} lineString Meridian
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {Point} Meridian point.
     * @private
     */
  }, {
    key: "getMeridianPoint_",
    value: function getMeridianPoint_(lineString, extent, index) {
      var flatCoordinates = lineString.getFlatCoordinates();
      var bottom = 1;
      var top = flatCoordinates.length - 1;
      if (flatCoordinates[bottom] > flatCoordinates[top]) {
        bottom = top;
        top = 1;
      }
      var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);
      var clampedTop = Math.min(extent[3], flatCoordinates[top]);
      var lat = (0, _math.clamp)(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);
      var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);
      var coordinate = [coordinate0, lat];
      var point = this.meridiansLabels_[index].geom;
      point.setCoordinates(coordinate);
      return point;
    }

    /**
     * Get the list of meridians.  Meridians are lines of equal longitude.
     * @return {Array<LineString>} The meridians.
     * @api
     */
  }, {
    key: "getMeridians",
    value: function getMeridians() {
      return this.meridians_;
    }

    /**
     * @param {number} lat Latitude.
     * @param {number} minLon Minimal longitude.
     * @param {number} maxLon Maximal longitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} The parallel line string.
     * @param {number} index Index.
     * @private
     */
  }, {
    key: "getParallel_",
    value: function getParallel_(lat, minLon, maxLon, squaredTolerance, index) {
      var flatCoordinates = (0, _geodesic.parallel)(lat, minLon, maxLon, this.projection_, squaredTolerance);
      var lineString = this.parallels_[index];
      if (!lineString) {
        lineString = new _LineString.default(flatCoordinates, 'XY');
      } else {
        lineString.setFlatCoordinates('XY', flatCoordinates);
        lineString.changed();
      }
      return lineString;
    }

    /**
     * @param {LineString} lineString Parallels.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {Point} Parallel point.
     * @private
     */
  }, {
    key: "getParallelPoint_",
    value: function getParallelPoint_(lineString, extent, index) {
      var flatCoordinates = lineString.getFlatCoordinates();
      var left = 0;
      var right = flatCoordinates.length - 2;
      if (flatCoordinates[left] > flatCoordinates[right]) {
        left = right;
        right = 0;
      }
      var clampedLeft = Math.max(extent[0], flatCoordinates[left]);
      var clampedRight = Math.min(extent[2], flatCoordinates[right]);
      var lon = (0, _math.clamp)(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);
      var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);
      var coordinate = [lon, coordinate1];
      var point = this.parallelsLabels_[index].geom;
      point.setCoordinates(coordinate);
      return point;
    }

    /**
     * Get the list of parallels.  Parallels are lines of equal latitude.
     * @return {Array<LineString>} The parallels.
     * @api
     */
  }, {
    key: "getParallels",
    value: function getParallels() {
      return this.parallels_;
    }

    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @private
     */
  }, {
    key: "updateProjectionInfo_",
    value: function updateProjectionInfo_(projection) {
      var epsg4326Projection = (0, _proj.get)('EPSG:4326');
      var worldExtent = projection.getWorldExtent();
      this.maxLat_ = worldExtent[3];
      this.maxLon_ = worldExtent[2];
      this.minLat_ = worldExtent[1];
      this.minLon_ = worldExtent[0];

      // If the world extent crosses the dateline define a custom transform to
      // return longitudes which wrap the dateline

      var toLonLatTransform = (0, _proj.getTransform)(projection, epsg4326Projection);
      if (this.minLon_ < this.maxLon_) {
        this.toLonLatTransform_ = toLonLatTransform;
      } else {
        var split = this.minLon_ + this.maxLon_ / 2;
        this.maxLon_ += 360;
        this.toLonLatTransform_ = function (coordinates, output, dimension) {
          dimension = dimension || 2;
          var lonLatCoordinates = toLonLatTransform(coordinates, output, dimension);
          for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {
            if (lonLatCoordinates[i] < split) {
              lonLatCoordinates[i] += 360;
            }
          }
          return lonLatCoordinates;
        };
      }

      // Transform the extent to get the limits of the view projection extent
      // which should be available to the graticule

      this.fromLonLatTransform_ = (0, _proj.getTransform)(epsg4326Projection, projection);
      var worldExtentP = (0, _extent.applyTransform)([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);
      this.minX_ = worldExtentP[0];
      this.maxX_ = worldExtentP[2];
      this.minY_ = worldExtentP[1];
      this.maxY_ = worldExtentP[3];

      // Determine the view projection coordinates of the extremities of the world extent
      // as these may lie inside a view extent (for example the pole in a polar projection)

      this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);
      this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);
      this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);
      this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);

      // Transform the projection center to lon lat
      // Some projections may have a void area at the poles
      // so replace any NaN latitudes with the min or max value closest to a pole

      this.projectionCenterLonLat_ = this.toLonLatTransform_((0, _extent.getCenter)(projection.getExtent()));
      if (isNaN(this.projectionCenterLonLat_[1])) {
        this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
      }
      this.projection_ = projection;
    }
  }]);
  return Graticule;
}(_Vector.default);
var _default = exports.default = Graticule;
},{"../Collection.js":"node_modules/ol/Collection.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../style/Fill.js":"node_modules/ol/style/Fill.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../style/Stroke.js":"node_modules/ol/style/Stroke.js","../style/Style.js":"node_modules/ol/style/Style.js","../style/Text.js":"node_modules/ol/style/Text.js","./Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../coordinate.js":"node_modules/ol/coordinate.js","../proj.js":"node_modules/ol/proj.js","../render.js":"node_modules/ol/render.js","../geom/flat/geodesic.js":"node_modules/ol/geom/flat/geodesic.js"}],"node_modules/ol/layer/Group.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GroupEvent = void 0;
var _Base = _interopRequireDefault(require("./Base.js"));
var _Collection = _interopRequireDefault(require("../Collection.js"));
var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));
var _asserts = require("../asserts.js");
var _obj = require("../obj.js");
var _extent = require("../extent.js");
var _util = require("../util.js");
var _events = require("../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Group
 */
/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */
/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */
var GroupEvent = exports.GroupEvent = /*#__PURE__*/function (_Event) {
  _inherits(GroupEvent, _Event);
  var _super = _createSuper(GroupEvent);
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  function GroupEvent(type, layer) {
    var _this;
    _classCallCheck(this, GroupEvent);
    _this = _super.call(this, type);

    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */
    _this.layer = layer;
    return _this;
  }
  return _createClass(GroupEvent);
}(_Event2.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};

/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var LayerGroup = /*#__PURE__*/function (_BaseLayer) {
  _inherits(LayerGroup, _BaseLayer);
  var _super2 = _createSuper(LayerGroup);
  /**
   * @param {Options} [options] Layer options.
   */
  function LayerGroup(options) {
    var _this2;
    _classCallCheck(this, LayerGroup);
    options = options || {};
    var baseOptions = /** @type {Options} */Object.assign({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this2 = _super2.call(this, baseOptions);

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {GroupOnSignature<void>}
     */
    _this2.un;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    _this2.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    _this2.listenerKeys_ = {};
    _this2.addChangeListener(Property.LAYERS, _this2.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection.default(layers.slice(), {
          unique: true
        });
      } else {
        (0, _asserts.assert)(typeof ( /** @type {?} */layers.getArray) === 'function', 'Expected `layers` to be an array or a `Collection`');
      }
    } else {
      layers = new _Collection.default(undefined, {
        unique: true
      });
    }
    _this2.setLayers(layers);
    return _this2;
  }

  /**
   * @private
   */
  _createClass(LayerGroup, [{
    key: "handleLayerChange_",
    value: function handleLayerChange_() {
      this.changed();
    }

    /**
     * @private
     */
  }, {
    key: "handleLayersChanged_",
    value: function handleLayersChanged_() {
      this.layersListenerKeys_.forEach(_events.unlistenByKey);
      this.layersListenerKeys_.length = 0;
      var layers = this.getLayers();
      this.layersListenerKeys_.push((0, _events.listen)(layers, _CollectionEventType.default.ADD, this.handleLayersAdd_, this), (0, _events.listen)(layers, _CollectionEventType.default.REMOVE, this.handleLayersRemove_, this));
      for (var id in this.listenerKeys_) {
        this.listenerKeys_[id].forEach(_events.unlistenByKey);
      }
      (0, _obj.clear)(this.listenerKeys_);
      var layersArray = layers.getArray();
      for (var i = 0, ii = layersArray.length; i < ii; i++) {
        var layer = layersArray[i];
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
      }
      this.changed();
    }

    /**
     * @param {BaseLayer} layer The layer.
     */
  }, {
    key: "registerLayerListeners_",
    value: function registerLayerListeners_(layer) {
      var listenerKeys = [(0, _events.listen)(layer, _ObjectEventType.default.PROPERTYCHANGE, this.handleLayerChange_, this), (0, _events.listen)(layer, _EventType.default.CHANGE, this.handleLayerChange_, this)];
      if (layer instanceof LayerGroup) {
        listenerKeys.push((0, _events.listen)(layer, 'addlayer', this.handleLayerGroupAdd_, this), (0, _events.listen)(layer, 'removelayer', this.handleLayerGroupRemove_, this));
      }
      this.listenerKeys_[(0, _util.getUid)(layer)] = listenerKeys;
    }

    /**
     * @param {GroupEvent} event The layer group event.
     */
  }, {
    key: "handleLayerGroupAdd_",
    value: function handleLayerGroupAdd_(event) {
      this.dispatchEvent(new GroupEvent('addlayer', event.layer));
    }

    /**
     * @param {GroupEvent} event The layer group event.
     */
  }, {
    key: "handleLayerGroupRemove_",
    value: function handleLayerGroupRemove_(event) {
      this.dispatchEvent(new GroupEvent('removelayer', event.layer));
    }

    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
  }, {
    key: "handleLayersAdd_",
    value: function handleLayersAdd_(collectionEvent) {
      var layer = collectionEvent.element;
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent('addlayer', layer));
      this.changed();
    }

    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
  }, {
    key: "handleLayersRemove_",
    value: function handleLayersRemove_(collectionEvent) {
      var layer = collectionEvent.element;
      var key = (0, _util.getUid)(layer);
      this.listenerKeys_[key].forEach(_events.unlistenByKey);
      delete this.listenerKeys_[key];
      this.dispatchEvent(new GroupEvent('removelayer', layer));
      this.changed();
    }

    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
  }, {
    key: "getLayers",
    value: function getLayers() {
      return /** @type {!Collection<import("./Base.js").default>} */(
        this.get(Property.LAYERS)
      );
    }

    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
  }, {
    key: "setLayers",
    value: function setLayers(layers) {
      var collection = this.getLayers();
      if (collection) {
        var currentLayers = collection.getArray();
        for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
          this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
        }
      }
      this.set(Property.LAYERS, layers);
    }

    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
  }, {
    key: "getLayersArray",
    value: function getLayersArray(array) {
      array = array !== undefined ? array : [];
      this.getLayers().forEach(function (layer) {
        layer.getLayersArray(array);
      });
      return array;
    }

    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(dest) {
      var states = dest !== undefined ? dest : [];
      var pos = states.length;
      this.getLayers().forEach(function (layer) {
        layer.getLayerStatesArray(states);
      });
      var ownLayerState = this.getLayerState();
      var defaultZIndex = ownLayerState.zIndex;
      if (!dest && ownLayerState.zIndex === undefined) {
        defaultZIndex = 0;
      }
      for (var i = pos, ii = states.length; i < ii; i++) {
        var layerState = states[i];
        layerState.opacity *= ownLayerState.opacity;
        layerState.visible = layerState.visible && ownLayerState.visible;
        layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
        layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
        layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
        layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
        if (ownLayerState.extent !== undefined) {
          if (layerState.extent !== undefined) {
            layerState.extent = (0, _extent.getIntersection)(layerState.extent, ownLayerState.extent);
          } else {
            layerState.extent = ownLayerState.extent;
          }
        }
        if (layerState.zIndex === undefined) {
          layerState.zIndex = defaultZIndex;
        }
      }
      return states;
    }

    /**
     * @return {import("../source/Source.js").State} Source state.
     */
  }, {
    key: "getSourceState",
    value: function getSourceState() {
      return 'ready';
    }
  }]);
  return LayerGroup;
}(_Base.default);
var _default = exports.default = LayerGroup;
},{"./Base.js":"node_modules/ol/layer/Base.js","../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/webgl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNSIGNED_SHORT = exports.UNSIGNED_INT = exports.UNSIGNED_BYTE = exports.STREAM_DRAW = exports.STATIC_DRAW = exports.FLOAT = exports.ELEMENT_ARRAY_BUFFER = exports.DYNAMIC_DRAW = exports.ARRAY_BUFFER = void 0;
exports.getContext = getContext;
exports.getSupportedExtensions = getSupportedExtensions;
var _has = require("./has.js");
/**
 * @module ol/webgl
 */

/**
 * Constants taken from goog.webgl
 */

/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
 * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
 * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).
 * @const
 * @type {number}
 * @api
 */
var ARRAY_BUFFER = exports.ARRAY_BUFFER = 0x8892;

/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.
 * Index buffers are essentially lists of references to vertices defined in a vertex buffer
 * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
 * @const
 * @type {number}
 * @api
 */
var ELEMENT_ARRAY_BUFFER = exports.ELEMENT_ARRAY_BUFFER = 0x8893;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
var STREAM_DRAW = exports.STREAM_DRAW = 0x88e0;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
var STATIC_DRAW = exports.STATIC_DRAW = 0x88e4;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
var DYNAMIC_DRAW = exports.DYNAMIC_DRAW = 0x88e8;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = exports.UNSIGNED_BYTE = 0x1401;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = exports.UNSIGNED_SHORT = 0x1403;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = exports.UNSIGNED_INT = 0x1405;

/**
 * @const
 * @type {number}
 */
var FLOAT = exports.FLOAT = 0x1406;

/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array<string>}
 */
var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [attributes] Attributes.
 * @return {WebGLRenderingContext|null} WebGL rendering context.
 */
function getContext(canvas, attributes) {
  attributes = Object.assign({
    preserveDrawingBuffer: true,
    antialias: _has.SAFARI_BUG_237906 ? false : true // https://bugs.webkit.org/show_bug.cgi?id=237906
  }, attributes);
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */context;
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}

/**
 * @type {Array<string>|null}
 */
var supportedExtensions = null;

/**
 * @return {Array<string>|null} List of supported WebGL extensions.
 */
function getSupportedExtensions() {
  if (!supportedExtensions) {
    var canvas = document.createElement('canvas');
    var gl = getContext(canvas);
    if (gl) {
      supportedExtensions = gl.getSupportedExtensions();
    }
  }
  return supportedExtensions;
}
},{"./has.js":"node_modules/ol/has.js"}],"node_modules/ol/webgl/Buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BufferUsage = void 0;
exports.getArrayClassForType = getArrayClassForType;
var _webgl = require("../webgl.js");
var _asserts = require("../asserts.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/webgl/Buffer
 */
/**
 * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`
 * or `DYNAMIC_DRAW`.
 * @enum {number}
 */
var BufferUsage = exports.BufferUsage = {
  STATIC_DRAW: _webgl.STATIC_DRAW,
  STREAM_DRAW: _webgl.STREAM_DRAW,
  DYNAMIC_DRAW: _webgl.DYNAMIC_DRAW
};

/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 */
var WebGLArrayBuffer = /*#__PURE__*/function () {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  function WebGLArrayBuffer(type, usage) {
    _classCallCheck(this, WebGLArrayBuffer);
    /**
     * @private
     * @type {Float32Array|Uint32Array|null}
     */
    this.array_ = null;

    /**
     * @private
     * @type {number}
     */
    this.type_ = type;
    (0, _asserts.assert)(type === _webgl.ARRAY_BUFFER || type === _webgl.ELEMENT_ARRAY_BUFFER, 'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`');

    /**
     * @private
     * @type {number}
     */
    this.usage_ = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;
  }

  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  _createClass(WebGLArrayBuffer, [{
    key: "ofSize",
    value: function ofSize(size) {
      this.array_ = new (getArrayClassForType(this.type_))(size);
      return this;
    }

    /**
     * Populates the buffer with an array of the given size.
     * @param {Array<number>} array Numerical array
     * @return {WebGLArrayBuffer} This
     */
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      this.array_ = getArrayClassForType(this.type_).from(array);
      return this;
    }

    /**
     * Populates the buffer with a raw binary array buffer.
     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
     * initialized for the same typed array class.
     * @return {WebGLArrayBuffer} This
     */
  }, {
    key: "fromArrayBuffer",
    value: function fromArrayBuffer(buffer) {
      this.array_ = new (getArrayClassForType(this.type_))(buffer);
      return this;
    }

    /**
     * @return {number} Buffer type.
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.type_;
    }

    /**
     * Will return null if the buffer was not initialized
     * @return {Float32Array|Uint32Array|null} Array.
     */
  }, {
    key: "getArray",
    value: function getArray() {
      return this.array_;
    }

    /**
     * @return {number} Usage.
     */
  }, {
    key: "getUsage",
    value: function getUsage() {
      return this.usage_;
    }

    /**
     * Will return 0 if the buffer is not initialized
     * @return {number} Array size
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return this.array_ ? this.array_.length : 0;
    }
  }]);
  return WebGLArrayBuffer;
}();
/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */
function getArrayClassForType(type) {
  switch (type) {
    case _webgl.ARRAY_BUFFER:
      return Float32Array;
    case _webgl.ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
var _default = exports.default = WebGLArrayBuffer;
},{"../webgl.js":"node_modules/ol/webgl.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/webgl/ContextEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/webgl/ContextEventType
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};
},{}],"node_modules/ol/webgl/PostProcessingPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = require("../util.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/webgl/PostProcessingPass
 */
var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";

/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {WebGLUniformLocation} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *   uniform float u_opacity;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
 *   }
 *   ```
 */
var WebGLPostProcessingPass = /*#__PURE__*/function () {
  /**
   * @param {Options} options Options.
   */
  function WebGLPostProcessingPass(options) {
    var _this = this;
    _classCallCheck(this, WebGLPostProcessingPass);
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer();
    this.depthBuffer_ = gl.createRenderbuffer();

    // compile the program for the frame buffer
    // TODO: make compilation errors show up
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);

    // bind the vertices buffer for the frame buffer
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');

    /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function (name) {
      _this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(_this.renderTargetProgram_, name)
      });
    });
  }

  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  _createClass(WebGLPostProcessingPass, [{
    key: "getGL",
    value: function getGL() {
      return this.gl_;
    }

    /**
     * Initialize the render target texture of the post process, make sure it is at the
     * right size and bind it as a render target for the next draw calls.
     * The last step to be initialized will be the one where the primitives are rendered.
     * @param {import("../Map.js").FrameState} frameState current frame state
     */
  }, {
    key: "init",
    value: function init(frameState) {
      var gl = this.getGL();
      var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_];

      // rendering goes to my buffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());
      gl.viewport(0, 0, textureSize[0], textureSize[1]);

      // if size has changed: adjust canvas & render target texture
      if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
        this.renderTargetTextureSize_ = textureSize;

        // create a new texture
        var level = 0;
        var internalFormat = gl.RGBA;
        var border = 0;
        var format = gl.RGBA;
        var type = gl.UNSIGNED_BYTE;
        var data = null;
        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // bind the texture to the framebuffer
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureSize[0], textureSize[1]);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer_);
      }
    }

    /**
     * Render to the next postprocessing pass (or to the canvas if final pass).
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
  }, {
    key: "apply",
    value: function apply(frameState, nextPass, preCompose, postCompose) {
      var gl = this.getGL();
      var size = frameState.size;
      gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      if (!nextPass) {
        // clear the canvas if we are the first to render to it
        // and preserveDrawingBuffer is true
        var canvasId = (0, _util.getUid)(gl.canvas);
        if (!frameState.renderTargets[canvasId]) {
          var attributes = gl.getContextAttributes();
          if (attributes && attributes.preserveDrawingBuffer) {
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clearDepth(1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          }
          frameState.renderTargets[canvasId] = true;
        }
      }
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
      gl.useProgram(this.renderTargetProgram_);
      gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
      gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
      gl.uniform1i(this.renderTargetTextureLocation_, 0);
      var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
      gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
      this.applyUniforms(frameState);
      if (preCompose) {
        preCompose(gl, frameState);
      }
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      if (postCompose) {
        postCompose(gl, frameState);
      }
    }

    /**
     * @return {WebGLFramebuffer} Frame buffer
     */
  }, {
    key: "getFrameBuffer",
    value: function getFrameBuffer() {
      return this.frameBuffer_;
    }

    /**
     * @return {WebGLRenderbuffer} Depth buffer
     */
  }, {
    key: "getDepthBuffer",
    value: function getDepthBuffer() {
      return this.depthBuffer_;
    }

    /**
     * Sets the custom uniforms based on what was given in the constructor.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @private
     */
  }, {
    key: "applyUniforms",
    value: function applyUniforms(frameState) {
      var gl = this.getGL();
      var value;
      var textureSlot = 1;
      this.uniforms_.forEach(function (uniform) {
        value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;

        // apply value based on type
        if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
          // create a texture & put data
          if (!uniform.texture) {
            uniform.texture = gl.createTexture();
          }
          gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
          gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          if (value instanceof ImageData) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
          }

          // fill texture slots
          gl.uniform1i(uniform.location, textureSlot++);
        } else if (Array.isArray(value)) {
          switch (value.length) {
            case 2:
              gl.uniform2f(uniform.location, value[0], value[1]);
              return;
            case 3:
              gl.uniform3f(uniform.location, value[0], value[1], value[2]);
              return;
            case 4:
              gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
              return;
            default:
              return;
          }
        } else if (typeof value === 'number') {
          gl.uniform1f(uniform.location, value);
        }
      });
    }
  }]);
  return WebGLPostProcessingPass;
}();
var _default = exports.default = WebGLPostProcessingPass;
},{"../util.js":"node_modules/ol/util.js"}],"node_modules/ol/vec/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromTransform = fromTransform;
/**
 * @module ol/vec/mat4
 */

/**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */
function create() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */
function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}
},{}],"node_modules/ol/webgl/Helper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShaderType = exports.DefaultUniform = exports.AttributeType = void 0;
exports.computeAttributesStride = computeAttributesStride;
exports.default = void 0;
var _ContextEventType = _interopRequireDefault(require("../webgl/ContextEventType.js"));
var _Disposable2 = _interopRequireDefault(require("../Disposable.js"));
var _PostProcessingPass = _interopRequireDefault(require("./PostProcessingPass.js"));
var _webgl = require("../webgl.js");
var _obj = require("../obj.js");
var _transform = require("../transform.js");
var _mat = require("../vec/mat4.js");
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/webgl/Helper
 */
/**
 * @typedef {Object} BufferCacheEntry
 * @property {import("./Buffer.js").default} buffer Buffer.
 * @property {WebGLBuffer} webGlBuffer WebGlBuffer.
 */

/**
 * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.
 * @enum {number}
 */
var ShaderType = exports.ShaderType = {
  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31
};

/**
 * Names of uniforms made available to all shaders.
 * Please note: changing these *will* break custom shaders!
 * @enum {string}
 */
var DefaultUniform = exports.DefaultUniform = {
  PROJECTION_MATRIX: 'u_projectionMatrix',
  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',
  TIME: 'u_time',
  ZOOM: 'u_zoom',
  RESOLUTION: 'u_resolution',
  ROTATION: 'u_rotation',
  VIEWPORT_SIZE_PX: 'u_viewportSizePx',
  PIXEL_RATIO: 'u_pixelRatio',
  HIT_DETECTION: 'u_hitDetection'
};

/**
 * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`
 * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.
 * @enum {number}
 */
var AttributeType = exports.AttributeType = {
  UNSIGNED_BYTE: _webgl.UNSIGNED_BYTE,
  UNSIGNED_SHORT: _webgl.UNSIGNED_SHORT,
  UNSIGNED_INT: _webgl.UNSIGNED_INT,
  FLOAT: _webgl.FLOAT
};

/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */

/**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */

/**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../Map.js").FrameState):UniformLiteralValue} UniformValue
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 * @property {string} [canvasCacheKey] The cache key for the canvas.
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue} [value] Value
 * @property {UniformValue} [prevValue] The previous value.
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @typedef {Object} CanvasCacheItem
 * @property {WebGLRenderingContext} context The context of this canvas.
 * @property {number} users The count of users of this canvas.
 */

/**
 * @type {Object<string,CanvasCacheItem>}
 */
var canvasCache = {};

/**
 * @param {string} key The cache key for the canvas.
 * @return {string} The shared cache key.
 */
function getSharedCanvasCacheKey(key) {
  return 'shared/' + key;
}
var uniqueCanvasCacheKeyCount = 0;

/**
 * @return {string} The unique cache key.
 */
function getUniqueCanvasCacheKey() {
  var key = 'unique/' + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}

/**
 * @param {string} key The cache key for the canvas.
 * @return {WebGLRenderingContext} The canvas.
 */
function getOrCreateContext(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    canvas.style.position = 'absolute';
    canvas.style.left = '0';
    var context = (0, _webgl.getContext)(canvas);
    cacheItem = {
      users: 0,
      context: context
    };
    canvasCache[key] = cacheItem;
  }
  cacheItem.users += 1;
  return cacheItem.context;
}

/**
 * @param {string} key The cache key for the canvas.
 */
function releaseCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }
  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }
  var gl = cacheItem.context;
  var extension = gl.getExtension('WEBGL_lose_context');
  if (extension) {
    extension.loseContext();
  }
  var canvas = gl.canvas;
  canvas.width = 1;
  canvas.height = 1;
  delete canvasCache[key];
}

/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls; note how a frameState is required to set up a program,
 *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program, frameState);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Specify the attribute names with
 *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 */
var WebGLHelper = /*#__PURE__*/function (_Disposable) {
  _inherits(WebGLHelper, _Disposable);
  var _super = _createSuper(WebGLHelper);
  /**
   * @param {Options} [options] Options.
   */
  function WebGLHelper(options) {
    var _this;
    _classCallCheck(this, WebGLHelper);
    _this = _super.call(this);
    options = options || {};

    /** @private */
    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_assertThisInitialized(_this));

    /** @private */
    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_assertThisInitialized(_this));

    /**
     * @private
     * @type {string}
     */
    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();

    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    _this.gl_ = getOrCreateContext(_this.canvasCacheKey_);

    /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */
    _this.bufferCache_ = {};

    /**
     * @private
     * @type {Object<string, Object>}
     */
    _this.extensionCache_ = {};

    /**
     * @private
     * @type {WebGLProgram}
     */
    _this.currentProgram_ = null;

    /**
     * @private
     * @type boolean
     */
    _this.needsToBeRecreated_ = false;
    var canvas = _this.gl_.canvas;
    canvas.addEventListener(_ContextEventType.default.LOST, _this.boundHandleWebGLContextLost_);
    canvas.addEventListener(_ContextEventType.default.RESTORED, _this.boundHandleWebGLContextRestored_);

    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    _this.offsetRotateMatrix_ = (0, _transform.create)();

    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    _this.offsetScaleMatrix_ = (0, _transform.create)();

    /**
     * @private
     * @type {Array<number>}
     */
    _this.tmpMat4_ = (0, _mat.create)();

    /**
     * @private
     * @type {Object<string, Object<string, WebGLUniformLocation>>}
     */
    _this.uniformLocationsByProgram_ = {};

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    _this.attribLocationsByProgram_ = {};

    /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    _this.uniforms_ = [];
    if (options.uniforms) {
      _this.setUniforms(options.uniforms);
    }

    /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */
    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {
      return new _PostProcessingPass.default({
        webGlContext: _this.gl_,
        scaleRatio: options.scaleRatio,
        vertexShader: options.vertexShader,
        fragmentShader: options.fragmentShader,
        uniforms: options.uniforms
      });
    }) : [new _PostProcessingPass.default({
      webGlContext: _this.gl_
    })];

    /**
     * @type {string|null}
     * @private
     */
    _this.shaderCompileErrors_ = null;

    /**
     * @type {number}
     * @private
     */
    _this.startTime_ = Date.now();
    return _this;
  }

  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  _createClass(WebGLHelper, [{
    key: "setUniforms",
    value: function setUniforms(uniforms) {
      this.uniforms_ = [];
      this.addUniforms(uniforms);
    }

    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */
  }, {
    key: "addUniforms",
    value: function addUniforms(uniforms) {
      for (var name in uniforms) {
        this.uniforms_.push({
          name: name,
          value: uniforms[name]
        });
      }
    }

    /**
     * @param {string} canvasCacheKey The canvas cache key.
     * @return {boolean} The provided key matches the one this helper was constructed with.
     */
  }, {
    key: "canvasCacheKeyMatches",
    value: function canvasCacheKeyMatches(canvasCacheKey) {
      return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
    }

    /**
     * Get a WebGL extension.  If the extension is not supported, null is returned.
     * Extensions are cached after they are enabled for the first time.
     * @param {string} name The extension name.
     * @return {Object|null} The extension or null if not supported.
     */
  }, {
    key: "getExtension",
    value: function getExtension(name) {
      if (name in this.extensionCache_) {
        return this.extensionCache_[name];
      }
      var extension = this.gl_.getExtension(name);
      this.extensionCache_[name] = extension;
      return extension;
    }

    /**
     * Just bind the buffer if it's in the cache. Otherwise create
     * the WebGL buffer, bind it, populate it, and add an entry to
     * the cache.
     * @param {import("./Buffer").default} buffer Buffer.
     */
  }, {
    key: "bindBuffer",
    value: function bindBuffer(buffer) {
      var gl = this.gl_;
      var bufferKey = (0, _util.getUid)(buffer);
      var bufferCache = this.bufferCache_[bufferKey];
      if (!bufferCache) {
        var webGlBuffer = gl.createBuffer();
        bufferCache = {
          buffer: buffer,
          webGlBuffer: webGlBuffer
        };
        this.bufferCache_[bufferKey] = bufferCache;
      }
      gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
    }

    /**
     * Update the data contained in the buffer array; this is required for the
     * new data to be rendered
     * @param {import("./Buffer").default} buffer Buffer.
     */
  }, {
    key: "flushBufferData",
    value: function flushBufferData(buffer) {
      var gl = this.gl_;
      this.bindBuffer(buffer);
      gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
    }

    /**
     * @param {import("./Buffer.js").default} buf Buffer.
     */
  }, {
    key: "deleteBuffer",
    value: function deleteBuffer(buf) {
      var gl = this.gl_;
      var bufferKey = (0, _util.getUid)(buf);
      var bufferCacheEntry = this.bufferCache_[bufferKey];
      if (bufferCacheEntry && !gl.isContextLost()) {
        gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
      }
      delete this.bufferCache_[bufferKey];
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      var canvas = this.gl_.canvas;
      canvas.removeEventListener(_ContextEventType.default.LOST, this.boundHandleWebGLContextLost_);
      canvas.removeEventListener(_ContextEventType.default.RESTORED, this.boundHandleWebGLContextRestored_);
      releaseCanvas(this.canvasCacheKey_);
      delete this.gl_;
    }

    /**
     * Clear the buffer & set the viewport to draw.
     * Post process passes will be initialized here, the first one being bound as a render target for
     * subsequent draw calls.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
  }, {
    key: "prepareDraw",
    value: function prepareDraw(frameState, disableAlphaBlend, enableDepth) {
      var gl = this.gl_;
      var canvas = this.getCanvas();
      var size = frameState.size;
      var pixelRatio = frameState.pixelRatio;
      if (canvas.width !== size[0] * pixelRatio || canvas.height !== size[1] * pixelRatio) {
        canvas.width = size[0] * pixelRatio;
        canvas.height = size[1] * pixelRatio;
        canvas.style.width = size[0] + 'px';
        canvas.style.height = size[1] + 'px';
      }

      // loop backwards in post processes list
      for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
        this.postProcessPasses_[i].init(frameState);
      }
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.depthRange(0.0, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
      if (enableDepth) {
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
    }

    /**
     * Prepare a program to use a texture.
     * @param {WebGLTexture} texture The texture.
     * @param {number} slot The texture slot.
     * @param {string} uniformName The corresponding uniform name.
     */
  }, {
    key: "bindTexture",
    value: function bindTexture(texture, slot, uniformName) {
      var gl = this.gl_;
      gl.activeTexture(gl.TEXTURE0 + slot);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(this.getUniformLocation(uniformName), slot);
    }

    /**
     * Clear the render target & bind it for future draw operations.
     * This is similar to `prepareDraw`, only post processes will not be applied.
     * Note: the whole viewport will be drawn to the render target, regardless of its size.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
  }, {
    key: "prepareDrawToRenderTarget",
    value: function prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend, enableDepth) {
      var gl = this.gl_;
      var size = renderTarget.getSize();
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());
      gl.viewport(0, 0, size[0], size[1]);
      gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.depthRange(0.0, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
      if (enableDepth) {
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
    }

    /**
     * Execute a draw call based on the currently bound program, texture, buffers, attributes.
     * @param {number} start Start index.
     * @param {number} end End index.
     */
  }, {
    key: "drawElements",
    value: function drawElements(start, end) {
      var gl = this.gl_;
      this.getExtension('OES_element_index_uint');
      var elementType = gl.UNSIGNED_INT;
      var elementSize = 4;
      var numItems = end - start;
      var offsetInBytes = start * elementSize;
      gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
    }

    /**
     * Apply the successive post process passes which will eventually render to the actual canvas.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
  }, {
    key: "finalizeDraw",
    value: function finalizeDraw(frameState, preCompose, postCompose) {
      // apply post processes using the next one as target
      for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
        if (i === ii - 1) {
          this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
        } else {
          this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
        }
      }
    }

    /**
     * @return {HTMLCanvasElement} Canvas.
     */
  }, {
    key: "getCanvas",
    value: function getCanvas() {
      return /** @type {HTMLCanvasElement} */this.gl_.canvas;
    }

    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     */
  }, {
    key: "getGL",
    value: function getGL() {
      return this.gl_;
    }

    /**
     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "applyFrameState",
    value: function applyFrameState(frameState) {
      var size = frameState.size;
      var rotation = frameState.viewState.rotation;
      var pixelRatio = frameState.pixelRatio;
      this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
      this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
      this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);
      this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [size[0], size[1]]);
      this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);
    }

    /**
     * Sets the `u_hitDetection` uniform.
     * @param {boolean} enabled Whether to enable the hit detection code path
     */
  }, {
    key: "applyHitDetectionUniform",
    value: function applyHitDetectionUniform(enabled) {
      var loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);
      this.getGL().uniform1i(loc, enabled ? 1 : 0);

      // hit detection uses a fixed pixel ratio
      if (enabled) {
        this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);
      }
    }

    /**
     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "applyUniforms",
    value: function applyUniforms(frameState) {
      var _this2 = this;
      var gl = this.gl_;
      var value;
      var textureSlot = 0;
      this.uniforms_.forEach(function (uniform) {
        value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;

        // apply value based on type
        if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
          // create a texture & put data
          if (!uniform.texture) {
            uniform.prevValue = undefined;
            uniform.texture = gl.createTexture();
          }
          _this2.bindTexture(uniform.texture, textureSlot, uniform.name);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          var imageReady = !(value instanceof HTMLImageElement) || /** @type {HTMLImageElement} */value.complete;
          if (imageReady && uniform.prevValue !== value) {
            uniform.prevValue = value;
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
          }
          textureSlot++;
        } else if (Array.isArray(value) && value.length === 6) {
          _this2.setUniformMatrixValue(uniform.name, (0, _mat.fromTransform)(_this2.tmpMat4_, value));
        } else if (Array.isArray(value) && value.length <= 4) {
          switch (value.length) {
            case 2:
              gl.uniform2f(_this2.getUniformLocation(uniform.name), value[0], value[1]);
              return;
            case 3:
              gl.uniform3f(_this2.getUniformLocation(uniform.name), value[0], value[1], value[2]);
              return;
            case 4:
              gl.uniform4f(_this2.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
              return;
            default:
              return;
          }
        } else if (typeof value === 'number') {
          gl.uniform1f(_this2.getUniformLocation(uniform.name), value);
        }
      });
    }

    /**
     * Set up a program for use. The program will be set as the current one. Then, the uniforms used
     * in the program will be set based on the current frame state and the helper configuration.
     * @param {WebGLProgram} program Program.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "useProgram",
    value: function useProgram(program, frameState) {
      var gl = this.gl_;
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.applyFrameState(frameState);
      this.applyUniforms(frameState);
    }

    /**
     * Will attempt to compile a vertex or fragment shader based on source
     * On error, the shader will be returned but
     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
     * Use `gl.getShaderInfoLog(shader)` to have details
     * @param {string} source Shader source
     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
     * @return {WebGLShader} Shader object
     */
  }, {
    key: "compileShader",
    value: function compileShader(source, type) {
      var gl = this.gl_;
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    /**
     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
     * @param {string} fragmentShaderSource Fragment shader source.
     * @param {string} vertexShaderSource Vertex shader source.
     * @return {WebGLProgram} Program
     */
  }, {
    key: "getProgram",
    value: function getProgram(fragmentShaderSource, vertexShaderSource) {
      var gl = this.gl_;
      var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      var program = gl.createProgram();
      gl.attachShader(program, fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.linkProgram(program);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var message = "Fragment shader compilation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
        throw new Error(message);
      }
      gl.deleteShader(fragmentShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var _message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));
        throw new Error(_message);
      }
      gl.deleteShader(vertexShader);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var _message2 = "GL program linking failed: ".concat(gl.getProgramInfoLog(program));
        throw new Error(_message2);
      }
      return program;
    }

    /**
     * Will get the location from the shader or the cache
     * @param {string} name Uniform name
     * @return {WebGLUniformLocation} uniformLocation
     */
  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(name) {
      var programUid = (0, _util.getUid)(this.currentProgram_);
      if (this.uniformLocationsByProgram_[programUid] === undefined) {
        this.uniformLocationsByProgram_[programUid] = {};
      }
      if (this.uniformLocationsByProgram_[programUid][name] === undefined) {
        this.uniformLocationsByProgram_[programUid][name] = this.gl_.getUniformLocation(this.currentProgram_, name);
      }
      return this.uniformLocationsByProgram_[programUid][name];
    }

    /**
     * Will get the location from the shader or the cache
     * @param {string} name Attribute name
     * @return {number} attribLocation
     */
  }, {
    key: "getAttributeLocation",
    value: function getAttributeLocation(name) {
      var programUid = (0, _util.getUid)(this.currentProgram_);
      if (this.attribLocationsByProgram_[programUid] === undefined) {
        this.attribLocationsByProgram_[programUid] = {};
      }
      if (this.attribLocationsByProgram_[programUid][name] === undefined) {
        this.attribLocationsByProgram_[programUid][name] = this.gl_.getAttribLocation(this.currentProgram_, name);
      }
      return this.attribLocationsByProgram_[programUid][name];
    }

    /**
     * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
     * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../transform").Transform} transform Transform to update.
     * @return {import("../transform").Transform} The updated transform object.
     */
  }, {
    key: "makeProjectionTransform",
    value: function makeProjectionTransform(frameState, transform) {
      var size = frameState.size;
      var rotation = frameState.viewState.rotation;
      var resolution = frameState.viewState.resolution;
      var center = frameState.viewState.center;
      (0, _transform.compose)(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
      return transform;
    }

    /**
     * Give a value for a standard float uniform
     * @param {string} uniform Uniform name
     * @param {number} value Value
     */
  }, {
    key: "setUniformFloatValue",
    value: function setUniformFloatValue(uniform, value) {
      this.gl_.uniform1f(this.getUniformLocation(uniform), value);
    }

    /**
     * Give a value for a vec2 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
  }, {
    key: "setUniformFloatVec2",
    value: function setUniformFloatVec2(uniform, value) {
      this.gl_.uniform2fv(this.getUniformLocation(uniform), value);
    }

    /**
     * Give a value for a vec4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
  }, {
    key: "setUniformFloatVec4",
    value: function setUniformFloatVec4(uniform, value) {
      this.gl_.uniform4fv(this.getUniformLocation(uniform), value);
    }

    /**
     * Give a value for a standard matrix4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Matrix value
     */
  }, {
    key: "setUniformMatrixValue",
    value: function setUniformMatrixValue(uniform, value) {
      this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
    }

    /**
     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
     * internally.
     * @param {string} attribName Attribute name
     * @param {number} size Number of components per attributes
     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
     * @param {number} stride Stride in bytes (0 means attribs are packed)
     * @param {number} offset Offset in bytes
     * @private
     */
  }, {
    key: "enableAttributeArray_",
    value: function enableAttributeArray_(attribName, size, type, stride, offset) {
      var location = this.getAttributeLocation(attribName);
      // the attribute has not been found in the shaders or is not used; do not enable it
      if (location < 0) {
        return;
      }
      this.gl_.enableVertexAttribArray(location);
      this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);
    }

    /**
     * Will enable the following attributes to be read from the currently bound buffer,
     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
     */
  }, {
    key: "enableAttributes",
    value: function enableAttributes(attributes) {
      var stride = computeAttributesStride(attributes);
      var offset = 0;
      for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i];
        this.enableAttributeArray_(attr.name, attr.size, attr.type || _webgl.FLOAT, stride, offset);
        offset += attr.size * getByteSizeFromType(attr.type);
      }
    }

    /**
     * WebGL context was lost
     * @param {WebGLContextEvent} event The context loss event.
     * @private
     */
  }, {
    key: "handleWebGLContextLost",
    value: function handleWebGLContextLost(event) {
      (0, _obj.clear)(this.bufferCache_);
      this.currentProgram_ = null;
      event.preventDefault();
    }

    /**
     * WebGL context was restored
     * @private
     */
  }, {
    key: "handleWebGLContextRestored",
    value: function handleWebGLContextRestored() {
      this.needsToBeRecreated_ = true;
    }

    /**
     * Returns whether this helper needs to be recreated, as the context was lost and then restored.
     * @return {boolean} Whether this helper needs to be recreated.
     */
  }, {
    key: "needsToBeRecreated",
    value: function needsToBeRecreated() {
      return this.needsToBeRecreated_;
    }

    /**
     * Will create or reuse a given webgl texture and apply the given size. If no image data
     * specified, the texture will be empty, otherwise image data will be used and the `size`
     * parameter will be ignored.
     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
     * @param {Array<number>} size Expected size of the texture
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
     * @param {WebGLTexture} [texture] Existing texture to reuse
     * @return {WebGLTexture} The generated texture
     */
  }, {
    key: "createTexture",
    value: function createTexture(size, data, texture) {
      var gl = this.gl_;
      texture = texture || gl.createTexture();

      // set params & size
      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      gl.bindTexture(gl.TEXTURE_2D, texture);
      if (data) {
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }
  }]);
  return WebGLHelper;
}(_Disposable2.default);
/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
 */
function computeAttributesStride(attributes) {
  var stride = 0;
  for (var i = 0; i < attributes.length; i++) {
    var attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}

/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @return {number} The size in bytes
 */
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
var _default = exports.default = WebGLHelper;
},{"../webgl/ContextEventType.js":"node_modules/ol/webgl/ContextEventType.js","../Disposable.js":"node_modules/ol/Disposable.js","./PostProcessingPass.js":"node_modules/ol/webgl/PostProcessingPass.js","../webgl.js":"node_modules/ol/webgl.js","../obj.js":"node_modules/ol/obj.js","../transform.js":"node_modules/ol/transform.js","../vec/mat4.js":"node_modules/ol/vec/mat4.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/renderer/webgl/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Property = _interopRequireDefault(require("../../layer/Property.js"));
var _Layer = _interopRequireDefault(require("../Layer.js"));
var _Event = _interopRequireDefault(require("../../render/Event.js"));
var _EventType = _interopRequireDefault(require("../../render/EventType.js"));
var _Helper = _interopRequireDefault(require("../../webgl/Helper.js"));
var _transform = require("../../transform.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/webgl/Layer
 */
/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */
/**
 * @typedef {Object} Options
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */
/**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
var WebGLLayerRenderer = /*#__PURE__*/function (_LayerRenderer) {
  _inherits(WebGLLayerRenderer, _LayerRenderer);
  var _super = _createSuper(WebGLLayerRenderer);
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  function WebGLLayerRenderer(layer, options) {
    var _this;
    _classCallCheck(this, WebGLLayerRenderer);
    _this = _super.call(this, layer);
    options = options || {};

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform is only
     * set before dispatching rendering events.
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.inversePixelTransform_ = (0, _transform.create)();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    _this.pixelContext_ = null;

    /**
     * @private
     */
    _this.postProcesses_ = options.postProcesses;

    /**
     * @private
     */
    _this.uniforms_ = options.uniforms;

    /**
     * @type {WebGLHelper}
     * @protected
     */
    _this.helper;
    layer.addChangeListener(_Property.default.MAP, _this.removeHelper.bind(_assertThisInitialized(_this)));
    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_assertThisInitialized(_this));
    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  _createClass(WebGLLayerRenderer, [{
    key: "dispatchPreComposeEvent",
    value: function dispatchPreComposeEvent(context, frameState) {
      var layer = this.getLayer();
      if (layer.hasListener(_EventType.default.PRECOMPOSE)) {
        var event = new _Event.default(_EventType.default.PRECOMPOSE, undefined, frameState, context);
        layer.dispatchEvent(event);
      }
    }

    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "dispatchPostComposeEvent",
    value: function dispatchPostComposeEvent(context, frameState) {
      var layer = this.getLayer();
      if (layer.hasListener(_EventType.default.POSTCOMPOSE)) {
        var event = new _Event.default(_EventType.default.POSTCOMPOSE, undefined, frameState, context);
        layer.dispatchEvent(event);
      }
    }

    /**
     * Reset options (only handles uniforms).
     * @param {Options} options Options.
     */
  }, {
    key: "reset",
    value: function reset(options) {
      this.uniforms_ = options.uniforms;
      if (this.helper) {
        this.helper.setUniforms(this.uniforms_);
      }
    }

    /**
     * @protected
     */
  }, {
    key: "removeHelper",
    value: function removeHelper() {
      if (this.helper) {
        this.helper.dispose();
        delete this.helper;
      }
    }

    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      if (this.getLayer().getRenderSource()) {
        var incrementGroup = true;
        var groupNumber = -1;
        var className;
        for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
          var layer = frameState.layerStatesArray[i].layer;
          var renderer = layer.getRenderer();
          if (!(renderer instanceof WebGLLayerRenderer)) {
            incrementGroup = true;
            continue;
          }
          var layerClassName = layer.getClassName();
          if (incrementGroup || layerClassName !== className) {
            groupNumber += 1;
            incrementGroup = false;
          }
          className = layerClassName;
          if (renderer === this) {
            break;
          }
        }
        var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;
        if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey) || this.helper.needsToBeRecreated()) {
          this.removeHelper();
          this.helper = new _Helper.default({
            postProcesses: this.postProcesses_,
            uniforms: this.uniforms_,
            canvasCacheKey: canvasCacheKey
          });
          if (className) {
            this.helper.getCanvas().className = className;
          }
          this.afterHelperCreated();
        }
      }
      return this.prepareFrameInternal(frameState);
    }

    /**
     * @protected
     */
  }, {
    key: "afterHelperCreated",
    value: function afterHelperCreated() {}

    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @protected
     */
  }, {
    key: "prepareFrameInternal",
    value: function prepareFrameInternal(frameState) {
      return true;
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.removeHelper();
      _get(_getPrototypeOf(WebGLLayerRenderer.prototype), "disposeInternal", this).call(this);
    }

    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
  }, {
    key: "dispatchRenderEvent_",
    value: function dispatchRenderEvent_(type, context, frameState) {
      var layer = this.getLayer();
      if (layer.hasListener(type)) {
        (0, _transform.compose)(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
        var event = new _Event.default(type, this.inversePixelTransform_, frameState, context);
        layer.dispatchEvent(event);
      }
    }

    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "preRender",
    value: function preRender(context, frameState) {
      this.dispatchRenderEvent_(_EventType.default.PRERENDER, context, frameState);
    }

    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "postRender",
    value: function postRender(context, frameState) {
      this.dispatchRenderEvent_(_EventType.default.POSTRENDER, context, frameState);
    }
  }]);
  return WebGLLayerRenderer;
}(_Layer.default);
var _default = exports.default = WebGLLayerRenderer;
},{"../../layer/Property.js":"node_modules/ol/layer/Property.js","../Layer.js":"node_modules/ol/renderer/Layer.js","../../render/Event.js":"node_modules/ol/render/Event.js","../../render/EventType.js":"node_modules/ol/render/EventType.js","../../webgl/Helper.js":"node_modules/ol/webgl/Helper.js","../../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/webgl/RenderTarget.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _array = require("../array.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * A wrapper class to simplify rendering to a texture instead of the final canvas
 * @module ol/webgl/RenderTarget
 */
// for pixel color reading
var tmpArray4 = new Uint8Array(4);

/**
 * @classdesc
 * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,
 * simplifying initialization and binding for rendering.
 */
var WebGLRenderTarget = /*#__PURE__*/function () {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  function WebGLRenderTarget(helper, size) {
    _classCallCheck(this, WebGLRenderTarget);
    /**
     * @private
     * @type {import("./Helper.js").default}
     */
    this.helper_ = helper;
    var gl = helper.getGL();

    /**
     * @private
     * @type {WebGLTexture}
     */
    this.texture_ = gl.createTexture();

    /**
     * @private
     * @type {WebGLFramebuffer}
     */
    this.framebuffer_ = gl.createFramebuffer();

    /**
     * @private
     * @type {WebGLRenderbuffer}
     */
    this.depthbuffer_ = gl.createRenderbuffer();

    /**
     * @type {Array<number>}
     * @private
     */
    this.size_ = size || [1, 1];

    /**
     * @type {Uint8Array}
     * @private
     */
    this.data_ = new Uint8Array(0);

    /**
     * @type {boolean}
     * @private
     */
    this.dataCacheDirty_ = true;
    this.updateSize_();
  }

  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   */
  _createClass(WebGLRenderTarget, [{
    key: "setSize",
    value: function setSize(size) {
      if ((0, _array.equals)(size, this.size_)) {
        return;
      }
      this.size_[0] = size[0];
      this.size_[1] = size[1];
      this.updateSize_();
    }

    /**
     * Returns the size of the render target texture
     * @return {Array<number>} Size of the render target texture
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return this.size_;
    }

    /**
     * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
     * render target into memory, which is an expensive operation.
     * This content will be kept in cache but should be cleared after each new render.
     */
  }, {
    key: "clearCachedData",
    value: function clearCachedData() {
      this.dataCacheDirty_ = true;
    }

    /**
     * Returns the full content of the frame buffer as a series of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * @return {Uint8Array} Integer array of color values
     */
  }, {
    key: "readAll",
    value: function readAll() {
      if (this.dataCacheDirty_) {
        var size = this.size_;
        var gl = this.helper_.getGL();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
        gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
        this.dataCacheDirty_ = false;
      }
      return this.data_;
    }

    /**
     * Reads one pixel of the frame buffer as an array of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * If x and/or y are outside of existing data, an array filled with 0 is returned.
     * @param {number} x Pixel coordinate
     * @param {number} y Pixel coordinate
     * @return {Uint8Array} Integer array with one color value (4 components)
     */
  }, {
    key: "readPixel",
    value: function readPixel(x, y) {
      if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
        tmpArray4[0] = 0;
        tmpArray4[1] = 0;
        tmpArray4[2] = 0;
        tmpArray4[3] = 0;
        return tmpArray4;
      }
      this.readAll();
      var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
      tmpArray4[0] = this.data_[index * 4];
      tmpArray4[1] = this.data_[index * 4 + 1];
      tmpArray4[2] = this.data_[index * 4 + 2];
      tmpArray4[3] = this.data_[index * 4 + 3];
      return tmpArray4;
    }

    /**
     * @return {WebGLTexture} Texture to render to
     */
  }, {
    key: "getTexture",
    value: function getTexture() {
      return this.texture_;
    }

    /**
     * @return {WebGLFramebuffer} Frame buffer of the render target
     */
  }, {
    key: "getFramebuffer",
    value: function getFramebuffer() {
      return this.framebuffer_;
    }

    /**
     * @return {WebGLRenderbuffer} Depth buffer of the render target
     */
  }, {
    key: "getDepthbuffer",
    value: function getDepthbuffer() {
      return this.depthbuffer_;
    }

    /**
     * @private
     */
  }, {
    key: "updateSize_",
    value: function updateSize_() {
      var size = this.size_;
      var gl = this.helper_.getGL();
      this.texture_ = this.helper_.createTexture(size, null, this.texture_);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.viewport(0, 0, size[0], size[1]);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthbuffer_);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size[0], size[1]);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthbuffer_);
      this.data_ = new Uint8Array(size[0] * size[1] * 4);
    }
  }]);
  return WebGLRenderTarget;
}();
var _default = exports.default = WebGLRenderTarget;
},{"../array.js":"node_modules/ol/array.js"}],"node_modules/ol/render/webgl/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGLWorkerMessageType = void 0;
/**
 * @module ol/render/webgl/constants
 */

/**
 * @enum {string}
 */
var WebGLWorkerMessageType = exports.WebGLWorkerMessageType = {
  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',
  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',
  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS'
};

/**
 * @typedef {Object} WebGLWorkerGenerateBuffersMessage
 * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.
 * When the buffers are generated, the worked will send a message of the same type to the main thread, with
 * the generated buffers in it.
 * Note that any addition properties present in the message *will* be sent back to the main thread.
 * @property {number} id Message id; will be used both in request and response as a means of identification
 * @property {WebGLWorkerMessageType} type Message type
 * @property {ArrayBuffer} renderInstructions render instructions raw binary buffer.
 * @property {number} [customAttributesSize] Amount of hit detection + custom attributes count in the render instructions.
 * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).
 * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).
 * @property {import("../../transform").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates
 */
},{}],"node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"node_modules/ol/render/webgl/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LINESTRING_ANGLE_COSINE_CUTOFF = void 0;
exports.colorDecodeId = colorDecodeId;
exports.colorEncodeId = colorEncodeId;
exports.getBlankImageData = getBlankImageData;
exports.writeLineSegmentToBuffers = writeLineSegmentToBuffers;
exports.writePointFeatureToBuffers = writePointFeatureToBuffers;
exports.writePolygonTrianglesToBuffers = writePolygonTrianglesToBuffers;
var _earcut = _interopRequireDefault(require("earcut"));
var _transform = require("../../transform.js");
var _math = require("../../math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * @module ol/render/webgl/utils
 */
var LINESTRING_ANGLE_COSINE_CUTOFF = exports.LINESTRING_ANGLE_COSINE_CUTOFF = 0.985;

/** @type {Array<number>} */
var tmpArray_ = [];

/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */
var bufferPositions_ = {
  vertexPosition: 0,
  indexPosition: 0
};

/**
 * @param {Float32Array} buffer Buffer
 * @param {number} pos Position
 * @param {number} x X
 * @param {number} y Y
 * @param {number} index Index
 */
function writePointVertex(buffer, pos, x, y, index) {
  buffer[pos + 0] = x;
  buffer[pos + 1] = y;
  buffer[pos + 2] = index;
}

/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */
function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesSize, bufferPositions) {
  // This is for x, y and index
  var baseVertexAttrsCount = 3;
  var baseInstructionsCount = 2;
  var stride = baseVertexAttrsCount + customAttributesSize;
  var x = instructions[elementIndex + 0];
  var y = instructions[elementIndex + 1];

  // read custom numerical attributes on the feature
  var customAttrs = tmpArray_;
  customAttrs.length = customAttributesSize;
  for (var i = 0; i < customAttrs.length; i++) {
    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
  }
  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;
  var baseIndex = vPos / stride;

  // push vertices for each of the four quad corners (first standard then custom attributes)
  writePointVertex(vertexBuffer, vPos, x, y, 0);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 1);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 2);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 3);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  indexBuffer[iPos++] = baseIndex;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 3;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 2;
  indexBuffer[iPos++] = baseIndex + 3;
  bufferPositions_.vertexPosition = vPos;
  bufferPositions_.indexPosition = iPos;
  return bufferPositions_;
}

/**
 * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next
 * segment, in order to be able to offset the vertices correctly in the shader.
 * Join angles are between 0 and 2PI.
 * This also computes the length of the current segment and the sum of the join angle tangents in order
 * to store this information on each subsequent segment along the line. This is necessary to correctly render dashes
 * and symbols along the line.
 *
 *   pB (before)                          pA (after)
 *    X             negative             X
 *     \             offset             /
 *      \                              /
 *       \   join              join   /
 *        \ angle 0          angle 1 /
 *         \---                ---/      positive
 *          \   --          --   /        offset
 *           \                  /
 *            XX
 *            p0                  p1
 *
 * @param {Float32Array} instructions Array of render instructions for lines.s
 * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.
 * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.
 * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)
 * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {Array<number>} customAttributes Array of custom attributes value
 * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions
 * @param {number} currentLength Cumulated length of segments processed so far
 * @param {number} currentAngleTangentSum Cumulated tangents of the join angles processed so far
 * @return {{length: number, angle: number}} Cumulated length with the newly processed segment (in world units), new sum of the join angle tangents
 * @private
 */
function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, toWorldTransform, currentLength, currentAngleTangentSum) {
  // compute the stride to determine how many vertices were already pushed
  var baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params
  var stride = baseVertexAttrsCount + customAttributes.length;
  var baseIndex = vertexArray.length / stride;

  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]
  // Depending on whether there are points before and after the segment, its final shape
  // will be different
  var p0 = [instructions[segmentStartIndex + 0], instructions[segmentStartIndex + 1]];
  var p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];

  // to compute join angles we need to reproject coordinates back in world units
  var p0world = (0, _transform.apply)(toWorldTransform, [].concat(p0));
  var p1world = (0, _transform.apply)(toWorldTransform, [].concat(p1));

  /**
   * Compute the angle between p0pA and p0pB
   * @param {import("../../coordinate.js").Coordinate} p0 Point 0
   * @param {import("../../coordinate.js").Coordinate} pA Point A
   * @param {import("../../coordinate.js").Coordinate} pB Point B
   * @return {number} a value in [0, 2PI]
   */
  function angleBetween(p0, pA, pB) {
    var lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));
    var tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];
    var orthoA = [-tangentA[1], tangentA[0]];
    var lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));
    var tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];

    // this angle can be clockwise or anticlockwise; hence the computation afterwards
    var angle = lenA === 0 || lenB === 0 ? 0 : Math.acos((0, _math.clamp)(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));
    var isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;
    return !isClockwise ? Math.PI * 2 - angle : angle;
  }

  // a negative angle indicates a line cap
  var angle0 = -1;
  var angle1 = -1;
  var newAngleTangentSum = currentAngleTangentSum;
  var joinBefore = beforeSegmentIndex !== null;
  var joinAfter = afterSegmentIndex !== null;

  // add vertices and adapt offsets for P0 in case of join
  if (joinBefore) {
    // B for before
    var pB = [instructions[beforeSegmentIndex], instructions[beforeSegmentIndex + 1]];
    var pBworld = (0, _transform.apply)(toWorldTransform, [].concat(pB));
    angle0 = angleBetween(p0world, p1world, pBworld);

    // only add to the sum if the angle isn't too close to 0 or 2PI
    if (Math.cos(angle0) <= LINESTRING_ANGLE_COSINE_CUTOFF) {
      newAngleTangentSum += Math.tan((angle0 - Math.PI) / 2);
    }
  }
  // adapt offsets for P1 in case of join; add to angle sum
  if (joinAfter) {
    // A for after
    var pA = [instructions[afterSegmentIndex], instructions[afterSegmentIndex + 1]];
    var pAworld = (0, _transform.apply)(toWorldTransform, [].concat(pA));
    angle1 = angleBetween(p1world, p0world, pAworld);

    // only add to the sum if the angle isn't too close to 0 or 2PI
    if (Math.cos(angle1) <= LINESTRING_ANGLE_COSINE_CUTOFF) {
      newAngleTangentSum += Math.tan((Math.PI - angle1) / 2);
    }
  }

  /**
   * @param {number} vertexIndex From 0 to 3, indicating position in the quad
   * @param {number} angleSum Sum of the join angles encountered so far (used to compute distance offset
   * @return {number} A float value containing both information
   */
  function computeParameters(vertexIndex, angleSum) {
    if (angleSum === 0) {
      return vertexIndex * 10000;
    }
    return Math.sign(angleSum) * (vertexIndex * 10000 + Math.abs(angleSum));
  }

  // add main segment triangles
  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(0, currentAngleTangentSum));
  vertexArray.push.apply(vertexArray, _toConsumableArray(customAttributes));
  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(1, currentAngleTangentSum));
  vertexArray.push.apply(vertexArray, _toConsumableArray(customAttributes));
  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(2, currentAngleTangentSum));
  vertexArray.push.apply(vertexArray, _toConsumableArray(customAttributes));
  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(3, currentAngleTangentSum));
  vertexArray.push.apply(vertexArray, _toConsumableArray(customAttributes));
  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);
  return {
    length: currentLength + Math.sqrt((p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) + (p1world[1] - p0world[1]) * (p1world[1] - p0world[1])),
    angle: newAngleTangentSum
  };
}

/**
 * Pushes several triangles to form a polygon, including holes
 * @param {Float32Array} instructions Array of render instructions for lines.
 * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @return {number} Next polygon instructions index
 * @private
 */
function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesSize) {
  var instructionsPerVertex = 2; // x, y
  var attributesPerVertex = 2 + customAttributesSize;
  var instructionsIndex = polygonStartIndex;
  var customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesSize);
  instructionsIndex += customAttributesSize;
  var ringsCount = instructions[instructionsIndex++];
  var verticesCount = 0;
  var holes = new Array(ringsCount - 1);
  for (var i = 0; i < ringsCount; i++) {
    verticesCount += instructions[instructionsIndex++];
    if (i < ringsCount - 1) {
      holes[i] = verticesCount;
    }
  }
  var flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);

  // pushing to vertices and indices!! this is where the magic happens
  var result = (0, _earcut.default)(flatCoords, holes, instructionsPerVertex);
  for (var _i = 0; _i < result.length; _i++) {
    indexArray.push(result[_i] + vertexArray.length / attributesPerVertex);
  }
  for (var _i2 = 0; _i2 < flatCoords.length; _i2 += 2) {
    vertexArray.push.apply(vertexArray, [flatCoords[_i2], flatCoords[_i2 + 1]].concat(_toConsumableArray(customAttributes)));
  }
  return instructionsIndex + verticesCount * instructionsPerVertex;
}

/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */
function getBlankImageData() {
  var canvas = document.createElement('canvas');
  var image = canvas.getContext('2d').createImageData(1, 1);
  image.data[0] = 255;
  image.data[1] = 255;
  image.data[2] = 255;
  image.data[3] = 255;
  return image;
}

/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */
function colorEncodeId(id, array) {
  array = array || [];
  var radix = 256;
  var divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}

/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */
function colorDecodeId(color) {
  var id = 0;
  var radix = 256;
  var mult = radix - 1;
  id += Math.round(color[0] * radix * radix * radix * mult);
  id += Math.round(color[1] * radix * radix * mult);
  id += Math.round(color[2] * radix * mult);
  id += Math.round(color[3] * mult);
  return id;
}
},{"earcut":"node_modules/earcut/src/earcut.js","../../transform.js":"node_modules/ol/transform.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/worker/webgl.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
function create() {
  var source = "const e=\"GENERATE_POLYGON_BUFFERS\",t=\"GENERATE_POINT_BUFFERS\",n=\"GENERATE_LINE_STRING_BUFFERS\";function r(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function x(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new Error(t)}(0!==n,\"Transformation matrix cannot be inverted\");const x=t[0],i=t[1],u=t[2],o=t[3],f=t[4],s=t[5];return e[0]=o/n,e[1]=-i/n,e[2]=-u/n,e[3]=x/n,e[4]=(u*s-o*f)/n,e[5]=-(x*s-i*f)/n,e}function i(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}new Array(6);var u={exports:{}};function o(e,t,n){n=n||2;var r,x,i,u,o,s,l,v=t&&t.length,h=v?t[0]*n:e.length,c=f(e,0,h,n,!0),g=[];if(!c||c.next===c.prev)return g;if(v&&(c=function(e,t,n,r){var x,i,u,o=[];for(x=0,i=t.length;x<i;x++)(u=f(e,t[x]*r,x<i-1?t[x+1]*r:e.length,r,!1))===u.next&&(u.steiner=!0),o.push(d(u));for(o.sort(p),x=0;x<o.length;x++)n=y(o[x],n);return n}(e,t,c,n)),e.length>80*n){r=i=e[0],x=u=e[1];for(var b=n;b<h;b+=n)(o=e[b])<r&&(r=o),(s=e[b+1])<x&&(x=s),o>i&&(i=o),s>u&&(u=s);l=0!==(l=Math.max(i-r,u-x))?32767/l:0}return a(c,g,n,r,x,l,0),g}function f(e,t,n,r,x){var i,u;if(x===O(e,t,n,r)>0)for(i=t;i<n;i+=r)u=P(i,e[i],e[i+1],u);else for(i=n-r;i>=t;i-=r)u=P(i,e[i],e[i+1],u);return u&&m(u,u.next)&&(B(u),u=u.next),u}function s(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!m(r,r.next)&&0!==w(r.prev,r,r.next))r=r.next;else{if(B(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function a(e,t,n,r,x,i,u){if(e){!u&&i&&function(e,t,n,r){var x=e;do{0===x.z&&(x.z=b(x.x,x.y,t,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,function(e){var t,n,r,x,i,u,o,f,s=1;do{for(n=e,e=null,i=null,u=0;n;){for(u++,r=n,o=0,t=0;t<s&&(o++,r=r.nextZ);t++);for(f=s;o>0||f>0&&r;)0!==o&&(0===f||!r||n.z<=r.z)?(x=n,n=n.nextZ,o--):(x=r,r=r.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;n=r}i.nextZ=null,s*=2}while(u>1)}(x)}(e,r,x,i);for(var o,f,p=e;e.prev!==e.next;)if(o=e.prev,f=e.next,i?v(e,r,x,i):l(e))t.push(o.i/n|0),t.push(e.i/n|0),t.push(f.i/n|0),B(e),e=f.next,p=f.next;else if((e=f)===p){u?1===u?a(e=h(s(e),t,n),t,n,r,x,i,2):2===u&&c(e,t,n,r,x,i):a(s(e),t,n,r,x,i,1);break}}}function l(e){var t=e.prev,n=e,r=e.next;if(w(t,n,r)>=0)return!1;for(var x=t.x,i=n.x,u=r.x,o=t.y,f=n.y,s=r.y,a=x<i?x<u?x:u:i<u?i:u,l=o<f?o<s?o:s:f<s?f:s,v=x>i?x>u?x:u:i>u?i:u,h=o>f?o>s?o:s:f>s?f:s,c=r.next;c!==t;){if(c.x>=a&&c.x<=v&&c.y>=l&&c.y<=h&&M(x,o,i,f,u,s,c.x,c.y)&&w(c.prev,c,c.next)>=0)return!1;c=c.next}return!0}function v(e,t,n,r){var x=e.prev,i=e,u=e.next;if(w(x,i,u)>=0)return!1;for(var o=x.x,f=i.x,s=u.x,a=x.y,l=i.y,v=u.y,h=o<f?o<s?o:s:f<s?f:s,c=a<l?a<v?a:v:l<v?l:v,p=o>f?o>s?o:s:f>s?f:s,y=a>l?a>v?a:v:l>v?l:v,g=b(h,c,t,n,r),d=b(p,y,t,n,r),Z=e.prevZ,m=e.nextZ;Z&&Z.z>=g&&m&&m.z<=d;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;if(Z=Z.prevZ,m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;Z&&Z.z>=g;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;Z=Z.prevZ}for(;m&&m.z<=d;){if(m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function h(e,t,n){var r=e;do{var x=r.prev,i=r.next.next;!m(x,i)&&A(x,r,r.next,i)&&z(x,i)&&z(i,x)&&(t.push(x.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),B(r),B(r.next),r=e=i),r=r.next}while(r!==e);return s(r)}function c(e,t,n,r,x,i){var u=e;do{for(var o=u.next.next;o!==u.prev;){if(u.i!==o.i&&Z(u,o)){var f=F(u,o);return u=s(u,u.next),f=s(f,f.next),a(u,t,n,r,x,i,0),void a(f,t,n,r,x,i,0)}o=o.next}u=u.next}while(u!==e)}function p(e,t){return e.x-t.x}function y(e,t){var n=function(e,t){var n,r=t,x=e.x,i=e.y,u=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var o=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(o<=x&&o>u&&(u=o,n=r.x<r.next.x?r:r.next,o===x))return n}r=r.next}while(r!==t);if(!n)return null;var f,s=n,a=n.x,l=n.y,v=1/0;r=n;do{x>=r.x&&r.x>=a&&x!==r.x&&M(i<l?x:u,i,a,l,i<l?u:x,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(x-r.x),z(r,e)&&(f<v||f===v&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,v=f)),r=r.next}while(r!==s);return n}(e,t);if(!n)return t;var r=F(n,e);return s(r,r.next),s(n,n.next)}function g(e,t){return w(e.prev,e,t.prev)<0&&w(t.next,e,e.next)<0}function b(e,t,n,r,x){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function d(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function M(e,t,n,r,x,i,u,o){return(x-u)*(t-o)>=(e-u)*(i-o)&&(e-u)*(r-o)>=(n-u)*(t-o)&&(n-u)*(i-o)>=(x-u)*(r-o)}function Z(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&A(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(z(e,t)&&z(t,e)&&function(e,t){var n=e,r=!1,x=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&x<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(w(e.prev,e,t.prev)||w(e,t.prev,t))||m(e,t)&&w(e.prev,e,e.next)>0&&w(t.prev,t,t.next)>0)}function w(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function m(e,t){return e.x===t.x&&e.y===t.y}function A(e,t,n,r){var x=I(w(e,t,n)),i=I(w(e,t,r)),u=I(w(n,r,e)),o=I(w(n,r,t));return x!==i&&u!==o||(!(0!==x||!E(e,n,t))||(!(0!==i||!E(e,r,t))||(!(0!==u||!E(n,e,r))||!(0!==o||!E(n,t,r)))))}function E(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function z(e,t){return w(e.prev,e,e.next)<0?w(e,t,e.next)>=0&&w(e,e.prev,t)>=0:w(e,t,e.prev)<0||w(e,e.next,t)<0}function F(e,t){var n=new _(e.i,e.x,e.y),r=new _(t.i,t.x,t.y),x=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=x,x.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function P(e,t,n,r){var x=new _(e,t,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function B(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function _(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(e,t,n,r){for(var x=0,i=t,u=n-r;i<n;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}u.exports=o,u.exports.default=o,o.deviation=function(e,t,n,r){var x=t&&t.length,i=x?t[0]*n:e.length,u=Math.abs(O(e,0,i,n));if(x)for(var o=0,f=t.length;o<f;o++){var s=t[o]*n,a=o<f-1?t[o+1]*n:e.length;u-=Math.abs(O(e,s,a,n))}var l=0;for(o=0;o<r.length;o+=3){var v=r[o]*n,h=r[o+1]*n,c=r[o+2]*n;l+=Math.abs((e[v]-e[c])*(e[h+1]-e[v+1])-(e[v]-e[h])*(e[c+1]-e[v+1]))}return 0===u&&0===l?0:Math.abs((l-u)/u)},o.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;u<t;u++)n.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,n.holes.push(r))}return n};var N=i(u.exports);const R=[],S={vertexPosition:0,indexPosition:0};function T(e,t,n,r,x){e[t+0]=n,e[t+1]=r,e[t+2]=x}function U(e,t,n,r,x,i){const u=3+x,o=e[t+0],f=e[t+1],s=R;s.length=x;for(let n=0;n<s.length;n++)s[n]=e[t+2+n];let a=i?i.vertexPosition:0,l=i?i.indexPosition:0;const v=a/u;return T(n,a,o,f,0),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,1),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,2),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,3),s.length&&n.set(s,a+3),a+=u,r[l++]=v,r[l++]=v+1,r[l++]=v+3,r[l++]=v+1,r[l++]=v+2,r[l++]=v+3,S.vertexPosition=a,S.indexPosition=l,S}function k(e,t,n,x,i,u,o,f,s,a,l){const v=8+f.length,h=u.length/v,c=[e[t+0],e[t+1]],p=[e[n],e[n+1]],y=r(s,[...c]),g=r(s,[...p]);function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),x=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-x[1],x[0]],u=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),o=[(n[0]-e[0])/u,(n[1]-e[1])/u],f=0===r||0===u?0:Math.acos((s=o[0]*x[0]+o[1]*x[1],a=-1,l=1,Math.min(Math.max(s,a),l)));var s,a,l;return o[0]*i[0]+o[1]*i[1]>0?f:2*Math.PI-f}let d=-1,M=-1,Z=l;const w=null!==i;if(null!==x){d=b(y,g,r(s,[...[e[x],e[x+1]]])),Math.cos(d)<=.985&&(Z+=Math.tan((d-Math.PI)/2))}if(w){M=b(g,y,r(s,[...[e[i],e[i+1]]])),Math.cos(M)<=.985&&(Z+=Math.tan((Math.PI-M)/2))}function m(e,t){return 0===t?1e4*e:Math.sign(t)*(1e4*e+Math.abs(t))}return u.push(c[0],c[1],p[0],p[1],d,M,a,m(0,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(1,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(2,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(3,l)),u.push(...f),o.push(h,h+1,h+2,h+1,h+3,h+2),{length:a+Math.sqrt((g[0]-y[0])*(g[0]-y[0])+(g[1]-y[1])*(g[1]-y[1])),angle:Z}}function G(e,t,n,r,x){const i=2+x;let u=t;const o=e.slice(u,u+x);u+=x;const f=e[u++];let s=0;const a=new Array(f-1);for(let t=0;t<f;t++)s+=e[u++],t<f-1&&(a[t]=s);const l=e.slice(u,u+2*s),v=N(l,a,2);for(let e=0;e<v.length;e++)r.push(v[e]+n.length/i);for(let e=0;e<l.length;e+=2)n.push(l[e],l[e+1],...o);return u+2*s}const j=self;j.onmessage=r=>{const i=r.data;switch(i.type){case t:{const e=3,t=2,n=i.customAttributesSize,r=t+n,x=new Float32Array(i.renderInstructions),u=x.length/r,o=4*u*(n+e),f=new Uint32Array(6*u),s=new Float32Array(o);let a;for(let e=0;e<x.length;e+=r)a=U(x,e,s,f,n,a);const l=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},i);j.postMessage(l,[s.buffer,f.buffer,x.buffer]);break}case n:{const e=[],t=[],n=i.customAttributesSize,r=2,u=new Float32Array(i.renderInstructions);let o=0;const f=[1,0,0,1,0,0];let s,a;for(x(f,i.renderInstructionsTransform);o<u.length;){a=Array.from(u.slice(o,o+n)),o+=n,s=u[o++];const x=o,i=o+(s-1)*r,l=u[x]===u[i]&&u[x+1]===u[i+1];let v=0,h=0;for(let n=0;n<s-1;n++){let c=null;n>0?c=o+(n-1)*r:l&&(c=i-r);let p=null;n<s-2?p=o+(n+2)*r:l&&(p=x+r);const y=k(u,o+n*r,o+(n+1)*r,c,p,e,t,a,f,v,h);v=y.length,h=y.angle}o+=s*r}const l=Uint32Array.from(t),v=Float32Array.from(e),h=Object.assign({vertexBuffer:v.buffer,indexBuffer:l.buffer,renderInstructions:u.buffer},i);j.postMessage(h,[v.buffer,l.buffer,u.buffer]);break}case e:{const e=[],t=[],n=i.customAttributesSize,r=new Float32Array(i.renderInstructions);let x=0;for(;x<r.length;)x=G(r,x,e,t,n);const u=Uint32Array.from(t),o=Float32Array.from(e),f=Object.assign({vertexBuffer:o.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},i);j.postMessage(f,[o.buffer,u.buffer,r.buffer]);break}}};";
  return new Worker(typeof Blob === 'undefined' ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64') : URL.createObjectURL(new Blob([source], {
    type: 'application/javascript'
  })));
}
},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/ol/renderer/webgl/worldUtil.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldParameters = getWorldParameters;
var _extent = require("../../extent.js");
/**
 * Compute world params
 * @param {import("../../Map.js").FrameState} frameState Frame state.
 * @param {any} layer The layer
 * @return {Array<number>} The world start, end and width.
 */
function getWorldParameters(frameState, layer) {
  var projection = frameState.viewState.projection;
  var vectorSource = layer.getSource();
  var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
  var projectionExtent = projection.getExtent();
  var extent = frameState.extent;
  var worldWidth = multiWorld ? (0, _extent.getWidth)(projectionExtent) : null;
  var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
  var startWorld = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
  return [startWorld, endWorld, worldWidth];
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/renderer/webgl/PointsLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseVector = _interopRequireDefault(require("../../layer/BaseVector.js"));
var _VectorEventType = _interopRequireDefault(require("../../source/VectorEventType.js"));
var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));
var _Buffer = _interopRequireDefault(require("../../webgl/Buffer.js"));
var _Layer = _interopRequireDefault(require("./Layer.js"));
var _RenderTarget = _interopRequireDefault(require("../../webgl/RenderTarget.js"));
var _webgl = require("../../webgl.js");
var _Helper = require("../../webgl/Helper.js");
var _constants = require("../../render/webgl/constants.js");
var _transform = require("../../transform.js");
var _asserts = require("../../asserts.js");
var _extent = require("../../extent.js");
var _utils = require("../../render/webgl/utils.js");
var _webgl2 = require("../../worker/webgl.js");
var _proj = require("../../proj.js");
var _util = require("../../util.js");
var _worldUtil = require("./worldUtil.js");
var _events = require("../../events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/webgl/PointsLayer
 */
/**
 * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {string} name Attribute name.
 * @property {function(import("../../Feature").default, Object<string, *>):number} callback This callback computes the numerical value of the
 * attribute for a given feature (properties are available as 2nd arg for quicker access).
 */
/**
 * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize
 * rebuildBuffers by accessing these objects quicker.
 * @property {import("../../Feature").default} feature Feature
 * @property {Object<string, *>} properties Feature properties
 * @property {import("../../geom").Geometry} geometry Feature geometry
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then
 * passed to the GPU. The `name` property of each attribute will serve as its identifier:
 *  * In the vertex shader as an `attribute` by prefixing it with `a_`
 *  * In the fragment shader as a `varying` by prefixing it with `v_`
 * Please note that these can only be numerical values.
 * @property {string} vertexShader Vertex shader source, mandatory.
 * @property {string} fragmentShader Fragment shader source, mandatory.
 * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */
/**
 * @classdesc
 * WebGL vector renderer optimized for points.
 * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU
 * every time the vector source changes.
 *
 * You need to provide vertex and fragment shaders for rendering. This can be done using
 * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute
 * containing the screen-space projected center of the quad, as well as a `a_index` attribute
 * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).
 *
 * To include variable attributes in the shaders, you need to declare them using the `attributes` property of
 * the options object like so:
 * ```js
 * new WebGLPointsLayerRenderer(layer, {
 *   attributes: [
 *     {
 *       name: 'size',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *     {
 *       name: 'weight',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *   ],
 *   vertexShader:
 *     // shader using attribute a_weight and a_size
 *   fragmentShader:
 *     // shader using varying v_weight and v_size
 * ```
 *
 * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`
 * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain
 * the final color that will have to be output for hit detection to work.
 *
 * The following uniform is used for the main texture: `u_texture`.
 * The following uniform is used for the layer opacity: `u_opacity`.
 *
 * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Points are rendered as quads with the following structure:
 *
 * ```
 *   (u0, v1)      (u1, v1)
 *  [3]----------[2]
 *   |`           |
 *   |  `         |
 *   |    `       |
 *   |      `     |
 *   |        `   |
 *   |          ` |
 *  [0]----------[1]
 *   (u0, v0)      (u1, v0)
 *  ```
 *
 * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.
 *
 * @api
 */
var WebGLPointsLayerRenderer = /*#__PURE__*/function (_WebGLLayerRenderer) {
  _inherits(WebGLPointsLayerRenderer, _WebGLLayerRenderer);
  var _super = _createSuper(WebGLPointsLayerRenderer);
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  function WebGLPointsLayerRenderer(layer, options) {
    var _options$hitDetection, _this$attributes;
    var _this;
    _classCallCheck(this, WebGLPointsLayerRenderer);
    var uniforms = options.uniforms || {};
    var projectionMatrixTransform = (0, _transform.create)();
    uniforms[_Helper.DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    _this = _super.call(this, layer, {
      uniforms: uniforms,
      postProcesses: options.postProcesses
    });
    _this.sourceRevision_ = -1;
    _this.verticesBuffer_ = new _Buffer.default(_webgl.ARRAY_BUFFER, _webgl.DYNAMIC_DRAW);
    _this.indicesBuffer_ = new _Buffer.default(_webgl.ELEMENT_ARRAY_BUFFER, _webgl.DYNAMIC_DRAW);

    /**
     * @private
     */
    _this.vertexShader_ = options.vertexShader;

    /**
     * @private
     */
    _this.fragmentShader_ = options.fragmentShader;

    /**
     * @type {WebGLProgram}
     * @private
     */
    _this.program_;

    /**
     * @type {boolean}
     * @private
     */
    _this.hitDetectionEnabled_ = (_options$hitDetection = options.hitDetectionEnabled) !== null && _options$hitDetection !== void 0 ? _options$hitDetection : true;
    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {
      return {
        name: 'a_prop_' + attribute.name,
        size: 1,
        type: _Helper.AttributeType.FLOAT
      };
    }) : [];

    /**
     * A list of attributes used by the renderer. By default only the position and
     * index of the vertex (0 to 3) are required.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */
    _this.attributes = [{
      name: 'a_position',
      size: 2,
      type: _Helper.AttributeType.FLOAT
    }, {
      name: 'a_index',
      size: 1,
      type: _Helper.AttributeType.FLOAT
    }];
    if (_this.hitDetectionEnabled_) {
      _this.attributes.push({
        name: 'a_hitColor',
        size: 4,
        type: _Helper.AttributeType.FLOAT
      });
      _this.attributes.push({
        name: 'a_featureUid',
        size: 1,
        type: _Helper.AttributeType.FLOAT
      });
    }
    (_this$attributes = _this.attributes).push.apply(_this$attributes, _toConsumableArray(customAttributes));
    _this.customAttributes = options.attributes ? options.attributes : [];
    _this.previousExtent_ = (0, _extent.createEmpty)();

    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */
    _this.currentTransform_ = projectionMatrixTransform;

    /**
     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space
     * @type {import("../../transform.js").Transform}
     * @private
     */
    _this.renderTransform_ = (0, _transform.create)();

    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */
    _this.invertRenderTransform_ = (0, _transform.create)();

    /**
     * @type {Float32Array}
     * @private
     */
    _this.renderInstructions_ = new Float32Array(0);

    /**
     * @type {WebGLRenderTarget}
     * @private
     */
    _this.hitRenderTarget_;

    /**
     * Keep track of latest message sent to worker
     * @type {number}
     * @private
     */
    _this.lastSentId = 0;

    /**
     * @private
     */
    _this.worker_ = (0, _webgl2.create)();
    _this.worker_.addEventListener('message',
    /**
     * @param {*} event Event.
     */
    function (event) {
      var received = event.data;
      if (received.type === _constants.WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {
        var projectionTransform = received.projectionTransform;
        _this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
        _this.helper.flushBufferData(_this.verticesBuffer_);
        _this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        _this.helper.flushBufferData(_this.indicesBuffer_);
        _this.renderTransform_ = projectionTransform;
        (0, _transform.makeInverse)(_this.invertRenderTransform_, _this.renderTransform_);
        _this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
        if (received.id === _this.lastSentId) {
          _this.ready = true;
        }
        _this.getLayer().changed();
      }
    });

    /**
     * This object will be updated when the source changes. Key is uid.
     * @type {Object<string, FeatureCacheItem>}
     * @private
     */
    _this.featureCache_ = {};

    /**
     * Amount of features in the cache.
     * @type {number}
     * @private
     */
    _this.featureCount_ = 0;
    var source = _this.getLayer().getSource();
    _this.sourceListenKeys_ = [(0, _events.listen)(source, _VectorEventType.default.ADDFEATURE, _this.handleSourceFeatureAdded_, _assertThisInitialized(_this)), (0, _events.listen)(source, _VectorEventType.default.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _assertThisInitialized(_this)), (0, _events.listen)(source, _VectorEventType.default.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _assertThisInitialized(_this)), (0, _events.listen)(source, _VectorEventType.default.CLEAR, _this.handleSourceFeatureClear_, _assertThisInitialized(_this))];
    source.forEachFeature(function (feature) {
      _this.featureCache_[(0, _util.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      _this.featureCount_++;
    });
    return _this;
  }
  _createClass(WebGLPointsLayerRenderer, [{
    key: "afterHelperCreated",
    value: function afterHelperCreated() {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
      if (this.hitDetectionEnabled_) {
        this.hitRenderTarget_ = new _RenderTarget.default(this.helper);
      }
    }

    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
  }, {
    key: "handleSourceFeatureAdded_",
    value: function handleSourceFeatureAdded_(event) {
      var feature = event.feature;
      this.featureCache_[(0, _util.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      this.featureCount_++;
    }

    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
  }, {
    key: "handleSourceFeatureChanged_",
    value: function handleSourceFeatureChanged_(event) {
      var feature = event.feature;
      this.featureCache_[(0, _util.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
    }

    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
  }, {
    key: "handleSourceFeatureDelete_",
    value: function handleSourceFeatureDelete_(event) {
      var feature = event.feature;
      delete this.featureCache_[(0, _util.getUid)(feature)];
      this.featureCount_--;
    }

    /**
     * @private
     */
  }, {
    key: "handleSourceFeatureClear_",
    value: function handleSourceFeatureClear_() {
      this.featureCache_ = {};
      this.featureCount_ = 0;
    }

    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      var gl = this.helper.getGL();
      this.preRender(gl, frameState);
      var _getWorldParameters = (0, _worldUtil.getWorldParameters)(frameState, this.getLayer()),
        _getWorldParameters2 = _slicedToArray(_getWorldParameters, 3),
        startWorld = _getWorldParameters2[0],
        endWorld = _getWorldParameters2[1],
        worldWidth = _getWorldParameters2[2];

      // draw the normal canvas
      this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);
      this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
      if (this.hitDetectionEnabled_) {
        // draw the hit buffer
        this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);
        this.hitRenderTarget_.clearCachedData();
      }
      this.postRender(gl, frameState);
      var canvas = this.helper.getCanvas();
      return canvas;
    }

    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrameInternal",
    value: function prepareFrameInternal(frameState) {
      var layer = this.getLayer();
      var vectorSource = layer.getSource();
      var viewState = frameState.viewState;
      var viewNotMoving = !frameState.viewHints[_ViewHint.default.ANIMATING] && !frameState.viewHints[_ViewHint.default.INTERACTING];
      var extentChanged = !(0, _extent.equals)(this.previousExtent_, frameState.extent);
      var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
      if (sourceChanged) {
        this.sourceRevision_ = vectorSource.getRevision();
      }
      if (viewNotMoving && (extentChanged || sourceChanged)) {
        var projection = viewState.projection;
        var resolution = viewState.resolution;
        var renderBuffer = layer instanceof _BaseVector.default ? layer.getRenderBuffer() : 0;
        var extent = (0, _extent.buffer)(frameState.extent, renderBuffer * resolution);
        vectorSource.loadFeatures(extent, resolution, projection);
        this.rebuildBuffers_(frameState);
        this.previousExtent_ = frameState.extent.slice();
      }
      this.helper.useProgram(this.program_, frameState);
      this.helper.prepareDraw(frameState);

      // write new data
      this.helper.bindBuffer(this.verticesBuffer_);
      this.helper.bindBuffer(this.indicesBuffer_);
      this.helper.enableAttributes(this.attributes);
      return true;
    }

    /**
     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
  }, {
    key: "rebuildBuffers_",
    value: function rebuildBuffers_(frameState) {
      // saves the projection transform for the current frame state
      var projectionTransform = (0, _transform.create)();
      this.helper.makeProjectionTransform(frameState, projectionTransform);
      var userProjection = (0, _proj.getUserProjection)();
      var baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below
      var singleInstructionLength = baseInstructionLength + this.customAttributes.length;
      var totalSize = singleInstructionLength * this.featureCount_;
      if (!this.renderInstructions_ || this.renderInstructions_.length !== totalSize) {
        this.renderInstructions_ = new Float32Array(totalSize);
      }

      // loop on features to fill the buffer
      var featureCache, geometry;
      var tmpCoords = [];
      var tmpColor = [];
      var idx = -1;
      for (var featureUid in this.featureCache_) {
        featureCache = this.featureCache_[featureUid];
        geometry = /** @type {import("../../geom").Point} */
        featureCache.geometry;
        if (!geometry || geometry.getType() !== 'Point') {
          continue;
        }
        if (userProjection) {
          var userCoords = (0, _proj.fromUserCoordinate)(geometry.getFlatCoordinates(), frameState.viewState.projection);
          tmpCoords[0] = userCoords[0];
          tmpCoords[1] = userCoords[1];
        } else {
          tmpCoords[0] = geometry.getFlatCoordinates()[0];
          tmpCoords[1] = geometry.getFlatCoordinates()[1];
        }
        (0, _transform.apply)(projectionTransform, tmpCoords);
        this.renderInstructions_[++idx] = tmpCoords[0];
        this.renderInstructions_[++idx] = tmpCoords[1];

        // for hit detection, the feature uid is saved in the opacity value
        // and the index of the opacity value is encoded in the color values
        if (this.hitDetectionEnabled_) {
          var hitColor = (0, _utils.colorEncodeId)(idx + 5, tmpColor);
          this.renderInstructions_[++idx] = hitColor[0];
          this.renderInstructions_[++idx] = hitColor[1];
          this.renderInstructions_[++idx] = hitColor[2];
          this.renderInstructions_[++idx] = hitColor[3];
          this.renderInstructions_[++idx] = Number(featureUid);
        }

        // pushing custom attributes
        for (var j = 0; j < this.customAttributes.length; j++) {
          var value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);
          this.renderInstructions_[++idx] = value;
        }
      }

      /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */
      var message = {
        id: ++this.lastSentId,
        type: _constants.WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,
        renderInstructions: this.renderInstructions_.buffer,
        customAttributesSize: singleInstructionLength - 2
      };
      // additional properties will be sent back as-is by the worker
      message['projectionTransform'] = projectionTransform;
      this.ready = false;
      this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
      this.renderInstructions_ = null;
    }

    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      (0, _asserts.assert)(this.hitDetectionEnabled_, '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.');
      if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {
        return undefined;
      }
      var pixel = (0, _transform.apply)(frameState.coordinateToPixelTransform, coordinate.slice());
      var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
      var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
      var index = (0, _utils.colorDecodeId)(color);
      var opacity = this.renderInstructions_[index];
      var uid = Math.floor(opacity).toString();
      var source = this.getLayer().getSource();
      var feature = source.getFeatureByUid(uid);
      if (feature) {
        return callback(feature, this.getLayer(), null);
      }
      return undefined;
    }

    /**
     * Render the world, either to the main framebuffer or to the hit framebuffer
     * @param {import("../../Map.js").FrameState} frameState current frame state
     * @param {boolean} forHitDetection whether the rendering is for hit detection
     * @param {number} startWorld the world to render in the first iteration
     * @param {number} endWorld the last world to render
     * @param {number} worldWidth the width of the worlds being rendered
     */
  }, {
    key: "renderWorlds",
    value: function renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {
      var world = startWorld;
      this.helper.useProgram(this.program_, frameState);
      if (forHitDetection) {
        this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);
        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
      }
      this.helper.bindBuffer(this.verticesBuffer_);
      this.helper.bindBuffer(this.indicesBuffer_);
      this.helper.enableAttributes(this.attributes);
      do {
        this.helper.makeProjectionTransform(frameState, this.currentTransform_);
        (0, _transform.translate)(this.currentTransform_, world * worldWidth, 0);
        (0, _transform.multiply)(this.currentTransform_, this.invertRenderTransform_);
        this.helper.applyUniforms(frameState);
        this.helper.applyHitDetectionUniform(forHitDetection);
        var renderCount = this.indicesBuffer_.getSize();
        this.helper.drawElements(0, renderCount);
      } while (++world < endWorld);
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.worker_.terminate();
      this.layer_ = null;
      this.sourceListenKeys_.forEach(function (key) {
        (0, _events.unlistenByKey)(key);
      });
      this.sourceListenKeys_ = null;
      _get(_getPrototypeOf(WebGLPointsLayerRenderer.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return WebGLPointsLayerRenderer;
}(_Layer.default);
var _default = exports.default = WebGLPointsLayerRenderer;
},{"../../layer/BaseVector.js":"node_modules/ol/layer/BaseVector.js","../../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../webgl/Buffer.js":"node_modules/ol/webgl/Buffer.js","./Layer.js":"node_modules/ol/renderer/webgl/Layer.js","../../webgl/RenderTarget.js":"node_modules/ol/webgl/RenderTarget.js","../../webgl.js":"node_modules/ol/webgl.js","../../webgl/Helper.js":"node_modules/ol/webgl/Helper.js","../../render/webgl/constants.js":"node_modules/ol/render/webgl/constants.js","../../transform.js":"node_modules/ol/transform.js","../../asserts.js":"node_modules/ol/asserts.js","../../extent.js":"node_modules/ol/extent.js","../../render/webgl/utils.js":"node_modules/ol/render/webgl/utils.js","../../worker/webgl.js":"node_modules/ol/worker/webgl.js","../../proj.js":"node_modules/ol/proj.js","../../util.js":"node_modules/ol/util.js","./worldUtil.js":"node_modules/ol/renderer/webgl/worldUtil.js","../../events.js":"node_modules/ol/events.js"}],"node_modules/ol/webgl/PaletteTexture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/webgl/PaletteTexture
 */
var PaletteTexture = /*#__PURE__*/function () {
  /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */
  function PaletteTexture(name, data) {
    _classCallCheck(this, PaletteTexture);
    this.name = name;
    this.data = data;

    /**
     * @type {WebGLTexture|null}
     * @private
     */
    this.texture_ = null;
  }

  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */
  _createClass(PaletteTexture, [{
    key: "getTexture",
    value: function getTexture(gl) {
      if (!this.texture_) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        this.texture_ = texture;
      }
      return this.texture_;
    }
  }]);
  return PaletteTexture;
}();
var _default = exports.default = PaletteTexture;
},{}],"node_modules/ol/webgl/BaseTileRepresentation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Target = _interopRequireDefault(require("../events/Target.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));
var _TileState = _interopRequireDefault(require("../TileState.js"));
var _util = require("../util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/webgl/BaseTileRepresentation
 */
/**
 * @typedef {import("../Tile.js").default} BaseTileType
 */
/**
 * @template {BaseTileType} TileType
 * @typedef {Object} TileRepresentationOptions
 * @property {TileType} tile The tile.
 * @property {import("../tilegrid/TileGrid.js").default} grid Tile grid.
 * @property {import("../webgl/Helper.js").default} helper WebGL helper.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 */
/**
 * @classdesc
 * Base class for representing a tile in a webgl context
 * @template {import("../Tile.js").default} TileType
 * @abstract
 */
var BaseTileRepresentation = /*#__PURE__*/function (_EventTarget) {
  _inherits(BaseTileRepresentation, _EventTarget);
  var _super = _createSuper(BaseTileRepresentation);
  /**
   * @param {TileRepresentationOptions<TileType>} options The tile representation options.
   */
  function BaseTileRepresentation(options) {
    var _this;
    _classCallCheck(this, BaseTileRepresentation);
    _this = _super.call(this);

    /**
     * @type {TileType}
     */
    _this.tile;
    _this.handleTileChange_ = _this.handleTileChange_.bind(_assertThisInitialized(_this));

    /**
     * @type {number}
     * @protected
     */
    _this.gutter_ = options.gutter || 0;

    /**
     * @type {import("../webgl/Helper.js").default}
     * @protected
     */
    _this.helper_ = options.helper;
    _this.loaded = false;
    _this.ready = false;
    return _this;
  }

  /**
   * @param {TileType} tile Tile.
   */
  _createClass(BaseTileRepresentation, [{
    key: "setTile",
    value: function setTile(tile) {
      if (tile !== this.tile) {
        if (this.tile) {
          this.tile.removeEventListener(_EventType.default.CHANGE, this.handleTileChange_);
        }
        this.tile = tile;
        this.loaded = tile.getState() === _TileState.default.LOADED;
        if (this.loaded) {
          this.uploadTile();
        } else {
          if (tile instanceof _ImageTile.default) {
            var image = tile.getImage();
            if (image instanceof Image && !image.crossOrigin) {
              image.crossOrigin = 'anonymous';
            }
          }
          tile.addEventListener(_EventType.default.CHANGE, this.handleTileChange_);
        }
      }
    }

    /**
     * @abstract
     * @protected
     */
  }, {
    key: "uploadTile",
    value: function uploadTile() {
      (0, _util.abstract)();
    }
  }, {
    key: "setReady",
    value: function setReady() {
      this.ready = true;
      this.dispatchEvent(_EventType.default.CHANGE);
    }
  }, {
    key: "handleTileChange_",
    value: function handleTileChange_() {
      if (this.tile.getState() === _TileState.default.LOADED) {
        this.loaded = true;
        this.uploadTile();
      }
    }
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.tile.removeEventListener(_EventType.default.CHANGE, this.handleTileChange_);
    }
  }]);
  return BaseTileRepresentation;
}(_Target.default);
var _default = exports.default = BaseTileRepresentation;
},{"../events/Target.js":"node_modules/ol/events/Target.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../TileState.js":"node_modules/ol/TileState.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/webgl/TileTexture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseTileRepresentation = _interopRequireDefault(require("./BaseTileRepresentation.js"));
var _DataTile = _interopRequireWildcard(require("../DataTile.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));
var _Tile = _interopRequireDefault(require("../reproj/Tile.js"));
var _Buffer = _interopRequireDefault(require("./Buffer.js"));
var _webgl = require("../webgl.js");
var _dom = require("../dom.js");
var _size = require("../size.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/webgl/TileTexture
 */
/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {boolean} interpolate Interpolate when resampling.
 */
function bindAndConfigure(gl, texture, interpolate) {
  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}

/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").ImageLike} image The image.
 * @param {boolean} interpolate Interpolate when resampling.
 */
function uploadImageTexture(gl, texture, image, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}

/**
 * @param {import("./Helper.js").default} helper The WebGL helper.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").ArrayLike} data The pixel data.
 * @param {import("../size.js").Size} size The pixel size.
 * @param {number} bandCount The band count.
 * @param {boolean} interpolate Interpolate when resampling.
 */
function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
  var gl = helper.getGL();
  var textureType;
  var canInterpolate;
  if (data instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension('OES_texture_float');
    var extension = helper.getExtension('OES_texture_float_linear');
    canInterpolate = extension !== null;
  } else {
    textureType = gl.UNSIGNED_BYTE;
    canInterpolate = true;
  }
  bindAndConfigure(gl, texture, interpolate && canInterpolate);
  var bytesPerRow = data.byteLength / size[1];
  var unpackAlignment = 1;
  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }
  var format;
  switch (bandCount) {
    case 1:
      {
        format = gl.LUMINANCE;
        break;
      }
    case 2:
      {
        format = gl.LUMINANCE_ALPHA;
        break;
      }
    case 3:
      {
        format = gl.RGB;
        break;
      }
    case 4:
      {
        format = gl.RGBA;
        break;
      }
    default:
      {
        throw new Error("Unsupported number of bands: ".concat(bandCount));
      }
  }
  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}

/**
 * @type {CanvasRenderingContext2D}
 */
var pixelContext = null;
function createPixelContext() {
  pixelContext = (0, _dom.createCanvasContext2D)(1, 1, undefined, {
    willReadFrequently: true
  });
}

/**
 * @typedef {import("../DataTile.js").default|ImageTile|ReprojTile} TileType
 */

/**
 * @extends {BaseTileRepresentation<TileType>}
 */
var TileTexture = /*#__PURE__*/function (_BaseTileRepresentati) {
  _inherits(TileTexture, _BaseTileRepresentati);
  var _super = _createSuper(TileTexture);
  /**
   * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
   */
  function TileTexture(options) {
    var _this;
    _classCallCheck(this, TileTexture);
    _this = _super.call(this, options);

    /**
     * @type {Array<WebGLTexture>}
     */
    _this.textures = [];

    /**
     * @type {import("../size.js").Size}
     * @private
     */
    _this.renderSize_ = (0, _size.toSize)(options.grid.getTileSize(options.tile.tileCoord[0]));

    /**
     * @type {number}
     */
    _this.bandCount = NaN;
    var coords = new _Buffer.default(_webgl.ARRAY_BUFFER, _webgl.STATIC_DRAW);
    coords.fromArray([0,
    // P0
    1, 1,
    // P1
    1, 1,
    // P2
    0, 0,
    // P3
    0]);
    _this.helper_.flushBufferData(coords);

    /**
     * @type {WebGLArrayBuffer}
     */
    _this.coords = coords;
    _this.setTile(options.tile);
    return _this;
  }
  _createClass(TileTexture, [{
    key: "uploadTile",
    value: function uploadTile() {
      var helper = this.helper_;
      var gl = helper.getGL();
      var tile = this.tile;
      this.textures.length = 0;

      /**
       * @type {import("../DataTile.js").Data}
       */
      var data;
      if (tile instanceof _ImageTile.default || tile instanceof _Tile.default) {
        data = tile.getImage();
      } else {
        data = tile.getData();
      }
      var image = (0, _DataTile.asImageLike)(data);
      if (image) {
        var texture = gl.createTexture();
        this.textures.push(texture);
        this.bandCount = 4;
        uploadImageTexture(gl, texture, image, tile.interpolate);
        this.setReady();
        return;
      }
      data = (0, _DataTile.asArrayLike)(data);
      var sourceTileSize = /** @type {DataTile} */tile.getSize();
      var pixelSize = [sourceTileSize[0] + 2 * this.gutter_, sourceTileSize[1] + 2 * this.gutter_];
      var isFloat = data instanceof Float32Array;
      var pixelCount = pixelSize[0] * pixelSize[1];
      var DataType = isFloat ? Float32Array : Uint8Array;
      var bytesPerElement = DataType.BYTES_PER_ELEMENT;
      var bytesPerRow = data.byteLength / pixelSize[1];
      this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
      var textureCount = Math.ceil(this.bandCount / 4);
      if (textureCount === 1) {
        var _texture = gl.createTexture();
        this.textures.push(_texture);
        uploadDataTexture(helper, _texture, data, pixelSize, this.bandCount, tile.interpolate);
        this.setReady();
        return;
      }
      var textureDataArrays = new Array(textureCount);
      for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
        var _texture2 = gl.createTexture();
        this.textures.push(_texture2);
        var bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
        textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
      }
      var dataIndex = 0;
      var rowOffset = 0;
      var colCount = pixelSize[0] * this.bandCount;
      for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
        for (var colIndex = 0; colIndex < colCount; ++colIndex) {
          var dataValue = data[rowOffset + colIndex];
          var pixelIndex = Math.floor(dataIndex / this.bandCount);
          var bandIndex = colIndex % this.bandCount;
          var _textureIndex = Math.floor(bandIndex / 4);
          var textureData = textureDataArrays[_textureIndex];
          var _bandCount = textureData.length / pixelCount;
          var textureBandIndex = bandIndex % 4;
          textureData[pixelIndex * _bandCount + textureBandIndex] = dataValue;
          ++dataIndex;
        }
        rowOffset += bytesPerRow / bytesPerElement;
      }
      for (var _textureIndex2 = 0; _textureIndex2 < textureCount; ++_textureIndex2) {
        var _texture3 = this.textures[_textureIndex2];
        var _textureData = textureDataArrays[_textureIndex2];
        var _bandCount2 = _textureData.length / pixelCount;
        uploadDataTexture(helper, _texture3, _textureData, pixelSize, _bandCount2, tile.interpolate);
      }
      this.setReady();
    }
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      var gl = this.helper_.getGL();
      this.helper_.deleteBuffer(this.coords);
      for (var i = 0; i < this.textures.length; ++i) {
        gl.deleteTexture(this.textures[i]);
      }
      this.tile.removeEventListener(_EventType.default.CHANGE, this.handleTileChange_);
    }

    /**
     * @param {import("../DataTile.js").ImageLike} image The image.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {Uint8ClampedArray|null} The data.
     * @private
     */
  }, {
    key: "getImagePixelData_",
    value: function getImagePixelData_(image, renderCol, renderRow) {
      var gutter = this.gutter_;
      var renderWidth = this.renderSize_[0];
      var renderHeight = this.renderSize_[1];
      if (!pixelContext) {
        createPixelContext();
      }
      pixelContext.clearRect(0, 0, 1, 1);
      var sourceWidth = image.width;
      var sourceHeight = image.height;
      var sourceWidthWithoutGutter = sourceWidth - 2 * gutter;
      var sourceHeightWithoutGutter = sourceHeight - 2 * gutter;
      var sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
      var sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
      var data;
      try {
        pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);
        data = pixelContext.getImageData(0, 0, 1, 1).data;
      } catch (err) {
        pixelContext = null;
        return null;
      }
      return data;
    }

    /**
     * @param {import("../DataTile.js").ArrayLike} data The data.
     * @param {import("../size.js").Size} sourceSize The size.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {import("../DataTile.js").ArrayLike|null} The data.
     * @private
     */
  }, {
    key: "getArrayPixelData_",
    value: function getArrayPixelData_(data, sourceSize, renderCol, renderRow) {
      var gutter = this.gutter_;
      var renderWidth = this.renderSize_[0];
      var renderHeight = this.renderSize_[1];
      var sourceWidthWithoutGutter = sourceSize[0];
      var sourceHeightWithoutGutter = sourceSize[1];
      var sourceWidth = sourceWidthWithoutGutter + 2 * gutter;
      var sourceHeight = sourceHeightWithoutGutter + 2 * gutter;
      var sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
      var sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
      if (data instanceof DataView) {
        var bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);
        var _offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);
        var buffer = data.buffer.slice(_offset, _offset + bytesPerPixel);
        return new DataView(buffer);
      }
      var offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);
      return data.slice(offset, offset + this.bandCount);
    }

    /**
     * Get data for a pixel.  If the tile is not loaded, null is returned.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {import("../DataTile.js").ArrayLike|null} The data.
     */
  }, {
    key: "getPixelData",
    value: function getPixelData(renderCol, renderRow) {
      if (!this.loaded) {
        return null;
      }
      if (this.tile instanceof _DataTile.default) {
        var data = this.tile.getData();
        var arrayData = (0, _DataTile.asArrayLike)(data);
        if (arrayData) {
          var sourceSize = this.tile.getSize();
          return this.getArrayPixelData_(arrayData, sourceSize, renderCol, renderRow);
        }
        return this.getImagePixelData_((0, _DataTile.asImageLike)(data), renderCol, renderRow);
      }
      return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);
    }
  }]);
  return TileTexture;
}(_BaseTileRepresentation.default);
var _default = exports.default = TileTexture;
},{"./BaseTileRepresentation.js":"node_modules/ol/webgl/BaseTileRepresentation.js","../DataTile.js":"node_modules/ol/DataTile.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","./Buffer.js":"node_modules/ol/webgl/Buffer.js","../webgl.js":"node_modules/ol/webgl.js","../dom.js":"node_modules/ol/dom.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/renderer/webgl/TileLayerBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Uniforms = void 0;
exports.getCacheKey = getCacheKey;
exports.newTileRepresentationLookup = newTileRepresentationLookup;
var _LRUCache = _interopRequireDefault(require("../../structs/LRUCache.js"));
var _DataTile = _interopRequireDefault(require("../../reproj/DataTile.js"));
var _Tile = _interopRequireDefault(require("../../reproj/Tile.js"));
var _TileRange = _interopRequireDefault(require("../../TileRange.js"));
var _TileState = _interopRequireDefault(require("../../TileState.js"));
var _Layer = _interopRequireDefault(require("./Layer.js"));
var _util = require("../../util.js");
var _mat = require("../../vec/mat4.js");
var _tilecoord = require("../../tilecoord.js");
var _transform = require("../../transform.js");
var _array = require("../../array.js");
var _proj = require("../../proj.js");
var _extent = require("../../extent.js");
var _size = require("../../size.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/webgl/TileLayerBase
 */
var Uniforms = exports.Uniforms = {
  TILE_TRANSFORM: 'u_tileTransform',
  TRANSITION_ALPHA: 'u_transitionAlpha',
  DEPTH: 'u_depth',
  RENDER_EXTENT: 'u_renderExtent',
  // intersection of layer, source, and view extent
  PATTERN_ORIGIN: 'u_patternOrigin',
  RESOLUTION: 'u_resolution',
  ZOOM: 'u_zoom',
  GLOBAL_ALPHA: 'u_globalAlpha',
  PROJECTION_MATRIX: 'u_projectionMatrix',
  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix'
};

/**
 * @type {Object<string, boolean>}
 */
var empty = {};

/**
 * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values
 * have a depth trending towards 0
 * @param {number} z A zoom level.
 * @return {number} A depth value.
 */
function depthForZ(z) {
  return 1 / (z + 2);
}

/**
 * @typedef {import("../../webgl/BaseTileRepresentation.js").default<import("../../Tile.js").default>} AbstractTileRepresentation
 */
/**
 * @typedef {Object} TileRepresentationLookup
 * @property {Set<string>} tileIds The set of tile ids in the lookup.
 * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.
 */

/**
 * @return {TileRepresentationLookup} A new tile representation lookup.
 */
function newTileRepresentationLookup() {
  return {
    tileIds: new Set(),
    representationsByZ: {}
  };
}

/**
 * Check if a tile is already in the tile representation lookup.
 * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.
 * @param {import("../../Tile.js").default} tile A tile.
 * @return {boolean} The tile is already in the lookup.
 */
function lookupHasTile(tileRepresentationLookup, tile) {
  return tileRepresentationLookup.tileIds.has((0, _util.getUid)(tile));
}

/**
 * Add a tile representation to the lookup.
 * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.
 * @param {AbstractTileRepresentation} tileRepresentation A tile representation.
 * @param {number} z The zoom level.
 */
function addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z) {
  var representationsByZ = tileRepresentationLookup.representationsByZ;
  if (!(z in representationsByZ)) {
    representationsByZ[z] = new Set();
  }
  representationsByZ[z].add(tileRepresentation);
  tileRepresentationLookup.tileIds.add((0, _util.getUid)(tileRepresentation.tile));
}

/**
 * @param {import("../../Map.js").FrameState} frameState Frame state.
 * @param {import("../../extent.js").Extent} extent The frame extent.
 * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
 */
function getRenderExtent(frameState, extent) {
  var layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = (0, _extent.getIntersection)(extent, (0, _proj.fromUserExtent)(layerState.extent, frameState.viewState.projection));
  }
  var source = /** @type {import("../../source/Tile.js").default} */
  layerState.layer.getRenderSource();
  if (!source.getWrapX()) {
    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = (0, _extent.getIntersection)(extent, gridExtent);
    }
  }
  return extent;
}
function getCacheKey(source, tileCoord) {
  return "".concat(source.getKey(), ",").concat((0, _tilecoord.getKey)(tileCoord));
}

/**
 * @typedef {Object} Options
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {number} [cacheSize=512] The tile representation cache size.
 * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.
 */

/**
 * @typedef {import("../../layer/BaseTile.js").default} BaseLayerType
 */

/**
 * @classdesc
 * Base WebGL renderer for tile layers.
 * @template {BaseLayerType} LayerType
 * @template {import("../../Tile.js").default} TileType
 * @template {import("../../webgl/BaseTileRepresentation.js").default<TileType>} TileRepresentation
 * @extends {WebGLLayerRenderer<LayerType>}
 */
var WebGLBaseTileLayerRenderer = /*#__PURE__*/function (_WebGLLayerRenderer) {
  _inherits(WebGLBaseTileLayerRenderer, _WebGLLayerRenderer);
  var _super = _createSuper(WebGLBaseTileLayerRenderer);
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */
  function WebGLBaseTileLayerRenderer(tileLayer, options) {
    var _this;
    _classCallCheck(this, WebGLBaseTileLayerRenderer);
    _this = _super.call(this, tileLayer, {
      uniforms: options.uniforms,
      postProcesses: options.postProcesses
    });

    /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */
    _this.renderComplete = false;

    /**
     * This transform converts representation coordinates to screen coordinates.
     * @type {import("../../transform.js").Transform}
     * @private
     */
    _this.tileTransform_ = (0, _transform.create)();

    /**
     * @type {Array<number>}
     * @protected
     */
    _this.tempMat4 = (0, _mat.create)();

    /**
     * @type {import("../../TileRange.js").default}
     * @private
     */
    _this.tempTileRange_ = new _TileRange.default(0, 0, 0, 0);

    /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */
    _this.tempTileCoord_ = (0, _tilecoord.createOrUpdate)(0, 0, 0);

    /**
     * @type {import("../../size.js").Size}
     * @private
     */
    _this.tempSize_ = [0, 0];
    var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;
    /**
     * @type {import("../../structs/LRUCache.js").default<TileRepresentation>}
     * @protected
     */
    _this.tileRepresentationCache = new _LRUCache.default(cacheSize);

    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    _this.frameState = null;

    /**
     * @private
     * @type {import("../../proj/Projection.js").default}
     */
    _this.projection_ = undefined;
    return _this;
  }

  /**
   * @param {Options} options Options.
   */
  _createClass(WebGLBaseTileLayerRenderer, [{
    key: "reset",
    value: function reset(options) {
      _get(_getPrototypeOf(WebGLBaseTileLayerRenderer.prototype), "reset", this).call(this, {
        uniforms: options.uniforms
      });
    }

    /**
     * @param {TileType} tile Tile.
     * @return {boolean} Tile is drawable.
     * @private
     */
  }, {
    key: "isDrawableTile_",
    value: function isDrawableTile_(tile) {
      var tileLayer = this.getLayer();
      var tileState = tile.getState();
      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
      return tileState == _TileState.default.LOADED || tileState == _TileState.default.EMPTY || tileState == _TileState.default.ERROR && !useInterimTilesOnError;
    }

    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrameInternal",
    value: function prepareFrameInternal(frameState) {
      if (!this.projection_) {
        this.projection_ = frameState.viewState.projection;
      } else if (frameState.viewState.projection !== this.projection_) {
        this.clearCache();
        this.projection_ = frameState.viewState.projection;
      }
      var layer = this.getLayer();
      var source = layer.getRenderSource();
      if (!source) {
        return false;
      }
      if ((0, _extent.isEmpty)(getRenderExtent(frameState, frameState.extent))) {
        return false;
      }
      return source.getState() === 'ready';
    }

    /**
     * @abstract
     * @param {import("../../webgl/BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options tile representation options
     * @return {TileRepresentation} A new tile representation
     * @protected
     */
  }, {
    key: "createTileRepresentation",
    value: function createTileRepresentation(options) {
      return (0, _util.abstract)();
    }

    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.
     * @param {number} preload Number of additional levels to load.
     */
  }, {
    key: "enqueueTiles",
    value: function enqueueTiles(frameState, extent, initialZ, tileRepresentationLookup, preload) {
      var viewState = frameState.viewState;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getRenderSource();
      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
      var gutter = tileSource.getGutterForProjection(viewState.projection);
      var tileSourceKey = (0, _util.getUid)(tileSource);
      if (!(tileSourceKey in frameState.wantedTiles)) {
        frameState.wantedTiles[tileSourceKey] = {};
      }
      var wantedTiles = frameState.wantedTiles[tileSourceKey];
      var tileRepresentationCache = this.tileRepresentationCache;
      var map = tileLayer.getMapInternal();
      var minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));
      for (var z = initialZ; z >= minZ; --z) {
        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
        var tileResolution = tileGrid.getResolution(z);
        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
            var tileCoord = (0, _tilecoord.createOrUpdate)(z, x, y, this.tempTileCoord_);
            var cacheKey = getCacheKey(tileSource, tileCoord);

            /** @type {TileRepresentation} */
            var tileRepresentation = void 0;

            /** @type {TileType} */
            var tile = void 0;
            if (tileRepresentationCache.containsKey(cacheKey)) {
              tileRepresentation = tileRepresentationCache.get(cacheKey);
              tile = tileRepresentation.tile;
            }
            if (!tileRepresentation || tileRepresentation.tile.key !== tileSource.getKey()) {
              tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);
            }
            if (lookupHasTile(tileRepresentationLookup, tile)) {
              continue;
            }
            if (!tileRepresentation) {
              tileRepresentation = this.createTileRepresentation({
                tile: tile,
                grid: tileGrid,
                helper: this.helper,
                gutter: gutter
              });
              tileRepresentationCache.set(cacheKey, tileRepresentation);
            } else {
              if (this.isDrawableTile_(tile)) {
                tileRepresentation.setTile(tile);
              } else {
                var interimTile = /** @type {TileType} */
                tile.getInterimTile();
                tileRepresentation.setTile(interimTile);
              }
            }
            addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z);
            var tileQueueKey = tile.getKey();
            wantedTiles[tileQueueKey] = true;
            if (tile.getState() === _TileState.default.IDLE) {
              if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
                frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);
              }
            }
          }
        }
      }
    }

    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha
     * @protected
     */
  }, {
    key: "beforeTilesRender",
    value: function beforeTilesRender(frameState, tilesWithAlpha) {
      this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);
    }

    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} If returns false, tile mask rendering will be skipped
     * @protected
     */
  }, {
    key: "beforeTilesMaskRender",
    value: function beforeTilesMaskRender(frameState) {
      return false;
    }

    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {import("../../transform.js").Transform} tileTransform Tile transform
     * @param {import("../../Map.js").FrameState} frameState Frame state
     * @param {import("../../extent.js").Extent} renderExtent Render extent
     * @param {number} tileResolution Tile resolution
     * @param {import("../../size.js").Size} tileSize Tile size
     * @param {import("../../coordinate.js").Coordinate} tileOrigin Tile origin
     * @param {import("../../extent.js").Extent} tileExtent tile Extent
     * @param {number} depth Depth
     * @param {number} gutter Gutter
     * @param {number} alpha Alpha
     * @protected
     */
  }, {
    key: "renderTile",
    value: function renderTile(tileRepresentation, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {}

    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {number} tileZ Tile Z
     * @param {import("../../extent.js").Extent} extent Render extent
     * @param {number} depth Depth
     * @protected
     */
  }, {
    key: "renderTileMask",
    value: function renderTileMask(tileRepresentation, tileZ, extent, depth) {}
  }, {
    key: "drawTile_",
    value: function drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid) {
      if (!tileRepresentation.ready) {
        return;
      }
      var tile = tileRepresentation.tile;
      var tileCoord = tile.tileCoord;
      var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);
      var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
      var tileResolution = tileGrid.getResolution(tileZ);
      var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileZ), this.tempSize_);
      var tileOrigin = tileGrid.getOrigin(tileZ);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
      // tiles with alpha are rendered last to allow blending
      var depth = alpha < 1 ? -1 : depthForZ(tileZ);
      if (alpha < 1) {
        frameState.animate = true;
      }
      var viewState = frameState.viewState;
      var centerX = viewState.center[0];
      var centerY = viewState.center[1];
      var tileWidthWithGutter = tileSize[0] + 2 * gutter;
      var tileHeightWithGutter = tileSize[1] + 2 * gutter;
      var aspectRatio = tileWidthWithGutter / tileHeightWithGutter;
      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      var tileScale = viewState.resolution / tileResolution;
      var tileCenterI = tileCoord[1];
      var tileCenterJ = tileCoord[2];
      (0, _transform.reset)(this.tileTransform_);
      (0, _transform.scale)(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));
      (0, _transform.rotate)(this.tileTransform_, viewState.rotation);
      (0, _transform.scale)(this.tileTransform_, 1, 1 / aspectRatio);
      (0, _transform.translate)(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);
      this.renderTile( /** @type {TileRepresentation} */tileRepresentation, this.tileTransform_, frameState, extent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha);
    }

    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      var _this2 = this;
      this.frameState = frameState;
      this.renderComplete = true;
      var gl = this.helper.getGL();
      this.preRender(gl, frameState);
      var viewState = frameState.viewState;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getRenderSource();
      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
      var gutter = tileSource.getGutterForProjection(viewState.projection);
      var extent = getRenderExtent(frameState, frameState.extent);
      var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);

      /**
       * @type {TileRepresentationLookup}
       */
      var tileRepresentationLookup = newTileRepresentationLookup();
      var preload = tileLayer.getPreload();
      if (frameState.nextExtent) {
        var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
        var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
        this.enqueueTiles(frameState, nextExtent, targetZ, tileRepresentationLookup, preload);
      }
      this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);
      if (preload > 0) {
        setTimeout(function () {
          _this2.enqueueTiles(frameState, extent, z - 1, tileRepresentationLookup, preload - 1);
        }, 0);
      }

      /**
       * A lookup of alpha values for tiles at the target rendering resolution
       * for tiles that are in transition.  If a tile coord key is absent from
       * this lookup, the tile should be rendered at alpha 1.
       * @type {Object<string, number>}
       */
      var alphaLookup = {};
      var uid = (0, _util.getUid)(this);
      var time = frameState.time;
      var blend = false;

      // look for cached tiles to use if a target tile is not ready
      var _iterator = _createForOfIteratorHelper(tileRepresentationLookup.representationsByZ[z]),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _tileRepresentation3 = _step.value;
          var tile = _tileRepresentation3.tile;
          if ((tile instanceof _Tile.default || tile instanceof _DataTile.default) && tile.getState() === _TileState.default.EMPTY) {
            continue;
          }
          var _tileCoord2 = tile.tileCoord;
          if (_tileRepresentation3.ready) {
            var alpha = tile.getAlpha(uid, time);
            if (alpha === 1) {
              // no need to look for alt tiles
              tile.endTransition(uid);
              continue;
            }
            blend = true;
            var _tileCoordKey2 = (0, _tilecoord.getKey)(_tileCoord2);
            alphaLookup[_tileCoordKey2] = alpha;
          }
          this.renderComplete = false;

          // first look for child tiles (at z + 1)
          var coveredByChildren = this.findAltTiles_(tileGrid, _tileCoord2, z + 1, tileRepresentationLookup);
          if (coveredByChildren) {
            continue;
          }

          // next look for parent tiles
          var minZoom = tileGrid.getMinZoom();
          for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {
            var coveredByParent = this.findAltTiles_(tileGrid, _tileCoord2, parentZ, tileRepresentationLookup);
            if (coveredByParent) {
              break;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var representationsByZ = tileRepresentationLookup.representationsByZ;
      var zs = Object.keys(representationsByZ).map(Number).sort(_array.descending);
      var renderTileMask = this.beforeTilesMaskRender(frameState);
      if (renderTileMask) {
        for (var j = 0, jj = zs.length; j < jj; ++j) {
          var tileZ = zs[j];
          var _iterator2 = _createForOfIteratorHelper(representationsByZ[tileZ]),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var tileRepresentation = _step2.value;
              var tileCoord = tileRepresentation.tile.tileCoord;
              var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);
              // do not render the tile mask if alpha < 1
              if (tileCoordKey in alphaLookup) {
                continue;
              }
              var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
              this.renderTileMask( /** @type {TileRepresentation} */tileRepresentation, tileZ, tileExtent, depthForZ(tileZ));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
      this.beforeTilesRender(frameState, blend);
      for (var _j = 0, _jj = zs.length; _j < _jj; ++_j) {
        var _tileZ = zs[_j];
        var _iterator3 = _createForOfIteratorHelper(representationsByZ[_tileZ]),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _tileRepresentation = _step3.value;
            var _tileCoord = _tileRepresentation.tile.tileCoord;
            var _tileCoordKey = (0, _tilecoord.getKey)(_tileCoord);
            if (_tileCoordKey in alphaLookup) {
              continue;
            }
            this.drawTile_(frameState, _tileRepresentation, _tileZ, gutter, extent, alphaLookup, tileGrid);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      var _iterator4 = _createForOfIteratorHelper(representationsByZ[z]),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _tileRepresentation4 = _step4.value;
          var _tileCoord3 = _tileRepresentation4.tile.tileCoord;
          var _tileCoordKey3 = (0, _tilecoord.getKey)(_tileCoord3);
          if (_tileCoordKey3 in alphaLookup) {
            this.drawTile_(frameState, _tileRepresentation4, z, gutter, extent, alphaLookup, tileGrid);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
      var canvas = this.helper.getCanvas();
      var tileRepresentationCache = this.tileRepresentationCache;
      while (tileRepresentationCache.canExpireCache()) {
        var _tileRepresentation2 = tileRepresentationCache.pop();
        _tileRepresentation2.dispose();
      }

      // TODO: let the renderers manage their own cache instead of managing the source cache
      /**
       * Here we unconditionally expire the source cache since the renderer maintains
       * its own cache.
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function postRenderFunction(map, frameState) {
        tileSource.updateCacheSize(0.1, frameState.viewState.projection);
        tileSource.expireCache(frameState.viewState.projection, empty);
      };
      frameState.postRenderFunctions.push(postRenderFunction);
      this.postRender(gl, frameState);
      return canvas;
    }

    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile representation lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of
     * tile representations by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
  }, {
    key: "findAltTiles_",
    value: function findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {
      var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
      if (!tileRange) {
        return false;
      }
      var covered = true;
      var tileRepresentationCache = this.tileRepresentationCache;
      var source = this.getLayer().getRenderSource();
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          var cacheKey = getCacheKey(source, [altZ, x, y]);
          var loaded = false;
          if (tileRepresentationCache.containsKey(cacheKey)) {
            var tileRepresentation = tileRepresentationCache.get(cacheKey);
            if (tileRepresentation.ready && !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)) {
              addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, altZ);
              loaded = true;
            }
          }
          if (!loaded) {
            covered = false;
          }
        }
      }
      return covered;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      var tileRepresentationCache = this.tileRepresentationCache;
      tileRepresentationCache.forEach(function (tileRepresentation) {
        return tileRepresentation.dispose();
      });
      tileRepresentationCache.clear();
    }
  }, {
    key: "removeHelper",
    value: function removeHelper() {
      if (this.helper) {
        this.clearCache();
      }
      _get(_getPrototypeOf(WebGLBaseTileLayerRenderer.prototype), "removeHelper", this).call(this);
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      _get(_getPrototypeOf(WebGLBaseTileLayerRenderer.prototype), "disposeInternal", this).call(this);
      delete this.frameState;
    }
  }]);
  return WebGLBaseTileLayerRenderer;
}(_Layer.default);
var _default = exports.default = WebGLBaseTileLayerRenderer;
},{"../../structs/LRUCache.js":"node_modules/ol/structs/LRUCache.js","../../reproj/DataTile.js":"node_modules/ol/reproj/DataTile.js","../../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","../../TileRange.js":"node_modules/ol/TileRange.js","../../TileState.js":"node_modules/ol/TileState.js","./Layer.js":"node_modules/ol/renderer/webgl/Layer.js","../../util.js":"node_modules/ol/util.js","../../vec/mat4.js":"node_modules/ol/vec/mat4.js","../../tilecoord.js":"node_modules/ol/tilecoord.js","../../transform.js":"node_modules/ol/transform.js","../../array.js":"node_modules/ol/array.js","../../proj.js":"node_modules/ol/proj.js","../../extent.js":"node_modules/ol/extent.js","../../size.js":"node_modules/ol/size.js"}],"node_modules/ol/renderer/webgl/TileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Uniforms = exports.Attributes = void 0;
var _DataTile = _interopRequireDefault(require("../../reproj/DataTile.js"));
var _Tile = _interopRequireDefault(require("../../reproj/Tile.js"));
var _TileState = _interopRequireDefault(require("../../TileState.js"));
var _TileTexture = _interopRequireDefault(require("../../webgl/TileTexture.js"));
var _Buffer = _interopRequireDefault(require("../../webgl/Buffer.js"));
var _TileLayerBase = _interopRequireWildcard(require("./TileLayerBase.js"));
var _Helper = require("../../webgl/Helper.js");
var _webgl = require("../../webgl.js");
var _transform = require("../../transform.js");
var _extent = require("../../extent.js");
var _proj = require("../../proj.js");
var _mat = require("../../vec/mat4.js");
var _size = require("../../size.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/renderer/webgl/TileLayer
 */
var Uniforms = exports.Uniforms = _objectSpread(_objectSpread({}, _TileLayerBase.Uniforms), {}, {
  TILE_TEXTURE_ARRAY: 'u_tileTextures',
  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',
  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',
  TEXTURE_RESOLUTION: 'u_textureResolution',
  // map units per texture pixel
  TEXTURE_ORIGIN_X: 'u_textureOriginX',
  // map x coordinate of left edge of texture
  TEXTURE_ORIGIN_Y: 'u_textureOriginY' // map y coordinate of top edge of texture
});
var Attributes = exports.Attributes = {
  TEXTURE_COORD: 'a_textureCoord'
};

/**
 * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
 */
var attributeDescriptions = [{
  name: Attributes.TEXTURE_COORD,
  size: 2,
  type: _Helper.AttributeType.FLOAT
}];

/**
 * @typedef {Object} Options
 * @property {string} vertexShader Vertex shader source.
 * @property {string} fragmentShader Fragment shader source.
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {Array<import("../../webgl/PaletteTexture.js").default>} [paletteTextures] Palette textures.
 * @property {number} [cacheSize=512] The texture cache size.
 */

/**
 * @typedef {import("../../layer/WebGLTile.js").default} LayerType
 */
/**
 * @typedef {import("../../webgl/TileTexture.js").TileType} TileTextureType
 */
/**
 * @typedef {import("../../webgl/TileTexture.js").default} TileTextureRepresentation
 */

/**
 * @classdesc
 * WebGL renderer for tile layers.
 * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}
 * @api
 */
var WebGLTileLayerRenderer = /*#__PURE__*/function (_WebGLBaseTileLayerRe) {
  _inherits(WebGLTileLayerRenderer, _WebGLBaseTileLayerRe);
  var _super = _createSuper(WebGLTileLayerRenderer);
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */
  function WebGLTileLayerRenderer(tileLayer, options) {
    var _this;
    _classCallCheck(this, WebGLTileLayerRenderer);
    _this = _super.call(this, tileLayer, options);

    /**
     * @type {WebGLProgram}
     * @private
     */
    _this.program_;

    /**
     * @private
     */
    _this.vertexShader_ = options.vertexShader;

    /**
     * @private
     */
    _this.fragmentShader_ = options.fragmentShader;

    /**
     * Tiles are rendered as a quad with the following structure:
     *
     *  [P3]---------[P2]
     *   |`           |
     *   |  `     B   |
     *   |    `       |
     *   |      `     |
     *   |   A    `   |
     *   |          ` |
     *  [P0]---------[P1]
     *
     * Triangle A: P0, P1, P3
     * Triangle B: P1, P2, P3
     *
     * @private
     */
    _this.indices_ = new _Buffer.default(_webgl.ELEMENT_ARRAY_BUFFER, _webgl.STATIC_DRAW);
    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);

    /**
     * @type {Array<import("../../webgl/PaletteTexture.js").default>}
     * @private
     */
    _this.paletteTextures_ = options.paletteTextures || [];
    return _this;
  }

  /**
   * @param {Options} options Options.
   */
  _createClass(WebGLTileLayerRenderer, [{
    key: "reset",
    value: function reset(options) {
      _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "reset", this).call(this, options);
      this.vertexShader_ = options.vertexShader;
      this.fragmentShader_ = options.fragmentShader;
      this.paletteTextures_ = options.paletteTextures || [];
      if (this.helper) {
        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
      }
    }
  }, {
    key: "afterHelperCreated",
    value: function afterHelperCreated() {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
      this.helper.flushBufferData(this.indices_);
    }
  }, {
    key: "createTileRepresentation",
    value: function createTileRepresentation(options) {
      return new _TileTexture.default(options);
    }
  }, {
    key: "beforeTilesRender",
    value: function beforeTilesRender(frameState, tilesWithAlpha) {
      _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "beforeTilesRender", this).call(this, frameState, tilesWithAlpha);
      this.helper.useProgram(this.program_, frameState);
    }
  }, {
    key: "renderTile",
    value: function renderTile(tileTexture, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {
      var gl = this.helper.getGL();
      this.helper.bindBuffer(tileTexture.coords);
      this.helper.bindBuffer(this.indices_);
      this.helper.enableAttributes(attributeDescriptions);
      var textureSlot = 0;
      while (textureSlot < tileTexture.textures.length) {
        var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
        this.helper.bindTexture(tileTexture.textures[textureSlot], textureSlot, uniformName);
        ++textureSlot;
      }
      for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
        var paletteTexture = this.paletteTextures_[paletteIndex];
        var texture = paletteTexture.getTexture(gl);
        this.helper.bindTexture(texture, textureSlot, paletteTexture.name);
        ++textureSlot;
      }
      var viewState = frameState.viewState;
      var tileWidthWithGutter = tileSize[0] + 2 * gutter;
      var tileHeightWithGutter = tileSize[1] + 2 * gutter;
      var tile = tileTexture.tile;
      var tileCoord = tile.tileCoord;
      var tileCenterI = tileCoord[1];
      var tileCenterJ = tileCoord[2];
      this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, (0, _mat.fromTransform)(this.tempMat4, tileTransform));
      this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
      this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
      var gutterExtent = renderExtent;
      if (gutter > 0) {
        gutterExtent = tileExtent;
        (0, _extent.getIntersection)(gutterExtent, renderExtent, gutterExtent);
      }
      this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);
      this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
      this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
      this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);
      this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);
      this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
      this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);
      this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);
      this.helper.drawElements(0, this.indices_.getSize());
    }

    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
     */
  }, {
    key: "getData",
    value: function getData(pixel) {
      var gl = this.helper.getGL();
      if (!gl) {
        return null;
      }
      var frameState = this.frameState;
      if (!frameState) {
        return null;
      }
      var layer = this.getLayer();
      var coordinate = (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      var viewState = frameState.viewState;
      var layerExtent = layer.getExtent();
      if (layerExtent) {
        if (!(0, _extent.containsCoordinate)((0, _proj.fromUserExtent)(layerExtent, viewState.projection), coordinate)) {
          return null;
        }
      }

      // determine last source suitable for rendering at coordinate
      var sources = layer.getSources((0, _extent.boundingExtent)([coordinate]), viewState.resolution);
      var i, source, tileGrid;
      for (i = sources.length - 1; i >= 0; --i) {
        source = sources[i];
        if (source.getState() === 'ready') {
          tileGrid = source.getTileGridForProjection(viewState.projection);
          if (source.getWrapX()) {
            break;
          }
          var gridExtent = tileGrid.getExtent();
          if (!gridExtent || (0, _extent.containsCoordinate)(gridExtent, coordinate)) {
            break;
          }
        }
      }
      if (i < 0) {
        return null;
      }
      var tileTextureCache = this.tileRepresentationCache;
      for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
        var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
        var cacheKey = (0, _TileLayerBase.getCacheKey)(source, tileCoord);
        if (!tileTextureCache.containsKey(cacheKey)) {
          continue;
        }
        var tileTexture = tileTextureCache.get(cacheKey);
        var tile = tileTexture.tile;
        if ((tile instanceof _Tile.default || tile instanceof _DataTile.default) && tile.getState() === _TileState.default.EMPTY) {
          return null;
        }
        if (!tileTexture.loaded) {
          continue;
        }
        var tileOrigin = tileGrid.getOrigin(z);
        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z));
        var tileResolution = tileGrid.getResolution(z);
        var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
        var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
        return tileTexture.getPixelData(col, row);
      }
      return null;
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      var helper = this.helper;
      if (helper) {
        var gl = helper.getGL();
        gl.deleteProgram(this.program_);
        delete this.program_;
        helper.deleteBuffer(this.indices_);
      }
      _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "disposeInternal", this).call(this);
      delete this.indices_;
    }
  }]);
  return WebGLTileLayerRenderer;
}(_TileLayerBase.default);
var _default = exports.default = WebGLTileLayerRenderer;
},{"../../reproj/DataTile.js":"node_modules/ol/reproj/DataTile.js","../../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","../../TileState.js":"node_modules/ol/TileState.js","../../webgl/TileTexture.js":"node_modules/ol/webgl/TileTexture.js","../../webgl/Buffer.js":"node_modules/ol/webgl/Buffer.js","./TileLayerBase.js":"node_modules/ol/renderer/webgl/TileLayerBase.js","../../webgl/Helper.js":"node_modules/ol/webgl/Helper.js","../../webgl.js":"node_modules/ol/webgl.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../proj.js":"node_modules/ol/proj.js","../../vec/mat4.js":"node_modules/ol/vec/mat4.js","../../size.js":"node_modules/ol/size.js"}],"node_modules/ol/expr/gpu.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PALETTE_TEXTURE_ARRAY = void 0;
exports.arrayToGlsl = arrayToGlsl;
exports.buildExpression = buildExpression;
exports.colorToGlsl = colorToGlsl;
exports.getStringNumberEquivalent = getStringNumberEquivalent;
exports.newCompilationContext = newCompilationContext;
exports.numberToGlsl = numberToGlsl;
exports.stringToGlsl = stringToGlsl;
exports.uniformNameForVariable = uniformNameForVariable;
var _PaletteTexture = _interopRequireDefault(require("../webgl/PaletteTexture.js"));
var _expression = require("./expression.js");
var _TileLayer = require("../renderer/webgl/TileLayer.js");
var _color = require("../color.js");
var _compilers;
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } /**
 * @module ol/expr/gpu
 */
/**
 * @param {string} operator Operator
 * @param {CompilationContext} context Compilation context
 * @return {string} A function name based on the operator, unique in the given context
 */
function computeOperatorFunctionName(operator, context) {
  return "operator_".concat(operator, "_").concat(Object.keys(context.functions).length);
}

/**
 * Will return the number as a float with a dot separator, which is required by GLSL.
 * @param {number} v Numerical value.
 * @return {string} The value as string.
 */
function numberToGlsl(v) {
  var s = v.toString();
  return s.includes('.') ? s : s + '.0';
}

/**
 * Will return the number array as a float with a dot separator, concatenated with ', '.
 * @param {Array<number>} array Numerical values array.
 * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
 */
function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');
  }
  return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(', '), ")");
}

/**
 * Will normalize and converts to string a `vec4` color array compatible with GLSL.
 * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
 * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
 * Note that the final array will always have 4 components.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */
function colorToGlsl(color) {
  var array = (0, _color.asArray)(color);
  var alpha = array.length > 3 ? array[3] : 1;
  // all components are premultiplied with alpha value
  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);
}

/** @type {Object<string, number>} */
var stringToFloatMap = {};
var stringToFloatCounter = 0;

/**
 * Returns a stable equivalent number for the string literal.
 * @param {string} string String literal value
 * @return {number} Number equivalent
 */
function getStringNumberEquivalent(string) {
  if (!(string in stringToFloatMap)) {
    stringToFloatMap[string] = stringToFloatCounter++;
  }
  return stringToFloatMap[string];
}

/**
 * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
 * converted to be a GLSL-compatible string.
 * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216
 * @param {string} string String literal value
 * @return {string} GLSL-compatible string containing a number
 */
function stringToGlsl(string) {
  return numberToGlsl(getStringNumberEquivalent(string));
}

/**
 * Get the uniform name given a variable name.
 * @param {string} variableName The variable name.
 * @return {string} The uniform name.
 */
function uniformNameForVariable(variableName) {
  return 'u_var_' + variableName;
}

/**
 * @typedef {import('./expression.js').ParsingContext} ParsingContext
 */
/**
 *
 * @typedef {import("./expression.js").Expression} Expression
 */
/**
 *
 * @typedef {import("./expression.js").LiteralExpression} LiteralExpression
 */

/**
 * @typedef {Object} CompilationContextProperty
 * @property {string} name Name
 * @property {number} type Resolved property type
 * @property {function(import("../Feature.js").FeatureLike): *} [evaluator] Function used for evaluating the value;
 */

/**
 * @typedef {Object} CompilationContextVariable
 * @property {string} name Name
 * @property {number} type Resolved variable type
 * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object
 */

/**
 * @typedef {Object} CompilationContext
 * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
 * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.
 * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.
 * @property {Object<string, string>} functions Lookup of functions used by the style.
 * @property {number} [bandCount] Number of bands per pixel.
 * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.
 * @property {import("../style/webgl.js").WebGLStyle} style Literal style.
 */

/**
 * @return {CompilationContext} A new compilation context.
 */
function newCompilationContext() {
  return {
    inFragmentShader: false,
    variables: {},
    properties: {},
    functions: {},
    bandCount: 0,
    style: {}
  };
}
var GET_BAND_VALUE_FUNC = 'getBandValue';
var PALETTE_TEXTURE_ARRAY = exports.PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';

/**
 * @typedef {string} CompiledExpression
 */

/**
 * @typedef {function(CompilationContext, CallExpression, number): string} Compiler
 * Third argument is the expected value types
 */

/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.
 * @param {CompilationContext} compilationContext An existing compilation context
 * @return {CompiledExpression} The compiled expression.
 */
function buildExpression(encoded, type, parsingContext, compilationContext) {
  var expression = (0, _expression.parse)(encoded, parsingContext, type);
  if ((0, _expression.isType)(expression.type, _expression.NoneType)) {
    throw new Error("No matching type was found");
  }
  if (!(0, _expression.overlapsType)(type, expression.type)) {
    var expected = (0, _expression.typeName)(type);
    var actual = (0, _expression.typeName)(expression.type);
    throw new Error("Expected expression to be of type ".concat(expected, ", got ").concat(actual));
  }
  return compile(expression, type, compilationContext);
}

/**
 * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string
 * @return {function(CompilationContext, import("./expression.js").CallExpression, number): string} Compiler for the call expression
 */
function createCompiler(output) {
  return function (context, expression, type) {
    var length = expression.args.length;
    var args = new Array(length);
    for (var i = 0; i < length; ++i) {
      args[i] = compile(expression.args[i], type, context);
    }
    return output(args, context);
  };
}

/**
 * @type {Object<string, Compiler>}
 */
var compilers = (_compilers = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, _expression.Ops.Get, function (context, expression) {
  var firstArg = /** @type {LiteralExpression} */expression.args[0];
  var propName = /** @type {string} */firstArg.value;
  var isExisting = (propName in context.properties);
  if (!isExisting) {
    context.properties[propName] = {
      name: propName,
      type: expression.type
    };
  }
  var prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';
  return prefix + propName;
}), _expression.Ops.GeometryType, function (context, expression, type) {
  var propName = 'geometryType';
  var computeType = function computeType(geometry) {
    var type = geometry.getType();
    switch (type) {
      case 'Point':
      case 'LineString':
      case 'Polygon':
        return type;
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
        return type.substring(5);
      case 'Circle':
        return 'Polygon';
      case 'GeometryCollection':
        return computeType(geometry.getGeometries()[0]);
      default:
    }
  };
  var isExisting = (propName in context.properties);
  if (!isExisting) {
    context.properties[propName] = {
      name: propName,
      type: _expression.StringType,
      evaluator: function evaluator(feature) {
        return computeType(feature.getGeometry());
      }
    };
  }
  var prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';
  return prefix + propName;
}), _expression.Ops.Var, function (context, expression) {
  var firstArg = /** @type {LiteralExpression} */expression.args[0];
  var varName = /** @type {string} */firstArg.value;
  var isExisting = (varName in context.variables);
  if (!isExisting) {
    context.variables[varName] = {
      name: varName,
      type: expression.type
    };
  }
  return uniformNameForVariable(varName);
}), _expression.Ops.Resolution, function () {
  return 'u_resolution';
}), _expression.Ops.Zoom, function () {
  return 'u_zoom';
}), _expression.Ops.Time, function () {
  return 'u_time';
}), _expression.Ops.Any, createCompiler(function (compiledArgs) {
  return "(".concat(compiledArgs.join(" || "), ")");
})), _expression.Ops.All, createCompiler(function (compiledArgs) {
  return "(".concat(compiledArgs.join(" && "), ")");
})), _expression.Ops.Not, createCompiler(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 1),
    value = _ref2[0];
  return "(!".concat(value, ")");
})), _expression.Ops.Equal, createCompiler(function (_ref3) {
  var _ref4 = _slicedToArray(_ref3, 2),
    firstValue = _ref4[0],
    secondValue = _ref4[1];
  return "(".concat(firstValue, " == ").concat(secondValue, ")");
})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, _expression.Ops.NotEqual, createCompiler(function (_ref5) {
  var _ref6 = _slicedToArray(_ref5, 2),
    firstValue = _ref6[0],
    secondValue = _ref6[1];
  return "(".concat(firstValue, " != ").concat(secondValue, ")");
})), _expression.Ops.GreaterThan, createCompiler(function (_ref7) {
  var _ref8 = _slicedToArray(_ref7, 2),
    firstValue = _ref8[0],
    secondValue = _ref8[1];
  return "(".concat(firstValue, " > ").concat(secondValue, ")");
})), _expression.Ops.GreaterThanOrEqualTo, createCompiler(function (_ref9) {
  var _ref10 = _slicedToArray(_ref9, 2),
    firstValue = _ref10[0],
    secondValue = _ref10[1];
  return "(".concat(firstValue, " >= ").concat(secondValue, ")");
})), _expression.Ops.LessThan, createCompiler(function (_ref11) {
  var _ref12 = _slicedToArray(_ref11, 2),
    firstValue = _ref12[0],
    secondValue = _ref12[1];
  return "(".concat(firstValue, " < ").concat(secondValue, ")");
})), _expression.Ops.LessThanOrEqualTo, createCompiler(function (_ref13) {
  var _ref14 = _slicedToArray(_ref13, 2),
    firstValue = _ref14[0],
    secondValue = _ref14[1];
  return "(".concat(firstValue, " <= ").concat(secondValue, ")");
})), _expression.Ops.Multiply, createCompiler(function (compiledArgs) {
  return "(".concat(compiledArgs.join(' * '), ")");
})), _expression.Ops.Divide, createCompiler(function (_ref15) {
  var _ref16 = _slicedToArray(_ref15, 2),
    firstValue = _ref16[0],
    secondValue = _ref16[1];
  return "(".concat(firstValue, " / ").concat(secondValue, ")");
})), _expression.Ops.Add, createCompiler(function (compiledArgs) {
  return "(".concat(compiledArgs.join(' + '), ")");
})), _expression.Ops.Subtract, createCompiler(function (_ref17) {
  var _ref18 = _slicedToArray(_ref17, 2),
    firstValue = _ref18[0],
    secondValue = _ref18[1];
  return "(".concat(firstValue, " - ").concat(secondValue, ")");
})), _expression.Ops.Clamp, createCompiler(function (_ref19) {
  var _ref20 = _slicedToArray(_ref19, 3),
    value = _ref20[0],
    min = _ref20[1],
    max = _ref20[2];
  return "clamp(".concat(value, ", ").concat(min, ", ").concat(max, ")");
})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, _expression.Ops.Mod, createCompiler(function (_ref21) {
  var _ref22 = _slicedToArray(_ref21, 2),
    value = _ref22[0],
    modulo = _ref22[1];
  return "mod(".concat(value, ", ").concat(modulo, ")");
})), _expression.Ops.Pow, createCompiler(function (_ref23) {
  var _ref24 = _slicedToArray(_ref23, 2),
    value = _ref24[0],
    power = _ref24[1];
  return "pow(".concat(value, ", ").concat(power, ")");
})), _expression.Ops.Abs, createCompiler(function (_ref25) {
  var _ref26 = _slicedToArray(_ref25, 1),
    value = _ref26[0];
  return "abs(".concat(value, ")");
})), _expression.Ops.Floor, createCompiler(function (_ref27) {
  var _ref28 = _slicedToArray(_ref27, 1),
    value = _ref28[0];
  return "floor(".concat(value, ")");
})), _expression.Ops.Ceil, createCompiler(function (_ref29) {
  var _ref30 = _slicedToArray(_ref29, 1),
    value = _ref30[0];
  return "ceil(".concat(value, ")");
})), _expression.Ops.Round, createCompiler(function (_ref31) {
  var _ref32 = _slicedToArray(_ref31, 1),
    value = _ref32[0];
  return "floor(".concat(value, " + 0.5)");
})), _expression.Ops.Sin, createCompiler(function (_ref33) {
  var _ref34 = _slicedToArray(_ref33, 1),
    value = _ref34[0];
  return "sin(".concat(value, ")");
})), _expression.Ops.Cos, createCompiler(function (_ref35) {
  var _ref36 = _slicedToArray(_ref35, 1),
    value = _ref36[0];
  return "cos(".concat(value, ")");
})), _expression.Ops.Atan, createCompiler(function (_ref37) {
  var _ref38 = _slicedToArray(_ref37, 2),
    firstValue = _ref38[0],
    secondValue = _ref38[1];
  return secondValue !== undefined ? "atan(".concat(firstValue, ", ").concat(secondValue, ")") : "atan(".concat(firstValue, ")");
})), _expression.Ops.Sqrt, createCompiler(function (_ref39) {
  var _ref40 = _slicedToArray(_ref39, 1),
    value = _ref40[0];
  return "sqrt(".concat(value, ")");
})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, _expression.Ops.Match, createCompiler(function (compiledArgs) {
  var input = compiledArgs[0];
  var fallback = compiledArgs[compiledArgs.length - 1];
  var result = null;
  for (var i = compiledArgs.length - 3; i >= 1; i -= 2) {
    var match = compiledArgs[i];
    var output = compiledArgs[i + 1];
    result = "(".concat(input, " == ").concat(match, " ? ").concat(output, " : ").concat(result || fallback, ")");
  }
  return result;
})), _expression.Ops.Between, createCompiler(function (_ref41) {
  var _ref42 = _slicedToArray(_ref41, 3),
    value = _ref42[0],
    min = _ref42[1],
    max = _ref42[2];
  return "(".concat(value, " >= ").concat(min, " && ").concat(value, " <= ").concat(max, ")");
})), _expression.Ops.Interpolate, createCompiler(function (_ref43) {
  var _ref44 = _toArray(_ref43),
    exponent = _ref44[0],
    input = _ref44[1],
    compiledArgs = _ref44.slice(2);
  var result = '';
  for (var i = 0; i < compiledArgs.length - 2; i += 2) {
    var stop1 = compiledArgs[i];
    var output1 = result || compiledArgs[i + 1];
    var stop2 = compiledArgs[i + 2];
    var output2 = compiledArgs[i + 3];
    var ratio = void 0;
    if (exponent === numberToGlsl(1)) {
      ratio = "(".concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, ")");
    } else {
      ratio = "(pow(".concat(exponent, ", (").concat(input, " - ").concat(stop1, ")) - 1.0) / (pow(").concat(exponent, ", (").concat(stop2, " - ").concat(stop1, ")) - 1.0)");
    }
    result = "mix(".concat(output1, ", ").concat(output2, ", clamp(").concat(ratio, ", 0.0, 1.0))");
  }
  return result;
})), _expression.Ops.Case, createCompiler(function (compiledArgs) {
  var fallback = compiledArgs[compiledArgs.length - 1];
  var result = null;
  for (var i = compiledArgs.length - 3; i >= 0; i -= 2) {
    var condition = compiledArgs[i];
    var output = compiledArgs[i + 1];
    result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
  }
  return result;
})), _expression.Ops.In, createCompiler(function (_ref45, context) {
  var _ref46 = _toArray(_ref45),
    needle = _ref46[0],
    haystack = _ref46.slice(1);
  var funcName = computeOperatorFunctionName('in', context);
  var tests = [];
  for (var i = 0; i < haystack.length; i += 1) {
    tests.push("  if (inputValue == ".concat(haystack[i], ") { return true; }"));
  }
  context.functions[funcName] = "bool ".concat(funcName, "(float inputValue) {\n").concat(tests.join('\n'), "\n  return false;\n}");
  return "".concat(funcName, "(").concat(needle, ")");
})), _expression.Ops.Array, createCompiler(function (args) {
  return "vec".concat(args.length, "(").concat(args.join(', '), ")");
})), _expression.Ops.Color, createCompiler(function (compiledArgs) {
  var rgb = compiledArgs.slice(0, 3).map(function (color) {
    return "".concat(color, " / 255.0");
  });
  if (compiledArgs.length === 3) {
    return "vec4(".concat(rgb.join(', '), ", 1.0)");
  }
  var alpha = compiledArgs[3];
  return "(".concat(alpha, " * vec4(").concat(rgb.join(', '), ", 1.0))");
})), _expression.Ops.Band, createCompiler(function (_ref47, context) {
  var _ref48 = _slicedToArray(_ref47, 3),
    band = _ref48[0],
    xOffset = _ref48[1],
    yOffset = _ref48[2];
  if (!(GET_BAND_VALUE_FUNC in context.functions)) {
    var ifBlocks = '';
    var bandCount = context.bandCount || 1;
    for (var i = 0; i < bandCount; i++) {
      var colorIndex = Math.floor(i / 4);
      var bandIndex = i % 4;
      if (i === bandCount - 1 && bandIndex === 1) {
        // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha
        bandIndex = 3;
      }
      var textureName = "".concat(_TileLayer.Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
      ifBlocks += "  if (band == ".concat(i + 1, ".0) {\n    return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n  }\n");
    }
    context.functions[GET_BAND_VALUE_FUNC] = "float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ".concat(_TileLayer.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n  float dy = yOffset / ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n").concat(ifBlocks, "\n}");
  }
  return "".concat(GET_BAND_VALUE_FUNC, "(").concat(band, ", ").concat(xOffset !== null && xOffset !== void 0 ? xOffset : '0.0', ", ").concat(yOffset !== null && yOffset !== void 0 ? yOffset : '0.0', ")");
})), _expression.Ops.Palette, function (context, expression) {
  var _expression$args = _toArray(expression.args),
    index = _expression$args[0],
    colors = _expression$args.slice(1);
  var numColors = colors.length;
  var palette = new Uint8Array(numColors * 4);
  for (var i = 0; i < colors.length; i++) {
    var parsedValue = /** @type {string | Array<number>} */
    /** @type {LiteralExpression} */colors[i].value;
    var color = (0, _color.asArray)(parsedValue);
    var offset = i * 4;
    palette[offset] = color[0];
    palette[offset + 1] = color[1];
    palette[offset + 2] = color[2];
    palette[offset + 3] = color[3] * 255;
  }
  if (!context.paletteTextures) {
    context.paletteTextures = [];
  }
  var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
  var paletteTexture = new _PaletteTexture.default(paletteName, palette);
  context.paletteTextures.push(paletteTexture);
  var compiledIndex = compile(index, _expression.NumberType, context);
  return "texture2D(".concat(paletteName, ", vec2((").concat(compiledIndex, " + 0.5) / ").concat(numColors, ".0, 0.5))");
}));

/**
 * @param {Expression} expression The expression.
 * @param {number} returnType The expected return type.
 * @param {CompilationContext} context The compilation context.
 * @return {CompiledExpression} The compiled expression
 */
function compile(expression, returnType, context) {
  // operator
  if (expression instanceof _expression.CallExpression) {
    var compiler = compilers[expression.operator];
    if (compiler === undefined) {
      throw new Error("No compiler defined for this operator: ".concat(JSON.stringify(expression.operator)));
    }
    return compiler(context, expression, returnType);
  }
  if ((expression.type & _expression.NumberType) > 0) {
    return numberToGlsl( /** @type {number} */expression.value);
  }
  if ((expression.type & _expression.BooleanType) > 0) {
    return expression.value.toString();
  }
  if ((expression.type & _expression.StringType) > 0) {
    return stringToGlsl(expression.value.toString());
  }
  if ((expression.type & _expression.ColorType) > 0) {
    return colorToGlsl( /** @type {Array<number> | string} */expression.value);
  }
  if ((expression.type & _expression.NumberArrayType) > 0) {
    return arrayToGlsl( /** @type {Array<number>} */expression.value);
  }
  throw new Error("Unexpected expression ".concat(expression.value, " (expected type ").concat((0, _expression.typeName)(returnType), ")"));
}
},{"../webgl/PaletteTexture.js":"node_modules/ol/webgl/PaletteTexture.js","./expression.js":"node_modules/ol/expr/expression.js","../renderer/webgl/TileLayer.js":"node_modules/ol/renderer/webgl/TileLayer.js","../color.js":"node_modules/ol/color.js"}],"node_modules/ol/style/flat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDefaultStyle = createDefaultStyle;
/**
 * @module ol/style/flat
 */

/**
 * @api
 * @fileoverview Vector layers can be styled with an object literal containing properties for
 * stroke, fill, image, and text styles.  The types below can be composed into a single object.
 * For example, a style with both stroke and fill properties could look like this:
 *
 *     const style = {
 *       'stroke-color': 'yellow',
 *       'stroke-width': 1.5,
 *       'fill-color': 'orange',
 *     };
 *
 * See details about the available properties depending on what type of symbolizer should be applied:
 *  * {@link module:ol/style/flat~FlatStroke Stroke} - properties for applying a stroke to lines and polygons
 *  * {@link module:ol/style/flat~FlatFill Fill} - properties for filling polygons
 *  * {@link module:ol/style/flat~FlatText Text} - properties for labeling points, lines, and polygons
 *  * {@link module:ol/style/flat~FlatIcon Icon} - properties for rendering points with an icon
 *  * {@link module:ol/style/flat~FlatCircle Circle} - properties for rendering points with a circle
 *  * {@link module:ol/style/flat~FlatShape Shape} - properties for rendering points with a regular shape
 *
 * To conditionally apply styles based on a filter, a list of {@link module:ol/style/flat~Rule rules} can be used.
 * For example, to style points with a big orange circle if the population is greater than 1 million and
 * a smaller blue circle otherwise:
 *
 *     const rules = [
 *       {
 *         filter: ['>', ['get', 'population'], 1_000_000],
 *         style: {
 *           'circle-radius': 10,
 *           'circle-fill-color': 'red',
 *         }
 *       },
 *       {
 *         else: true,
 *         style: {
 *           'circle-radius': 5,
 *           'circle-fill-color': 'blue',
 *         },
 *       },
 *     ];
 */

/**
 * A literal boolean (e.g. `true`) or an expression that evaluates to a boolean (e.g. `['>', ['get', 'population'], 1_000_000]`).
 *
 * @typedef {boolean|Array} BooleanExpression
 */

/**
 * A literal string (e.g. `'hello'`) or an expression that evaluates to a string (e.g. `['get', 'greeting']`).
 *
 * @typedef {string|Array} StringExpression
 */

/**
 * A literal number (e.g. `42`) or an expression that evaluates to a number (e.g. `['+', 40, 2]`).
 *
 * @typedef {number|Array} NumberExpression
 */

/**
 * A CSS named color (e.g. `'blue'`), an array of 3 RGB values (e.g. `[0, 255, 0]`), an array of 4 RGBA values
 * (e.g. `[0, 255, 0, 0.5]`), or an expression that evaluates to one of these color types (e.g. `['get', 'color']`).
 *
 * @typedef {import("../color.js").Color|string|Array} ColorExpression
 */

/**
 * An array of numbers (e.g. `[1, 2, 3]`) or an expression that evaluates to the same (e.g. `['get', 'values']`).
 *
 * @typedef {Array<number>|Array} NumberArrayExpression
 */

/**
 * An array of two numbers (e.g. `[10, 20]`) or an expression that evaluates to the same (e.g. `['get', 'size']`).
 *
 * @typedef {number|Array<number>|Array} SizeExpression
 */

/**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */

/**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>|Array<Rule>} FlatStyleLike
 */

/**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {ColorExpression} [fill-color] The fill color.
 */

/**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {ColorExpression} [stroke-color] The stroke color.
 * @property {NumberExpression} [stroke-width] Stroke pixel width.
 * @property {StringExpression} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */

/**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {StringExpression} [text-value] Text content (with `\n` for line breaks).
 * @property {StringExpression} [text-font='10px sans-serif'] Font style as [CSS `font`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font) value.
 * @property {NumberExpression} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45 (`Math.PI / 4`).
 * @property {NumberExpression} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {NumberExpression} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {BooleanExpression} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {StringExpression} [text-placement='point'] Text placement.
 * @property {NumberExpression} [text-repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when
 * `text-placement` is set to `'line'`. Overrides `text-align`.
 * @property {SizeExpression} [text-scale] Scale.
 * @property {BooleanExpression} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {NumberExpression} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {StringExpression} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `'text-placement': 'point'`. For `'text-placement': 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {StringExpression} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `'text-placement': 'line'`.
 * @property {StringExpression} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {NumberArrayExpression} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {ColorExpression} [text-fill-color] The fill color. Specify `'none'` to avoid hit detection on the fill.
 * @property {ColorExpression} [text-background-fill-color] The fill color.
 * @property {ColorExpression} [text-stroke-color] The stroke color.
 * @property {StringExpression} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-stroke-width] Stroke pixel width.
 * @property {ColorExpression} [text-background-stroke-color] The stroke color.
 * @property {StringExpression} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-background-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-background-stroke-width] Stroke pixel width.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */

/**
 * Icon style properties applied to point features. `icon-src` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {NumberArrayExpression} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {NumberArrayExpression} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {NumberExpression} [icon-opacity=1] Opacity of the icon.
 * @property {SizeExpression} [icon-scale=1] Scale.
 * @property {number} [icon-width] Width of the icon. If not specified, the actual image width will be used. Cannot be combined
 * with `scale`.
 * @property {number} [icon-height] Height of the icon. If not specified, the actual image height will be used. Cannot be combined
 * with `scale`.
 * @property {NumberExpression} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {"declutter"|"obstacle"|"none"|undefined} [icon-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */

/**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {ColorExpression} [shape-fill-color] The fill color.
 * @property {ColorExpression} [shape-stroke-color] The stroke color.
 * @property {NumberExpression} [shape-stroke-width] Stroke pixel width.
 * @property {StringExpression} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [shape-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [shape-radius2] Second radius of a star.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {NumberArrayExpression} [shape-displacement=[0,0]] Displacement of the shape
 * @property {NumberExpression} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {SizeExpression} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [shape-declutter-mode] Declutter mode.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */

/**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {ColorExpression} [circle-fill-color] The fill color.
 * @property {ColorExpression} [circle-stroke-color] The stroke color.
 * @property {NumberExpression} [circle-stroke-width] Stroke pixel width.
 * @property {StringExpression} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [circle-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [circle-stroke-miter-limit=10] Miter limit.
 * @property {NumberArrayExpression} [circle-displacement=[0,0]] displacement
 * @property {SizeExpression} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {NumberExpression} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {BooleanExpression} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [circle-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */

/**
 * These default style properties are applied when no other style is given.
 *
 * @typedef {Object} DefaultStyle
 * @property {string} fill-color `'rgba(255,255,255,0.4)'`
 * @property {string} stroke-color `'#3399CC'`
 * @property {number} stroke-width `1.25`
 * @property {number} circle-radius `5`
 * @property {string} circle-fill-color `'rgba(255,255,255,0.4)'`
 * @property {number} circle-stroke-width `1.25`
 * @property {string} circle-stroke-color `'#3399CC'`
 */

/**
 * @return {DefaultStyle} The default flat style.
 */
function createDefaultStyle() {
  return {
    'fill-color': 'rgba(255,255,255,0.4)',
    'stroke-color': '#3399CC',
    'stroke-width': 1.25,
    'circle-radius': 5,
    'circle-fill-color': 'rgba(255,255,255,0.4)',
    'circle-stroke-width': 1.25,
    'circle-stroke-color': '#3399CC'
  };
}

/**
 * A rule is used to conditionally apply a style.  If the rule's filter evaluates to true,
 * the style will be applied.
 *
 * @typedef {Object} Rule
 * @property {FlatStyle|Array<FlatStyle>} style The style to be applied if the filter matches.
 * @property {import("../expr/expression.js").EncodedExpression} [filter] The filter used
 * to determine if a style applies.  If no filter is included, the rule always applies
 * (unless it is an else rule).
 * @property {boolean} [else] If true, the rule applies only if no other previous rule applies.
 * If the else rule also has a filter, the rule will not apply if the filter does not match.
 */
},{}],"node_modules/ol/webgl/ShaderBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShaderBuilder = exports.COMMON_HEADER = void 0;
var _utils = require("../render/webgl/utils.js");
var _gpu = require("../expr/gpu.js");
var _flat = require("../style/flat.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * Class for generating shaders from literal style objects
 * @module ol/webgl/ShaderBuilder
 */
var COMMON_HEADER = exports.COMMON_HEADER = "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform vec2 u_patternOrigin;\nuniform float u_depth;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\n\n// this used to produce an alpha-premultiplied color from a texture\nvec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}\n";
var DEFAULT_STYLE = (0, _flat.createDefaultStyle)();

/**
 * @typedef {Object} VaryingDescription
 * @property {string} name Varying name, as will be declared in the header.
 * @property {string} type Varying type, either `float`, `vec2`, `vec4`...
 * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and
 * passed on to the fragment shader.
 */

/**
 * @classdesc
 * This class implements a classic builder pattern for generating many different types of shaders.
 * Methods can be chained, e. g.:
 *
 * ```js
 * const shader = new ShaderBuilder()
 *   .addVarying('v_width', 'float', 'a_width')
 *   .addUniform('u_time')
 *   .setColorExpression('...')
 *   .setSymbolSizeExpression('...')
 *   .getSymbolFragmentShader();
 * ```
 */
var ShaderBuilder = exports.ShaderBuilder = /*#__PURE__*/function () {
  function ShaderBuilder() {
    _classCallCheck(this, ShaderBuilder);
    /**
     * Uniforms; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */
    this.uniforms_ = [];

    /**
     * Attributes; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */
    this.attributes_ = [];

    /**
     * Varyings with a name, a type and an expression.
     * @type {Array<VaryingDescription>}
     * @private
     */
    this.varyings_ = [];

    /**
     * @type {boolean}
     * @private
     */
    this.hasSymbol_ = false;

    /**
     * @type {string}
     * @private
     */
    this.symbolSizeExpression_ = "vec2(".concat((0, _gpu.numberToGlsl)(DEFAULT_STYLE['circle-radius']), " + ").concat((0, _gpu.numberToGlsl)(DEFAULT_STYLE['circle-stroke-width'] * 0.5), ")");

    /**
     * @type {string}
     * @private
     */
    this.symbolRotationExpression_ = '0.0';

    /**
     * @type {string}
     * @private
     */
    this.symbolOffsetExpression_ = 'vec2(0.0)';

    /**
     * @type {string}
     * @private
     */
    this.symbolColorExpression_ = (0, _gpu.colorToGlsl)( /** @type {string} */DEFAULT_STYLE['circle-fill-color']);

    /**
     * @type {string}
     * @private
     */
    this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';

    /**
     * @type {string}
     * @private
     */
    this.discardExpression_ = 'false';

    /**
     * @type {boolean}
     * @private
     */
    this.symbolRotateWithView_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.hasStroke_ = false;

    /**
     * @type {string}
     * @private
     */
    this.strokeWidthExpression_ = (0, _gpu.numberToGlsl)(DEFAULT_STYLE['stroke-width']);

    /**
     * @type {string}
     * @private
     */
    this.strokeColorExpression_ = (0, _gpu.colorToGlsl)( /** @type {string} */DEFAULT_STYLE['stroke-color']);

    /**
     * @private
     */
    this.strokeOffsetExpression_ = '0.';

    /**
     * @private
     */
    this.strokeCapExpression_ = (0, _gpu.stringToGlsl)('round');

    /**
     * @private
     */
    this.strokeJoinExpression_ = (0, _gpu.stringToGlsl)('round');

    /**
     * @private
     */
    this.strokeMiterLimitExpression_ = '10.';

    /**
     * @private
     */
    this.strokeDistanceFieldExpression_ = '-1000.';

    /**
     * @type {boolean}
     * @private
     */
    this.hasFill_ = false;

    /**
     * @type {string}
     * @private
     */
    this.fillColorExpression_ = (0, _gpu.colorToGlsl)( /** @type {string} */DEFAULT_STYLE['fill-color']);

    /**
     * @type {Array<string>}
     * @private
     */
    this.vertexShaderFunctions_ = [];

    /**
     * @type {Array<string>}
     * @private
     */
    this.fragmentShaderFunctions_ = [];
  }

  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */
  _createClass(ShaderBuilder, [{
    key: "addUniform",
    value: function addUniform(name) {
      this.uniforms_.push(name);
      return this;
    }

    /**
     * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
     * The given name should include a type, such as `vec2 a_position`.
     * @param {string} name Attribute name
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "addAttribute",
    value: function addAttribute(name) {
      this.attributes_.push(name);
      return this;
    }

    /**
     * Adds a varying defined in the vertex shader and accessible from the fragment shader.
     * The type and expression of the varying have to be specified separately.
     * @param {string} name Varying name
     * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
     * @param {string} expression Expression used to assign a value to the varying.
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "addVarying",
    value: function addVarying(name, type, expression) {
      this.varyings_.push({
        name: name,
        type: type,
        expression: expression
      });
      return this;
    }

    /**
     * Sets an expression to compute the size of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setSymbolSizeExpression",
    value: function setSymbolSizeExpression(expression) {
      this.hasSymbol_ = true;
      this.symbolSizeExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current symbol size expression
     */
  }, {
    key: "getSymbolSizeExpression",
    value: function getSymbolSizeExpression() {
      return this.symbolSizeExpression_;
    }

    /**
     * Sets an expression to compute the rotation of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `float` value in radians.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setSymbolRotationExpression",
    value: function setSymbolRotationExpression(expression) {
      this.symbolRotationExpression_ = expression;
      return this;
    }

    /**
     * Sets an expression to compute the offset of the symbol from the point center.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Offset expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setSymbolOffsetExpression",
    value: function setSymbolOffsetExpression(expression) {
      this.symbolOffsetExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current symbol offset expression
     */
  }, {
    key: "getSymbolOffsetExpression",
    value: function getSymbolOffsetExpression() {
      return this.symbolOffsetExpression_;
    }

    /**
     * Sets an expression to compute the color of the shape.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `vec4` value.
     * @param {string} expression Color expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setSymbolColorExpression",
    value: function setSymbolColorExpression(expression) {
      this.hasSymbol_ = true;
      this.symbolColorExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current symbol color expression
     */
  }, {
    key: "getSymbolColorExpression",
    value: function getSymbolColorExpression() {
      return this.symbolColorExpression_;
    }

    /**
     * Sets an expression to compute the texture coordinates of the vertices.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec4` value.
     * @param {string} expression Texture coordinate expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setTextureCoordinateExpression",
    value: function setTextureCoordinateExpression(expression) {
      this.texCoordExpression_ = expression;
      return this;
    }

    /**
     * Sets an expression to determine whether a fragment (pixel) should be discarded,
     * i.e. not drawn at all.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `bool` value (it will be
     * used in an `if` statement)
     * @param {string} expression Fragment discard expression
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setFragmentDiscardExpression",
    value: function setFragmentDiscardExpression(expression) {
      this.discardExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current fragment discard expression
     */
  }, {
    key: "getFragmentDiscardExpression",
    value: function getFragmentDiscardExpression() {
      return this.discardExpression_;
    }

    /**
     * Sets whether the symbols should rotate with the view or stay aligned with the map.
     * Note: will only be used for point geometry shaders.
     * @param {boolean} rotateWithView Rotate with view
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setSymbolRotateWithView",
    value: function setSymbolRotateWithView(rotateWithView) {
      this.symbolRotateWithView_ = rotateWithView;
      return this;
    }

    /**
     * @param {string} expression Stroke width expression, returning value in pixels
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeWidthExpression",
    value: function setStrokeWidthExpression(expression) {
      this.hasStroke_ = true;
      this.strokeWidthExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeColorExpression",
    value: function setStrokeColorExpression(expression) {
      this.hasStroke_ = true;
      this.strokeColorExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current stroke color expression
     */
  }, {
    key: "getStrokeColorExpression",
    value: function getStrokeColorExpression() {
      return this.strokeColorExpression_;
    }

    /**
     * @param {string} expression Stroke color expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeOffsetExpression",
    value: function setStrokeOffsetExpression(expression) {
      this.strokeOffsetExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Stroke line cap expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeCapExpression",
    value: function setStrokeCapExpression(expression) {
      this.strokeCapExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Stroke line join expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeJoinExpression",
    value: function setStrokeJoinExpression(expression) {
      this.strokeJoinExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Stroke miter limit expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeMiterLimitExpression",
    value: function setStrokeMiterLimitExpression(expression) {
      this.strokeMiterLimitExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Stroke distance field expression, evaluate to `float`
     * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setStrokeDistanceFieldExpression",
    value: function setStrokeDistanceFieldExpression(expression) {
      this.strokeDistanceFieldExpression_ = expression;
      return this;
    }

    /**
     * @param {string} expression Fill color expression, evaluate to `vec4`
     * @return {ShaderBuilder} the builder object
     */
  }, {
    key: "setFillColorExpression",
    value: function setFillColorExpression(expression) {
      this.hasFill_ = true;
      this.fillColorExpression_ = expression;
      return this;
    }

    /**
     * @return {string} The current fill color expression
     */
  }, {
    key: "getFillColorExpression",
    value: function getFillColorExpression() {
      return this.fillColorExpression_;
    }
  }, {
    key: "addVertexShaderFunction",
    value: function addVertexShaderFunction(code) {
      if (this.vertexShaderFunctions_.includes(code)) {
        return;
      }
      this.vertexShaderFunctions_.push(code);
    }
  }, {
    key: "addFragmentShaderFunction",
    value: function addFragmentShaderFunction(code) {
      if (this.fragmentShaderFunctions_.includes(code)) {
        return;
      }
      this.fragmentShaderFunctions_.push(code);
    }

    /**
     * Generates a symbol vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
  }, {
    key: "getSymbolVertexShader",
    value: function getSymbolVertexShader() {
      if (!this.hasSymbol_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n").concat(this.attributes_.map(function (attribute) {
        return 'attribute ' + attribute + ';';
      }).join('\n'), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.vertexShaderFunctions_.join('\n'), "\nvec2 pxToScreen(vec2 coordPx) {\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\n  return scaled;\n}\n\nvec2 screenToPx(vec2 coordScreen) {\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  v_quadSizePx = ").concat(this.symbolSizeExpression_, ";\n  vec2 halfSizePx = v_quadSizePx * 0.5;\n  vec2 centerOffsetPx = ").concat(this.symbolOffsetExpression_, ";\n  vec2 offsetPx = centerOffsetPx;\n  if (a_index == 0.0) {\n    offsetPx -= halfSizePx;\n  } else if (a_index == 1.0) {\n    offsetPx += halfSizePx * vec2(1., -1.);\n  } else if (a_index == 2.0) {\n    offsetPx += halfSizePx;\n  } else {\n    offsetPx += halfSizePx * vec2(-1., 1.);\n  }\n  float angle = ").concat(this.symbolRotationExpression_, ";\n  ").concat(this.symbolRotateWithView_ ? 'angle += u_rotation;' : '', "\n  float c = cos(-angle);\n  float s = sin(-angle);\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);\n  vec4 texCoord = ").concat(this.texCoordExpression_, ";\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n  v_angle = angle;\n  c = cos(-v_angle);\n  s = sin(-v_angle);\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\n").concat(this.varyings_.map(function (varying) {
        return '  ' + varying.name + ' = ' + varying.expression + ';';
      }).join('\n'), "\n}");
    }

    /**
     * Generates a symbol fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
  }, {
    key: "getSymbolFragmentShader",
    value: function getSymbolFragmentShader() {
      if (!this.hasSymbol_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nvarying vec2 v_texCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.fragmentShaderFunctions_.join('\n'), "\n\nvoid main(void) {\n  if (").concat(this.discardExpression_, ") { discard; }\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\n  float c = cos(v_angle);\n  float s = sin(v_angle);\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\n  gl_FragColor = ").concat(this.symbolColorExpression_, ";\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.05) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}");
    }

    /**
     * Generates a stroke vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
  }, {
    key: "getStrokeVertexShader",
    value: function getStrokeVertexShader() {
      if (!this.hasStroke_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute float a_distance;\nattribute vec2 a_joinAngles;\nattribute vec4 a_hitColor;\n").concat(this.attributes_.map(function (attribute) {
        return 'attribute ' + attribute + ';';
      }).join('\n'), "\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.vertexShaderFunctions_.join('\n'), "\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return vec4(screenPos, u_depth, 1.0);\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\n  float halfAngle = joinAngle / 2.0;\n  float c = cos(halfAngle);\n  float s = sin(halfAngle);\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\n  float length = 1.0 / s;\n  return angleBisectorNormal * length;\n}\n\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\n  // if on a cap or the join angle is too high, offset the line along the segment normal\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\n    return point - normal * offsetPx;\n  }\n  // offset is applied along the inverted normal (positive offset goes \"right\" relative to line direction)\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\n}\n\nvoid main(void) {\n  v_angleStart = a_joinAngles.x;\n  v_angleEnd = a_joinAngles.y;\n  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);\n  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)\n  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);\n\n  float lineWidth = ").concat(this.strokeWidthExpression_, ";\n  float lineOffsetPx = ").concat(this.strokeOffsetExpression_, ";\n\n  // compute segment start/end in px with offset\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\n  \n  // compute current vertex position\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 joinDirection;\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\n  // if angle is too high, do not make a proper join\n  if (cos(angle) > ").concat(_utils.LINESTRING_ANGLE_COSINE_CUTOFF, " || isCap(angle)) {\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\n  } else {\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\n  }\n  positionPx = positionPx + joinDirection * lineWidth * 0.5;\n  gl_Position = pxToScreen(positionPx);\n\n  v_segmentStart = segmentStartPx;\n  v_segmentEnd = segmentEndPx;\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);\n").concat(this.varyings_.map(function (varying) {
        return '  ' + varying.name + ' = ' + varying.expression + ';';
      }).join('\n'), "\n}");
    }

    /**
     * Generates a stroke fragment shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
  }, {
    key: "getStrokeFragmentShader",
    value: function getStrokeFragmentShader() {
      if (!this.hasStroke_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.fragmentShaderFunctions_.join('\n'), "\n\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  vec2 tangent = normalize(end - start);\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 startToPoint = point - start;\n  return abs(dot(startToPoint, normal)) - width * 0.5;\n}\n\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  return dot(startToPoint, -tangent);\n}\n\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return buttCapDistanceField(point, start, end) - width * 0.5;\n}\n\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\n  return length(point - start) - width * 0.5 - onSegment;\n}\n\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  float c = cos(joinAngle * 0.5);\n  float s = sin(joinAngle * 0.5);\n  float direction = -sign(sin(joinAngle));\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\n  float radius = width * 0.5 * s;\n  return dot(startToPoint, bisector * direction) - radius;\n}\n\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  if (cos(joinAngle) > ").concat(_utils.LINESTRING_ANGLE_COSINE_CUTOFF, ") { // avoid risking a division by zero\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  float miterLength = 1. / sin(joinAngle * 0.5);\n  float miterLimit = ").concat(this.strokeMiterLimitExpression_, ";\n  if (miterLength > miterLimit) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  return -1000.;\n}\n\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\n   if (capType == ").concat((0, _gpu.stringToGlsl)('butt'), ") {\n    return buttCapDistanceField(point, start, end);\n  } else if (capType == ").concat((0, _gpu.stringToGlsl)('square'), ") {\n    return squareCapDistanceField(point, start, end, width);\n  }\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\n  if (joinType == ").concat((0, _gpu.stringToGlsl)('bevel'), ") {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  } else if (joinType == ").concat((0, _gpu.stringToGlsl)('miter'), ") {\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\n  }\n  return roundJoinDistanceField(point, start, end, width);\n}\n\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\n  if (isCap(joinAngle)) {\n    return capDistanceField(point, start, end, width, capType);\n  }\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\n}\n\nvoid main(void) {\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (").concat(this.discardExpression_, ") { discard; }\n\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\n  vec2 startToPoint = currentPoint - v_segmentStart;\n  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; \n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\n  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;\n  vec4 color = ").concat(this.strokeColorExpression_, " * u_globalAlpha;\n  float capType = ").concat(this.strokeCapExpression_, ";\n  float joinType = ").concat(this.strokeJoinExpression_, ";\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\n  float distance = max(\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\n    max(segmentStartDistance, segmentEndDistance)\n  );\n  distance = max(distance, ").concat(this.strokeDistanceFieldExpression_, ");\n  gl_FragColor = color * smoothstep(0., -1., distance);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}");
    }

    /**
     * Generates a fill vertex shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no color specified
     */
  }, {
    key: "getFillVertexShader",
    value: function getFillVertexShader() {
      if (!this.hasFill_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n").concat(this.attributes_.map(function (attribute) {
        return 'attribute ' + attribute + ';';
      }).join('\n'), "\nvarying vec4 v_hitColor;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.vertexShaderFunctions_.join('\n'), "\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);\n  v_hitColor = a_hitColor;\n").concat(this.varyings_.map(function (varying) {
        return '  ' + varying.name + ' = ' + varying.expression + ';';
      }).join('\n'), "\n}");
    }

    /**
     * Generates a fill fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no color specified
     */
  }, {
    key: "getFillFragmentShader",
    value: function getFillFragmentShader() {
      if (!this.hasFill_) {
        return null;
      }
      return "".concat(COMMON_HEADER, "\n").concat(this.uniforms_.map(function (uniform) {
        return 'uniform ' + uniform + ';';
      }).join('\n'), "\nvarying vec4 v_hitColor;\n").concat(this.varyings_.map(function (varying) {
        return 'varying ' + varying.type + ' ' + varying.name + ';';
      }).join('\n'), "\n").concat(this.fragmentShaderFunctions_.join('\n'), "\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;\n  vec2 pxOrigin = worldToPx(u_patternOrigin);\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(pxPos);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (").concat(this.discardExpression_, ") { discard; }\n  gl_FragColor = ").concat(this.fillColorExpression_, " * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}");
    }
  }]);
  return ShaderBuilder;
}();
},{"../render/webgl/utils.js":"node_modules/ol/render/webgl/utils.js","../expr/gpu.js":"node_modules/ol/expr/gpu.js","../style/flat.js":"node_modules/ol/style/flat.js"}],"node_modules/ol/layer/Heatmap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseVector2 = _interopRequireDefault(require("./BaseVector.js"));
var _PointsLayer = _interopRequireDefault(require("../renderer/webgl/PointsLayer.js"));
var _ShaderBuilder = require("../webgl/ShaderBuilder.js");
var _math = require("../math.js");
var _dom = require("../dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/Heatmap
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient
 * of the heatmap, specified as an array of CSS color strings.
 * @property {number} [radius=8] Radius size in pixels.
 * @property {number} [blur=15] Blur size in pixels.
 * @property {string|function(import("../Feature.js").default):number} [weight='weight'] The feature
 * attribute to use for the weight or a function that returns a weight from a feature. Weight values
 * should range from 0 to 1 (and values outside will be clamped to that range).
 * @property {import("../source/Vector.js").default} [source] Point source.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius'
};

/**
 * @const
 * @type {Array<string>}
 */
var DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];

/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @extends {BaseVector<import("../source/Vector.js").default, WebGLPointsLayerRenderer>}
 * @api
 */
var Heatmap = /*#__PURE__*/function (_BaseVector) {
  _inherits(Heatmap, _BaseVector);
  var _super = _createSuper(Heatmap);
  /**
   * @param {Options} [options] Options.
   */
  function Heatmap(options) {
    var _this;
    _classCallCheck(this, Heatmap);
    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    _this = _super.call(this, baseOptions);

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    _this.gradient_ = null;
    _this.addChangeListener(Property.GRADIENT, _this.handleGradientChanged_);
    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);
    _this.setBlur(options.blur !== undefined ? options.blur : 15);
    _this.setRadius(options.radius !== undefined ? options.radius : 8);
    var weight = options.weight ? options.weight : 'weight';
    if (typeof weight === 'string') {
      _this.weightFunction_ = function (feature) {
        return feature.get(weight);
      };
    } else {
      _this.weightFunction_ = weight;
    }

    // For performance reasons, don't sort the features before rendering.
    // The render order is not relevant for a heatmap representation.
    _this.setRenderOrder(null);
    return _this;
  }

  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  _createClass(Heatmap, [{
    key: "getBlur",
    value: function getBlur() {
      return /** @type {number} */this.get(Property.BLUR);
    }

    /**
     * Return the gradient colors as array of strings.
     * @return {Array<string>} Colors.
     * @api
     * @observable
     */
  }, {
    key: "getGradient",
    value: function getGradient() {
      return /** @type {Array<string>} */this.get(Property.GRADIENT);
    }

    /**
     * Return the size of the radius in pixels.
     * @return {number} Radius size in pixel.
     * @api
     * @observable
     */
  }, {
    key: "getRadius",
    value: function getRadius() {
      return /** @type {number} */this.get(Property.RADIUS);
    }

    /**
     * @private
     */
  }, {
    key: "handleGradientChanged_",
    value: function handleGradientChanged_() {
      this.gradient_ = createGradient(this.getGradient());
    }

    /**
     * Set the blur size in pixels.
     * @param {number} blur Blur size in pixels.
     * @api
     * @observable
     */
  }, {
    key: "setBlur",
    value: function setBlur(blur) {
      this.set(Property.BLUR, blur);
    }

    /**
     * Set the gradient colors as array of strings.
     * @param {Array<string>} colors Gradient.
     * @api
     * @observable
     */
  }, {
    key: "setGradient",
    value: function setGradient(colors) {
      this.set(Property.GRADIENT, colors);
    }

    /**
     * Set the size of the radius in pixels.
     * @param {number} radius Radius size in pixel.
     * @api
     * @observable
     */
  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this.set(Property.RADIUS, radius);
    }
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      var _this2 = this;
      var builder = new _ShaderBuilder.ShaderBuilder().addAttribute('float a_prop_weight').addVarying('v_prop_weight', 'float', 'a_prop_weight').addUniform('float u_size').addUniform('float u_blurSlope').setSymbolSizeExpression('vec2(u_size)').setSymbolColorExpression('vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_prop_weight)');
      return new _PointsLayer.default(this, {
        className: this.getClassName(),
        attributes: [{
          name: 'weight',
          callback: function callback(feature) {
            var weight = _this2.weightFunction_(feature);
            return weight !== undefined ? (0, _math.clamp)(weight, 0, 1) : 1;
          }
        }],
        uniforms: {
          u_size: function u_size() {
            return (_this2.get(Property.RADIUS) + _this2.get(Property.BLUR)) * 2;
          },
          u_blurSlope: function u_blurSlope() {
            return _this2.get(Property.RADIUS) / Math.max(1, _this2.get(Property.BLUR));
          }
        },
        hitDetectionEnabled: true,
        vertexShader: builder.getSymbolVertexShader(),
        fragmentShader: builder.getSymbolFragmentShader(),
        postProcesses: [{
          fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
          uniforms: {
            u_gradientTexture: function u_gradientTexture() {
              return _this2.gradient_;
            },
            u_opacity: function u_opacity() {
              return _this2.getOpacity();
            }
          }
        }]
      });
    }
  }, {
    key: "renderDeclutter",
    value: function renderDeclutter() {}
  }]);
  return Heatmap;
}(_BaseVector2.default);
/**
 * @param {Array<string>} colors A list of colored.
 * @return {HTMLCanvasElement} canvas with gradient texture.
 */
function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = (0, _dom.createCanvasContext2D)(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);
  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.canvas;
}
var _default = exports.default = Heatmap;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/webgl/PointsLayer.js":"node_modules/ol/renderer/webgl/PointsLayer.js","../webgl/ShaderBuilder.js":"node_modules/ol/webgl/ShaderBuilder.js","../math.js":"node_modules/ol/math.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/renderer/canvas/VectorImageLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ImageLayer = _interopRequireDefault(require("./ImageLayer.js"));
var _VectorLayer = _interopRequireDefault(require("./VectorLayer.js"));
var _EventType = _interopRequireDefault(require("../../events/EventType.js"));
var _ImageCanvas = _interopRequireDefault(require("../../ImageCanvas.js"));
var _ImageState = _interopRequireDefault(require("../../ImageState.js"));
var _rbush = _interopRequireDefault(require("rbush"));
var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));
var _transform = require("../../transform.js");
var _resolution = require("../../resolution.js");
var _extent = require("../../extent.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/VectorImageLayer
 */
/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasVectorImageLayerRenderer = /*#__PURE__*/function (_CanvasImageLayerRend) {
  _inherits(CanvasVectorImageLayerRenderer, _CanvasImageLayerRend);
  var _super = _createSuper(CanvasVectorImageLayerRenderer);
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */
  function CanvasVectorImageLayerRenderer(layer) {
    var _this;
    _classCallCheck(this, CanvasVectorImageLayerRenderer);
    _this = _super.call(this, layer);

    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    _this.vectorRenderer_ = new _VectorLayer.default(layer);

    /**
     * @private
     * @type {number}
     */
    _this.layerImageRatio_ = layer.getImageRatio();

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.coordinateToVectorPixelTransform_ = (0, _transform.create)();

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.renderedPixelToCoordinateTransform_ = null;
    return _this;
  }

  /**
   * Clean up.
   */
  _createClass(CanvasVectorImageLayerRenderer, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      this.vectorRenderer_.dispose();
      _get(_getPrototypeOf(CanvasVectorImageLayerRenderer.prototype), "disposeInternal", this).call(this);
    }

    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      if (!this.vectorRenderer_) {
        return Promise.resolve([]);
      }
      var vectorPixel = (0, _transform.apply)(this.coordinateToVectorPixelTransform_, (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice()));
      return this.vectorRenderer_.getFeatures(vectorPixel);
    }

    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */
  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {
      this.vectorRenderer_.handleFontsChanged();
    }

    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      var _this2 = this;
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var viewResolution = viewState.resolution;
      var hints = frameState.viewHints;
      var vectorRenderer = this.vectorRenderer_;
      var renderedExtent = frameState.extent;
      if (this.layerImageRatio_ !== 1) {
        renderedExtent = renderedExtent.slice(0);
        (0, _extent.scaleFromCenter)(renderedExtent, this.layerImageRatio_);
      }
      var width = (0, _extent.getWidth)(renderedExtent) / viewResolution;
      var height = (0, _extent.getHeight)(renderedExtent) / viewResolution;
      if (!hints[_ViewHint.default.ANIMATING] && !hints[_ViewHint.default.INTERACTING] && !(0, _extent.isEmpty)(renderedExtent)) {
        vectorRenderer.useContainer(null, null);
        var context = vectorRenderer.context;
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var imageLayerState = Object.assign({}, layerState, {
          opacity: 1
        });
        var imageFrameState = /** @type {import("../../Map.js").FrameState} */
        Object.assign({}, frameState, {
          declutterTree: new _rbush.default(9),
          extent: renderedExtent,
          size: [width, height],
          viewState: ( /** @type {import("../../View.js").State} */
          Object.assign({}, frameState.viewState, {
            rotation: 0
          })),
          layerStatesArray: [imageLayerState],
          layerIndex: 0
        });
        var emptyImage = true;
        var image = new _ImageCanvas.default(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {
          if (vectorRenderer.prepareFrame(imageFrameState) && vectorRenderer.replayGroupChanged) {
            vectorRenderer.clipping = false;
            if (vectorRenderer.renderFrame(imageFrameState, null)) {
              vectorRenderer.renderDeclutter(imageFrameState);
              emptyImage = false;
            }
            callback();
          }
        });
        image.addEventListener(_EventType.default.CHANGE, function () {
          if (image.getState() !== _ImageState.default.LOADED) {
            return;
          }
          _this2.image_ = emptyImage ? null : image;
          var imagePixelRatio = image.getPixelRatio();
          var renderedResolution = (0, _resolution.fromResolutionLike)(image.getResolution()) * pixelRatio / imagePixelRatio;
          _this2.renderedResolution = renderedResolution;
          _this2.coordinateToVectorPixelTransform_ = (0, _transform.compose)(_this2.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);
        });
        image.load();
      }
      if (this.image_) {
        this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
      }
      return !!this.image_;
    }

    /**
     */
  }, {
    key: "preRender",
    value: function preRender() {}

    /**
     */
  }, {
    key: "postRender",
    value: function postRender() {}

    /**
     */
  }, {
    key: "renderDeclutter",
    value: function renderDeclutter() {}

    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      if (this.vectorRenderer_) {
        return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);
      }
      return _get(_getPrototypeOf(CanvasVectorImageLayerRenderer.prototype), "forEachFeatureAtCoordinate", this).call(this, coordinate, frameState, hitTolerance, callback, matches);
    }
  }]);
  return CanvasVectorImageLayerRenderer;
}(_ImageLayer.default);
var _default = exports.default = CanvasVectorImageLayerRenderer;
},{"./ImageLayer.js":"node_modules/ol/renderer/canvas/ImageLayer.js","./VectorLayer.js":"node_modules/ol/renderer/canvas/VectorLayer.js","../../events/EventType.js":"node_modules/ol/events/EventType.js","../../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","../../ImageState.js":"node_modules/ol/ImageState.js","rbush":"node_modules/rbush/rbush.min.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../transform.js":"node_modules/ol/transform.js","../../resolution.js":"node_modules/ol/resolution.js","../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/layer/VectorImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));
var _VectorImageLayer = _interopRequireDefault(require("../renderer/canvas/VectorImageLayer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/VectorImage
 */
/**
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined
 * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.
 * Within the same z-index, a feature rendered before another has higher priority.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
 * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Vector data is rendered client-side, to an image. This layer type provides great performance
 * during panning and zooming, but point symbols and texts are always rotated with the view and
 * pixels are scaled during zoom animations. For more accurate rendering of vector data, use
 * {@link module:ol/layer/Vector~VectorLayer} instead.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorImageLayerRenderer>}
 * @api
 */
var VectorImageLayer = /*#__PURE__*/function (_BaseVectorLayer) {
  _inherits(VectorImageLayer, _BaseVectorLayer);
  var _super = _createSuper(VectorImageLayer);
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  function VectorImageLayer(options) {
    var _this;
    _classCallCheck(this, VectorImageLayer);
    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.imageRatio;
    _this = _super.call(this, baseOptions);

    /**
     * @type {number}
     * @private
     */
    _this.imageRatio_ = options.imageRatio !== undefined ? options.imageRatio : 1;
    return _this;
  }

  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */
  _createClass(VectorImageLayer, [{
    key: "getImageRatio",
    value: function getImageRatio() {
      return this.imageRatio_;
    }
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      return new _VectorImageLayer.default(this);
    }
  }]);
  return VectorImageLayer;
}(_BaseVector.default);
var _default = exports.default = VectorImageLayer;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorImageLayer.js":"node_modules/ol/renderer/canvas/VectorImageLayer.js"}],"node_modules/ol/renderer/canvas/VectorTileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));
var _ExecutorGroup = _interopRequireDefault(require("../../render/canvas/ExecutorGroup.js"));
var _TileLayer = _interopRequireDefault(require("./TileLayer.js"));
var _TileState = _interopRequireDefault(require("../../TileState.js"));
var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));
var _hitdetect = require("../../render/canvas/hitdetect.js");
var _transform = require("../../transform.js");
var _extent2 = require("../../extent.js");
var _vector = require("../vector.js");
var _util = require("../../util.js");
var _size = require("../../size.js");
var _coordinate = require("../../coordinate.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/canvas/VectorTileLayer
 */
/**
 * @type {!Object<string, Array<import("../../render/canvas.js").BuilderType>>}
 */
var IMAGE_REPLAYS = {
  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],
  'hybrid': ['Polygon', 'LineString'],
  'vector': []
};

/**
 * @type {!Object<string, Array<import("../../render/canvas.js").BuilderType>>}
 */
var VECTOR_REPLAYS = {
  'hybrid': ['Image', 'Text', 'Default'],
  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default']
};

/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 * @extends {CanvasTileLayerRenderer<import("../../layer/VectorTile.js").default>}
 */
var CanvasVectorTileLayerRenderer = /*#__PURE__*/function (_CanvasTileLayerRende) {
  _inherits(CanvasVectorTileLayerRenderer, _CanvasTileLayerRende);
  var _super = _createSuper(CanvasVectorTileLayerRenderer);
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  function CanvasVectorTileLayerRenderer(layer) {
    var _this;
    _classCallCheck(this, CanvasVectorTileLayerRenderer);
    _this = _super.call(this, layer);

    /** @private */
    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_assertThisInitialized(_this));

    /**
     * @private
     * @type {number}
     */
    _this.renderedLayerRevision_;

    /**
     * @private
     * @type {import("../../transform").Transform}
     */
    _this.renderedPixelToCoordinateTransform_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.renderedRotation_;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    _this.tmpTransform_ = (0, _transform.create)();
    return _this;
  }

  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  _createClass(CanvasVectorTileLayerRenderer, [{
    key: "prepareTile",
    value: function prepareTile(tile, pixelRatio, projection) {
      var render;
      var state = tile.getState();
      if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {
        this.updateExecutorGroup_(tile, pixelRatio, projection);
        if (this.tileImageNeedsRender_(tile)) {
          render = true;
        }
      }
      return render;
    }

    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {!import("../../Tile.js").default} Tile.
     */
  }, {
    key: "getTile",
    value: function getTile(z, x, y, frameState) {
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var resolution = viewState.resolution;
      var projection = viewState.projection;
      var layer = this.getLayer();
      var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);
      var viewHints = frameState.viewHints;
      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
      if (hifi || !tile.wantedResolution) {
        tile.wantedResolution = resolution;
      }
      var render = this.prepareTile(tile, pixelRatio, projection);
      if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== 'vector') {
        this.renderTileImage_(tile, frameState);
      }
      return _get(_getPrototypeOf(CanvasVectorTileLayerRenderer.prototype), "getTile", this).call(this, z, x, y, frameState);
    }

    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @return {boolean} Tile is drawable.
     */
  }, {
    key: "isDrawableTile",
    value: function isDrawableTile(tile) {
      var layer = this.getLayer();
      return _get(_getPrototypeOf(CanvasVectorTileLayerRenderer.prototype), "isDrawableTile", this).call(this, tile) && (layer.getRenderMode() === 'vector' ? (0, _util.getUid)(layer) in tile.executorGroups : tile.hasContext(layer));
    }

    /**
     * @inheritDoc
     */
  }, {
    key: "getTileImage",
    value: function getTileImage(tile) {
      return tile.getImage(this.getLayer());
    }

    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      var layerRevision = this.getLayer().getRevision();
      if (this.renderedLayerRevision_ !== layerRevision) {
        this.renderedLayerRevision_ = layerRevision;
        this.renderedTiles.length = 0;
      }
      return _get(_getPrototypeOf(CanvasVectorTileLayerRenderer.prototype), "prepareFrame", this).call(this, frameState);
    }

    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @private
     */
  }, {
    key: "updateExecutorGroup_",
    value: function updateExecutorGroup_(tile, pixelRatio, projection) {
      var _this2 = this;
      var layer = /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var revision = layer.getRevision();
      var renderOrder = layer.getRenderOrder() || null;
      var resolution = tile.wantedResolution;
      var builderState = tile.getReplayState(layer);
      if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
        return;
      }
      var source = layer.getSource();
      var declutter = layer.getDeclutter();
      var sourceTileGrid = source.getTileGrid();
      var tileGrid = source.getTileGridForProjection(projection);
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
      var layerUid = (0, _util.getUid)(layer);
      delete tile.hitDetectionImageData[layerUid];
      tile.executorGroups[layerUid] = [];
      if (declutter) {
        tile.declutterExecutorGroups[layerUid] = [];
      }
      builderState.dirty = false;
      var _loop = function _loop() {
        var sourceTile = sourceTiles[t];
        if (sourceTile.getState() != _TileState.default.LOADED) {
          return 1; // continue
        }
        var sourceTileCoord = sourceTile.tileCoord;
        var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
        var sharedExtent = (0, _extent2.getIntersection)(tileExtent, sourceTileExtent);
        var builderExtent = (0, _extent2.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, _this2.tmpExtent);
        var bufferedExtent = (0, _extent2.equals)(sourceTileExtent, sharedExtent) ? null : builderExtent;
        var builderGroup = new _BuilderGroup.default(0, builderExtent, resolution, pixelRatio);
        var declutterBuilderGroup = declutter ? new _BuilderGroup.default(0, sharedExtent, resolution, pixelRatio) : undefined;
        var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);

        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @this {CanvasVectorTileLayerRenderer}
         */
        var render = function render(feature) {
          var styles;
          var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
          if (styleFunction) {
            styles = styleFunction(feature, resolution);
          }
          if (styles) {
            var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
            builderState.dirty = builderState.dirty || dirty;
          }
        };
        var features = sourceTile.getFeatures();
        if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
          features.sort(renderOrder);
        }
        for (var i = 0, ii = features.length; i < ii; ++i) {
          var feature = features[i];
          if (!bufferedExtent || (0, _extent2.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {
            render.call(_this2, feature);
          }
        }
        var executorGroupInstructions = builderGroup.finish();
        // no need to clip when the render tile is covered by a single source tile
        var replayExtent = layer.getRenderMode() !== 'vector' && declutter && sourceTiles.length === 1 ? null : sharedExtent;
        var renderingReplayGroup = new _ExecutorGroup.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
        tile.executorGroups[layerUid].push(renderingReplayGroup);
        if (declutterBuilderGroup) {
          var declutterExecutorGroup = new _ExecutorGroup.default(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
          tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
        }
      };
      for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
        if (_loop()) continue;
      }
      builderState.renderedRevision = revision;
      builderState.renderedRenderOrder = renderOrder;
      builderState.renderedResolution = resolution;
    }

    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
      var layer = this.getLayer();
      var source = layer.getSource();
      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
      var hitExtent = (0, _extent2.boundingExtent)([coordinate]);
      (0, _extent2.buffer)(hitExtent, resolution * hitTolerance, hitExtent);

      /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
      var features = {};

      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {number} distanceSq The squared distance to the click position.
       * @return {T|undefined} Callback result.
       */
      var featureCallback = function featureCallback(feature, geometry, distanceSq) {
        var key = feature.getId();
        if (key === undefined) {
          key = (0, _util.getUid)(feature);
        }
        var match = features[key];
        if (!match) {
          if (distanceSq === 0) {
            features[key] = true;
            return callback(feature, layer, geometry);
          }
          matches.push(features[key] = {
            feature: feature,
            layer: layer,
            geometry: geometry,
            distanceSq: distanceSq,
            callback: callback
          });
        } else if (match !== true && distanceSq < match.distanceSq) {
          if (distanceSq === 0) {
            features[key] = true;
            matches.splice(matches.lastIndexOf(match), 1);
            return callback(feature, layer, geometry);
          }
          match.geometry = geometry;
          match.distanceSq = distanceSq;
        }
        return undefined;
      };
      var renderedTiles = /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles;
      var found;
      var _loop2 = function _loop2() {
        var tile = renderedTiles[i];
        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
        if (!(0, _extent2.intersects)(tileExtent, hitExtent)) {
          return 1; // continue
        }
        var layerUid = (0, _util.getUid)(layer);
        var executorGroups = [tile.executorGroups[layerUid]];
        var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];
        if (declutterExecutorGroups) {
          executorGroups.push(declutterExecutorGroups);
        }
        executorGroups.some(function (executorGroups) {
          var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {
            return item.value;
          }) : null;
          for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
            var executorGroup = executorGroups[t];
            found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
            if (found) {
              return true;
            }
          }
        });
      };
      for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {
        if (_loop2()) continue;
      }
      return found;
    }

    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        var layer = _this3.getLayer();
        var layerUid = (0, _util.getUid)(layer);
        var source = layer.getSource();
        var projection = _this3.renderedProjection;
        var projectionExtent = projection.getExtent();
        var resolution = _this3.renderedResolution;
        var tileGrid = source.getTileGridForProjection(projection);
        var coordinate = (0, _transform.apply)(_this3.renderedPixelToCoordinateTransform_, pixel.slice());
        var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
        /** @type {import("../../VectorRenderTile.js").default|undefined} */
        var tile;
        for (var i = 0, ii = _this3.renderedTiles.length; i < ii; ++i) {
          if (tileCoord.toString() === _this3.renderedTiles[i].tileCoord.toString()) {
            tile = /** @type {import("../../VectorRenderTile.js").default} */
            _this3.renderedTiles[i];
            if (tile.getState() === _TileState.default.LOADED) {
              var _extent = tileGrid.getTileCoordExtent(tile.tileCoord);
              if (source.getWrapX() && projection.canWrapX() && !(0, _extent2.containsExtent)(projectionExtent, _extent)) {
                (0, _coordinate.wrapX)(coordinate, projection);
              }
              break;
            }
            tile = undefined;
          }
        }
        if (!tile || tile.loadingSourceTiles > 0) {
          resolve([]);
          return;
        }
        var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
        var corner = (0, _extent2.getTopLeft)(extent);
        var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];
        /** @type {Array<import("../../Feature.js").FeatureLike>} */
        var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {
          return accumulator.concat(sourceTile.getFeatures());
        }, []);
        /** @type {ImageData|undefined} */
        var hitDetectionImageData = tile.hitDetectionImageData[layerUid];
        if (!hitDetectionImageData) {
          var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));
          var rotation = _this3.renderedRotation_;
          var transforms = [_this3.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, _hitdetect.HIT_DETECT_RESOLUTION, tileSize[0] * _hitdetect.HIT_DETECT_RESOLUTION, tileSize[1] * _hitdetect.HIT_DETECT_RESOLUTION, 0)];
          hitDetectionImageData = (0, _hitdetect.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
          tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
        }
        resolve((0, _hitdetect.hitDetect)(tilePixel, features, hitDetectionImageData));
      });
    }

    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */
  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {
      var layer = this.getLayer();
      if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
        layer.changed();
      }
    }

    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
  }, {
    key: "handleStyleImageChange_",
    value: function handleStyleImageChange_(event) {
      this.renderIfReadyAndVisible();
    }

    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "renderDeclutter",
    value: function renderDeclutter(frameState) {
      var context = this.context;
      var alpha = context.globalAlpha;
      context.globalAlpha = this.getLayer().getOpacity();
      var viewHints = frameState.viewHints;
      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
      var tiles = /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles;
      for (var i = 0, ii = tiles.length; i < ii; ++i) {
        var tile = tiles[i];
        var declutterExecutorGroups = tile.declutterExecutorGroups[(0, _util.getUid)(this.getLayer())];
        if (declutterExecutorGroups) {
          for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {
            declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);
          }
        }
      }
      context.globalAlpha = alpha;
    }
  }, {
    key: "getTileRenderTransform",
    value: function getTileRenderTransform(tile, frameState) {
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var center = viewState.center;
      var resolution = viewState.resolution;
      var rotation = viewState.rotation;
      var size = frameState.size;
      var width = Math.round(size[0] * pixelRatio);
      var height = Math.round(size[1] * pixelRatio);
      var source = this.getLayer().getSource();
      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
      var tileCoord = tile.tileCoord;
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
      var transform = (0, _transform.multiply)((0, _transform.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
      return transform;
    }

    /**
     * Render the vectors for this layer.
     * @param {CanvasRenderingContext2D} context Target context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "postRender",
    value: function postRender(context, frameState) {
      var viewHints = frameState.viewHints;
      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
      this.renderedRotation_ = frameState.viewState.rotation;
      var layer = /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var renderMode = layer.getRenderMode();
      var alpha = context.globalAlpha;
      context.globalAlpha = layer.getOpacity();
      var replayTypes = VECTOR_REPLAYS[renderMode];
      var viewState = frameState.viewState;
      var rotation = viewState.rotation;
      var tileSource = layer.getSource();
      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
      var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
      var tiles = this.renderedTiles;
      var clips = [];
      var clipZs = [];
      var ready = true;
      for (var i = tiles.length - 1; i >= 0; --i) {
        var tile = /** @type {import("../../VectorRenderTile.js").default} */
        tiles[i];
        ready = ready && !tile.getReplayState(layer).dirty;
        var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)].filter(function (group) {
          return group.hasExecutors(replayTypes);
        });
        if (executorGroups.length === 0) {
          continue;
        }
        var transform = this.getTileRenderTransform(tile, frameState);
        var currentZ = tile.tileCoord[0];
        var contextSaved = false;
        // Clip mask for regions in this tile that already filled by a higher z tile
        var currentClip = executorGroups[0].getClipCoords(transform);
        if (currentClip) {
          for (var j = 0, jj = clips.length; j < jj; ++j) {
            if (z !== currentZ && currentZ < clipZs[j]) {
              var clip = clips[j];
              if ((0, _extent2.intersects)([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {
                if (!contextSaved) {
                  context.save();
                  contextSaved = true;
                }
                context.beginPath();
                // counter-clockwise (outer ring) for current tile
                context.moveTo(currentClip[0], currentClip[1]);
                context.lineTo(currentClip[2], currentClip[3]);
                context.lineTo(currentClip[4], currentClip[5]);
                context.lineTo(currentClip[6], currentClip[7]);
                // clockwise (inner ring) for higher z tile
                context.moveTo(clip[6], clip[7]);
                context.lineTo(clip[4], clip[5]);
                context.lineTo(clip[2], clip[3]);
                context.lineTo(clip[0], clip[1]);
                context.clip();
              }
            }
          }
          clips.push(currentClip);
          clipZs.push(currentZ);
        }
        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
          var executorGroup = executorGroups[t];
          executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);
        }
        if (contextSaved) {
          context.restore();
        }
      }
      context.globalAlpha = alpha;
      this.ready = ready;
      _get(_getPrototypeOf(CanvasVectorTileLayerRenderer.prototype), "postRender", this).call(this, context, frameState);
    }

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder group for decluttering.
     * @return {boolean} `true` if an image is loading.
     */
  }, {
    key: "renderFeature",
    value: function renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup) {
      if (!styles) {
        return false;
      }
      var loading = false;
      if (Array.isArray(styles)) {
        for (var i = 0, ii = styles.length; i < ii; ++i) {
          loading = (0, _vector.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup) || loading;
        }
      } else {
        loading = (0, _vector.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup);
      }
      return loading;
    }

    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @return {boolean} A new tile image was rendered.
     * @private
     */
  }, {
    key: "tileImageNeedsRender_",
    value: function tileImageNeedsRender_(tile) {
      var layer = /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      if (layer.getRenderMode() === 'vector') {
        return false;
      }
      var replayState = tile.getReplayState(layer);
      var revision = layer.getRevision();
      var resolution = tile.wantedResolution;
      return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
    }

    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
  }, {
    key: "renderTileImage_",
    value: function renderTileImage_(tile, frameState) {
      var layer = /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var replayState = tile.getReplayState(layer);
      var revision = layer.getRevision();
      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];
      replayState.renderedTileRevision = revision;
      var tileCoord = tile.wrappedTileCoord;
      var z = tileCoord[0];
      var source = layer.getSource();
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      var tileGrid = source.getTileGridForProjection(projection);
      var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
      var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
      var resolution = tileGrid.getResolution(z);
      var context = tile.getContext(layer);

      // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles
      pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
      var size = source.getTilePixelSize(z, pixelRatio, projection);
      context.canvas.width = size[0];
      context.canvas.height = size[1];
      var renderScale = pixelRatio / renderPixelRatio;
      if (renderScale !== 1) {
        var canvasTransform = (0, _transform.reset)(this.tmpTransform_);
        (0, _transform.scale)(canvasTransform, renderScale, renderScale);
        context.setTransform.apply(context, canvasTransform);
      }
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
      var pixelScale = renderPixelRatio / resolution;
      var transform = (0, _transform.reset)(this.tmpTransform_);
      (0, _transform.scale)(transform, pixelScale, -pixelScale);
      (0, _transform.translate)(transform, -tileExtent[0], -tileExtent[3]);
      for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
        var executorGroup = executorGroups[i];
        executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
      }
      replayState.renderedTileResolution = tile.wantedResolution;
    }
  }]);
  return CanvasVectorTileLayerRenderer;
}(_TileLayer.default);
var _default = exports.default = CanvasVectorTileLayerRenderer;
},{"../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","./TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js","../../TileState.js":"node_modules/ol/TileState.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../vector.js":"node_modules/ol/renderer/vector.js","../../util.js":"node_modules/ol/util.js","../../size.js":"node_modules/ol/size.js","../../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/layer/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));
var _VectorTileLayer = _interopRequireDefault(require("../renderer/canvas/VectorTileLayer.js"));
var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));
var _asserts = require("../asserts.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/VectorTile
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature
 */
/**
 * @typedef {'hybrid' | 'vector'} VectorTileRenderType
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor|false} [background] Background color for the layer. If not specified, no
 * background will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options} [options] Options.
 * @extends {BaseVectorLayer<import("../source/VectorTile.js").default, CanvasVectorTileLayerRenderer>}
 * @api
 */
var VectorTileLayer = /*#__PURE__*/function (_BaseVectorLayer) {
  _inherits(VectorTileLayer, _BaseVectorLayer);
  var _super = _createSuper(VectorTileLayer);
  /**
   * @param {Options} [options] Options.
   */
  function VectorTileLayer(options) {
    var _this;
    _classCallCheck(this, VectorTileLayer);
    options = options ? options : {};
    var baseOptions = /** @type {Object} */Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
    baseOptions);

    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */
    _this.on;

    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */
    _this.once;

    /***
     * @type {VectorTileLayerOnSignature<void>}
     */
    _this.un;
    var renderMode = options.renderMode || 'hybrid';
    (0, _asserts.assert)(renderMode == 'hybrid' || renderMode == 'vector', "`renderMode` must be `'hybrid'` or `'vector'`");

    /**
     * @private
     * @type {VectorTileRenderType}
     */
    _this.renderMode_ = renderMode;
    _this.setPreload(options.preload ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    /**
     * @return {import("./Base.js").BackgroundColor} Background color.
     * @function
     * @api
     */
    _this.getBackground;

    /**
     * @param {import("./Base.js").BackgroundColor} background Background color.
     * @function
     * @api
     */
    _this.setBackground;
    return _this;
  }
  _createClass(VectorTileLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new _VectorTileLayer.default(this);
    }

    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     */
  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return _get(_getPrototypeOf(VectorTileLayer.prototype), "getFeatures", this).call(this, pixel);
    }

    /**
     * @return {VectorTileRenderType} The render mode.
     */
  }, {
    key: "getRenderMode",
    value: function getRenderMode() {
      return this.renderMode_;
    }

    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
  }, {
    key: "getPreload",
    value: function getPreload() {
      return /** @type {number} */this.get(_TileProperty.default.PRELOAD);
    }

    /**
     * Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
  }, {
    key: "getUseInterimTilesOnError",
    value: function getUseInterimTilesOnError() {
      return /** @type {boolean} */(
        this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
      );
    }

    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
  }, {
    key: "setPreload",
    value: function setPreload(preload) {
      this.set(_TileProperty.default.PRELOAD, preload);
    }

    /**
     * Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
  }, {
    key: "setUseInterimTilesOnError",
    value: function setUseInterimTilesOnError(useInterimTilesOnError) {
      this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }
  }]);
  return VectorTileLayer;
}(_BaseVector.default);
var _default = exports.default = VectorTileLayer;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorTileLayer.js":"node_modules/ol/renderer/canvas/VectorTileLayer.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/webgl/styleparser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeHash = computeHash;
exports.expressionToGlsl = expressionToGlsl;
exports.packColor = packColor;
exports.parseLiteralStyle = parseLiteralStyle;
var _expression = require("../expr/expression.js");
var _ShaderBuilder = require("./ShaderBuilder.js");
var _gpu = require("../expr/gpu.js");
var _color = require("../color.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
 * Utilities for parsing literal style objects
 * @module ol/webgl/styleparser
 */
/**
 * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that
 * will be read and modified during the parsing operation.
 * @param {import("../expr/gpu.js").CompilationContext} compilationContext Compilation context
 * @param {import("../expr/expression.js").EncodedExpression} value Value
 * @param {number} [expectedType] Expected final type (can be several types combined)
 * @return {string} GLSL-compatible output
 */
function expressionToGlsl(compilationContext, value, expectedType) {
  var parsingContext = (0, _expression.newParsingContext)();
  parsingContext.style = compilationContext.style;
  return (0, _gpu.buildExpression)(value, expectedType, parsingContext, compilationContext);
}

/**
 * Packs all components of a color into a two-floats array
 * @param {import("../color.js").Color|string} color Color as array of numbers or string
 * @return {Array<number>} Vec2 array containing the color in compressed form
 */
function packColor(color) {
  var array = (0, _color.asArray)(color);
  var r = array[0] * 256;
  var g = array[1];
  var b = array[2] * 256;
  var a = Math.round(array[3] * 255);
  return [r + g, b + a];
}
var UNPACK_COLOR_FN = "vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}";

/**
 * @param {number} type Value type
 * @return {1|2|3|4} The amount of components for this value
 */
function getGlslSizeFromType(type) {
  if (type === _expression.ColorType) {
    return 2;
  }
  if (type === _expression.NumberArrayType) {
    return 4;
  }
  return 1;
}

/**
 * @param {number} type Value type
 * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value
 */
function getGlslTypeFromType(type) {
  var size = getGlslSizeFromType(type);
  if (size > 1) {
    return /** @type {'vec2'|'vec3'|'vec4'} */"vec".concat(size);
  }
  return 'float';
}

/**
 * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
 * @param {Object|string} input The hash input, either an object or string
 * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)
 */
function computeHash(input) {
  var hash = JSON.stringify(input).split('').reduce(function (prev, curr) {
    return (prev << 5) - prev + curr.charCodeAt(0);
  }, 0);
  return (hash >>> 0).toString();
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix
 */
function parseCommonSymbolProperties(style, builder, vertContext, prefix) {
  var radius;
  if ("".concat(prefix, "radius") in style && prefix !== 'icon-') {
    radius = expressionToGlsl(vertContext, style["".concat(prefix, "radius")], _expression.NumberType);
  } else if ("".concat(prefix, "radius1") in style && prefix === 'shape-') {
    radius = expressionToGlsl(vertContext, style["".concat(prefix, "radius1")], _expression.NumberType);
  }
  if (radius !== undefined) {
    if ("".concat(prefix, "stroke-width") in style) {
      radius = "(".concat(radius, " + ").concat(expressionToGlsl(vertContext, style["".concat(prefix, "stroke-width")], _expression.NumberType), " * 0.5)");
    }
    builder.setSymbolSizeExpression("vec2(".concat(radius, " * 2. + 0.5)")); // adding some padding for antialiasing
  }
  if ("".concat(prefix, "scale") in style) {
    var scale = expressionToGlsl(vertContext, style["".concat(prefix, "scale")], _expression.NumberType | _expression.NumberArrayType);
    builder.setSymbolSizeExpression("".concat(builder.getSymbolSizeExpression(), " * ").concat(scale));
  }
  if ("".concat(prefix, "displacement") in style) {
    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style["".concat(prefix, "displacement")], _expression.NumberArrayType));
  }
  if ("".concat(prefix, "rotation") in style) {
    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style["".concat(prefix, "rotation")], _expression.NumberType));
  }
  if ("".concat(prefix, "rotate-with-view") in style) {
    builder.setSymbolRotateWithView(!!style["".concat(prefix, "rotate-with-view")]);
  }
}

/**
 * @param {string} distanceField The distance field expression
 * @param {string|null} fillColor The fill color expression; null if no fill
 * @param {string|null} strokeColor The stroke color expression; null if no stroke
 * @param {string|null} strokeWidth The stroke width expression; null if no stroke
 * @param {string|null} opacity The opacity expression; null if no stroke
 * @return {string} The final color expression, based on the distance field and given params
 */
function getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {
  var color = 'vec4(0.)';
  if (fillColor !== null) {
    color = fillColor;
  }
  if (strokeColor !== null && strokeWidth !== null) {
    var strokeFillRatio = "smoothstep(-".concat(strokeWidth, " + 0.63, -").concat(strokeWidth, " - 0.58, ").concat(distanceField, ")");
    color = "mix(".concat(strokeColor, ", ").concat(color, ", ").concat(strokeFillRatio, ")");
  }
  var shapeOpacity = "(1.0 - smoothstep(-0.63, 0.58, ".concat(distanceField, "))");
  var result = "".concat(color, " * ").concat(shapeOpacity);
  if (opacity !== null) {
    result = "".concat(result, " * ").concat(opacity);
  }
  return result;
}

/**
 * This will parse an image property provided by `<prefix>-src`
 * The image size expression in GLSL will be returned
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix
 * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`
 * @return {string} The image size expression
 */
function parseImageProperties(style, builder, uniforms, prefix, textureId) {
  var image = new Image();
  var size;
  image.crossOrigin = style["".concat(prefix, "cross-origin")] === undefined ? 'anonymous' : style["".concat(prefix, "cross-origin")];
  image.src = style["".concat(prefix, "src")];
  if (image.complete && image.width && image.height) {
    size = (0, _gpu.arrayToGlsl)([image.width, image.height]);
  } else {
    // the size is provided asynchronously using a uniform
    uniforms["u_texture".concat(textureId, "_size")] = function () {
      return image.complete ? [image.width, image.height] : [0, 0];
    };
    builder.addUniform("vec2 u_texture".concat(textureId, "_size"));
    size = "u_texture".concat(textureId, "_size");
  }
  uniforms["u_texture".concat(textureId)] = image;
  builder.addUniform("sampler2D u_texture".concat(textureId));
  return size;
}

/**
 * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix
 * @param {import("../expr/gpu.js").CompilationContext} context Shader compilation context (vertex or fragment)
 * @param {string} imageSize Pixel size of the full image as a GLSL expression
 * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression
 * @return {string} The offset expression
 */
function parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {
  var offsetExpression = expressionToGlsl(context, style["".concat(prefix, "offset")], _expression.NumberArrayType);
  if ("".concat(prefix, "offset-origin") in style) {
    switch (style["".concat(prefix, "offset-origin")]) {
      case 'top-right':
        offsetExpression = "vec2(".concat(imageSize, ".x, 0.) + ").concat(sampleSize, " * vec2(-1., 0.) + ").concat(offsetExpression, " * vec2(-1., 1.)");
        break;
      case 'bottom-left':
        offsetExpression = "vec2(0., ".concat(imageSize, ".y) + ").concat(sampleSize, " * vec2(0., -1.) + ").concat(offsetExpression, " * vec2(1., -1.)");
        break;
      case 'bottom-right':
        offsetExpression = "".concat(imageSize, " - ").concat(sampleSize, " - ").concat(offsetExpression);
        break;
      default: // pass
    }
  }
  return offsetExpression;
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */
function parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {
  // this function takes in screen coordinates in pixels and returns the signed distance field
  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)
  fragContext.functions['circleDistanceField'] = "float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}";
  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');

  // OPACITY
  var opacity = null;
  if ('circle-opacity' in style) {
    opacity = expressionToGlsl(fragContext, style['circle-opacity'], _expression.NumberType);
  }

  // SCALE
  var currentPoint = 'coordsPx';
  if ('circle-scale' in style) {
    var scale = expressionToGlsl(fragContext, style['circle-scale'], _expression.NumberType | _expression.NumberArrayType);
    currentPoint = "coordsPx / ".concat(scale);
  }

  // FILL COLOR
  var fillColor = null;
  if ('circle-fill-color' in style) {
    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], _expression.ColorType);
  }

  // STROKE COLOR
  var strokeColor = null;
  if ('circle-stroke-color' in style) {
    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], _expression.ColorType);
  }

  // RADIUS
  var radius = expressionToGlsl(fragContext, style['circle-radius'], _expression.NumberType);

  // STROKE WIDTH
  var strokeWidth = null;
  if ('circle-stroke-width' in style) {
    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], _expression.NumberType);
    radius = "(".concat(radius, " + ").concat(strokeWidth, " * 0.5)");
  }

  // FINAL COLOR
  var distanceField = "circleDistanceField(".concat(currentPoint, ", ").concat(radius, ")");
  var colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);
  builder.setSymbolColorExpression(colorExpression);
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */
function parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {
  fragContext.functions['round'] = "float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}";

  // these functions take in screen coordinates in pixels and returns the signed distance field
  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)
  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon
  fragContext.functions['starDistanceField'] = "float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}";
  fragContext.functions['regularDistanceField'] = "float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}";
  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');

  // OPACITY
  var opacity = null;
  if ('shape-opacity' in style) {
    opacity = expressionToGlsl(fragContext, style['shape-opacity'], _expression.NumberType);
  }

  // SCALE
  var currentPoint = 'coordsPx';
  if ('shape-scale' in style) {
    var scale = expressionToGlsl(fragContext, style['shape-scale'], _expression.NumberType | _expression.NumberArrayType);
    currentPoint = "coordsPx / ".concat(scale);
  }

  // FILL COLOR
  var fillColor = null;
  if ('shape-fill-color' in style) {
    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], _expression.ColorType);
  }

  // STROKE COLOR
  var strokeColor = null;
  if ('shape-stroke-color' in style) {
    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], _expression.ColorType);
  }

  // STROKE WIDTH
  var strokeWidth = null;
  if ('shape-stroke-width' in style) {
    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], _expression.NumberType);
  }

  // SHAPE TYPE
  var numPoints = expressionToGlsl(fragContext, style['shape-points'], _expression.NumberType);
  var angle = '0.';
  if ('shape-angle' in style) {
    angle = expressionToGlsl(fragContext, style['shape-angle'], _expression.NumberType);
  }
  var shapeField;
  if ('shape-radius' in style) {
    var radius = expressionToGlsl(fragContext, style['shape-radius'], _expression.NumberType);
    if (strokeWidth !== null) {
      radius = "".concat(radius, " + ").concat(strokeWidth, " * 0.5");
    }
    shapeField = "regularDistanceField(".concat(currentPoint, ", ").concat(numPoints, ", ").concat(radius, ", ").concat(angle, ")");
  } else {
    var radiusOuter = expressionToGlsl(fragContext, style['shape-radius1'], _expression.NumberType);
    var radiusInner = expressionToGlsl(fragContext, style['shape-radius2'], _expression.NumberType);
    if (strokeWidth !== null) {
      radiusOuter = "".concat(radiusOuter, " + ").concat(strokeWidth, " * 0.5");
      radiusInner = "".concat(radiusInner, " + ").concat(strokeWidth, " * 0.5");
    }
    shapeField = "starDistanceField(".concat(currentPoint, ", ").concat(numPoints, ", ").concat(radiusInner, ", ").concat(radiusOuter, ", ").concat(angle, ")");
  }

  // FINAL COLOR
  var colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);
  builder.setSymbolColorExpression(colorExpression);
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */
function parseIconProperties(style, builder, uniforms, vertContext, fragContext) {
  // COLOR
  var color = 'vec4(1.0)';
  if ('icon-color' in style) {
    color = expressionToGlsl(fragContext, style['icon-color'], _expression.ColorType);
  }

  // OPACITY
  if ('icon-opacity' in style) {
    color = "".concat(color, " * ").concat(expressionToGlsl(fragContext, style['icon-opacity'], _expression.NumberType));
  }

  // IMAGE & SIZE
  var textureId = computeHash(style['icon-src']);
  var sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);
  builder.setSymbolColorExpression("".concat(color, " * samplePremultiplied(u_texture").concat(textureId, ", v_texCoord)")).setSymbolSizeExpression(sizeExpression);

  // override size if width/height were specified
  if ('icon-width' in style && 'icon-height' in style) {
    builder.setSymbolSizeExpression("vec2(".concat(expressionToGlsl(vertContext, style['icon-width'], _expression.NumberType), ", ").concat(expressionToGlsl(vertContext, style['icon-height'], _expression.NumberType), ")"));
  }

  // tex coord
  if ('icon-offset' in style && 'icon-size' in style) {
    var sampleSize = expressionToGlsl(vertContext, style['icon-size'], _expression.NumberArrayType);
    var fullsize = builder.getSymbolSizeExpression();
    builder.setSymbolSizeExpression(sampleSize);
    var offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);
    builder.setTextureCoordinateExpression("(vec4((".concat(offset, ").xyxy) + vec4(0., 0., ").concat(sampleSize, ")) / (").concat(fullsize, ").xyxy"));
  }
  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');
  if ('icon-anchor' in style) {
    var anchor = expressionToGlsl(vertContext, style['icon-anchor'], _expression.NumberArrayType);
    var scale = "1.0";
    if ("icon-scale" in style) {
      scale = expressionToGlsl(vertContext, style["icon-scale"], _expression.NumberType | _expression.NumberArrayType);
    }
    var shiftPx;
    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {
      shiftPx = "".concat(anchor, " * ").concat(scale);
    } else if (style['icon-anchor-x-units'] === 'pixels') {
      shiftPx = "".concat(anchor, " * vec2(vec2(").concat(scale, ").x, v_quadSizePx.y)");
    } else if (style['icon-anchor-y-units'] === 'pixels') {
      shiftPx = "".concat(anchor, " * vec2(v_quadSizePx.x, vec2(").concat(scale, ").x)");
    } else {
      shiftPx = "".concat(anchor, " * v_quadSizePx");
    }
    // default origin is top-left
    var offsetPx = "v_quadSizePx * vec2(0.5, -0.5) + ".concat(shiftPx, " * vec2(-1., 1.)");
    if ('icon-anchor-origin' in style) {
      switch (style['icon-anchor-origin']) {
        case 'top-right':
          offsetPx = "v_quadSizePx * -0.5 + ".concat(shiftPx);
          break;
        case 'bottom-left':
          offsetPx = "v_quadSizePx * 0.5 - ".concat(shiftPx);
          break;
        case 'bottom-right':
          offsetPx = "v_quadSizePx * vec2(-0.5, 0.5) + ".concat(shiftPx, " * vec2(1., -1.)");
          break;
        default: // pass
      }
    }
    builder.setSymbolOffsetExpression("".concat(builder.getSymbolOffsetExpression(), " + ").concat(offsetPx));
  }
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader Builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */
function parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {
  if ('stroke-color' in style) {
    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], _expression.ColorType));
  }
  if ('stroke-pattern-src' in style) {
    var textureId = computeHash(style['stroke-pattern-src']);
    var sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);
    var sampleSizeExpression = sizeExpression;
    var offsetExpression = 'vec2(0.)';
    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {
      sampleSizeExpression = expressionToGlsl(fragContext, style["stroke-pattern-size"], _expression.NumberArrayType);
      offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);
    }
    var spacingExpression = '0.';
    if ('stroke-pattern-spacing' in style) {
      spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], _expression.NumberType);
    }
    fragContext.functions['sampleStrokePattern'] = "vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {\n      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;\n      float spacingScaled = spacingPx * sampleSize.y / v_width;\n      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);\n    }";
    var textureName = "u_texture".concat(textureId);
    var tintExpression = '1.';
    if ('stroke-color' in style) {
      tintExpression = builder.getStrokeColorExpression();
    }
    builder.setStrokeColorExpression("".concat(tintExpression, " * sampleStrokePattern(").concat(textureName, ", ").concat(sizeExpression, ", ").concat(offsetExpression, ", ").concat(sampleSizeExpression, ", ").concat(spacingExpression, ", currentLengthPx, currentRadiusRatio)"));
  }
  if ('stroke-width' in style) {
    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], _expression.NumberType));
  }
  if ('stroke-offset' in style) {
    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], _expression.NumberType));
  }
  if ('stroke-line-cap' in style) {
    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], _expression.StringType));
  }
  if ('stroke-line-join' in style) {
    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], _expression.StringType));
  }
  if ('stroke-miter-limit' in style) {
    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], _expression.NumberType));
  }
  if ('stroke-line-dash' in style) {
    fragContext.functions['getSingleDashDistance'] = "float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ".concat((0, _gpu.stringToGlsl)('square'), ") {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ").concat((0, _gpu.stringToGlsl)('round'), ") {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}");
    var dashPattern = style['stroke-line-dash'].map(function (v) {
      return expressionToGlsl(fragContext, v, _expression.NumberType);
    });
    // if pattern has odd length, concatenate it with itself to be even
    if (dashPattern.length % 2 === 1) {
      dashPattern = [].concat(_toConsumableArray(dashPattern), _toConsumableArray(dashPattern));
    }
    var _offsetExpression = '0.';
    if ('stroke-line-dash-offset' in style) {
      _offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], _expression.NumberType);
    }

    // define a function for this dash specifically
    var uniqueDashKey = computeHash(style['stroke-line-dash']);
    var dashFunctionName = "dashDistanceField_".concat(uniqueDashKey);
    var dashLengthsDef = dashPattern.map(function (v, i) {
      return "float dashLength".concat(i, " = ").concat(v, ";");
    });
    var totalLengthDef = dashPattern.map(function (v, i) {
      return "dashLength".concat(i);
    }).join(' + ');
    var currentDashOffset = '0.';
    var distanceExpression = "getSingleDashDistance(distance, radius, ".concat(currentDashOffset, ", dashLength0, totalDashLength, capType)");
    for (var i = 2; i < dashPattern.length; i += 2) {
      currentDashOffset = "".concat(currentDashOffset, " + dashLength").concat(i - 2, " + dashLength").concat(i - 1);
      distanceExpression = "min(".concat(distanceExpression, ", getSingleDashDistance(distance, radius, ").concat(currentDashOffset, ", dashLength").concat(i, ", totalDashLength, capType))");
    }
    fragContext.functions[dashFunctionName] = "float ".concat(dashFunctionName, "(float distance, float radius, float capType) {\n  ").concat(dashLengthsDef.join('\n  '), "\n  float totalDashLength = ").concat(totalLengthDef, ";\n  return ").concat(distanceExpression, ";\n}");
    builder.setStrokeDistanceFieldExpression("".concat(dashFunctionName, "(currentLengthPx + ").concat(_offsetExpression, ", currentRadiusPx, capType)"));
  }
}

/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader Builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */
function parseFillProperties(style, builder, uniforms, vertContext, fragContext) {
  if ('fill-color' in style) {
    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], _expression.ColorType));
  }
  if ('fill-pattern-src' in style) {
    var textureId = computeHash(style['fill-pattern-src']);
    var sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);
    var sampleSizeExpression = sizeExpression;
    var offsetExpression = 'vec2(0.)';
    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {
      sampleSizeExpression = expressionToGlsl(fragContext, style["fill-pattern-size"], _expression.NumberArrayType);
      offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);
    }
    fragContext.functions['sampleFillPattern'] = "vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}";
    var textureName = "u_texture".concat(textureId);
    var tintExpression = '1.';
    if ('fill-color' in style) {
      tintExpression = builder.getFillColorExpression();
    }
    builder.setFillColorExpression("".concat(tintExpression, " * sampleFillPattern(").concat(textureName, ", ").concat(sizeExpression, ", ").concat(offsetExpression, ", ").concat(sampleSizeExpression, ", pxOrigin, pxPos)"));
  }
}

/**
 * @typedef {Object} StyleParseResult
 * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style
 * @property {import("../render/webgl/VectorStyleRenderer.js").UniformDefinitions} uniforms Uniform definitions
 * @property {import("../render/webgl/VectorStyleRenderer.js").AttributeDefinitions} attributes Attribute definitions
 */

/**
 * Parses a {@link import("../style/webgl.js").WebGLStyle} object and returns a {@link ShaderBuilder}
 * object that has been configured according to the given style, as well as `attributes` and `uniforms`
 * arrays to be fed to the `WebGLPointsRenderer` class.
 *
 * Also returns `uniforms` and `attributes` properties as expected by the
 * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 * @param {import("../style/webgl.js").WebGLStyle} style Literal style.
 * @return {StyleParseResult} Result containing shader params, attributes and uniforms.
 */
function parseLiteralStyle(style) {
  /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */
  var vertContext = {
    inFragmentShader: false,
    properties: {},
    variables: {},
    functions: {},
    style: style
  };

  /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */
  var fragContext = {
    inFragmentShader: true,
    variables: vertContext.variables,
    properties: {},
    functions: {},
    style: style
  };
  var builder = new _ShaderBuilder.ShaderBuilder();

  /** @type {Object<string,import("../webgl/Helper").UniformValue>} */
  var uniforms = {};
  if ('icon-src' in style) {
    parseIconProperties(style, builder, uniforms, vertContext, fragContext);
  } else if ('shape-points' in style) {
    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);
  } else if ('circle-radius' in style) {
    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);
  }
  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);
  parseFillProperties(style, builder, uniforms, vertContext, fragContext);
  if (style.filter) {
    var parsedFilter = expressionToGlsl(fragContext, style.filter, _expression.BooleanType);
    builder.setFragmentDiscardExpression("!".concat(parsedFilter));
  }

  // define one uniform per variable
  Object.keys(fragContext.variables).forEach(function (varName) {
    var variable = fragContext.variables[varName];
    var uniformName = (0, _gpu.uniformNameForVariable)(variable.name);
    builder.addUniform("".concat(getGlslTypeFromType(variable.type), " ").concat(uniformName));
    var callback;
    if (variable.type === _expression.StringType) {
      callback = function callback() {
        return (0, _gpu.getStringNumberEquivalent)( /** @type {string} */style.variables[variable.name]);
      };
    } else if (variable.type === _expression.ColorType) {
      callback = function callback() {
        return packColor(_toConsumableArray((0, _color.asArray)( /** @type {string|Array<number>} */style.variables[variable.name] || '#eee')));
      };
    } else if (variable.type === _expression.BooleanType) {
      callback = function callback() {
        return /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;
      };
    } else {
      callback = function callback() {
        return /** @type {number} */style.variables[variable.name];
      };
    }
    uniforms[uniformName] = callback;
  });

  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data
  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)
  Object.keys(fragContext.properties).forEach(function (propName) {
    var property = fragContext.properties[propName];
    if (!vertContext.properties[propName]) {
      vertContext.properties[propName] = property;
    }
    var type = getGlslTypeFromType(property.type);
    var expression = "a_prop_".concat(property.name);
    if (property.type === _expression.ColorType) {
      type = 'vec4';
      expression = "unpackColor(".concat(expression, ")");
      builder.addVertexShaderFunction(UNPACK_COLOR_FN);
    }
    builder.addVarying("v_prop_".concat(property.name), type, expression);
  });

  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.
  Object.keys(vertContext.properties).forEach(function (propName) {
    var property = vertContext.properties[propName];
    builder.addAttribute("".concat(getGlslTypeFromType(property.type), " a_prop_").concat(property.name));
  });
  var attributes = Object.keys(vertContext.properties).map(function (propName) {
    var property = vertContext.properties[propName];
    var callback;
    if (property.evaluator) {
      callback = property.evaluator;
    } else if (property.type === _expression.StringType) {
      callback = function callback(feature) {
        return (0, _gpu.getStringNumberEquivalent)(feature.get(property.name));
      };
    } else if (property.type === _expression.ColorType) {
      callback = function callback(feature) {
        return packColor(_toConsumableArray((0, _color.asArray)(feature.get(property.name) || '#eee')));
      };
    } else if (property.type === _expression.BooleanType) {
      callback = function callback(feature) {
        return feature.get(property.name) ? 1.0 : 0.0;
      };
    } else {
      callback = function callback(feature) {
        return feature.get(property.name);
      };
    }
    return {
      name: property.name,
      size: getGlslSizeFromType(property.type),
      callback: callback
    };
  });

  // add functions that were collected in the compilation contexts
  for (var functionName in vertContext.functions) {
    builder.addVertexShaderFunction(vertContext.functions[functionName]);
  }
  for (var _functionName in fragContext.functions) {
    builder.addFragmentShaderFunction(fragContext.functions[_functionName]);
  }
  return {
    builder: builder,
    attributes: attributes.reduce(function (prev, curr) {
      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, curr.name, {
        callback: curr.callback,
        size: curr.size
      }));
    }, {}),
    uniforms: uniforms
  };
}
},{"../expr/expression.js":"node_modules/ol/expr/expression.js","./ShaderBuilder.js":"node_modules/ol/webgl/ShaderBuilder.js","../expr/gpu.js":"node_modules/ol/expr/gpu.js","../color.js":"node_modules/ol/color.js"}],"node_modules/ol/layer/WebGLPoints.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Layer2 = _interopRequireDefault(require("./Layer.js"));
var _PointsLayer = _interopRequireDefault(require("../renderer/webgl/PointsLayer.js"));
var _styleparser = require("../webgl/styleparser.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/layer/WebGLPoints
 */
/**
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {import('../style/webgl.js').WebGLStyle} style Literal style to apply to the layer features.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {VectorSourceType} [source] Point source.
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Layer optimized for rendering large point datasets. Takes a `style` property which
 * is a serializable JSON object describing how the layer should be rendered.
 *
 * Here are a few samples of literal style objects:
 * ```js
 * const style = {
 *   'circle-radius': 8,
 *   'circle-fill-color': '#33AAFF',
 *   'circle-opacity': 0.9
 * }
 * ```
 *
 * ```js
 * const style = {
 *   'icon-src': '../static/exclamation-mark.png',
 *   'icon-offset': [0, 12],
 *   'icon-width': 4,
 *   'icon-height': 8
 * }
 * ```
 *
 * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context
 * will not be garbage collected.**
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}
 * @fires import("../render/Event.js").RenderEvent
 */
var WebGLPointsLayer = /*#__PURE__*/function (_Layer) {
  _inherits(WebGLPointsLayer, _Layer);
  var _super = _createSuper(WebGLPointsLayer);
  /**
   * @param {Options<VectorSourceType>} options Options.
   */
  function WebGLPointsLayer(options) {
    var _this;
    _classCallCheck(this, WebGLPointsLayer);
    var baseOptions = Object.assign({}, options);
    _this = _super.call(this, baseOptions);

    /**
     * @private
     * @type {import('../webgl/styleparser.js').StyleParseResult}
     */
    _this.parseResult_ = (0, _styleparser.parseLiteralStyle)(options.style);

    /**
     * @type {Object<string, (string|number|Array<number>|boolean)>}
     * @private
     */
    _this.styleVariables_ = options.style.variables || {};

    /**
     * @private
     * @type {boolean}
     */
    _this.hitDetectionDisabled_ = !!options.disableHitDetection;
    return _this;
  }
  _createClass(WebGLPointsLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      var _this2 = this;
      var attributes = Object.keys(this.parseResult_.attributes).map(function (name) {
        return _objectSpread({
          name: name
        }, _this2.parseResult_.attributes[name]);
      });
      return new _PointsLayer.default(this, {
        vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
        fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
        hitDetectionEnabled: !this.hitDetectionDisabled_,
        uniforms: this.parseResult_.uniforms,
        attributes: ( /** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */
        attributes)
      });
    }

    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     */
  }, {
    key: "updateStyleVariables",
    value: function updateStyleVariables(variables) {
      Object.assign(this.styleVariables_, variables);
      this.changed();
    }
  }]);
  return WebGLPointsLayer;
}(_Layer2.default);
var _default = exports.default = WebGLPointsLayer;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","../renderer/webgl/PointsLayer.js":"node_modules/ol/renderer/webgl/PointsLayer.js","../webgl/styleparser.js":"node_modules/ol/webgl/styleparser.js"}],"node_modules/ol/layer/WebGLTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseTile = _interopRequireDefault(require("./BaseTile.js"));
var _Property = _interopRequireDefault(require("../layer/Property.js"));
var _TileLayer = _interopRequireWildcard(require("../renderer/webgl/TileLayer.js"));
var _expression = require("../expr/expression.js");
var _gpu = require("../expr/gpu.js");
var _styleparser = require("../webgl/styleparser.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * @module ol/layer/WebGLTile
 */
/**
 * @typedef {import("../source/DataTile.js").default|import("../source/TileImage.js").default} SourceType
 */

/**
 * @typedef {Object} Style
 * Translates tile data to rendered pixels.
 *
 * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These
 * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
 * {@link import("../expr/expression.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLTile.js").default#updateStyleVariables} method.
 * @property {import("../expr/expression.js").ExpressionValue} [color] An expression applied to color values.
 * @property {import("../expr/expression.js").ExpressionValue} [brightness=0] Value used to decrease or increase
 * the layer brightness.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [contrast=0] Value used to decrease or increase
 * the layer contrast.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [exposure=0] Value used to decrease or increase
 * the layer exposure.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [saturation=0] Value used to decrease or increase
 * the layer saturation.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.
 * Values range from 0 to infinity.
 */

/**
 * @typedef {Object} Options
 * @property {Style} [style] Style to apply to the layer.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {SourceType} [source] Source for this layer.
 * @property {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>} [sources] Array
 * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that
 * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See
 * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a
 * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map~Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @typedef {Object} ParsedStyle
 * @property {string} vertexShader The vertex shader.
 * @property {string} fragmentShader The fragment shader.
 * @property {Object<string,import("../webgl/Helper.js").UniformValue>} uniforms Uniform definitions.
 * @property {Array<import("../webgl/PaletteTexture.js").default>} paletteTextures Palette textures.
 */

/**
 * @param {Style} style The layer style.
 * @param {number} [bandCount] The number of bands.
 * @return {ParsedStyle} Shaders and uniforms generated from the style.
 */
function parseStyle(style, bandCount) {
  var vertexShader = "\n    attribute vec2 ".concat(_TileLayer.Attributes.TEXTURE_COORD, ";\n    uniform mat4 ").concat(_TileLayer.Uniforms.TILE_TRANSFORM, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_RESOLUTION, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_ORIGIN_X, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_ORIGIN_Y, ";\n    uniform float ").concat(_TileLayer.Uniforms.DEPTH, ";\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ").concat(_TileLayer.Attributes.TEXTURE_COORD, ";\n      v_mapCoord = vec2(\n        ").concat(_TileLayer.Uniforms.TEXTURE_ORIGIN_X, " + ").concat(_TileLayer.Uniforms.TEXTURE_RESOLUTION, " * ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_WIDTH, " * v_textureCoord[0],\n        ").concat(_TileLayer.Uniforms.TEXTURE_ORIGIN_Y, " - ").concat(_TileLayer.Uniforms.TEXTURE_RESOLUTION, " * ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_HEIGHT, " * v_textureCoord[1]\n      );\n      gl_Position = ").concat(_TileLayer.Uniforms.TILE_TRANSFORM, " * vec4(").concat(_TileLayer.Attributes.TEXTURE_COORD, ", ").concat(_TileLayer.Uniforms.DEPTH, ", 1.0);\n    }\n  ");

  /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */
  var context = _objectSpread(_objectSpread({}, (0, _gpu.newCompilationContext)()), {}, {
    inFragmentShader: true,
    bandCount: bandCount,
    style: style
  });
  var pipeline = [];
  if (style.color !== undefined) {
    var color = (0, _styleparser.expressionToGlsl)(context, style.color, _expression.ColorType);
    pipeline.push("color = ".concat(color, ";"));
  }
  if (style.contrast !== undefined) {
    var contrast = (0, _styleparser.expressionToGlsl)(context, style.contrast, _expression.NumberType);
    pipeline.push("color.rgb = clamp((".concat(contrast, " + 1.0) * color.rgb - (").concat(contrast, " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style.exposure !== undefined) {
    var exposure = (0, _styleparser.expressionToGlsl)(context, style.exposure, _expression.NumberType);
    pipeline.push("color.rgb = clamp((".concat(exposure, " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style.saturation !== undefined) {
    var saturation = (0, _styleparser.expressionToGlsl)(context, style.saturation, _expression.NumberType);
    pipeline.push("\n      float saturation = ".concat(saturation, " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    "));
  }
  if (style.gamma !== undefined) {
    var gamma = (0, _styleparser.expressionToGlsl)(context, style.gamma, _expression.NumberType);
    pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / ".concat(gamma, "));"));
  }
  if (style.brightness !== undefined) {
    var brightness = (0, _styleparser.expressionToGlsl)(context, style.brightness, _expression.NumberType);
    pipeline.push("color.rgb = clamp(color.rgb + ".concat(brightness, ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }

  /** @type {Object<string,import("../webgl/Helper").UniformValue>} */
  var uniforms = {};
  var numVariables = Object.keys(context.variables).length;
  if (numVariables > 1 && !style.variables) {
    throw new Error("Missing variables in style (expected ".concat(context.variables, ")"));
  }
  var _loop = function _loop() {
    var variable = context.variables[Object.keys(context.variables)[i]];
    if (!(variable.name in style.variables)) {
      throw new Error("Missing '".concat(variable.name, "' in style variables"));
    }
    var uniformName = (0, _gpu.uniformNameForVariable)(variable.name);
    uniforms[uniformName] = function () {
      var value = style.variables[variable.name];
      if (typeof value === 'string') {
        value = (0, _gpu.getStringNumberEquivalent)(value);
      }
      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
    };
  };
  for (var i = 0; i < numVariables; ++i) {
    _loop();
  }
  var uniformDeclarations = Object.keys(uniforms).map(function (name) {
    return "uniform float ".concat(name, ";");
  });
  var textureCount = Math.ceil(bandCount / 4);
  uniformDeclarations.push("uniform sampler2D ".concat(_TileLayer.Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureCount, "];"));
  if (context.paletteTextures) {
    uniformDeclarations.push("uniform sampler2D ".concat(_gpu.PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "];"));
  }
  var functionDefintions = Object.keys(context.functions).map(function (name) {
    return context.functions[name];
  });
  var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ".concat(_TileLayer.Uniforms.RENDER_EXTENT, ";\n    uniform float ").concat(_TileLayer.Uniforms.TRANSITION_ALPHA, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(_TileLayer.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(_TileLayer.Uniforms.RESOLUTION, ";\n    uniform float ").concat(_TileLayer.Uniforms.ZOOM, ";\n\n    ").concat(uniformDeclarations.join('\n'), "\n\n    ").concat(functionDefintions.join('\n'), "\n\n    void main() {\n      if (\n        v_mapCoord[0] < ").concat(_TileLayer.Uniforms.RENDER_EXTENT, "[0] ||\n        v_mapCoord[1] < ").concat(_TileLayer.Uniforms.RENDER_EXTENT, "[1] ||\n        v_mapCoord[0] > ").concat(_TileLayer.Uniforms.RENDER_EXTENT, "[2] ||\n        v_mapCoord[1] > ").concat(_TileLayer.Uniforms.RENDER_EXTENT, "[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(").concat(_TileLayer.Uniforms.TILE_TEXTURE_ARRAY, "[0],  v_textureCoord);\n\n      ").concat(pipeline.join('\n'), "\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ").concat(_TileLayer.Uniforms.TRANSITION_ALPHA, ";\n    }");
  return {
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    uniforms: uniforms,
    paletteTextures: context.paletteTextures
  };
}

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */
var WebGLTileLayer = /*#__PURE__*/function (_BaseTileLayer) {
  _inherits(WebGLTileLayer, _BaseTileLayer);
  var _super = _createSuper(WebGLTileLayer);
  /**
   * @param {Options} options Tile layer options.
   */
  function WebGLTileLayer(options) {
    var _this;
    _classCallCheck(this, WebGLTileLayer);
    options = options ? Object.assign({}, options) : {};
    var style = options.style || {};
    delete options.style;
    var cacheSize = options.cacheSize;
    delete options.cacheSize;
    _this = _super.call(this, options);

    /**
     * @type {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>}
     * @private
     */
    _this.sources_ = options.sources;

    /**
     * @type {SourceType|null}
     * @private
     */
    _this.renderedSource_ = null;

    /**
     * @type {number}
     * @private
     */
    _this.renderedResolution_ = NaN;

    /**
     * @type {Style}
     * @private
     */
    _this.style_ = style;

    /**
     * @type {number}
     * @private
     */
    _this.cacheSize_ = cacheSize;

    /**
     * @type {Object<string, (string|number)>}
     * @private
     */
    _this.styleVariables_ = _this.style_.variables || {};
    _this.addChangeListener(_Property.default.SOURCE, _this.handleSourceUpdate_);
    return _this;
  }

  /**
   * Gets the sources for this layer, for a given extent and resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<SourceType>} Sources.
   */
  _createClass(WebGLTileLayer, [{
    key: "getSources",
    value: function getSources(extent, resolution) {
      var source = this.getSource();
      return this.sources_ ? typeof this.sources_ === 'function' ? this.sources_(extent, resolution) : this.sources_ : source ? [source] : [];
    }

    /**
     * @return {SourceType} The source being rendered.
     */
  }, {
    key: "getRenderSource",
    value: function getRenderSource() {
      return this.renderedSource_ || this.getSource();
    }

    /**
     * @return {import("../source/Source.js").State} Source state.
     */
  }, {
    key: "getSourceState",
    value: function getSourceState() {
      var source = this.getRenderSource();
      return source ? source.getState() : 'undefined';
    }

    /**
     * @private
     */
  }, {
    key: "handleSourceUpdate_",
    value: function handleSourceUpdate_() {
      if (this.hasRenderer()) {
        this.getRenderer().clearCache();
      }
      if (this.getSource()) {
        this.setStyle(this.style_);
      }
    }

    /**
     * @private
     * @return {number} The number of source bands.
     */
  }, {
    key: "getSourceBandCount_",
    value: function getSourceBandCount_() {
      var max = Number.MAX_SAFE_INTEGER;
      var sources = this.getSources([-max, -max, max, max], max);
      return sources && sources.length && 'bandCount' in sources[0] ? sources[0].bandCount : 4;
    }
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
      return new _TileLayer.default(this, {
        vertexShader: parsedStyle.vertexShader,
        fragmentShader: parsedStyle.fragmentShader,
        uniforms: parsedStyle.uniforms,
        cacheSize: this.cacheSize_,
        paletteTextures: parsedStyle.paletteTextures
      });
    }

    /**
     * @param {import("../Map").FrameState} frameState Frame state.
     * @param {Array<SourceType>} sources Sources.
     * @return {HTMLElement} Canvas.
     */
  }, {
    key: "renderSources",
    value: function renderSources(frameState, sources) {
      var layerRenderer = this.getRenderer();
      var canvas;
      for (var i = 0, ii = sources.length; i < ii; ++i) {
        this.renderedSource_ = sources[i];
        if (layerRenderer.prepareFrame(frameState)) {
          canvas = layerRenderer.renderFrame(frameState);
        }
      }
      return canvas;
    }

    /**
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement} The rendered element.
     */
  }, {
    key: "render",
    value: function render(frameState, target) {
      var _this2 = this;
      this.rendered = true;
      var viewState = frameState.viewState;
      var sources = this.getSources(frameState.extent, viewState.resolution);
      var ready = true;
      var _loop2 = function _loop2() {
        var source = sources[i];
        var sourceState = source.getState();
        if (sourceState == 'loading') {
          var onChange = function onChange() {
            if (source.getState() == 'ready') {
              source.removeEventListener('change', onChange);
              _this2.changed();
            }
          };
          source.addEventListener('change', onChange);
        }
        ready = ready && sourceState == 'ready';
      };
      for (var i = 0, ii = sources.length; i < ii; ++i) {
        _loop2();
      }
      var canvas = this.renderSources(frameState, sources);
      if (this.getRenderer().renderComplete && ready) {
        // Fully rendered, done.
        this.renderedResolution_ = viewState.resolution;
        return canvas;
      }
      // Render sources from previously fully rendered frames
      if (this.renderedResolution_ > 0.5 * viewState.resolution) {
        var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function (source) {
          return !sources.includes(source);
        });
        if (altSources.length > 0) {
          return this.renderSources(frameState, altSources);
        }
      }
      return canvas;
    }

    /**
     * Update the layer style.  The `updateStyleVariables` function is a more efficient
     * way to update layer rendering.  In cases where the whole style needs to be updated,
     * this method may be called instead.  Note that calling this method will also replace
     * any previously set variables, so the new style also needs to include new variables,
     * if needed.
     * @param {Style} style The new style.
     */
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.styleVariables_ = style.variables || {};
      this.style_ = style;
      var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
      var renderer = this.getRenderer();
      renderer.reset({
        vertexShader: parsedStyle.vertexShader,
        fragmentShader: parsedStyle.fragmentShader,
        uniforms: parsedStyle.uniforms,
        paletteTextures: parsedStyle.paletteTextures
      });
      this.changed();
    }

    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     * @api
     */
  }, {
    key: "updateStyleVariables",
    value: function updateStyleVariables(variables) {
      Object.assign(this.styleVariables_, variables);
      this.changed();
    }
  }]);
  return WebGLTileLayer;
}(_BaseTile.default);
/**
 * Clean up underlying WebGL resources.
 * @function
 * @api
 */
WebGLTileLayer.prototype.dispose;
var _default = exports.default = WebGLTileLayer;
},{"./BaseTile.js":"node_modules/ol/layer/BaseTile.js","../layer/Property.js":"node_modules/ol/layer/Property.js","../renderer/webgl/TileLayer.js":"node_modules/ol/renderer/webgl/TileLayer.js","../expr/expression.js":"node_modules/ol/expr/expression.js","../expr/gpu.js":"node_modules/ol/expr/gpu.js","../webgl/styleparser.js":"node_modules/ol/webgl/styleparser.js"}],"node_modules/ol/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Graticule", {
  enumerable: true,
  get: function () {
    return _Graticule.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function () {
    return _Group.default;
  }
});
Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function () {
    return _Heatmap.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _Layer.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "Vector", {
  enumerable: true,
  get: function () {
    return _Vector.default;
  }
});
Object.defineProperty(exports, "VectorImage", {
  enumerable: true,
  get: function () {
    return _VectorImage.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});
Object.defineProperty(exports, "WebGLPoints", {
  enumerable: true,
  get: function () {
    return _WebGLPoints.default;
  }
});
Object.defineProperty(exports, "WebGLTile", {
  enumerable: true,
  get: function () {
    return _WebGLTile.default;
  }
});
var _Graticule = _interopRequireDefault(require("./layer/Graticule.js"));
var _Group = _interopRequireDefault(require("./layer/Group.js"));
var _Heatmap = _interopRequireDefault(require("./layer/Heatmap.js"));
var _Image = _interopRequireDefault(require("./layer/Image.js"));
var _Layer = _interopRequireDefault(require("./layer/Layer.js"));
var _Tile = _interopRequireDefault(require("./layer/Tile.js"));
var _Vector = _interopRequireDefault(require("./layer/Vector.js"));
var _VectorImage = _interopRequireDefault(require("./layer/VectorImage.js"));
var _VectorTile = _interopRequireDefault(require("./layer/VectorTile.js"));
var _WebGLPoints = _interopRequireDefault(require("./layer/WebGLPoints.js"));
var _WebGLTile = _interopRequireDefault(require("./layer/WebGLTile.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./layer/Graticule.js":"node_modules/ol/layer/Graticule.js","./layer/Group.js":"node_modules/ol/layer/Group.js","./layer/Heatmap.js":"node_modules/ol/layer/Heatmap.js","./layer/Image.js":"node_modules/ol/layer/Image.js","./layer/Layer.js":"node_modules/ol/layer/Layer.js","./layer/Tile.js":"node_modules/ol/layer/Tile.js","./layer/Vector.js":"node_modules/ol/layer/Vector.js","./layer/VectorImage.js":"node_modules/ol/layer/VectorImage.js","./layer/VectorTile.js":"node_modules/ol/layer/VectorTile.js","./layer/WebGLPoints.js":"node_modules/ol/layer/WebGLPoints.js","./layer/WebGLTile.js":"node_modules/ol/layer/WebGLTile.js"}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');
function updateLink(link) {
  var newLink = link.cloneNode();
  newLink.onload = function () {
    link.remove();
  };
  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
  if (cssTimeout) {
    return;
  }
  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }
    cssTimeout = null;
  }, 50);
}
module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"node_modules/ol/ol.css":[function(require,module,exports) {
var reloadCSS = require('_css_loader');
module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js"}],"node_modules/ol/Geolocation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GeolocationError = void 0;
var _Event = _interopRequireDefault(require("./events/Event.js"));
var _Object = _interopRequireDefault(require("./Object.js"));
var _Polygon = require("./geom/Polygon.js");
var _proj = require("./proj.js");
var _math = require("./math.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Geolocation
 */
/**
 * @enum {string}
 */
var Property = {
  ACCURACY: 'accuracy',
  ACCURACY_GEOMETRY: 'accuracyGeometry',
  ALTITUDE: 'altitude',
  ALTITUDE_ACCURACY: 'altitudeAccuracy',
  HEADING: 'heading',
  POSITION: 'position',
  PROJECTION: 'projection',
  SPEED: 'speed',
  TRACKING: 'tracking',
  TRACKING_OPTIONS: 'trackingOptions'
};

/**
 * @enum string
 */
var GeolocationErrorType = {
  /**
   * Triggered when a `GeolocationPositionError` occurs.
   * @event module:ol/Geolocation.GeolocationError#error
   * @api
   */
  ERROR: 'error'
};

/**
 * @classdesc
 * Events emitted on [GeolocationPositionError](https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError).
 */
var GeolocationError = exports.GeolocationError = /*#__PURE__*/function (_BaseEvent) {
  _inherits(GeolocationError, _BaseEvent);
  var _super = _createSuper(GeolocationError);
  /**
   * @param {GeolocationPositionError} error error object.
   */
  function GeolocationError(error) {
    var _this;
    _classCallCheck(this, GeolocationError);
    _this = _super.call(this, GeolocationErrorType.ERROR);

    /**
     * Code of the underlying `GeolocationPositionError`.
     * @type {number}
     * @api
     */
    _this.code = error.code;

    /**
     * Message of the underlying `GeolocationPositionError`.
     * @type {string}
     * @api
     */
    _this.message = error.message;
    return _this;
  }
  return _createClass(GeolocationError);
}(_Event.default);
/**
 * @typedef {Object} Options
 * @property {boolean} [tracking=false] Start Tracking right after
 * instantiation.
 * @property {PositionOptions} [trackingOptions] Tracking options.
 * See https://www.w3.org/TR/geolocation-API/#position_options_interface.
 * @property {import("./proj.js").ProjectionLike} [projection] The projection the position
 * is reported in.
 */
/**
 * @typedef {import("./ObjectEventType").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|
 *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|
 *    'change:trackingOptions'} GeolocationObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<GeolocationObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'error', GeolocationError, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|GeolocationObjectEventTypes, Return> &
 *   import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return>} GeolocationOnSignature
 */
/**
 * @classdesc
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 *
 * To get notified of position changes and errors, register listeners for the generic
 * `change` event and the `error` event on your instance of {@link module:ol/Geolocation~Geolocation}.
 *
 * Example:
 *
 *     const geolocation = new Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       console.log(geolocation.getPosition());
 *     });
 *     // listen to error
 *     geolocation.on('error', function(evt) {
 *       window.console.log(evt.message);
 *     });
 *
 * @fires GeolocationError
 * @api
 */
var Geolocation = /*#__PURE__*/function (_BaseObject) {
  _inherits(Geolocation, _BaseObject);
  var _super2 = _createSuper(Geolocation);
  /**
   * @param {Options} [options] Options.
   */
  function Geolocation(options) {
    var _this2;
    _classCallCheck(this, Geolocation);
    _this2 = _super2.call(this);

    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {GeolocationOnSignature<void>}
     */
    _this2.un;
    options = options || {};

    /**
     * The unprojected (EPSG:4326) device position.
     * @private
     * @type {?import("./coordinate.js").Coordinate}
     */
    _this2.position_ = null;

    /**
     * @private
     * @type {import("./proj.js").TransformFunction}
     */
    _this2.transform_ = _proj.identityTransform;

    /**
     * @private
     * @type {number|undefined}
     */
    _this2.watchId_ = undefined;
    _this2.addChangeListener(Property.PROJECTION, _this2.handleProjectionChanged_);
    _this2.addChangeListener(Property.TRACKING, _this2.handleTrackingChanged_);
    if (options.projection !== undefined) {
      _this2.setProjection(options.projection);
    }
    if (options.trackingOptions !== undefined) {
      _this2.setTrackingOptions(options.trackingOptions);
    }
    _this2.setTracking(options.tracking !== undefined ? options.tracking : false);
    return _this2;
  }

  /**
   * Clean up.
   */
  _createClass(Geolocation, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      this.setTracking(false);
      _get(_getPrototypeOf(Geolocation.prototype), "disposeInternal", this).call(this);
    }

    /**
     * @private
     */
  }, {
    key: "handleProjectionChanged_",
    value: function handleProjectionChanged_() {
      var projection = this.getProjection();
      if (projection) {
        this.transform_ = (0, _proj.getTransformFromProjections)((0, _proj.get)('EPSG:4326'), projection);
        if (this.position_) {
          this.set(Property.POSITION, this.transform_(this.position_));
        }
      }
    }

    /**
     * @private
     */
  }, {
    key: "handleTrackingChanged_",
    value: function handleTrackingChanged_() {
      if ('geolocation' in navigator) {
        var tracking = this.getTracking();
        if (tracking && this.watchId_ === undefined) {
          this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
        } else if (!tracking && this.watchId_ !== undefined) {
          navigator.geolocation.clearWatch(this.watchId_);
          this.watchId_ = undefined;
        }
      }
    }

    /**
     * @private
     * @param {GeolocationPosition} position position event.
     */
  }, {
    key: "positionChange_",
    value: function positionChange_(position) {
      var coords = position.coords;
      this.set(Property.ACCURACY, coords.accuracy);
      this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);
      this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);
      this.set(Property.HEADING, coords.heading === null ? undefined : (0, _math.toRadians)(coords.heading));
      if (!this.position_) {
        this.position_ = [coords.longitude, coords.latitude];
      } else {
        this.position_[0] = coords.longitude;
        this.position_[1] = coords.latitude;
      }
      var projectedPosition = this.transform_(this.position_);
      this.set(Property.POSITION, projectedPosition.slice());
      this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);
      var geometry = (0, _Polygon.circular)(this.position_, coords.accuracy);
      geometry.applyTransform(this.transform_);
      this.set(Property.ACCURACY_GEOMETRY, geometry);
      this.changed();
    }

    /**
     * @private
     * @param {GeolocationPositionError} error error object.
     */
  }, {
    key: "positionError_",
    value: function positionError_(error) {
      this.dispatchEvent(new GeolocationError(error));
    }

    /**
     * Get the accuracy of the position in meters.
     * @return {number|undefined} The accuracy of the position measurement in
     *     meters.
     * @observable
     * @api
     */
  }, {
    key: "getAccuracy",
    value: function getAccuracy() {
      return /** @type {number|undefined} */this.get(Property.ACCURACY);
    }

    /**
     * Get a geometry of the position accuracy.
     * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
     * @observable
     * @api
     */
  }, {
    key: "getAccuracyGeometry",
    value: function getAccuracyGeometry() {
      return /** @type {?import("./geom/Polygon.js").default} */(
        this.get(Property.ACCURACY_GEOMETRY) || null
      );
    }

    /**
     * Get the altitude associated with the position.
     * @return {number|undefined} The altitude of the position in meters above mean
     *     sea level.
     * @observable
     * @api
     */
  }, {
    key: "getAltitude",
    value: function getAltitude() {
      return /** @type {number|undefined} */this.get(Property.ALTITUDE);
    }

    /**
     * Get the altitude accuracy of the position.
     * @return {number|undefined} The accuracy of the altitude measurement in
     *     meters.
     * @observable
     * @api
     */
  }, {
    key: "getAltitudeAccuracy",
    value: function getAltitudeAccuracy() {
      return /** @type {number|undefined} */(
        this.get(Property.ALTITUDE_ACCURACY)
      );
    }

    /**
     * Get the heading as radians clockwise from North.
     * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
     * is set to `true` in the tracking options.
     * @return {number|undefined} The heading of the device in radians from north.
     * @observable
     * @api
     */
  }, {
    key: "getHeading",
    value: function getHeading() {
      return /** @type {number|undefined} */this.get(Property.HEADING);
    }

    /**
     * Get the position of the device.
     * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
     *     in the current projection.
     * @observable
     * @api
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      return /** @type {import("./coordinate.js").Coordinate|undefined} */(
        this.get(Property.POSITION)
      );
    }

    /**
     * Get the projection associated with the position.
     * @return {import("./proj/Projection.js").default|undefined} The projection the position is
     *     reported in.
     * @observable
     * @api
     */
  }, {
    key: "getProjection",
    value: function getProjection() {
      return /** @type {import("./proj/Projection.js").default|undefined} */(
        this.get(Property.PROJECTION)
      );
    }

    /**
     * Get the speed in meters per second.
     * @return {number|undefined} The instantaneous speed of the device in meters
     *     per second.
     * @observable
     * @api
     */
  }, {
    key: "getSpeed",
    value: function getSpeed() {
      return /** @type {number|undefined} */this.get(Property.SPEED);
    }

    /**
     * Determine if the device location is being tracked.
     * @return {boolean} The device location is being tracked.
     * @observable
     * @api
     */
  }, {
    key: "getTracking",
    value: function getTracking() {
      return /** @type {boolean} */this.get(Property.TRACKING);
    }

    /**
     * Get the tracking options.
     * See https://www.w3.org/TR/geolocation-API/#position-options.
     * @return {PositionOptions|undefined} PositionOptions as defined by
     *     the [HTML5 Geolocation spec
     *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
  }, {
    key: "getTrackingOptions",
    value: function getTrackingOptions() {
      return /** @type {PositionOptions|undefined} */(
        this.get(Property.TRACKING_OPTIONS)
      );
    }

    /**
     * Set the projection to use for transforming the coordinates.
     * @param {import("./proj.js").ProjectionLike} projection The projection the position is
     *     reported in.
     * @observable
     * @api
     */
  }, {
    key: "setProjection",
    value: function setProjection(projection) {
      this.set(Property.PROJECTION, (0, _proj.get)(projection));
    }

    /**
     * Enable or disable tracking.
     * @param {boolean} tracking Enable tracking.
     * @observable
     * @api
     */
  }, {
    key: "setTracking",
    value: function setTracking(tracking) {
      this.set(Property.TRACKING, tracking);
    }

    /**
     * Set the tracking options.
     * See http://www.w3.org/TR/geolocation-API/#position-options.
     * @param {PositionOptions} options PositionOptions as defined by the
     *     [HTML5 Geolocation spec
     *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
  }, {
    key: "setTrackingOptions",
    value: function setTrackingOptions(options) {
      this.set(Property.TRACKING_OPTIONS, options);
    }
  }]);
  return Geolocation;
}(_Object.default);
var _default = exports.default = Geolocation;
},{"./events/Event.js":"node_modules/ol/events/Event.js","./Object.js":"node_modules/ol/Object.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./proj.js":"node_modules/ol/proj.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/Kinetic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @module ol/Kinetic
 */
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = /*#__PURE__*/function () {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  function Kinetic(decay, minVelocity, delay) {
    _classCallCheck(this, Kinetic);
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;

    /**
     * @private
     * @type {number}
     */
    this.minVelocity_ = minVelocity;

    /**
     * @private
     * @type {number}
     */
    this.delay_ = delay;

    /**
     * @private
     * @type {Array<number>}
     */
    this.points_ = [];

    /**
     * @private
     * @type {number}
     */
    this.angle_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.initialVelocity_ = 0;
  }

  /**
   * FIXME empty description for jsdoc
   */
  _createClass(Kinetic, [{
    key: "begin",
    value: function begin() {
      this.points_.length = 0;
      this.angle_ = 0;
      this.initialVelocity_ = 0;
    }

    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
  }, {
    key: "update",
    value: function update(x, y) {
      this.points_.push(x, y, Date.now());
    }

    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
  }, {
    key: "end",
    value: function end() {
      if (this.points_.length < 6) {
        // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
      }
      var delay = Date.now() - this.delay_;
      var lastIndex = this.points_.length - 3;
      if (this.points_[lastIndex + 2] < delay) {
        // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
      }

      // get the first point which still falls into the delay time
      var firstIndex = lastIndex - 3;
      while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
        firstIndex -= 3;
      }
      var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
      // we don't want a duration of 0 (divide by zero)
      // we also make sure the user panned for a duration of at least one frame
      // (1/60s) to compute sane displacement values
      if (duration < 1000 / 60) {
        return false;
      }
      var dx = this.points_[lastIndex] - this.points_[firstIndex];
      var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
      this.angle_ = Math.atan2(dy, dx);
      this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
      return this.initialVelocity_ > this.minVelocity_;
    }

    /**
     * @return {number} Total distance travelled (pixels).
     */
  }, {
    key: "getDistance",
    value: function getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }

    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
  }, {
    key: "getAngle",
    value: function getAngle() {
      return this.angle_;
    }
  }]);
  return Kinetic;
}();
var _default = exports.default = Kinetic;
},{}],"node_modules/ol/renderer/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Disposable2 = _interopRequireDefault(require("../Disposable.js"));
var _functions = require("../functions.js");
var _util = require("../util.js");
var _transform = require("../transform.js");
var _extent = require("../extent.js");
var _IconImageCache = require("../style/IconImageCache.js");
var _Layer = require("../layer/Layer.js");
var _coordinate = require("../coordinate.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/Map
 */
/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */
/**
 * @abstract
 */
var MapRenderer = /*#__PURE__*/function (_Disposable) {
  _inherits(MapRenderer, _Disposable);
  var _super = _createSuper(MapRenderer);
  /**
   * @param {import("../Map.js").default} map Map.
   */
  function MapRenderer(map) {
    var _this;
    _classCallCheck(this, MapRenderer);
    _this = _super.call(this);

    /**
     * @private
     * @type {import("../Map.js").default}
     */
    _this.map_ = map;
    return _this;
  }

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  _createClass(MapRenderer, [{
    key: "dispatchRenderEvent",
    value: function dispatchRenderEvent(type, frameState) {
      (0, _util.abstract)();
    }

    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
  }, {
    key: "calculateMatrices2D",
    value: function calculateMatrices2D(frameState) {
      var viewState = frameState.viewState;
      var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
      var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
      (0, _transform.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
      (0, _transform.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
    }

    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
      var result;
      var viewState = frameState.viewState;

      /**
       * @param {boolean} managed Managed layer.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @return {T|undefined} Callback result.
       */
      function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
        return callback.call(thisArg, feature, managed ? layer : null, geometry);
      }
      var projection = viewState.projection;
      var translatedCoordinate = (0, _coordinate.wrapX)(coordinate.slice(), projection);
      var offsets = [[0, 0]];
      if (projection.canWrapX() && checkWrapped) {
        var projectionExtent = projection.getExtent();
        var worldWidth = (0, _extent.getWidth)(projectionExtent);
        offsets.push([-worldWidth, 0], [worldWidth, 0]);
      }
      var layerStates = frameState.layerStatesArray;
      var numLayers = layerStates.length;
      var matches = /** @type {Array<HitMatch<T>>} */[];
      var tmpCoord = [];
      for (var i = 0; i < offsets.length; i++) {
        for (var j = numLayers - 1; j >= 0; --j) {
          var layerState = layerStates[j];
          var layer = layerState.layer;
          if (layer.hasRenderer() && (0, _Layer.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
            var layerRenderer = layer.getRenderer();
            var source = layer.getSource();
            if (layerRenderer && source) {
              var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
              var _callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);
              tmpCoord[0] = coordinates[0] + offsets[i][0];
              tmpCoord[1] = coordinates[1] + offsets[i][1];
              result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, _callback, matches);
            }
            if (result) {
              return result;
            }
          }
        }
      }
      if (matches.length === 0) {
        return undefined;
      }
      var order = 1 / matches.length;
      matches.forEach(function (m, i) {
        return m.distanceSq += i * order;
      });
      matches.sort(function (a, b) {
        return a.distanceSq - b.distanceSq;
      });
      matches.some(function (m) {
        return result = m.callback(m.feature, m.layer, m.geometry);
      });
      return result;
    }

    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
  }, {
    key: "hasFeatureAtCoordinate",
    value: function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
      var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, _functions.TRUE, this, layerFilter, thisArg);
      return hasFeature !== undefined;
    }

    /**
     * @return {import("../Map.js").default} Map.
     */
  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }

    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      (0, _util.abstract)();
    }

    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "flushDeclutterItems",
    value: function flushDeclutterItems(frameState) {}

    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
  }, {
    key: "scheduleExpireIconCache",
    value: function scheduleExpireIconCache(frameState) {
      if (_IconImageCache.shared.canExpireCache()) {
        frameState.postRenderFunctions.push(expireIconCache);
      }
    }
  }]);
  return MapRenderer;
}(_Disposable2.default);
/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _IconImageCache.shared.expire();
}
var _default = exports.default = MapRenderer;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../functions.js":"node_modules/ol/functions.js","../util.js":"node_modules/ol/util.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../style/IconImageCache.js":"node_modules/ol/style/IconImageCache.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/renderer/Composite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Map = _interopRequireDefault(require("./Map.js"));
var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));
var _Event = _interopRequireDefault(require("../render/Event.js"));
var _EventType = _interopRequireDefault(require("../render/EventType.js"));
var _css = require("../css.js");
var _canvas = require("../render/canvas.js");
var _Layer = require("../layer/Layer.js");
var _events = require("../events.js");
var _dom = require("../dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/renderer/Composite
 */
/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CompositeMapRenderer = /*#__PURE__*/function (_MapRenderer) {
  _inherits(CompositeMapRenderer, _MapRenderer);
  var _super = _createSuper(CompositeMapRenderer);
  /**
   * @param {import("../Map.js").default} map Map.
   */
  function CompositeMapRenderer(map) {
    var _this;
    _classCallCheck(this, CompositeMapRenderer);
    _this = _super.call(this, map);

    /**
     * @type {import("../events.js").EventsKey}
     */
    _this.fontChangeListenerKey_ = (0, _events.listen)(_canvas.checkedFonts, _ObjectEventType.default.PROPERTYCHANGE, map.redrawText.bind(map));

    /**
     * @private
     * @type {HTMLDivElement}
     */
    _this.element_ = document.createElement('div');
    var style = _this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';
    _this.element_.className = _css.CLASS_UNSELECTABLE + ' ol-layers';
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);

    /**
     * @private
     * @type {Array<HTMLElement>}
     */
    _this.children_ = [];

    /**
     * @private
     * @type {boolean}
     */
    _this.renderedVisible_ = true;

    /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */
    _this.declutterLayers_ = [];
    return _this;
  }

  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  _createClass(CompositeMapRenderer, [{
    key: "dispatchRenderEvent",
    value: function dispatchRenderEvent(type, frameState) {
      var map = this.getMap();
      if (map.hasListener(type)) {
        var event = new _Event.default(type, undefined, frameState);
        map.dispatchEvent(event);
      }
    }
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      (0, _events.unlistenByKey)(this.fontChangeListenerKey_);
      this.element_.parentNode.removeChild(this.element_);
      _get(_getPrototypeOf(CompositeMapRenderer.prototype), "disposeInternal", this).call(this);
    }

    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element_.style.display = 'none';
          this.renderedVisible_ = false;
        }
        return;
      }
      this.calculateMatrices2D(frameState);
      this.dispatchRenderEvent(_EventType.default.PRECOMPOSE, frameState);
      var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
        return a.zIndex - b.zIndex;
      });
      var viewState = frameState.viewState;
      this.children_.length = 0;
      var declutterLayers = this.declutterLayers_;
      declutterLayers.length = 0;
      var previousElement = null;
      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        var layerState = layerStatesArray[i];
        frameState.layerIndex = i;
        var layer = layerState.layer;
        var sourceState = layer.getSourceState();
        if (!(0, _Layer.inView)(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {
          layer.unrender();
          continue;
        }
        var element = layer.render(frameState, previousElement);
        if (!element) {
          continue;
        }
        if (element !== previousElement) {
          this.children_.push(element);
          previousElement = element;
        }
        if ('getDeclutter' in layer) {
          declutterLayers.push( /** @type {import("../layer/BaseVector.js").default} */layer);
        }
      }
      this.flushDeclutterItems(frameState);
      (0, _dom.replaceChildren)(this.element_, this.children_);
      this.dispatchRenderEvent(_EventType.default.POSTCOMPOSE, frameState);
      if (!this.renderedVisible_) {
        this.element_.style.display = '';
        this.renderedVisible_ = true;
      }
      this.scheduleExpireIconCache(frameState);
    }

    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "flushDeclutterItems",
    value: function flushDeclutterItems(frameState) {
      var layers = this.declutterLayers_;
      for (var i = layers.length - 1; i >= 0; --i) {
        layers[i].renderDeclutter(frameState);
      }
      layers.length = 0;
    }
  }]);
  return CompositeMapRenderer;
}(_Map.default);
var _default = exports.default = CompositeMapRenderer;
},{"./Map.js":"node_modules/ol/renderer/Map.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../render/Event.js":"node_modules/ol/render/Event.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../css.js":"node_modules/ol/css.js","../render/canvas.js":"node_modules/ol/render/canvas.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/pointer/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/pointer/EventType
 */
/**
 * Constants for event names.
 * @enum {string}
 */
var _default = exports.default = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
},{}],"node_modules/ol/MapBrowserEventHandler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));
var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));
var _EventType2 = _interopRequireDefault(require("./pointer/EventType.js"));
var _Target2 = _interopRequireDefault(require("./events/Target.js"));
var _has = require("./has.js");
var _events = require("./events.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/MapBrowserEventHandler
 */
var MapBrowserEventHandler = /*#__PURE__*/function (_Target) {
  _inherits(MapBrowserEventHandler, _Target);
  var _super = _createSuper(MapBrowserEventHandler);
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  function MapBrowserEventHandler(map, moveTolerance) {
    var _this;
    _classCallCheck(this, MapBrowserEventHandler);
    _this = _super.call(this, map);

    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */
    _this.map_ = map;

    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    _this.clickTimeoutId_;

    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */
    _this.emulateClicks_ = false;

    /**
     * @type {boolean}
     * @private
     */
    _this.dragging_ = false;

    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    _this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */
    _this.down_ = null;
    var element = _this.map_.getViewport();

    /**
     * @type {Array<PointerEvent>}
     * @private
     */
    _this.activePointers_ = [];

    /**
     * @type {!Object<number, Event>}
     * @private
     */
    _this.trackedTouches_ = {};
    _this.element_ = element;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    _this.pointerdownListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERDOWN, _this.handlePointerDown_, _assertThisInitialized(_this));

    /**
     * @type {PointerEvent}
     * @private
     */
    _this.originalPointerMoveEvent_;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    _this.relayedListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERMOVE, _this.relayMoveEvent_, _assertThisInitialized(_this));

    /**
     * @private
     */
    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_assertThisInitialized(_this));
    _this.element_.addEventListener(_EventType.default.TOUCHMOVE, _this.boundHandleTouchMove_, _has.PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);
    return _this;
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  _createClass(MapBrowserEventHandler, [{
    key: "emulateClick_",
    value: function emulateClick_(pointerEvent) {
      var _this2 = this;
      var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.CLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
      if (this.clickTimeoutId_ !== undefined) {
        // double-click
        clearTimeout(this.clickTimeoutId_);
        this.clickTimeoutId_ = undefined;
        newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.DBLCLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      } else {
        // click
        this.clickTimeoutId_ = setTimeout(function () {
          _this2.clickTimeoutId_ = undefined;
          var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.SINGLECLICK, _this2.map_, pointerEvent);
          _this2.dispatchEvent(newEvent);
        }, 250);
      }
    }

    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
  }, {
    key: "updateActivePointers_",
    value: function updateActivePointers_(pointerEvent) {
      var event = pointerEvent;
      var id = event.pointerId;
      if (event.type == _MapBrowserEventType.default.POINTERUP || event.type == _MapBrowserEventType.default.POINTERCANCEL) {
        delete this.trackedTouches_[id];
        for (var pointerId in this.trackedTouches_) {
          if (this.trackedTouches_[pointerId].target !== event.target) {
            // Some platforms assign a new pointerId when the target changes.
            // If this happens, delete one tracked pointer. If there is more
            // than one tracked pointer for the old target, it will be cleared
            // by subsequent POINTERUP events from other pointers.
            delete this.trackedTouches_[pointerId];
            break;
          }
        }
      } else if (event.type == _MapBrowserEventType.default.POINTERDOWN || event.type == _MapBrowserEventType.default.POINTERMOVE) {
        this.trackedTouches_[id] = event;
      }
      this.activePointers_ = Object.values(this.trackedTouches_);
    }

    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
  }, {
    key: "handlePointerUp_",
    value: function handlePointerUp_(pointerEvent) {
      this.updateActivePointers_(pointerEvent);
      var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
      this.dispatchEvent(newEvent);

      // We emulate click events on left mouse button click, touch contact, and pen
      // contact. isMouseActionButton returns true in these cases (evt.button is set
      // to 0).
      // See http://www.w3.org/TR/pointerevents/#button-states
      // We only fire click, singleclick, and doubleclick if nobody has called
      // event.preventDefault().
      if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
        this.emulateClick_(this.down_);
      }
      if (this.activePointers_.length === 0) {
        this.dragListenerKeys_.forEach(_events.unlistenByKey);
        this.dragListenerKeys_.length = 0;
        this.dragging_ = false;
        this.down_ = null;
      }
    }

    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
  }, {
    key: "isMouseActionButton_",
    value: function isMouseActionButton_(pointerEvent) {
      return pointerEvent.button === 0;
    }

    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
  }, {
    key: "handlePointerDown_",
    value: function handlePointerDown_(pointerEvent) {
      this.emulateClicks_ = this.activePointers_.length === 0;
      this.updateActivePointers_(pointerEvent);
      var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
      this.dispatchEvent(newEvent);
      this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
      Object.defineProperty(this.down_, 'target', {
        writable: false,
        value: pointerEvent.target
      });
      if (this.dragListenerKeys_.length === 0) {
        var doc = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push((0, _events.listen)(doc, _MapBrowserEventType.default.POINTERMOVE, this.handlePointerMove_, this), (0, _events.listen)(doc, _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        (0, _events.listen)(this.element_, _MapBrowserEventType.default.POINTERCANCEL, this.handlePointerUp_, this));
        if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
          this.dragListenerKeys_.push((0, _events.listen)(this.element_.getRootNode(), _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this));
        }
      }
    }

    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
  }, {
    key: "handlePointerMove_",
    value: function handlePointerMove_(pointerEvent) {
      // Between pointerdown and pointerup, pointermove events are triggered.
      // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
      // moved a significant distance.
      if (this.isMoving_(pointerEvent)) {
        this.updateActivePointers_(pointerEvent);
        this.dragging_ = true;
        var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
      }
    }

    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
  }, {
    key: "relayMoveEvent_",
    value: function relayMoveEvent_(pointerEvent) {
      this.originalPointerMoveEvent_ = pointerEvent;
      var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
      this.dispatchEvent(new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERMOVE, this.map_, pointerEvent, dragging));
    }

    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
  }, {
    key: "handleTouchMove_",
    value: function handleTouchMove_(event) {
      // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
      // may not be initialized yet when we get here on a platform without native pointer events,
      // when elm-pep is used as pointer events polyfill.
      var originalEvent = this.originalPointerMoveEvent_;
      if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
        event.preventDefault();
      }
    }

    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
  }, {
    key: "isMoving_",
    value: function isMoving_(pointerEvent) {
      return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }

    /**
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.relayedListenerKey_) {
        (0, _events.unlistenByKey)(this.relayedListenerKey_);
        this.relayedListenerKey_ = null;
      }
      this.element_.removeEventListener(_EventType.default.TOUCHMOVE, this.boundHandleTouchMove_);
      if (this.pointerdownListenerKey_) {
        (0, _events.unlistenByKey)(this.pointerdownListenerKey_);
        this.pointerdownListenerKey_ = null;
      }
      this.dragListenerKeys_.forEach(_events.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.element_ = null;
      _get(_getPrototypeOf(MapBrowserEventHandler.prototype), "disposeInternal", this).call(this);
    }
  }]);
  return MapBrowserEventHandler;
}(_Target2.default);
var _default = exports.default = MapBrowserEventHandler;
},{"./events/EventType.js":"node_modules/ol/events/EventType.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./pointer/EventType.js":"node_modules/ol/pointer/EventType.js","./events/Target.js":"node_modules/ol/events/Target.js","./has.js":"node_modules/ol/has.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/MapProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/MapProperty
 */
/**
 * @enum {string}
 */
var _default = exports.default = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};
},{}],"node_modules/ol/control/Control.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("../Object.js"));
var _MapEventType = _interopRequireDefault(require("../MapEventType.js"));
var _functions = require("../functions.js");
var _events = require("../events.js");
var _dom = require("../dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/control/Control
 */
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control = /*#__PURE__*/function (_BaseObject) {
  _inherits(Control, _BaseObject);
  var _super = _createSuper(Control);
  /**
   * @param {Options} options Control options.
   */
  function Control(options) {
    var _this;
    _classCallCheck(this, Control);
    _this = _super.call(this);
    var element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }

    /**
     * @protected
     * @type {HTMLElement}
     */
    _this.element = element ? element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    _this.target_ = null;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    _this.map_ = null;

    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    _this.listenerKeys = [];
    if (options.render) {
      _this.render = options.render;
    }
    if (options.target) {
      _this.setTarget(options.target);
    }
    return _this;
  }

  /**
   * Clean up.
   */
  _createClass(Control, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      (0, _dom.removeNode)(this.element);
      _get(_getPrototypeOf(Control.prototype), "disposeInternal", this).call(this);
    }

    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }

    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.map_) {
        (0, _dom.removeNode)(this.element);
      }
      for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
        (0, _events.unlistenByKey)(this.listenerKeys[i]);
      }
      this.listenerKeys.length = 0;
      this.map_ = map;
      if (map) {
        var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
        target.appendChild(this.element);
        if (this.render !== _functions.VOID) {
          this.listenerKeys.push((0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this));
        }
        map.render();
      }
    }

    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
  }, {
    key: "render",
    value: function render(mapEvent) {}

    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
    }
  }]);
  return Control;
}(_Object.default);
var _default = exports.default = Control;
},{"../Object.js":"node_modules/ol/Object.js","../MapEventType.js":"node_modules/ol/MapEventType.js","../functions.js":"node_modules/ol/functions.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/Attribution.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Control2 = _interopRequireDefault(require("./Control.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _css = require("../css.js");
var _array = require("../array.js");
var _dom = require("../dom.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/control/Attribution
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel=''] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */
/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution = /*#__PURE__*/function (_Control) {
  _inherits(Attribution, _Control);
  var _super = _createSuper(Attribution);
  /**
   * @param {Options} [options] Attribution options.
   */
  function Attribution(options) {
    var _this;
    _classCallCheck(this, Attribution);
    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    _this.ulElement_ = document.createElement('ul');

    /**
     * @private
     * @type {boolean}
     */
    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    _this.userCollapsed_ = _this.collapsed_;

    /**
     * @private
     * @type {boolean}
     */
    _this.overrideCollapsible_ = options.collapsible !== undefined;

    /**
     * @private
     * @type {boolean}
     */
    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    var className = options.className !== undefined ? options.className : 'ol-attribution';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
    var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u203A";
    var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';
    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }
    var label = options.label !== undefined ? options.label : 'i';
    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }
    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;

    /**
     * @private
     * @type {HTMLElement}
     */
    _this.toggleButton_ = document.createElement('button');
    _this.toggleButton_.setAttribute('type', 'button');
    _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));
    _this.toggleButton_.title = tipLabel;
    _this.toggleButton_.appendChild(activeLabel);
    _this.toggleButton_.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this)), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.toggleButton_);
    element.appendChild(_this.ulElement_);

    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    _this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    _this.renderedVisible_ = true;
    return _this;
  }

  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  _createClass(Attribution, [{
    key: "collectSourceAttributions_",
    value: function collectSourceAttributions_(frameState) {
      var visibleAttributions = Array.from(new Set(this.getMap().getAllLayers().flatMap(function (layer) {
        return layer.getAttributions(frameState);
      })));
      var collapsible = !this.getMap().getAllLayers().some(function (layer) {
        return layer.getSource() && layer.getSource().getAttributionsCollapsible() === false;
      });
      if (!this.overrideCollapsible_) {
        this.setCollapsible(collapsible);
      }
      return visibleAttributions;
    }

    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
  }, {
    key: "updateElement_",
    value: function updateElement_(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element.style.display = 'none';
          this.renderedVisible_ = false;
        }
        return;
      }
      var attributions = this.collectSourceAttributions_(frameState);
      var visible = attributions.length > 0;
      if (this.renderedVisible_ != visible) {
        this.element.style.display = visible ? '' : 'none';
        this.renderedVisible_ = visible;
      }
      if ((0, _array.equals)(attributions, this.renderedAttributions_)) {
        return;
      }
      (0, _dom.removeChildren)(this.ulElement_);

      // append the attributions
      for (var i = 0, ii = attributions.length; i < ii; ++i) {
        var element = document.createElement('li');
        element.innerHTML = attributions[i];
        this.ulElement_.appendChild(element);
      }
      this.renderedAttributions_ = attributions;
    }

    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
  }, {
    key: "handleClick_",
    value: function handleClick_(event) {
      event.preventDefault();
      this.handleToggle_();
      this.userCollapsed_ = this.collapsed_;
    }

    /**
     * @private
     */
  }, {
    key: "handleToggle_",
    value: function handleToggle_() {
      this.element.classList.toggle(_css.CLASS_COLLAPSED);
      if (this.collapsed_) {
        (0, _dom.replaceNode)(this.collapseLabel_, this.label_);
      } else {
        (0, _dom.replaceNode)(this.label_, this.collapseLabel_);
      }
      this.collapsed_ = !this.collapsed_;
      this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    }

    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
  }, {
    key: "getCollapsible",
    value: function getCollapsible() {
      return this.collapsible_;
    }

    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
  }, {
    key: "setCollapsible",
    value: function setCollapsible(collapsible) {
      if (this.collapsible_ === collapsible) {
        return;
      }
      this.collapsible_ = collapsible;
      this.element.classList.toggle('ol-uncollapsible');
      if (this.userCollapsed_) {
        this.handleToggle_();
      }
    }

    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      this.userCollapsed_ = collapsed;
      if (!this.collapsible_ || this.collapsed_ === collapsed) {
        return;
      }
      this.handleToggle_();
    }

    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
  }, {
    key: "getCollapsed",
    value: function getCollapsed() {
      return this.collapsed_;
    }

    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
  }, {
    key: "render",
    value: function render(mapEvent) {
      this.updateElement_(mapEvent.frameState);
    }
  }]);
  return Attribution;
}(_Control2.default);
var _default = exports.default = Attribution;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../array.js":"node_modules/ol/array.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/Rotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Control2 = _interopRequireDefault(require("./Control.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _css = require("../css.js");
var _easing = require("../easing.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/control/Rotate
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate = /*#__PURE__*/function (_Control) {
  _inherits(Rotate, _Control);
  var _super = _createSuper(Rotate);
  /**
   * @param {Options} [options] Rotate options.
   */
  function Rotate(options) {
    var _this;
    _classCallCheck(this, Rotate);
    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    });
    var className = options.className !== undefined ? options.className : 'ol-rotate';
    var label = options.label !== undefined ? options.label : "\u21E7";
    var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';

    /**
     * @type {HTMLElement}
     * @private
     */
    _this.label_ = null;
    if (typeof label === 'string') {
      _this.label_ = document.createElement('span');
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
      _this.label_.classList.add(compassClassName);
    }
    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this)), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.rotation_ = undefined;
    if (_this.autoHide_) {
      _this.element.classList.add(_css.CLASS_HIDDEN);
    }
    return _this;
  }

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  _createClass(Rotate, [{
    key: "handleClick_",
    value: function handleClick_(event) {
      event.preventDefault();
      if (this.callResetNorth_ !== undefined) {
        this.callResetNorth_();
      } else {
        this.resetNorth_();
      }
    }

    /**
     * @private
     */
  }, {
    key: "resetNorth_",
    value: function resetNorth_() {
      var map = this.getMap();
      var view = map.getView();
      if (!view) {
        // the map does not have a view, so we can't act
        // upon it
        return;
      }
      var rotation = view.getRotation();
      if (rotation !== undefined) {
        if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
          view.animate({
            rotation: 0,
            duration: this.duration_,
            easing: _easing.easeOut
          });
        } else {
          view.setRotation(0);
        }
      }
    }

    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
  }, {
    key: "render",
    value: function render(mapEvent) {
      var frameState = mapEvent.frameState;
      if (!frameState) {
        return;
      }
      var rotation = frameState.viewState.rotation;
      if (rotation != this.rotation_) {
        var transform = 'rotate(' + rotation + 'rad)';
        if (this.autoHide_) {
          var contains = this.element.classList.contains(_css.CLASS_HIDDEN);
          if (!contains && rotation === 0) {
            this.element.classList.add(_css.CLASS_HIDDEN);
          } else if (contains && rotation !== 0) {
            this.element.classList.remove(_css.CLASS_HIDDEN);
          }
        }
        this.label_.style.transform = transform;
      }
      this.rotation_ = rotation;
    }
  }]);
  return Rotate;
}(_Control2.default);
var _default = exports.default = Rotate;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/control/Zoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Control2 = _interopRequireDefault(require("./Control.js"));
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _css = require("../css.js");
var _easing = require("../easing.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/control/Zoom
 */
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel=''] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom = /*#__PURE__*/function (_Control) {
  _inherits(Zoom, _Control);
  var _super = _createSuper(Zoom);
  /**
   * @param {Options} [options] Zoom options.
   */
  function Zoom(options) {
    var _this;
    _classCallCheck(this, Zoom);
    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    });
    var className = options.className !== undefined ? options.className : 'ol-zoom';
    var delta = options.delta !== undefined ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
    var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "\u2013";
    var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
    var inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this), delta), false);
    var outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this), -delta), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  _createClass(Zoom, [{
    key: "handleClick_",
    value: function handleClick_(delta, event) {
      event.preventDefault();
      this.zoomByDelta_(delta);
    }

    /**
     * @param {number} delta Zoom delta.
     * @private
     */
  }, {
    key: "zoomByDelta_",
    value: function zoomByDelta_(delta) {
      var map = this.getMap();
      var view = map.getView();
      if (!view) {
        // the map does not have a view, so we can't act
        // upon it
        return;
      }
      var currentZoom = view.getZoom();
      if (currentZoom !== undefined) {
        var newZoom = view.getConstrainedZoom(currentZoom + delta);
        if (this.duration_ > 0) {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }
          view.animate({
            zoom: newZoom,
            duration: this.duration_,
            easing: _easing.easeOut
          });
        } else {
          view.setZoom(newZoom);
        }
      }
    }
  }]);
  return Zoom;
}(_Control2.default);
var _default = exports.default = Zoom;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/control/defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
var _Attribution = _interopRequireDefault(require("./Attribution.js"));
var _Collection = _interopRequireDefault(require("../Collection.js"));
var _Rotate = _interopRequireDefault(require("./Rotate.js"));
var _Zoom = _interopRequireDefault(require("./Zoom.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/control/defaults
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Control.js").default>} */
  var controls = new _Collection.default();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom.default(options.zoomOptions));
  }
  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate.default(options.rotateOptions));
  }
  var attributionControl = options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution.default(options.attributionOptions));
  }
  return controls;
}
},{"./Attribution.js":"node_modules/ol/control/Attribution.js","../Collection.js":"node_modules/ol/Collection.js","./Rotate.js":"node_modules/ol/control/Rotate.js","./Zoom.js":"node_modules/ol/control/Zoom.js"}],"node_modules/ol/interaction/DoubleClickZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Interaction2 = _interopRequireWildcard(require("./Interaction.js"));
var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/DoubleClickZoom
 */
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */
/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(DoubleClickZoom, _Interaction);
  var _super = _createSuper(DoubleClickZoom);
  /**
   * @param {Options} [options] Options.
   */
  function DoubleClickZoom(options) {
    var _this;
    _classCallCheck(this, DoubleClickZoom);
    _this = _super.call(this);
    options = options ? options : {};

    /**
     * @private
     * @type {number}
     */
    _this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  _createClass(DoubleClickZoom, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;
      if (mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK) {
        var browserEvent = /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent;
        var map = mapBrowserEvent.map;
        var anchor = mapBrowserEvent.coordinate;
        var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
        var view = map.getView();
        (0, _Interaction2.zoomByDelta)(view, delta, anchor, this.duration_);
        browserEvent.preventDefault();
        stopEvent = true;
      }
      return !stopEvent;
    }
  }]);
  return DoubleClickZoom;
}(_Interaction2.default);
var _default = exports.default = DoubleClickZoom;
},{"./Interaction.js":"node_modules/ol/interaction/Interaction.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js"}],"node_modules/ol/interaction/DragPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Pointer = _interopRequireWildcard(require("./Pointer.js"));
var _functions = require("../functions.js");
var _condition = require("../events/condition.js");
var _easing = require("../easing.js");
var _coordinate = require("../coordinate.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/DragPan
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */
/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragPan, _PointerInteraction);
  var _super = _createSuper(DragPan);
  /**
   * @param {Options} [options] Options.
   */
  function DragPan(options) {
    var _this;
    _classCallCheck(this, DragPan);
    _this = _super.call(this, {
      stopDown: _functions.FALSE
    });
    options = options ? options : {};

    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    _this.kinetic_ = options.kinetic;

    /**
     * @type {import("../pixel.js").Pixel}
     */
    _this.lastCentroid = null;

    /**
     * @type {number}
     */
    _this.lastPointersCount_;

    /**
     * @type {boolean}
     */
    _this.panning_ = false;
    var condition = options.condition ? options.condition : (0, _condition.all)(_condition.noModifierKeys, _condition.primaryAction);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this.condition_ = options.onFocusOnly ? (0, _condition.all)(_condition.focusWithTabindex, condition) : condition;

    /**
     * @private
     * @type {boolean}
     */
    _this.noKinetic_ = false;
    return _this;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  _createClass(DragPan, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      var map = mapBrowserEvent.map;
      if (!this.panning_) {
        this.panning_ = true;
        map.getView().beginInteraction();
      }
      var targetPointers = this.targetPointers;
      var centroid = map.getEventPixel((0, _Pointer.centroid)(targetPointers));
      if (targetPointers.length == this.lastPointersCount_) {
        if (this.kinetic_) {
          this.kinetic_.update(centroid[0], centroid[1]);
        }
        if (this.lastCentroid) {
          var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];
          var _map = mapBrowserEvent.map;
          var view = _map.getView();
          (0, _coordinate.scale)(delta, view.getResolution());
          (0, _coordinate.rotate)(delta, view.getRotation());
          view.adjustCenterInternal(delta);
        }
      } else if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
      }
      this.lastCentroid = centroid;
      this.lastPointersCount_ = targetPointers.length;
      mapBrowserEvent.originalEvent.preventDefault();
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          var distance = this.kinetic_.getDistance();
          var angle = this.kinetic_.getAngle();
          var center = view.getCenterInternal();
          var centerpx = map.getPixelFromCoordinateInternal(center);
          var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
          view.animateInternal({
            center: view.getConstrainedCenter(dest),
            duration: 500,
            easing: _easing.easeOut
          });
        }
        if (this.panning_) {
          this.panning_ = false;
          view.endInteraction();
        }
        return false;
      }
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        this.lastCentroid = null;
        // stop any current animation
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        if (this.kinetic_) {
          this.kinetic_.begin();
        }
        // No kinetic as soon as more than one pointer on the screen is
        // detected. This is to prevent nasty pans after pinch.
        this.noKinetic_ = this.targetPointers.length > 1;
        return true;
      }
      return false;
    }
  }]);
  return DragPan;
}(_Pointer.default);
var _default = exports.default = DragPan;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../easing.js":"node_modules/ol/easing.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/interaction/DragRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Pointer = _interopRequireDefault(require("./Pointer.js"));
var _functions = require("../functions.js");
var _condition = require("../events/condition.js");
var _rotationconstraint = require("../rotationconstraint.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/DragRotate
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragRotate, _PointerInteraction);
  var _super = _createSuper(DragRotate);
  /**
   * @param {Options} [options] Options.
   */
  function DragRotate(options) {
    var _this;
    _classCallCheck(this, DragRotate);
    options = options ? options : {};
    _this = _super.call(this, {
      stopDown: _functions.FALSE
    });

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this.condition_ = options.condition ? options.condition : _condition.altShiftKeysOnly;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  _createClass(DragRotate, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
        return;
      }
      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (view.getConstraints().rotation === _rotationconstraint.disable) {
        return;
      }
      var size = map.getSize();
      var offset = mapBrowserEvent.pixel;
      var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
      if (this.lastAngle_ !== undefined) {
        var delta = theta - this.lastAngle_;
        view.adjustRotationInternal(-delta);
      }
      this.lastAngle_ = theta;
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
        return true;
      }
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
        return false;
      }
      if ((0, _condition.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        map.getView().beginInteraction();
        this.lastAngle_ = undefined;
        return true;
      }
      return false;
    }
  }]);
  return DragRotate;
}(_Pointer.default);
var _default = exports.default = DragRotate;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../rotationconstraint.js":"node_modules/ol/rotationconstraint.js"}],"node_modules/ol/render/Box.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Disposable2 = _interopRequireDefault(require("../Disposable.js"));
var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/render/Box
 */
var RenderBox = /*#__PURE__*/function (_Disposable) {
  _inherits(RenderBox, _Disposable);
  var _super = _createSuper(RenderBox);
  /**
   * @param {string} className CSS class name.
   */
  function RenderBox(className) {
    var _this;
    _classCallCheck(this, RenderBox);
    _this = _super.call(this);

    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    _this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    _this.element_ = document.createElement('div');
    _this.element_.style.position = 'absolute';
    _this.element_.style.pointerEvents = 'auto';
    _this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    _this.map_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    _this.startPixel_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    _this.endPixel_ = null;
    return _this;
  }

  /**
   * Clean up.
   */
  _createClass(RenderBox, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      this.setMap(null);
    }

    /**
     * @private
     */
  }, {
    key: "render_",
    value: function render_() {
      var startPixel = this.startPixel_;
      var endPixel = this.endPixel_;
      var px = 'px';
      var style = this.element_.style;
      style.left = Math.min(startPixel[0], endPixel[0]) + px;
      style.top = Math.min(startPixel[1], endPixel[1]) + px;
      style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
      style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    }

    /**
     * @param {import("../Map.js").default|null} map Map.
     */
  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        var style = this.element_.style;
        style.left = 'inherit';
        style.top = 'inherit';
        style.width = 'inherit';
        style.height = 'inherit';
      }
      this.map_ = map;
      if (this.map_) {
        this.map_.getOverlayContainer().appendChild(this.element_);
      }
    }

    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
  }, {
    key: "setPixels",
    value: function setPixels(startPixel, endPixel) {
      this.startPixel_ = startPixel;
      this.endPixel_ = endPixel;
      this.createOrUpdateGeometry();
      this.render_();
    }

    /**
     * Creates or updates the cached geometry.
     */
  }, {
    key: "createOrUpdateGeometry",
    value: function createOrUpdateGeometry() {
      var startPixel = this.startPixel_;
      var endPixel = this.endPixel_;
      var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
      var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
      // close the polygon
      coordinates[4] = coordinates[0].slice();
      if (!this.geometry_) {
        this.geometry_ = new _Polygon.default([coordinates]);
      } else {
        this.geometry_.setCoordinates([coordinates]);
      }
    }

    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.geometry_;
    }
  }]);
  return RenderBox;
}(_Disposable2.default);
var _default = exports.default = RenderBox;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/interaction/DragBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DragBoxEvent = void 0;
var _Event2 = _interopRequireDefault(require("../events/Event.js"));
var _Pointer = _interopRequireDefault(require("./Pointer.js"));
var _Box = _interopRequireDefault(require("../render/Box.js"));
var _condition = require("../events/condition.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/DragBox
 */ // FIXME draw drag box
/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel'
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
var DragBoxEvent = exports.DragBoxEvent = /*#__PURE__*/function (_Event) {
  _inherits(DragBoxEvent, _Event);
  var _super = _createSuper(DragBoxEvent);
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    var _this;
    _classCallCheck(this, DragBoxEvent);
    _this = _super.call(this, type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    _this.coordinate = coordinate;

    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return _createClass(DragBoxEvent);
}(_Event2.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
var DragBox = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragBox, _PointerInteraction);
  var _super2 = _createSuper(DragBox);
  /**
   * @param {Options} [options] Options.
   */
  function DragBox(options) {
    var _this2;
    _classCallCheck(this, DragBox);
    _this2 = _super2.call(this);

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    _this2.on;

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    _this2.once;

    /***
     * @type {DragBoxOnSignature<void>}
     */
    _this2.un;
    options = options ? options : {};

    /**
     * @type {import("../render/Box.js").default}
     * @private
     */
    _this2.box_ = new _Box.default(options.className || 'ol-dragbox');

    /**
     * @type {number}
     * @private
     */
    _this2.minArea_ = options.minArea !== undefined ? options.minArea : 64;
    if (options.onBoxEnd) {
      _this2.onBoxEnd = options.onBoxEnd;
    }

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    _this2.startPixel_ = null;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this2.condition_ = options.condition ? options.condition : _condition.mouseActionButton;

    /**
     * @private
     * @type {EndCondition}
     */
    _this2.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this2.defaultBoxEndCondition;
    return _this2;
  }

  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  _createClass(DragBox, [{
    key: "defaultBoxEndCondition",
    value: function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
      var width = endPixel[0] - startPixel[0];
      var height = endPixel[1] - startPixel[1];
      return width * width + height * height >= this.minArea_;
    }

    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.box_.getGeometry();
    }

    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
  }, {
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      this.box_.setMap(null);
      var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
      if (completeBox) {
        this.onBoxEnd(mapBrowserEvent);
      }
      this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
      return false;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.condition_(mapBrowserEvent)) {
        this.startPixel_ = mapBrowserEvent.pixel;
        this.box_.setMap(mapBrowserEvent.map);
        this.box_.setPixels(this.startPixel_, this.startPixel_);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
        return true;
      }
      return false;
    }

    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
  }, {
    key: "onBoxEnd",
    value: function onBoxEnd(event) {}
  }]);
  return DragBox;
}(_Pointer.default);
var _default = exports.default = DragBox;
},{"../events/Event.js":"node_modules/ol/events/Event.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../render/Box.js":"node_modules/ol/render/Box.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/interaction/DragZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _DragBox2 = _interopRequireDefault(require("./DragBox.js"));
var _easing = require("../easing.js");
var _condition = require("../events/condition.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/DragZoom
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom = /*#__PURE__*/function (_DragBox) {
  _inherits(DragZoom, _DragBox);
  var _super = _createSuper(DragZoom);
  /**
   * @param {Options} [options] Options.
   */
  function DragZoom(options) {
    var _this;
    _classCallCheck(this, DragZoom);
    options = options ? options : {};
    var condition = options.condition ? options.condition : _condition.shiftKeyOnly;
    _this = _super.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea
    });

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    _this.out_ = options.out !== undefined ? options.out : false;
    return _this;
  }

  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  _createClass(DragZoom, [{
    key: "onBoxEnd",
    value: function onBoxEnd(event) {
      var map = this.getMap();
      var view = /** @type {!import("../View.js").default} */map.getView();
      var geometry = this.getGeometry();
      if (this.out_) {
        var rotatedExtent = view.rotatedExtentForGeometry(geometry);
        var resolution = view.getResolutionForExtentInternal(rotatedExtent);
        var factor = view.getResolution() / resolution;
        geometry = geometry.clone();
        geometry.scale(factor * factor);
      }
      view.fitInternal(geometry, {
        duration: this.duration_,
        easing: _easing.easeOut
      });
    }
  }]);
  return DragZoom;
}(_DragBox2.default);
var _default = exports.default = DragZoom;
},{"./DragBox.js":"node_modules/ol/interaction/DragBox.js","../easing.js":"node_modules/ol/easing.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/events/Key.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @module ol/events/Key
 */
/**
 * @enum {string}
 * @const
 */
var _default = exports.default = {
  LEFT: 'ArrowLeft',
  UP: 'ArrowUp',
  RIGHT: 'ArrowRight',
  DOWN: 'ArrowDown'
};
},{}],"node_modules/ol/interaction/KeyboardPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Interaction2 = _interopRequireWildcard(require("./Interaction.js"));
var _Key = _interopRequireDefault(require("../events/Key.js"));
var _condition = require("../events/condition.js");
var _coordinate = require("../coordinate.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/KeyboardPan
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */
/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan = /*#__PURE__*/function (_Interaction) {
  _inherits(KeyboardPan, _Interaction);
  var _super = _createSuper(KeyboardPan);
  /**
   * @param {Options} [options] Options.
   */
  function KeyboardPan(options) {
    var _this;
    _classCallCheck(this, KeyboardPan);
    _this = _super.call(this);
    options = options || {};

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    _this.defaultCondition_ = function (mapBrowserEvent) {
      return (0, _condition.noModifierKeys)(mapBrowserEvent) && (0, _condition.targetNotEditable)(mapBrowserEvent);
    };

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    return _this;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  _createClass(KeyboardPan, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;
      if (mapBrowserEvent.type == _EventType.default.KEYDOWN) {
        var keyEvent = /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent;
        var key = keyEvent.key;
        if (this.condition_(mapBrowserEvent) && (key == _Key.default.DOWN || key == _Key.default.LEFT || key == _Key.default.RIGHT || key == _Key.default.UP)) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
          var deltaX = 0,
            deltaY = 0;
          if (key == _Key.default.DOWN) {
            deltaY = -mapUnitsDelta;
          } else if (key == _Key.default.LEFT) {
            deltaX = -mapUnitsDelta;
          } else if (key == _Key.default.RIGHT) {
            deltaX = mapUnitsDelta;
          } else {
            deltaY = mapUnitsDelta;
          }
          var delta = [deltaX, deltaY];
          (0, _coordinate.rotate)(delta, view.getRotation());
          (0, _Interaction2.pan)(view, delta, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }
  }]);
  return KeyboardPan;
}(_Interaction2.default);
var _default = exports.default = KeyboardPan;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../events/Key.js":"node_modules/ol/events/Key.js","../events/condition.js":"node_modules/ol/events/condition.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/interaction/KeyboardZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Interaction2 = _interopRequireWildcard(require("./Interaction.js"));
var _condition = require("../events/condition.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/KeyboardZoom
 */
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */
/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(KeyboardZoom, _Interaction);
  var _super = _createSuper(KeyboardZoom);
  /**
   * @param {Options} [options] Options.
   */
  function KeyboardZoom(options) {
    var _this;
    _classCallCheck(this, KeyboardZoom);
    _this = _super.call(this);
    options = options ? options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this.condition_ = options.condition ? options.condition : function (mapBrowserEvent) {
      return !(0, _condition.platformModifierKey)(mapBrowserEvent) && (0, _condition.targetNotEditable)(mapBrowserEvent);
    };

    /**
     * @private
     * @type {number}
     */
    _this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    return _this;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  _createClass(KeyboardZoom, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;
      if (mapBrowserEvent.type == _EventType.default.KEYDOWN || mapBrowserEvent.type == _EventType.default.KEYPRESS) {
        var keyEvent = /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent;
        var key = keyEvent.key;
        if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {
          var map = mapBrowserEvent.map;
          var delta = key === '+' ? this.delta_ : -this.delta_;
          var view = map.getView();
          (0, _Interaction2.zoomByDelta)(view, delta, undefined, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }
  }]);
  return KeyboardZoom;
}(_Interaction2.default);
var _default = exports.default = KeyboardZoom;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/interaction/MouseWheelZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _EventType = _interopRequireDefault(require("../events/EventType.js"));
var _Interaction2 = _interopRequireWildcard(require("./Interaction.js"));
var _has = require("../has.js");
var _condition = require("../events/condition.js");
var _math = require("../math.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/MouseWheelZoom
 */
/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
var MouseWheelZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(MouseWheelZoom, _Interaction);
  var _super = _createSuper(MouseWheelZoom);
  /**
   * @param {Options} [options] Options.
   */
  function MouseWheelZoom(options) {
    var _this;
    _classCallCheck(this, MouseWheelZoom);
    options = options ? options : {};
    _this = _super.call(this, /** @type {import("./Interaction.js").InteractionOptions} */options);

    /**
     * @private
     * @type {number}
     */
    _this.totalDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.lastDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : _condition.always;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    _this.condition_ = options.onFocusOnly ? (0, _condition.all)(_condition.focusWithTabindex, condition) : condition;

    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */
    _this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.startTime_ = undefined;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    _this.timeoutId_;

    /**
     * @private
     * @type {Mode|undefined}
     */
    _this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */
    _this.trackpadEventGap_ = 400;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    _this.trackpadTimeoutId_;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    _this.deltaPerZoom_ = 300;
    return _this;
  }

  /**
   * @private
   */
  _createClass(MouseWheelZoom, [{
    key: "endInteraction_",
    value: function endInteraction_() {
      this.trackpadTimeoutId_ = undefined;
      var map = this.getMap();
      if (!map) {
        return;
      }
      var view = map.getView();
      view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    }

    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      if (!this.condition_(mapBrowserEvent)) {
        return true;
      }
      var type = mapBrowserEvent.type;
      if (type !== _EventType.default.WHEEL) {
        return true;
      }
      var map = mapBrowserEvent.map;
      var wheelEvent = /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent;
      wheelEvent.preventDefault();
      if (this.useAnchor_) {
        this.lastAnchor_ = mapBrowserEvent.coordinate;
      }

      // Delta normalisation inspired by
      // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
      var delta;
      if (mapBrowserEvent.type == _EventType.default.WHEEL) {
        delta = wheelEvent.deltaY;
        if (_has.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          delta /= _has.DEVICE_PIXEL_RATIO;
        }
        if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
          delta *= 40;
        }
      }
      if (delta === 0) {
        return false;
      }
      this.lastDelta_ = delta;
      var now = Date.now();
      if (this.startTime_ === undefined) {
        this.startTime_ = now;
      }
      if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
        this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
      }
      var view = map.getView();
      if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {
        if (this.trackpadTimeoutId_) {
          clearTimeout(this.trackpadTimeoutId_);
        } else {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }
          view.beginInteraction();
        }
        this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
        view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
        this.startTime_ = now;
        return false;
      }
      this.totalDelta_ += delta;
      var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
      clearTimeout(this.timeoutId_);
      this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
      return false;
    }

    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
  }, {
    key: "handleWheelZoom_",
    value: function handleWheelZoom_(map) {
      var view = map.getView();
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      var delta = -(0, _math.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
      if (view.getConstrainResolution() || this.constrainResolution_) {
        // view has a zoom constraint, zoom by 1
        delta = delta ? delta > 0 ? 1 : -1 : 0;
      }
      (0, _Interaction2.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
      this.mode_ = undefined;
      this.totalDelta_ = 0;
      this.lastAnchor_ = null;
      this.startTime_ = undefined;
      this.timeoutId_ = undefined;
    }

    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
  }, {
    key: "setMouseAnchor",
    value: function setMouseAnchor(useAnchor) {
      this.useAnchor_ = useAnchor;
      if (!useAnchor) {
        this.lastAnchor_ = null;
      }
    }
  }]);
  return MouseWheelZoom;
}(_Interaction2.default);
var _default = exports.default = MouseWheelZoom;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../has.js":"node_modules/ol/has.js","../events/condition.js":"node_modules/ol/events/condition.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/interaction/PinchRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Pointer = _interopRequireWildcard(require("./Pointer.js"));
var _functions = require("../functions.js");
var _rotationconstraint = require("../rotationconstraint.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/PinchRotate
 */
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(PinchRotate, _PointerInteraction);
  var _super = _createSuper(PinchRotate);
  /**
   * @param {Options} [options] Options.
   */
  function PinchRotate(options) {
    var _this;
    _classCallCheck(this, PinchRotate);
    options = options ? options : {};
    var pointerOptions = /** @type {import("./Pointer.js").Options} */
    options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }
    _this = _super.call(this, pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    _this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    _this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    _this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  _createClass(PinchRotate, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      var rotationDelta = 0.0;
      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1];

      // angle between touches
      var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
      if (this.lastAngle_ !== undefined) {
        var delta = angle - this.lastAngle_;
        this.rotationDelta_ += delta;
        if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
          this.rotating_ = true;
        }
        rotationDelta = delta;
      }
      this.lastAngle_ = angle;
      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (view.getConstraints().rotation === _rotationconstraint.disable) {
        return;
      }

      // rotate anchor point.
      // FIXME: should be the intersection point between the lines:
      //     touch0,touch1 and previousTouch0,previousTouch1
      this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, _Pointer.centroid)(this.targetPointers)));

      // rotate
      if (this.rotating_) {
        map.render();
        view.adjustRotationInternal(rotationDelta, this.anchor_);
      }
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.endInteraction(this.duration_);
        return false;
      }
      return true;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastAngle_ = undefined;
        this.rotating_ = false;
        this.rotationDelta_ = 0.0;
        if (!this.handlingDownUpSequence) {
          map.getView().beginInteraction();
        }
        return true;
      }
      return false;
    }
  }]);
  return PinchRotate;
}(_Pointer.default);
var _default = exports.default = PinchRotate;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../rotationconstraint.js":"node_modules/ol/rotationconstraint.js"}],"node_modules/ol/interaction/PinchZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Pointer = _interopRequireWildcard(require("./Pointer.js"));
var _functions = require("../functions.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/interaction/PinchZoom
 */
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(PinchZoom, _PointerInteraction);
  var _super = _createSuper(PinchZoom);
  /**
   * @param {Options} [options] Options.
   */
  function PinchZoom(options) {
    var _this;
    _classCallCheck(this, PinchZoom);
    options = options ? options : {};
    var pointerOptions = /** @type {import("./Pointer.js").Options} */
    options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }
    _this = _super.call(this, pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    _this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    _this.lastScaleDelta_ = 1;
    return _this;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  _createClass(PinchZoom, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      var scaleDelta = 1.0;
      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1];
      var dx = touch0.clientX - touch1.clientX;
      var dy = touch0.clientY - touch1.clientY;

      // distance between touches
      var distance = Math.sqrt(dx * dx + dy * dy);
      if (this.lastDistance_ !== undefined) {
        scaleDelta = this.lastDistance_ / distance;
      }
      this.lastDistance_ = distance;
      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (scaleDelta != 1.0) {
        this.lastScaleDelta_ = scaleDelta;
      }

      // scale anchor point.
      this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, _Pointer.centroid)(this.targetPointers)));

      // scale, bypass the resolution constraint
      map.render();
      view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }

    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
        view.endInteraction(this.duration_, direction);
        return false;
      }
      return true;
    }

    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastDistance_ = undefined;
        this.lastScaleDelta_ = 1;
        if (!this.handlingDownUpSequence) {
          map.getView().beginInteraction();
        }
        return true;
      }
      return false;
    }
  }]);
  return PinchZoom;
}(_Pointer.default);
var _default = exports.default = PinchZoom;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/interaction/defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
var _Collection = _interopRequireDefault(require("../Collection.js"));
var _DoubleClickZoom = _interopRequireDefault(require("./DoubleClickZoom.js"));
var _DragPan = _interopRequireDefault(require("./DragPan.js"));
var _DragRotate = _interopRequireDefault(require("./DragRotate.js"));
var _DragZoom = _interopRequireDefault(require("./DragZoom.js"));
var _KeyboardPan = _interopRequireDefault(require("./KeyboardPan.js"));
var _KeyboardZoom = _interopRequireDefault(require("./KeyboardZoom.js"));
var _Kinetic = _interopRequireDefault(require("../Kinetic.js"));
var _MouseWheelZoom = _interopRequireDefault(require("./MouseWheelZoom.js"));
var _PinchRotate = _interopRequireDefault(require("./PinchRotate.js"));
var _PinchZoom = _interopRequireDefault(require("./PinchZoom.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @module ol/interaction/defaults
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Interaction.js").default>} */
  var interactions = new _Collection.default();
  var kinetic = new _Kinetic.default(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new _DragRotate.default());
  }
  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new _DoubleClickZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new _DragPan.default({
      onFocusOnly: options.onFocusOnly,
      kinetic: kinetic
    }));
  }
  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new _PinchRotate.default());
  }
  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new _PinchZoom.default({
      duration: options.zoomDuration
    }));
  }
  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _KeyboardPan.default());
    interactions.push(new _KeyboardZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new _MouseWheelZoom.default({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }
  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new _DragZoom.default({
      duration: options.zoomDuration
    }));
  }
  return interactions;
}
},{"../Collection.js":"node_modules/ol/Collection.js","./DoubleClickZoom.js":"node_modules/ol/interaction/DoubleClickZoom.js","./DragPan.js":"node_modules/ol/interaction/DragPan.js","./DragRotate.js":"node_modules/ol/interaction/DragRotate.js","./DragZoom.js":"node_modules/ol/interaction/DragZoom.js","./KeyboardPan.js":"node_modules/ol/interaction/KeyboardPan.js","./KeyboardZoom.js":"node_modules/ol/interaction/KeyboardZoom.js","../Kinetic.js":"node_modules/ol/Kinetic.js","./MouseWheelZoom.js":"node_modules/ol/interaction/MouseWheelZoom.js","./PinchRotate.js":"node_modules/ol/interaction/PinchRotate.js","./PinchZoom.js":"node_modules/ol/interaction/PinchZoom.js"}],"node_modules/ol/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Object = _interopRequireDefault(require("./Object.js"));
var _Collection = _interopRequireDefault(require("./Collection.js"));
var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));
var _Composite = _interopRequireDefault(require("./renderer/Composite.js"));
var _EventType = _interopRequireDefault(require("./events/EventType.js"));
var _Layer = _interopRequireDefault(require("./layer/Layer.js"));
var _Group = _interopRequireWildcard(require("./layer/Group.js"));
var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));
var _MapBrowserEventHandler = _interopRequireDefault(require("./MapBrowserEventHandler.js"));
var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));
var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));
var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));
var _MapProperty = _interopRequireDefault(require("./MapProperty.js"));
var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));
var _EventType2 = _interopRequireDefault(require("./pointer/EventType.js"));
var _EventType3 = _interopRequireDefault(require("./render/EventType.js"));
var _TileQueue = _interopRequireWildcard(require("./TileQueue.js"));
var _View = _interopRequireDefault(require("./View.js"));
var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));
var _has = require("./has.js");
var _functions = require("./functions.js");
var _transform = require("./transform.js");
var _asserts = require("./asserts.js");
var _extent = require("./extent.js");
var _defaults = require("./control/defaults.js");
var _defaults2 = require("./interaction/defaults.js");
var _array = require("./array.js");
var _proj = require("./proj.js");
var _util = require("./util.js");
var _size = require("./size.js");
var _events = require("./events.js");
var _dom = require("./dom.js");
var _console = require("./console.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /**
 * @module ol/Map
 */
/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent (in view projection coordinates).
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */

/**
 * @typedef {function(Map, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * **Note:** CSS `transform` support for the target element is limited to `scale`.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */
function removeLayerMapProperty(layer) {
  if (layer instanceof _Layer.default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof _Group.default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */
function setLayerMapProperty(layer, map) {
  if (layer instanceof _Layer.default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof _Group.default) {
    var layers = layer.getLayers().getArray();
    for (var i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}

/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
var Map = /*#__PURE__*/function (_BaseObject) {
  _inherits(Map, _BaseObject);
  var _super = _createSuper(Map);
  /**
   * @param {MapOptions} [options] Map options.
   */
  function Map(options) {
    var _this;
    _classCallCheck(this, Map);
    _this = _super.call(this);
    options = options || {};

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    _this.on;

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    _this.once;

    /***
     * @type {MapEventHandler<void>}
     */
    _this.un;
    var optionsInternal = createOptionsInternal(options);

    /**
     * @private
     * @type {boolean|undefined}
     */
    _this.renderComplete_;

    /**
     * @private
     * @type {boolean}
     */
    _this.loaded_ = true;

    /** @private */
    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_assertThisInitialized(_this));

    /**
     * @type {number}
     * @private
     */
    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @private
     * @type {number}
     */
    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has.DEVICE_PIXEL_RATIO;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    _this.postRenderTimeoutHandle_;

    /**
     * @private
     * @type {number|undefined}
     */
    _this.animationDelayKey_;

    /**
     * @private
     */
    _this.animationDelay_ = _this.animationDelay_.bind(_assertThisInitialized(_this));

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    _this.coordinateToPixelTransform_ = (0, _transform.create)();

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    _this.pixelToCoordinateTransform_ = (0, _transform.create)();

    /**
     * @private
     * @type {number}
     */
    _this.frameIndex_ = 0;

    /**
     * @private
     * @type {?FrameState}
     */
    _this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    _this.previousExtent_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    _this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    _this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    _this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    _this.viewport_ = document.createElement('div');
    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    _this.viewport_.style.position = 'relative';
    _this.viewport_.style.overflow = 'hidden';
    _this.viewport_.style.width = '100%';
    _this.viewport_.style.height = '100%';

    /**
     * @private
     * @type {!HTMLElement}
     */
    _this.overlayContainer_ = document.createElement('div');
    _this.overlayContainer_.style.position = 'absolute';
    _this.overlayContainer_.style.zIndex = '0';
    _this.overlayContainer_.style.width = '100%';
    _this.overlayContainer_.style.height = '100%';
    _this.overlayContainer_.style.pointerEvents = 'none';
    _this.overlayContainer_.className = 'ol-overlaycontainer';
    _this.viewport_.appendChild(_this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    _this.overlayContainerStopEvent_ = document.createElement('div');
    _this.overlayContainerStopEvent_.style.position = 'absolute';
    _this.overlayContainerStopEvent_.style.zIndex = '0';
    _this.overlayContainerStopEvent_.style.width = '100%';
    _this.overlayContainerStopEvent_.style.height = '100%';
    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    _this.mapBrowserEventHandler_ = null;

    /**
     * @private
     * @type {number}
     */
    _this.moveTolerance_ = options.moveTolerance;

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    _this.targetChangeHandlerKeys_ = null;

    /**
     * @private
     * @type {HTMLElement|null}
     */
    _this.targetElement_ = null;

    /**
     * @type {ResizeObserver}
     */
    _this.resizeObserver_ = new ResizeObserver(function () {
      return _this.updateSize();
    });

    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    _this.controls = optionsInternal.controls || (0, _defaults.defaults)();

    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    _this.interactions = optionsInternal.interactions || (0, _defaults2.defaults)({
      onFocusOnly: true
    });

    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    _this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    _this.overlayIdIndex_ = {};

    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */
    _this.renderer_ = null;

    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    _this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {TileQueue}
     */
    _this.tileQueue_ = new _TileQueue.default(_this.getTilePriority.bind(_assertThisInitialized(_this)), _this.handleTileChange_.bind(_assertThisInitialized(_this)));
    _this.addChangeListener(_MapProperty.default.LAYERGROUP, _this.handleLayerGroupChanged_);
    _this.addChangeListener(_MapProperty.default.VIEW, _this.handleViewChanged_);
    _this.addChangeListener(_MapProperty.default.SIZE, _this.handleSizeChanged_);
    _this.addChangeListener(_MapProperty.default.TARGET, _this.handleTargetChanged_);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    _this.setProperties(optionsInternal.values);
    var map = _assertThisInitialized(_this);
    if (options.view && !(options.view instanceof _View.default)) {
      options.view.then(function (viewOptions) {
        map.setView(new _View.default(viewOptions));
      });
    }
    _this.controls.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
     */
    function (event) {
      event.element.setMap(_assertThisInitialized(_this));
    });
    _this.controls.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    });
    _this.interactions.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(_assertThisInitialized(_this));
    });
    _this.interactions.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    });
    _this.overlays_.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
     */
    function (event) {
      _this.addOverlayInternal_(event.element);
    });
    _this.overlays_.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
     */
    function (event) {
      var id = event.element.getId();
      if (id !== undefined) {
        delete _this.overlayIdIndex_[id.toString()];
      }
      event.element.setMap(null);
    });
    _this.controls.forEach(
    /**
     * @param {import("./control/Control.js").default} control Control.
     */
    function (control) {
      control.setMap(_assertThisInitialized(_this));
    });
    _this.interactions.forEach(
    /**
     * @param {import("./interaction/Interaction.js").default} interaction Interaction.
     */
    function (interaction) {
      interaction.setMap(_assertThisInitialized(_this));
    });
    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  _createClass(Map, [{
    key: "addControl",
    value: function addControl(control) {
      this.getControls().push(control);
    }

    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
  }, {
    key: "addInteraction",
    value: function addInteraction(interaction) {
      this.getInteractions().push(interaction);
    }

    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
  }, {
    key: "addLayer",
    value: function addLayer(layer) {
      var layers = this.getLayerGroup().getLayers();
      layers.push(layer);
    }

    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
  }, {
    key: "handleLayerAdd_",
    value: function handleLayerAdd_(event) {
      setLayerMapProperty(event.layer, this);
    }

    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
  }, {
    key: "addOverlay",
    value: function addOverlay(overlay) {
      this.getOverlays().push(overlay);
    }

    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
  }, {
    key: "addOverlayInternal_",
    value: function addOverlayInternal_(overlay) {
      var id = overlay.getId();
      if (id !== undefined) {
        this.overlayIdIndex_[id.toString()] = overlay;
      }
      overlay.setMap(this);
    }

    /**
     *
     * Clean up.
     */
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.controls.clear();
      this.interactions.clear();
      this.overlays_.clear();
      this.resizeObserver_.disconnect();
      this.setTarget(null);
      _get(_getPrototypeOf(Map.prototype), "disposeInternal", this).call(this);
    }

    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
  }, {
    key: "forEachFeatureAtPixel",
    value: function forEachFeatureAtPixel(pixel, callback, options) {
      if (!this.frameState_ || !this.renderer_) {
        return;
      }
      var coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== undefined ? options : {};
      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : _functions.TRUE;
      var checkWrapped = options.checkWrapped !== false;
      return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    }

    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
  }, {
    key: "getFeaturesAtPixel",
    value: function getFeaturesAtPixel(pixel, options) {
      var features = [];
      this.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature);
      }, options);
      return features;
    }

    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
  }, {
    key: "getAllLayers",
    value: function getAllLayers() {
      var layers = [];
      function addLayersFrom(layerGroup) {
        layerGroup.forEach(function (layer) {
          if (layer instanceof _Group.default) {
            addLayersFrom(layer.getLayers());
          } else {
            layers.push(layer);
          }
        });
      }
      addLayersFrom(this.getLayers());
      return layers;
    }

    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
  }, {
    key: "hasFeatureAtPixel",
    value: function hasFeatureAtPixel(pixel, options) {
      if (!this.frameState_ || !this.renderer_) {
        return false;
      }
      var coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== undefined ? options : {};
      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : _functions.TRUE;
      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
      var checkWrapped = options.checkWrapped !== false;
      return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    }

    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
  }, {
    key: "getEventCoordinate",
    value: function getEventCoordinate(event) {
      return this.getCoordinateFromPixel(this.getEventPixel(event));
    }

    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
  }, {
    key: "getEventCoordinateInternal",
    value: function getEventCoordinateInternal(event) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }

    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
  }, {
    key: "getEventPixel",
    value: function getEventPixel(event) {
      var viewport = this.viewport_;
      var viewportPosition = viewport.getBoundingClientRect();
      var viewportSize = this.getSize();
      var scaleX = viewportPosition.width / viewportSize[0];
      var scaleY = viewportPosition.height / viewportSize[1];
      var eventPosition =
      //FIXME Are we really calling this with a TouchEvent anywhere?
      'changedTouches' in event ? /** @type {TouchEvent} */event.changedTouches[0] : ( /** @type {MouseEvent} */event);
      return [(eventPosition.clientX - viewportPosition.left) / scaleX, (eventPosition.clientY - viewportPosition.top) / scaleY];
    }

    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
  }, {
    key: "getTarget",
    value: function getTarget() {
      return /** @type {HTMLElement|string|undefined} */(
        this.get(_MapProperty.default.TARGET)
      );
    }

    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
  }, {
    key: "getTargetElement",
    value: function getTargetElement() {
      return this.targetElement_;
    }

    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
  }, {
    key: "getCoordinateFromPixel",
    value: function getCoordinateFromPixel(pixel) {
      return (0, _proj.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    }

    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
  }, {
    key: "getCoordinateFromPixelInternal",
    value: function getCoordinateFromPixelInternal(pixel) {
      var frameState = this.frameState_;
      if (!frameState) {
        return null;
      }
      return (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }

    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this.controls;
    }

    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
  }, {
    key: "getOverlays",
    value: function getOverlays() {
      return this.overlays_;
    }

    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default} Overlay.
     * @api
     */
  }, {
    key: "getOverlayById",
    value: function getOverlayById(id) {
      var overlay = this.overlayIdIndex_[id.toString()];
      return overlay !== undefined ? overlay : null;
    }

    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
  }, {
    key: "getInteractions",
    value: function getInteractions() {
      return this.interactions;
    }

    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
  }, {
    key: "getLayerGroup",
    value: function getLayerGroup() {
      return /** @type {LayerGroup} */this.get(_MapProperty.default.LAYERGROUP);
    }

    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
  }, {
    key: "setLayers",
    value: function setLayers(layers) {
      var group = this.getLayerGroup();
      if (layers instanceof _Collection.default) {
        group.setLayers(layers);
        return;
      }
      var collection = group.getLayers();
      collection.clear();
      collection.extend(layers);
    }

    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
  }, {
    key: "getLayers",
    value: function getLayers() {
      var layers = this.getLayerGroup().getLayers();
      return layers;
    }

    /**
     * @return {boolean} Layers have sources that are still loading.
     */
  }, {
    key: "getLoadingOrNotReady",
    value: function getLoadingOrNotReady() {
      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        var state = layerStatesArray[i];
        if (!state.visible) {
          continue;
        }
        var renderer = state.layer.getRenderer();
        if (renderer && !renderer.ready) {
          return true;
        }
        var source = state.layer.getSource();
        if (source && source.loading) {
          return true;
        }
      }
      return false;
    }

    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
  }, {
    key: "getPixelFromCoordinate",
    value: function getPixelFromCoordinate(coordinate) {
      var viewCoordinate = (0, _proj.fromUserCoordinate)(coordinate, this.getView().getProjection());
      return this.getPixelFromCoordinateInternal(viewCoordinate);
    }

    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
  }, {
    key: "getPixelFromCoordinateInternal",
    value: function getPixelFromCoordinateInternal(coordinate) {
      var frameState = this.frameState_;
      if (!frameState) {
        return null;
      }
      return (0, _transform.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }

    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
  }, {
    key: "getRenderer",
    value: function getRenderer() {
      return this.renderer_;
    }

    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return /** @type {import("./size.js").Size|undefined} */(
        this.get(_MapProperty.default.SIZE)
      );
    }

    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
  }, {
    key: "getView",
    value: function getView() {
      return /** @type {View} */this.get(_MapProperty.default.VIEW);
    }

    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
  }, {
    key: "getViewport",
    value: function getViewport() {
      return this.viewport_;
    }

    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
  }, {
    key: "getOverlayContainer",
    value: function getOverlayContainer() {
      return this.overlayContainer_;
    }

    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
  }, {
    key: "getOverlayContainerStopEvent",
    value: function getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }

    /**
     * @return {!Document} The document where the map is displayed.
     */
  }, {
    key: "getOwnerDocument",
    value: function getOwnerDocument() {
      var targetElement = this.getTargetElement();
      return targetElement ? targetElement.ownerDocument : document;
    }

    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
  }, {
    key: "getTilePriority",
    value: function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
      return (0, _TileQueue.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    }

    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
  }, {
    key: "handleBrowserEvent",
    value: function handleBrowserEvent(browserEvent, type) {
      type = type || browserEvent.type;
      var mapBrowserEvent = new _MapBrowserEvent.default(type, this, browserEvent);
      this.handleMapBrowserEvent(mapBrowserEvent);
    }

    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
  }, {
    key: "handleMapBrowserEvent",
    value: function handleMapBrowserEvent(mapBrowserEvent) {
      if (!this.frameState_) {
        // With no view defined, we cannot translate pixels into geographical
        // coordinates so interactions cannot be used.
        return;
      }
      var originalEvent = /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent;
      var eventType = originalEvent.type;
      if (eventType === _EventType2.default.POINTERDOWN || eventType === _EventType.default.WHEEL || eventType === _EventType.default.KEYDOWN) {
        var doc = this.getOwnerDocument();
        var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
        var target = /** @type {Node} */originalEvent.target;
        if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) ||
        // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
          return;
        }
      }
      mapBrowserEvent.frameState = this.frameState_;
      if (this.dispatchEvent(mapBrowserEvent) !== false) {
        var interactionsArray = this.getInteractions().getArray().slice();
        for (var i = interactionsArray.length - 1; i >= 0; i--) {
          var interaction = interactionsArray[i];
          if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
            continue;
          }
          var cont = interaction.handleEvent(mapBrowserEvent);
          if (!cont || mapBrowserEvent.propagationStopped) {
            break;
          }
        }
      }
    }

    /**
     * @protected
     */
  }, {
    key: "handlePostRender",
    value: function handlePostRender() {
      var frameState = this.frameState_;

      // Manage the tile queue
      // Image loads are expensive and a limited resource, so try to use them
      // efficiently:
      // * When the view is static we allow a large number of parallel tile loads
      //   to complete the frame as quickly as possible.
      // * When animating or interacting, image loads can cause janks, so we reduce
      //   the maximum number of loads per frame and limit the number of parallel
      //   tile loads to remain reactive to view changes and to reduce the chance of
      //   loading tiles that will quickly disappear from view.
      var tileQueue = this.tileQueue_;
      if (!tileQueue.isEmpty()) {
        var maxTotalLoading = this.maxTilesLoading_;
        var maxNewLoads = maxTotalLoading;
        if (frameState) {
          var hints = frameState.viewHints;
          if (hints[_ViewHint.default.ANIMATING] || hints[_ViewHint.default.INTERACTING]) {
            var lowOnFrameBudget = Date.now() - frameState.time > 8;
            maxTotalLoading = lowOnFrameBudget ? 0 : 8;
            maxNewLoads = lowOnFrameBudget ? 0 : 2;
          }
        }
        if (tileQueue.getTilesLoading() < maxTotalLoading) {
          tileQueue.reprioritize(); // FIXME only call if view has changed
          tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
        }
      }
      if (frameState && this.renderer_ && !frameState.animate) {
        if (this.renderComplete_ === true) {
          if (this.hasListener(_EventType3.default.RENDERCOMPLETE)) {
            this.renderer_.dispatchRenderEvent(_EventType3.default.RENDERCOMPLETE, frameState);
          }
          if (this.loaded_ === false) {
            this.loaded_ = true;
            this.dispatchEvent(new _MapEvent.default(_MapEventType.default.LOADEND, this, frameState));
          }
        } else if (this.loaded_ === true) {
          this.loaded_ = false;
          this.dispatchEvent(new _MapEvent.default(_MapEventType.default.LOADSTART, this, frameState));
        }
      }
      var postRenderFunctions = this.postRenderFunctions_;
      for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
        postRenderFunctions[i](this, frameState);
      }
      postRenderFunctions.length = 0;
    }

    /**
     * @private
     */
  }, {
    key: "handleSizeChanged_",
    value: function handleSizeChanged_() {
      if (this.getView() && !this.getView().getAnimating()) {
        this.getView().resolveConstraints(0);
      }
      this.render();
    }

    /**
     * @private
     */
  }, {
    key: "handleTargetChanged_",
    value: function handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
          (0, _events.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
        }
        this.targetChangeHandlerKeys_ = null;
        this.viewport_.removeEventListener(_EventType.default.CONTEXTMENU, this.boundHandleBrowserEvent_);
        this.viewport_.removeEventListener(_EventType.default.WHEEL, this.boundHandleBrowserEvent_);
        this.mapBrowserEventHandler_.dispose();
        this.mapBrowserEventHandler_ = null;
        (0, _dom.removeNode)(this.viewport_);
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        var rootNode = this.targetElement_.getRootNode();
        if (rootNode instanceof ShadowRoot) {
          this.resizeObserver_.unobserve(rootNode.host);
        }
        this.setSize(undefined);
      }

      // target may be undefined, null, a string or an Element.
      // If it's a string we convert it to an Element before proceeding.
      // If it's not now an Element we remove the viewport from the DOM.
      // If it's an Element we append the viewport element to it.

      var target = this.getTarget();
      var targetElement = typeof target === 'string' ? document.getElementById(target) : target;
      this.targetElement_ = targetElement;
      if (!targetElement) {
        if (this.renderer_) {
          clearTimeout(this.postRenderTimeoutHandle_);
          this.postRenderTimeoutHandle_ = undefined;
          this.postRenderFunctions_.length = 0;
          this.renderer_.dispose();
          this.renderer_ = null;
        }
        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
          this.animationDelayKey_ = undefined;
        }
      } else {
        targetElement.appendChild(this.viewport_);
        if (!this.renderer_) {
          this.renderer_ = new _Composite.default(this);
        }
        this.mapBrowserEventHandler_ = new _MapBrowserEventHandler.default(this, this.moveTolerance_);
        for (var key in _MapBrowserEventType.default) {
          this.mapBrowserEventHandler_.addEventListener(_MapBrowserEventType.default[key], this.handleMapBrowserEvent.bind(this));
        }
        this.viewport_.addEventListener(_EventType.default.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
        this.viewport_.addEventListener(_EventType.default.WHEEL, this.boundHandleBrowserEvent_, _has.PASSIVE_EVENT_LISTENERS ? {
          passive: false
        } : false);
        var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
        this.targetChangeHandlerKeys_ = [(0, _events.listen)(keyboardEventTarget, _EventType.default.KEYDOWN, this.handleBrowserEvent, this), (0, _events.listen)(keyboardEventTarget, _EventType.default.KEYPRESS, this.handleBrowserEvent, this)];
        var _rootNode = targetElement.getRootNode();
        if (_rootNode instanceof ShadowRoot) {
          this.resizeObserver_.observe(_rootNode.host);
        }
        this.resizeObserver_.observe(targetElement);
      }
      this.updateSize();
      // updateSize calls setSize, so no need to call this.render
      // ourselves here.
    }

    /**
     * @private
     */
  }, {
    key: "handleTileChange_",
    value: function handleTileChange_() {
      this.render();
    }

    /**
     * @private
     */
  }, {
    key: "handleViewPropertyChanged_",
    value: function handleViewPropertyChanged_() {
      this.render();
    }

    /**
     * @private
     */
  }, {
    key: "handleViewChanged_",
    value: function handleViewChanged_() {
      if (this.viewPropertyListenerKey_) {
        (0, _events.unlistenByKey)(this.viewPropertyListenerKey_);
        this.viewPropertyListenerKey_ = null;
      }
      if (this.viewChangeListenerKey_) {
        (0, _events.unlistenByKey)(this.viewChangeListenerKey_);
        this.viewChangeListenerKey_ = null;
      }
      var view = this.getView();
      if (view) {
        this.updateViewportSize_(this.getSize());
        this.viewPropertyListenerKey_ = (0, _events.listen)(view, _ObjectEventType.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
        this.viewChangeListenerKey_ = (0, _events.listen)(view, _EventType.default.CHANGE, this.handleViewPropertyChanged_, this);
        view.resolveConstraints(0);
      }
      this.render();
    }

    /**
     * @private
     */
  }, {
    key: "handleLayerGroupChanged_",
    value: function handleLayerGroupChanged_() {
      if (this.layerGroupPropertyListenerKeys_) {
        this.layerGroupPropertyListenerKeys_.forEach(_events.unlistenByKey);
        this.layerGroupPropertyListenerKeys_ = null;
      }
      var layerGroup = this.getLayerGroup();
      if (layerGroup) {
        this.handleLayerAdd_(new _Group.GroupEvent('addlayer', layerGroup));
        this.layerGroupPropertyListenerKeys_ = [(0, _events.listen)(layerGroup, _ObjectEventType.default.PROPERTYCHANGE, this.render, this), (0, _events.listen)(layerGroup, _EventType.default.CHANGE, this.render, this), (0, _events.listen)(layerGroup, 'addlayer', this.handleLayerAdd_, this), (0, _events.listen)(layerGroup, 'removelayer', this.handleLayerRemove_, this)];
      }
      this.render();
    }

    /**
     * @return {boolean} Is rendered.
     */
  }, {
    key: "isRendered",
    value: function isRendered() {
      return !!this.frameState_;
    }

    /**
     * @private
     */
  }, {
    key: "animationDelay_",
    value: function animationDelay_() {
      this.animationDelayKey_ = undefined;
      this.renderFrame_(Date.now());
    }

    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
  }, {
    key: "renderSync",
    value: function renderSync() {
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
      }
      this.animationDelay_();
    }

    /**
     * Redraws all text after new fonts have loaded
     */
  }, {
    key: "redrawText",
    value: function redrawText() {
      var layerStates = this.getLayerGroup().getLayerStatesArray();
      for (var i = 0, ii = layerStates.length; i < ii; ++i) {
        var layer = layerStates[i].layer;
        if (layer.hasRenderer()) {
          layer.getRenderer().handleFontsChanged();
        }
      }
    }

    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
  }, {
    key: "render",
    value: function render() {
      if (this.renderer_ && this.animationDelayKey_ === undefined) {
        this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
      }
    }

    /**
     * This method is meant to be called in a layer's `prerender` listener. It causes all collected
     * declutter items to be decluttered and rendered on the map immediately. This is useful for
     * layers that need to appear entirely above the decluttered items of layers lower in the layer
     * stack.
     * @api
     */
  }, {
    key: "flushDeclutterItems",
    value: function flushDeclutterItems() {
      var frameState = this.frameState_;
      if (!frameState) {
        return;
      }
      this.renderer_.flushDeclutterItems(frameState);
    }

    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
  }, {
    key: "removeControl",
    value: function removeControl(control) {
      return this.getControls().remove(control);
    }

    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
  }, {
    key: "removeInteraction",
    value: function removeInteraction(interaction) {
      return this.getInteractions().remove(interaction);
    }

    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
  }, {
    key: "removeLayer",
    value: function removeLayer(layer) {
      var layers = this.getLayerGroup().getLayers();
      return layers.remove(layer);
    }

    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
  }, {
    key: "handleLayerRemove_",
    value: function handleLayerRemove_(event) {
      removeLayerMapProperty(event.layer);
    }

    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
  }, {
    key: "removeOverlay",
    value: function removeOverlay(overlay) {
      return this.getOverlays().remove(overlay);
    }

    /**
     * @param {number} time Time.
     * @private
     */
  }, {
    key: "renderFrame_",
    value: function renderFrame_(time) {
      var _this2 = this;
      var size = this.getSize();
      var view = this.getView();
      var previousFrameState = this.frameState_;
      /** @type {?FrameState} */
      var frameState = null;
      if (size !== undefined && (0, _size.hasArea)(size) && view && view.isDef()) {
        var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
        var viewState = view.getState();
        frameState = {
          animate: false,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutterTree: null,
          extent: (0, _extent.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size: size,
          tileQueue: this.tileQueue_,
          time: time,
          usedTiles: {},
          viewState: viewState,
          viewHints: viewHints,
          wantedTiles: {},
          mapId: (0, _util.getUid)(this),
          renderTargets: {}
        };
        if (viewState.nextCenter && viewState.nextResolution) {
          var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
          frameState.nextExtent = (0, _extent.getForViewAndSize)(viewState.nextCenter, viewState.nextResolution, rotation, size);
        }
      }
      this.frameState_ = frameState;
      this.renderer_.renderFrame(frameState);
      if (frameState) {
        if (frameState.animate) {
          this.render();
        }
        Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
        if (previousFrameState) {
          var moveStart = !this.previousExtent_ || !(0, _extent.isEmpty)(this.previousExtent_) && !(0, _extent.equals)(frameState.extent, this.previousExtent_);
          if (moveStart) {
            this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVESTART, this, previousFrameState));
            this.previousExtent_ = (0, _extent.createOrUpdateEmpty)(this.previousExtent_);
          }
        }
        var idle = this.previousExtent_ && !frameState.viewHints[_ViewHint.default.ANIMATING] && !frameState.viewHints[_ViewHint.default.INTERACTING] && !(0, _extent.equals)(frameState.extent, this.previousExtent_);
        if (idle) {
          this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVEEND, this, frameState));
          (0, _extent.clone)(frameState.extent, this.previousExtent_);
        }
      }
      this.dispatchEvent(new _MapEvent.default(_MapEventType.default.POSTRENDER, this, frameState));
      this.renderComplete_ = this.hasListener(_MapEventType.default.LOADSTART) || this.hasListener(_MapEventType.default.LOADEND) || this.hasListener(_EventType3.default.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;
      if (!this.postRenderTimeoutHandle_) {
        this.postRenderTimeoutHandle_ = setTimeout(function () {
          _this2.postRenderTimeoutHandle_ = undefined;
          _this2.handlePostRender();
        }, 0);
      }
    }

    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
  }, {
    key: "setLayerGroup",
    value: function setLayerGroup(layerGroup) {
      var oldLayerGroup = this.getLayerGroup();
      if (oldLayerGroup) {
        this.handleLayerRemove_(new _Group.GroupEvent('removelayer', oldLayerGroup));
      }
      this.set(_MapProperty.default.LAYERGROUP, layerGroup);
    }

    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
  }, {
    key: "setSize",
    value: function setSize(size) {
      this.set(_MapProperty.default.SIZE, size);
    }

    /**
     * Set the target element to render this map into.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.set(_MapProperty.default.TARGET, target);
    }

    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
  }, {
    key: "setView",
    value: function setView(view) {
      if (!view || view instanceof _View.default) {
        this.set(_MapProperty.default.VIEW, view);
        return;
      }
      this.set(_MapProperty.default.VIEW, new _View.default());
      var map = this;
      view.then(function (viewOptions) {
        map.setView(new _View.default(viewOptions));
      });
    }

    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
  }, {
    key: "updateSize",
    value: function updateSize() {
      var targetElement = this.getTargetElement();
      var size = undefined;
      if (targetElement) {
        var computedStyle = getComputedStyle(targetElement);
        var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
        var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);
        if (!isNaN(width) && !isNaN(height)) {
          size = [width, height];
          if (!(0, _size.hasArea)(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
            (0, _console.warn)("No map visible because the map container's width or height are 0.");
          }
        }
      }
      var oldSize = this.getSize();
      if (size && (!oldSize || !(0, _array.equals)(size, oldSize))) {
        this.setSize(size);
        this.updateViewportSize_(size);
      }
    }

    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @param {import("./size.js").Size|undefined} size The size.
     * @private
     */
  }, {
    key: "updateViewportSize_",
    value: function updateViewportSize_(size) {
      var view = this.getView();
      if (view) {
        view.setViewportSize(size);
      }
    }
  }]);
  return Map;
}(_Object.default);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }

  /**
   * @type {Object<string, *>}
   */
  var values = {};
  var layerGroup = options.layers && typeof ( /** @type {?} */options.layers.getLayers) === 'function' ? ( /** @type {LayerGroup} */options.layers) : new _Group.default({
    layers: ( /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
    options.layers)
  });
  values[_MapProperty.default.LAYERGROUP] = layerGroup;
  values[_MapProperty.default.TARGET] = options.target;
  values[_MapProperty.default.VIEW] = options.view instanceof _View.default ? options.view : new _View.default();

  /** @type {Collection<import("./control/Control.js").default>} */
  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection.default(options.controls.slice());
    } else {
      (0, _asserts.assert)(typeof ( /** @type {?} */options.controls.getArray) === 'function', 'Expected `controls` to be an array or an `ol/Collection.js`');
      controls = options.controls;
    }
  }

  /** @type {Collection<import("./interaction/Interaction").default>} */
  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection.default(options.interactions.slice());
    } else {
      (0, _asserts.assert)(typeof ( /** @type {?} */options.interactions.getArray) === 'function', 'Expected `interactions` to be an array or an `ol/Collection.js`');
      interactions = options.interactions;
    }
  }

  /** @type {Collection<import("./Overlay.js").default>} */
  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection.default(options.overlays.slice());
    } else {
      (0, _asserts.assert)(typeof ( /** @type {?} */options.overlays.getArray) === 'function', 'Expected `overlays` to be an array or an `ol/Collection.js`');
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection.default();
  }
  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };
}
var _default = exports.default = Map;
},{"./Object.js":"node_modules/ol/Object.js","./Collection.js":"node_modules/ol/Collection.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./renderer/Composite.js":"node_modules/ol/renderer/Composite.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./layer/Layer.js":"node_modules/ol/layer/Layer.js","./layer/Group.js":"node_modules/ol/layer/Group.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventHandler.js":"node_modules/ol/MapBrowserEventHandler.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./MapEvent.js":"node_modules/ol/MapEvent.js","./MapEventType.js":"node_modules/ol/MapEventType.js","./MapProperty.js":"node_modules/ol/MapProperty.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./pointer/EventType.js":"node_modules/ol/pointer/EventType.js","./render/EventType.js":"node_modules/ol/render/EventType.js","./TileQueue.js":"node_modules/ol/TileQueue.js","./View.js":"node_modules/ol/View.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./has.js":"node_modules/ol/has.js","./functions.js":"node_modules/ol/functions.js","./transform.js":"node_modules/ol/transform.js","./asserts.js":"node_modules/ol/asserts.js","./extent.js":"node_modules/ol/extent.js","./control/defaults.js":"node_modules/ol/control/defaults.js","./interaction/defaults.js":"node_modules/ol/interaction/defaults.js","./array.js":"node_modules/ol/array.js","./proj.js":"node_modules/ol/proj.js","./util.js":"node_modules/ol/util.js","./size.js":"node_modules/ol/size.js","./events.js":"node_modules/ol/events.js","./dom.js":"node_modules/ol/dom.js","./console.js":"node_modules/ol/console.js"}],"node_modules/ol/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Collection", {
  enumerable: true,
  get: function () {
    return _Collection.default;
  }
});
Object.defineProperty(exports, "Disposable", {
  enumerable: true,
  get: function () {
    return _Disposable.default;
  }
});
Object.defineProperty(exports, "Feature", {
  enumerable: true,
  get: function () {
    return _Feature.default;
  }
});
Object.defineProperty(exports, "Geolocation", {
  enumerable: true,
  get: function () {
    return _Geolocation.default;
  }
});
Object.defineProperty(exports, "Graticule", {
  enumerable: true,
  get: function () {
    return _Graticule.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "ImageCanvas", {
  enumerable: true,
  get: function () {
    return _ImageCanvas.default;
  }
});
Object.defineProperty(exports, "ImageTile", {
  enumerable: true,
  get: function () {
    return _ImageTile.default;
  }
});
Object.defineProperty(exports, "ImageWrapper", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "Kinetic", {
  enumerable: true,
  get: function () {
    return _Kinetic.default;
  }
});
Object.defineProperty(exports, "Map", {
  enumerable: true,
  get: function () {
    return _Map.default;
  }
});
Object.defineProperty(exports, "MapBrowserEvent", {
  enumerable: true,
  get: function () {
    return _MapBrowserEvent.default;
  }
});
Object.defineProperty(exports, "MapBrowserEventHandler", {
  enumerable: true,
  get: function () {
    return _MapBrowserEventHandler.default;
  }
});
Object.defineProperty(exports, "MapEvent", {
  enumerable: true,
  get: function () {
    return _MapEvent.default;
  }
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function () {
    return _Object.default;
  }
});
Object.defineProperty(exports, "Observable", {
  enumerable: true,
  get: function () {
    return _Observable.default;
  }
});
Object.defineProperty(exports, "Overlay", {
  enumerable: true,
  get: function () {
    return _Overlay.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "TileCache", {
  enumerable: true,
  get: function () {
    return _TileCache.default;
  }
});
Object.defineProperty(exports, "TileQueue", {
  enumerable: true,
  get: function () {
    return _TileQueue.default;
  }
});
Object.defineProperty(exports, "TileRange", {
  enumerable: true,
  get: function () {
    return _TileRange.default;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _util.VERSION;
  }
});
Object.defineProperty(exports, "VectorRenderTile", {
  enumerable: true,
  get: function () {
    return _VectorRenderTile.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _View.default;
  }
});
Object.defineProperty(exports, "getUid", {
  enumerable: true,
  get: function () {
    return _util.getUid;
  }
});
var _Collection = _interopRequireDefault(require("./Collection.js"));
var _Disposable = _interopRequireDefault(require("./Disposable.js"));
var _Feature = _interopRequireDefault(require("./Feature.js"));
var _Geolocation = _interopRequireDefault(require("./Geolocation.js"));
var _Graticule = _interopRequireDefault(require("./layer/Graticule.js"));
var _Image = _interopRequireDefault(require("./Image.js"));
var _ImageCanvas = _interopRequireDefault(require("./ImageCanvas.js"));
var _ImageTile = _interopRequireDefault(require("./ImageTile.js"));
var _Kinetic = _interopRequireDefault(require("./Kinetic.js"));
var _Map = _interopRequireDefault(require("./Map.js"));
var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));
var _MapBrowserEventHandler = _interopRequireDefault(require("./MapBrowserEventHandler.js"));
var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));
var _Object = _interopRequireDefault(require("./Object.js"));
var _Observable = _interopRequireDefault(require("./Observable.js"));
var _Overlay = _interopRequireDefault(require("./Overlay.js"));
var _Tile = _interopRequireDefault(require("./Tile.js"));
var _TileCache = _interopRequireDefault(require("./TileCache.js"));
var _TileQueue = _interopRequireDefault(require("./TileQueue.js"));
var _TileRange = _interopRequireDefault(require("./TileRange.js"));
var _VectorRenderTile = _interopRequireDefault(require("./VectorRenderTile.js"));
var _VectorTile = _interopRequireDefault(require("./VectorTile.js"));
var _View = _interopRequireDefault(require("./View.js"));
var _util = require("./util.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./Collection.js":"node_modules/ol/Collection.js","./Disposable.js":"node_modules/ol/Disposable.js","./Feature.js":"node_modules/ol/Feature.js","./Geolocation.js":"node_modules/ol/Geolocation.js","./layer/Graticule.js":"node_modules/ol/layer/Graticule.js","./Image.js":"node_modules/ol/Image.js","./ImageCanvas.js":"node_modules/ol/ImageCanvas.js","./ImageTile.js":"node_modules/ol/ImageTile.js","./Kinetic.js":"node_modules/ol/Kinetic.js","./Map.js":"node_modules/ol/Map.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventHandler.js":"node_modules/ol/MapBrowserEventHandler.js","./MapEvent.js":"node_modules/ol/MapEvent.js","./Object.js":"node_modules/ol/Object.js","./Observable.js":"node_modules/ol/Observable.js","./Overlay.js":"node_modules/ol/Overlay.js","./Tile.js":"node_modules/ol/Tile.js","./TileCache.js":"node_modules/ol/TileCache.js","./TileQueue.js":"node_modules/ol/TileQueue.js","./TileRange.js":"node_modules/ol/TileRange.js","./VectorRenderTile.js":"node_modules/ol/VectorRenderTile.js","./VectorTile.js":"node_modules/ol/VectorTile.js","./View.js":"node_modules/ol/View.js","./util.js":"node_modules/ol/util.js"}],"Scripts/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = void 0;
require("ol/ol.css");
var _ol2 = require("ol/");
var _layer = require("ol/layer");
var _ImageWMS = _interopRequireDefault(require("ol/source/ImageWMS"));
var _Tile = _interopRequireDefault(require("ol/layer/Tile"));
var _TileWMS = _interopRequireDefault(require("ol/source/TileWMS"));
var _Projection = _interopRequireDefault(require("ol/proj/Projection"));
var _OSM = _interopRequireDefault(require("ol/source/OSM.js"));
var _Mesaure = require("./Mesaure");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var serverURL = "http://localhost:8888/geoserver/wms";
var mapProjection = new _Projection.default({
  code: "EPSG:3857",
  units: "m",
  axisOrientation: "new",
  global: false
});

// const backgroundSource = new TileWMS({
//   url: serverURL,
//   params: {
//     LAYERS: "BIGC:background_bigc",
//     VERSION: "1.1.1",
//     FORMAT: "image/jpeg",
//   },
// });

// const backgroundLayer = new TileLayer({
//   source: backgroundSource,
//   name: "Background",
// });

var bigcSource = new _ImageWMS.default({
  url: serverURL,
  params: {
    LAYERS: "BIGC:datamoi",
    VERSION: "1.1.1",
    FORMAT: "image/png"
  }
});
var bigcLayer = new _layer.Image({
  source: bigcSource,
  name: "BigC"
});
var view = new _ol2.View({
  // extent: [
  //   11820535.00445471, 2421556.5714437757, 11827808.777048586,
  //   2426423.4337369716,
  // ],
  center: [11823873, 2423891],
  zoom: 15,
  projection: mapProjection
});
var map = exports.map = new _ol2.Map({
  target: "map",
  layers: [new _Tile.default({
    source: new _OSM.default()
  }), bigcLayer],
  view: view
});
$("#map").data("map", map);
},{"ol/ol.css":"node_modules/ol/ol.css","ol/":"node_modules/ol/index.js","ol/layer":"node_modules/ol/layer.js","ol/source/ImageWMS":"node_modules/ol/source/ImageWMS.js","ol/layer/Tile":"node_modules/ol/layer/Tile.js","ol/source/TileWMS":"node_modules/ol/source/TileWMS.js","ol/proj/Projection":"node_modules/ol/proj/Projection.js","ol/source/OSM.js":"node_modules/ol/source/OSM.js","./Mesaure":"Scripts/Mesaure.js"}],"Scripts/Mesaure.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawFunctions = void 0;
var _Draw = _interopRequireDefault(require("ol/interaction/Draw.js"));
var _Overlay = _interopRequireDefault(require("ol/Overlay.js"));
var _style2 = require("ol/style.js");
var _geom = require("ol/geom.js");
var _source = require("ol/source.js");
var _layer = require("ol/layer.js");
var _sphere = require("ol/sphere.js");
var _Observable = require("ol/Observable.js");
var _Map = require("./Map.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var source = new _source.Vector();
var vector = new _layer.Vector({
  source: source,
  style: {
    "fill-color": "rgba(255, 255, 255, 0.2)",
    "stroke-color": "#ffcc33",
    "stroke-width": 2,
    "circle-radius": 7,
    "circle-fill-color": "#ffcc33"
  }
});
localStorage.setItem("display", false);
$("#measure").click(function () {
  var formDisplay = $("#form-mesaure").css("display");
  if (formDisplay == "none") {
    $("#form-mesaure").css("display", "block");
    localStorage.setItem("display", true);
    DrawFunctions(_Map.map);
  } else {
    $("#form-mesaure").css("display", "none");
    localStorage.setItem("display", false);
    $(".ol-tooltip").remove();
    vector.getSource().clear(true);
    _Map.map.removeLayer(vector);
    _Map.map.getInteractions().pop();
  }
});
var DrawFunctions = exports.DrawFunctions = function DrawFunctions(map) {
  /**
   * Currently drawn feature.
   * @type {import("../src/ol/Feature.js").default}
   */
  var sketch;

  /**
   * The help tooltip element.
   * @type {HTMLElement}
   */
  var helpTooltipElement;

  /**
   * Overlay to show the help messages.
   * @type {Overlay}
   */
  var helpTooltip;

  /**
   * The measure tooltip element.
   * @type {HTMLElement}
   */
  var measureTooltipElement;

  /**
   * Overlay to show the measurement.
   * @type {Overlay}
   */
  var measureTooltip;

  /**
   * Message to show when the user is drawing a polygon.
   * @type {string}
   */
  var continuePolygonMsg = "Click to continue drawing the polygon";

  /**
   * Message to show when the user is drawing a line.
   * @type {string}
   */
  var continueLineMsg = "Click to continue drawing the line";

  /**
   * Handle pointer move.
   * @param {import("../src/ol/MapBrowserEvent").default} evt The event.
   */
  var pointerMoveHandler = function pointerMoveHandler(evt) {
    if (evt.dragging) {
      return;
    }
    /** @type {string} */
    var helpMsg = "Click to start drawing";
    if (sketch) {
      var geom = sketch.getGeometry();
      if (geom instanceof _geom.Polygon) {
        helpMsg = continuePolygonMsg;
      } else if (geom instanceof _geom.LineString) {
        helpMsg = continueLineMsg;
      }
    }
    helpTooltipElement.innerHTML = helpMsg;
    helpTooltip.setPosition(evt.coordinate);
    helpTooltipElement.classList.remove("hidden");
  };
  map.addLayer(vector);
  map.on("pointermove", pointerMoveHandler);
  map.getViewport().addEventListener("mouseout", function () {
    helpTooltipElement.classList.add("hidden");
  });
  var typeSelect = document.getElementById("type");
  var draw; // global so we can remove it later

  /**
   * Format length output.
   * @param {LineString} line The line.
   * @return {string} The formatted length.
   */
  var formatLength = function formatLength(line) {
    var length = (0, _sphere.getLength)(line);
    var output;
    if (length > 100) {
      output = Math.round(length / 1000 * 100) / 100 + " " + "km";
    } else {
      output = Math.round(length * 100) / 100 + " " + "m";
    }
    return output;
  };

  /**
   * Format area output.
   * @param {Polygon} polygon The polygon.
   * @return {string} Formatted area.
   */
  var formatArea = function formatArea(polygon) {
    var area = (0, _sphere.getArea)(polygon);
    var output;
    if (area > 10000) {
      output = Math.round(area / 1000000 * 100) / 100 + " " + "km<sup>2</sup>";
    } else {
      output = Math.round(area * 100) / 100 + " " + "m<sup>2</sup>";
    }
    return output;
  };
  var _style = new _style2.Style({
    fill: new _style2.Fill({
      color: "rgba(255, 255, 255, 0.2)"
    }),
    stroke: new _style2.Stroke({
      color: "red",
      // lineDash: [10, 10],
      width: 2
    }),
    image: new _style2.Circle({
      radius: 5,
      stroke: new _style2.Stroke({
        color: "rgba(0, 0, 0, 0.7)"
      }),
      fill: new _style2.Fill({
        color: "rgba(255, 255, 255, 0.2)"
      })
    })
  });
  function addInteraction() {
    var type = typeSelect.value == "area" ? "Polygon" : "LineString";
    draw = new _Draw.default({
      source: source,
      type: type,
      style: function style(feature) {
        var geometryType = feature.getGeometry().getType();
        if (geometryType === type || geometryType === "Point") {
          return _style;
        }
      }
    });
    map.addInteraction(draw);
    createMeasureTooltip();
    createHelpTooltip();
    var listener;
    draw.on("drawstart", function (evt) {
      // set sketch
      sketch = evt.feature;

      /** @type {import("../src/ol/coordinate.js").Coordinate|undefined} */
      var tooltipCoord = evt.coordinate;
      listener = sketch.getGeometry().on("change", function (evt) {
        var geom = evt.target;
        var output;
        if (geom instanceof _geom.Polygon) {
          output = formatArea(geom);
          tooltipCoord = geom.getInteriorPoint().getCoordinates();
        } else if (geom instanceof _geom.LineString) {
          output = formatLength(geom);
          tooltipCoord = geom.getLastCoordinate();
        }
        measureTooltipElement.innerHTML = output;
        measureTooltip.setPosition(tooltipCoord);
      });
    });
    draw.on("drawend", function () {
      measureTooltipElement.className = "ol-tooltip ol-tooltip-static";
      measureTooltip.setOffset([0, -7]);
      // unset sketch
      sketch = null;
      // unset tooltip so that a new one can be created
      measureTooltipElement = null;
      createMeasureTooltip();
      (0, _Observable.unByKey)(listener);
    });
  }

  /**
   * Creates a new help tooltip
   */
  function createHelpTooltip() {
    if (helpTooltipElement) {
      helpTooltipElement.parentNode.removeChild(helpTooltipElement);
    }
    helpTooltipElement = document.createElement("div");
    helpTooltipElement.className = "ol-tooltip hidden";
    helpTooltip = new _Overlay.default({
      element: helpTooltipElement,
      offset: [15, 0],
      positioning: "center-left"
    });
    map.addOverlay(helpTooltip);
  }

  /**
   * Creates a new measure tooltip
   */
  function createMeasureTooltip() {
    if (measureTooltipElement) {
      measureTooltipElement.parentNode.removeChild(measureTooltipElement);
    }
    measureTooltipElement = document.createElement("div");
    measureTooltipElement.className = "ol-tooltip ol-tooltip-measure";
    measureTooltip = new _Overlay.default({
      element: measureTooltipElement,
      offset: [0, -15],
      positioning: "bottom-center",
      stopEvent: false,
      insertFirst: false
    });
    map.addOverlay(measureTooltip);
  }

  /**
   * Let user change the geometry type.
   */
  typeSelect.onchange = function () {
    map.removeInteraction(draw);
    addInteraction();
  };
  addInteraction();
};
},{"ol/interaction/Draw.js":"node_modules/ol/interaction/Draw.js","ol/Overlay.js":"node_modules/ol/Overlay.js","ol/style.js":"node_modules/ol/style.js","ol/geom.js":"node_modules/ol/geom.js","ol/source.js":"node_modules/ol/source.js","ol/layer.js":"node_modules/ol/layer.js","ol/sphere.js":"node_modules/ol/sphere.js","ol/Observable.js":"node_modules/ol/Observable.js","./Map.js":"Scripts/Map.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "53037" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}],"node_modules/parcel-bundler/src/builtins/loaders/browser/js-loader.js":[function(require,module,exports) {
module.exports = function loadJSBundle(bundle) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement('script');
    script.async = true;
    script.type = 'text/javascript';
    script.charset = 'utf-8';
    script.src = bundle;
    script.onerror = function (e) {
      script.onerror = script.onload = null;
      reject(e);
    };
    script.onload = function () {
      script.onerror = script.onload = null;
      resolve();
    };
    document.getElementsByTagName('head')[0].appendChild(script);
  });
};
},{}],0:[function(require,module,exports) {
var b=require("node_modules/parcel-bundler/src/builtins/bundle-loader.js");b.register("js",require("node_modules/parcel-bundler/src/builtins/loaders/browser/js-loader.js"));
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js",0,"Scripts/Mesaure.js"], null)
//# sourceMappingURL=/Mesaure.ab9fadb9.js.map